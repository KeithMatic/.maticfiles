'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var require$$0$3 = require('crypto');
var fs$r = require('fs');
var require$$2$1 = require('module');
var require$$0$4 = require('path');
var require$$1$1 = require('util');
var require$$5 = require('os');
var require$$6 = require('vm');
var require$$7 = require('url');
var require$$8 = require('assert');
var require$$1$2 = require('buffer');
var require$$0$5 = require('tty');
var require$$9 = require('v8');
require('http');
var require$$0$6 = require('stream');
var require$$0$7 = require('events');
var require$$4 = require('net');
require('querystring');
var require$$0$8 = require('constants');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0$3);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs$r);
var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2$1);
var require$$0__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$0$4);
var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1$1);
var require$$5__default = /*#__PURE__*/_interopDefaultLegacy(require$$5);
var require$$6__default = /*#__PURE__*/_interopDefaultLegacy(require$$6);
var require$$7__default = /*#__PURE__*/_interopDefaultLegacy(require$$7);
var require$$8__default = /*#__PURE__*/_interopDefaultLegacy(require$$8);
var require$$1__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$1$2);
var require$$0__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$0$5);
var require$$9__default = /*#__PURE__*/_interopDefaultLegacy(require$$9);
var require$$0__default$3 = /*#__PURE__*/_interopDefaultLegacy(require$$0$6);
var require$$0__default$4 = /*#__PURE__*/_interopDefaultLegacy(require$$0$7);
var require$$4__default = /*#__PURE__*/_interopDefaultLegacy(require$$4);
var require$$0__default$5 = /*#__PURE__*/_interopDefaultLegacy(require$$0$8);

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var jiti$1 = {exports: {}};

(function (module) {
(()=>{var __webpack_modules__={"./node_modules/create-require/create-require.js":(module,__unused_webpack_exports,__webpack_require__)=>{const nativeModule=__webpack_require__("module"),path=__webpack_require__("path"),fs=__webpack_require__("fs");module.exports=function(filename){return filename||(filename=process.cwd()),function(path){try{return fs.lstatSync(path).isDirectory()}catch(e){return !1}}(filename)&&(filename=path.join(filename,"index.js")),nativeModule.createRequire?nativeModule.createRequire(filename):nativeModule.createRequireFromPath?nativeModule.createRequireFromPath(filename):function(filename){const mod=new nativeModule.Module(filename,null);return mod.filename=filename,mod.paths=nativeModule.Module._nodeModulePaths(path.dirname(filename)),mod._compile("module.exports = require;",filename),mod.exports}(filename)};},"./node_modules/lru-cache/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{const Yallist=__webpack_require__("./node_modules/yallist/yallist.js"),MAX=Symbol("max"),LENGTH=Symbol("length"),LENGTH_CALCULATOR=Symbol("lengthCalculator"),ALLOW_STALE=Symbol("allowStale"),MAX_AGE=Symbol("maxAge"),DISPOSE=Symbol("dispose"),NO_DISPOSE_ON_SET=Symbol("noDisposeOnSet"),LRU_LIST=Symbol("lruList"),CACHE=Symbol("cache"),UPDATE_AGE_ON_GET=Symbol("updateAgeOnGet"),naiveLength=()=>1;const get=(self,key,doUse)=>{const node=self[CACHE].get(key);if(node){const hit=node.value;if(isStale(self,hit)){if(del(self,node),!self[ALLOW_STALE])return}else doUse&&(self[UPDATE_AGE_ON_GET]&&(node.value.now=Date.now()),self[LRU_LIST].unshiftNode(node));return hit.value}},isStale=(self,hit)=>{if(!hit||!hit.maxAge&&!self[MAX_AGE])return !1;const diff=Date.now()-hit.now;return hit.maxAge?diff>hit.maxAge:self[MAX_AGE]&&diff>self[MAX_AGE]},trim=self=>{if(self[LENGTH]>self[MAX])for(let walker=self[LRU_LIST].tail;self[LENGTH]>self[MAX]&&null!==walker;){const prev=walker.prev;del(self,walker),walker=prev;}},del=(self,node)=>{if(node){const hit=node.value;self[DISPOSE]&&self[DISPOSE](hit.key,hit.value),self[LENGTH]-=hit.length,self[CACHE].delete(hit.key),self[LRU_LIST].removeNode(node);}};class Entry{constructor(key,value,length,now,maxAge){this.key=key,this.value=value,this.length=length,this.now=now,this.maxAge=maxAge||0;}}const forEachStep=(self,fn,node,thisp)=>{let hit=node.value;isStale(self,hit)&&(del(self,node),self[ALLOW_STALE]||(hit=void 0)),hit&&fn.call(thisp,hit.value,hit.key,self);};module.exports=class{constructor(options){if("number"==typeof options&&(options={max:options}),options||(options={}),options.max&&("number"!=typeof options.max||options.max<0))throw new TypeError("max must be a non-negative number");this[MAX]=options.max||1/0;const lc=options.length||naiveLength;if(this[LENGTH_CALCULATOR]="function"!=typeof lc?naiveLength:lc,this[ALLOW_STALE]=options.stale||!1,options.maxAge&&"number"!=typeof options.maxAge)throw new TypeError("maxAge must be a number");this[MAX_AGE]=options.maxAge||0,this[DISPOSE]=options.dispose,this[NO_DISPOSE_ON_SET]=options.noDisposeOnSet||!1,this[UPDATE_AGE_ON_GET]=options.updateAgeOnGet||!1,this.reset();}set max(mL){if("number"!=typeof mL||mL<0)throw new TypeError("max must be a non-negative number");this[MAX]=mL||1/0,trim(this);}get max(){return this[MAX]}set allowStale(allowStale){this[ALLOW_STALE]=!!allowStale;}get allowStale(){return this[ALLOW_STALE]}set maxAge(mA){if("number"!=typeof mA)throw new TypeError("maxAge must be a non-negative number");this[MAX_AGE]=mA,trim(this);}get maxAge(){return this[MAX_AGE]}set lengthCalculator(lC){"function"!=typeof lC&&(lC=naiveLength),lC!==this[LENGTH_CALCULATOR]&&(this[LENGTH_CALCULATOR]=lC,this[LENGTH]=0,this[LRU_LIST].forEach((hit=>{hit.length=this[LENGTH_CALCULATOR](hit.value,hit.key),this[LENGTH]+=hit.length;}))),trim(this);}get lengthCalculator(){return this[LENGTH_CALCULATOR]}get length(){return this[LENGTH]}get itemCount(){return this[LRU_LIST].length}rforEach(fn,thisp){thisp=thisp||this;for(let walker=this[LRU_LIST].tail;null!==walker;){const prev=walker.prev;forEachStep(this,fn,walker,thisp),walker=prev;}}forEach(fn,thisp){thisp=thisp||this;for(let walker=this[LRU_LIST].head;null!==walker;){const next=walker.next;forEachStep(this,fn,walker,thisp),walker=next;}}keys(){return this[LRU_LIST].toArray().map((k=>k.key))}values(){return this[LRU_LIST].toArray().map((k=>k.value))}reset(){this[DISPOSE]&&this[LRU_LIST]&&this[LRU_LIST].length&&this[LRU_LIST].forEach((hit=>this[DISPOSE](hit.key,hit.value))),this[CACHE]=new Map,this[LRU_LIST]=new Yallist,this[LENGTH]=0;}dump(){return this[LRU_LIST].map((hit=>!isStale(this,hit)&&{k:hit.key,v:hit.value,e:hit.now+(hit.maxAge||0)})).toArray().filter((h=>h))}dumpLru(){return this[LRU_LIST]}set(key,value,maxAge){if((maxAge=maxAge||this[MAX_AGE])&&"number"!=typeof maxAge)throw new TypeError("maxAge must be a number");const now=maxAge?Date.now():0,len=this[LENGTH_CALCULATOR](value,key);if(this[CACHE].has(key)){if(len>this[MAX])return del(this,this[CACHE].get(key)),!1;const item=this[CACHE].get(key).value;return this[DISPOSE]&&(this[NO_DISPOSE_ON_SET]||this[DISPOSE](key,item.value)),item.now=now,item.maxAge=maxAge,item.value=value,this[LENGTH]+=len-item.length,item.length=len,this.get(key),trim(this),!0}const hit=new Entry(key,value,len,now,maxAge);return hit.length>this[MAX]?(this[DISPOSE]&&this[DISPOSE](key,value),!1):(this[LENGTH]+=hit.length,this[LRU_LIST].unshift(hit),this[CACHE].set(key,this[LRU_LIST].head),trim(this),!0)}has(key){if(!this[CACHE].has(key))return !1;const hit=this[CACHE].get(key).value;return !isStale(this,hit)}get(key){return get(this,key,!0)}peek(key){return get(this,key,!1)}pop(){const node=this[LRU_LIST].tail;return node?(del(this,node),node.value):null}del(key){del(this,this[CACHE].get(key));}load(arr){this.reset();const now=Date.now();for(let l=arr.length-1;l>=0;l--){const hit=arr[l],expiresAt=hit.e||0;if(0===expiresAt)this.set(hit.k,hit.v);else {const maxAge=expiresAt-now;maxAge>0&&this.set(hit.k,hit.v,maxAge);}}}prune(){this[CACHE].forEach(((value,key)=>get(this,key,!1)));}};},"./node_modules/mkdirp/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{const optsArg=__webpack_require__("./node_modules/mkdirp/lib/opts-arg.js"),pathArg=__webpack_require__("./node_modules/mkdirp/lib/path-arg.js"),{mkdirpNative,mkdirpNativeSync}=__webpack_require__("./node_modules/mkdirp/lib/mkdirp-native.js"),{mkdirpManual,mkdirpManualSync}=__webpack_require__("./node_modules/mkdirp/lib/mkdirp-manual.js"),{useNative,useNativeSync}=__webpack_require__("./node_modules/mkdirp/lib/use-native.js"),mkdirp=(path,opts)=>(path=pathArg(path),opts=optsArg(opts),useNative(opts)?mkdirpNative(path,opts):mkdirpManual(path,opts));mkdirp.sync=(path,opts)=>(path=pathArg(path),opts=optsArg(opts),useNativeSync(opts)?mkdirpNativeSync(path,opts):mkdirpManualSync(path,opts)),mkdirp.native=(path,opts)=>mkdirpNative(pathArg(path),optsArg(opts)),mkdirp.manual=(path,opts)=>mkdirpManual(pathArg(path),optsArg(opts)),mkdirp.nativeSync=(path,opts)=>mkdirpNativeSync(pathArg(path),optsArg(opts)),mkdirp.manualSync=(path,opts)=>mkdirpManualSync(pathArg(path),optsArg(opts)),module.exports=mkdirp;},"./node_modules/mkdirp/lib/find-made.js":(module,__unused_webpack_exports,__webpack_require__)=>{const{dirname}=__webpack_require__("path"),findMade=(opts,parent,path)=>path===parent?Promise.resolve():opts.statAsync(parent).then((st=>st.isDirectory()?path:void 0),(er=>"ENOENT"===er.code?findMade(opts,dirname(parent),parent):void 0)),findMadeSync=(opts,parent,path)=>{if(path!==parent)try{return opts.statSync(parent).isDirectory()?path:void 0}catch(er){return "ENOENT"===er.code?findMadeSync(opts,dirname(parent),parent):void 0}};module.exports={findMade,findMadeSync};},"./node_modules/mkdirp/lib/mkdirp-manual.js":(module,__unused_webpack_exports,__webpack_require__)=>{const{dirname}=__webpack_require__("path"),mkdirpManual=(path,opts,made)=>{opts.recursive=!1;const parent=dirname(path);return parent===path?opts.mkdirAsync(path,opts).catch((er=>{if("EISDIR"!==er.code)throw er})):opts.mkdirAsync(path,opts).then((()=>made||path),(er=>{if("ENOENT"===er.code)return mkdirpManual(parent,opts).then((made=>mkdirpManual(path,opts,made)));if("EEXIST"!==er.code&&"EROFS"!==er.code)throw er;return opts.statAsync(path).then((st=>{if(st.isDirectory())return made;throw er}),(()=>{throw er}))}))},mkdirpManualSync=(path,opts,made)=>{const parent=dirname(path);if(opts.recursive=!1,parent===path)try{return opts.mkdirSync(path,opts)}catch(er){if("EISDIR"!==er.code)throw er;return}try{return opts.mkdirSync(path,opts),made||path}catch(er){if("ENOENT"===er.code)return mkdirpManualSync(path,opts,mkdirpManualSync(parent,opts,made));if("EEXIST"!==er.code&&"EROFS"!==er.code)throw er;try{if(!opts.statSync(path).isDirectory())throw er}catch(_){throw er}}};module.exports={mkdirpManual,mkdirpManualSync};},"./node_modules/mkdirp/lib/mkdirp-native.js":(module,__unused_webpack_exports,__webpack_require__)=>{const{dirname}=__webpack_require__("path"),{findMade,findMadeSync}=__webpack_require__("./node_modules/mkdirp/lib/find-made.js"),{mkdirpManual,mkdirpManualSync}=__webpack_require__("./node_modules/mkdirp/lib/mkdirp-manual.js");module.exports={mkdirpNative:(path,opts)=>{opts.recursive=!0;return dirname(path)===path?opts.mkdirAsync(path,opts):findMade(opts,path).then((made=>opts.mkdirAsync(path,opts).then((()=>made)).catch((er=>{if("ENOENT"===er.code)return mkdirpManual(path,opts);throw er}))))},mkdirpNativeSync:(path,opts)=>{opts.recursive=!0;if(dirname(path)===path)return opts.mkdirSync(path,opts);const made=findMadeSync(opts,path);try{return opts.mkdirSync(path,opts),made}catch(er){if("ENOENT"===er.code)return mkdirpManualSync(path,opts);throw er}}};},"./node_modules/mkdirp/lib/opts-arg.js":(module,__unused_webpack_exports,__webpack_require__)=>{const{promisify}=__webpack_require__("util"),fs=__webpack_require__("fs");module.exports=opts=>{if(opts)if("object"==typeof opts)opts={mode:511,fs,...opts};else if("number"==typeof opts)opts={mode:opts,fs};else {if("string"!=typeof opts)throw new TypeError("invalid options argument");opts={mode:parseInt(opts,8),fs};}else opts={mode:511,fs};return opts.mkdir=opts.mkdir||opts.fs.mkdir||fs.mkdir,opts.mkdirAsync=promisify(opts.mkdir),opts.stat=opts.stat||opts.fs.stat||fs.stat,opts.statAsync=promisify(opts.stat),opts.statSync=opts.statSync||opts.fs.statSync||fs.statSync,opts.mkdirSync=opts.mkdirSync||opts.fs.mkdirSync||fs.mkdirSync,opts};},"./node_modules/mkdirp/lib/path-arg.js":(module,__unused_webpack_exports,__webpack_require__)=>{const platform=process.env.__TESTING_MKDIRP_PLATFORM__||process.platform,{resolve,parse}=__webpack_require__("path");module.exports=path=>{if(/\0/.test(path))throw Object.assign(new TypeError("path must be a string without null bytes"),{path,code:"ERR_INVALID_ARG_VALUE"});if(path=resolve(path),"win32"===platform){const badWinChars=/[*|"<>?:]/,{root}=parse(path);if(badWinChars.test(path.substr(root.length)))throw Object.assign(new Error("Illegal characters in path."),{path,code:"EINVAL"})}return path};},"./node_modules/mkdirp/lib/use-native.js":(module,__unused_webpack_exports,__webpack_require__)=>{const fs=__webpack_require__("fs"),versArr=(process.env.__TESTING_MKDIRP_NODE_VERSION__||process.version).replace(/^v/,"").split("."),hasNative=+versArr[0]>10||10==+versArr[0]&&+versArr[1]>=12,useNative=hasNative?opts=>opts.mkdir===fs.mkdir:()=>!1,useNativeSync=hasNative?opts=>opts.mkdirSync===fs.mkdirSync:()=>!1;module.exports={useNative,useNativeSync};},"./node_modules/mlly/dist lazy recursive":module=>{function webpackEmptyAsyncContext(req){return Promise.resolve().then((()=>{var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}))}webpackEmptyAsyncContext.keys=()=>[],webpackEmptyAsyncContext.resolve=webpackEmptyAsyncContext,webpackEmptyAsyncContext.id="./node_modules/mlly/dist lazy recursive",module.exports=webpackEmptyAsyncContext;},"./node_modules/object-hash/index.js":(module,exports,__webpack_require__)=>{var crypto=__webpack_require__("crypto");function objectHash(object,options){return function(object,options){var hashingStream;hashingStream="passthrough"!==options.algorithm?crypto.createHash(options.algorithm):new PassThrough;void 0===hashingStream.write&&(hashingStream.write=hashingStream.update,hashingStream.end=hashingStream.update);typeHasher(options,hashingStream).dispatch(object),hashingStream.update||hashingStream.end("");if(hashingStream.digest)return hashingStream.digest("buffer"===options.encoding?void 0:options.encoding);var buf=hashingStream.read();if("buffer"===options.encoding)return buf;return buf.toString(options.encoding)}(object,options=applyDefaults(object,options))}(exports=module.exports=objectHash).sha1=function(object){return objectHash(object)},exports.keys=function(object){return objectHash(object,{excludeValues:!0,algorithm:"sha1",encoding:"hex"})},exports.MD5=function(object){return objectHash(object,{algorithm:"md5",encoding:"hex"})},exports.keysMD5=function(object){return objectHash(object,{algorithm:"md5",encoding:"hex",excludeValues:!0})};var hashes=crypto.getHashes?crypto.getHashes().slice():["sha1","md5"];hashes.push("passthrough");var encodings=["buffer","hex","binary","base64"];function applyDefaults(object,sourceOptions){sourceOptions=sourceOptions||{};var options={};if(options.algorithm=sourceOptions.algorithm||"sha1",options.encoding=sourceOptions.encoding||"hex",options.excludeValues=!!sourceOptions.excludeValues,options.algorithm=options.algorithm.toLowerCase(),options.encoding=options.encoding.toLowerCase(),options.ignoreUnknown=!0===sourceOptions.ignoreUnknown,options.respectType=!1!==sourceOptions.respectType,options.respectFunctionNames=!1!==sourceOptions.respectFunctionNames,options.respectFunctionProperties=!1!==sourceOptions.respectFunctionProperties,options.unorderedArrays=!0===sourceOptions.unorderedArrays,options.unorderedSets=!1!==sourceOptions.unorderedSets,options.unorderedObjects=!1!==sourceOptions.unorderedObjects,options.replacer=sourceOptions.replacer||void 0,options.excludeKeys=sourceOptions.excludeKeys||void 0,void 0===object)throw new Error("Object argument required.");for(var i=0;i<hashes.length;++i)hashes[i].toLowerCase()===options.algorithm.toLowerCase()&&(options.algorithm=hashes[i]);if(-1===hashes.indexOf(options.algorithm))throw new Error('Algorithm "'+options.algorithm+'"  not supported. supported values: '+hashes.join(", "));if(-1===encodings.indexOf(options.encoding)&&"passthrough"!==options.algorithm)throw new Error('Encoding "'+options.encoding+'"  not supported. supported values: '+encodings.join(", "));return options}function isNativeFunction(f){if("function"!=typeof f)return !1;return null!=/^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(f))}function typeHasher(options,writeTo,context){context=context||[];var write=function(str){return writeTo.update?writeTo.update(str,"utf8"):writeTo.write(str,"utf8")};return {dispatch:function(value){options.replacer&&(value=options.replacer(value));var type=typeof value;return null===value&&(type="null"),this["_"+type](value)},_object:function(object){var objString=Object.prototype.toString.call(object),objType=/\[object (.*)\]/i.exec(objString);objType=(objType=objType?objType[1]:"unknown:["+objString+"]").toLowerCase();var objectNumber;if((objectNumber=context.indexOf(object))>=0)return this.dispatch("[CIRCULAR:"+objectNumber+"]");if(context.push(object),"undefined"!=typeof Buffer&&Buffer.isBuffer&&Buffer.isBuffer(object))return write("buffer:"),write(object);if("object"===objType||"function"===objType||"asyncfunction"===objType){var keys=Object.keys(object);options.unorderedObjects&&(keys=keys.sort()),!1===options.respectType||isNativeFunction(object)||keys.splice(0,0,"prototype","__proto__","constructor"),options.excludeKeys&&(keys=keys.filter((function(key){return !options.excludeKeys(key)}))),write("object:"+keys.length+":");var self=this;return keys.forEach((function(key){self.dispatch(key),write(":"),options.excludeValues||self.dispatch(object[key]),write(",");}))}if(!this["_"+objType]){if(options.ignoreUnknown)return write("["+objType+"]");throw new Error('Unknown object type "'+objType+'"')}this["_"+objType](object);},_array:function(arr,unordered){unordered=void 0!==unordered?unordered:!1!==options.unorderedArrays;var self=this;if(write("array:"+arr.length+":"),!unordered||arr.length<=1)return arr.forEach((function(entry){return self.dispatch(entry)}));var contextAdditions=[],entries=arr.map((function(entry){var strm=new PassThrough,localContext=context.slice();return typeHasher(options,strm,localContext).dispatch(entry),contextAdditions=contextAdditions.concat(localContext.slice(context.length)),strm.read().toString()}));return context=context.concat(contextAdditions),entries.sort(),this._array(entries,!1)},_date:function(date){return write("date:"+date.toJSON())},_symbol:function(sym){return write("symbol:"+sym.toString())},_error:function(err){return write("error:"+err.toString())},_boolean:function(bool){return write("bool:"+bool.toString())},_string:function(string){write("string:"+string.length+":"),write(string.toString());},_function:function(fn){write("fn:"),isNativeFunction(fn)?this.dispatch("[native]"):this.dispatch(fn.toString()),!1!==options.respectFunctionNames&&this.dispatch("function-name:"+String(fn.name)),options.respectFunctionProperties&&this._object(fn);},_number:function(number){return write("number:"+number.toString())},_xml:function(xml){return write("xml:"+xml.toString())},_null:function(){return write("Null")},_undefined:function(){return write("Undefined")},_regexp:function(regex){return write("regex:"+regex.toString())},_uint8array:function(arr){return write("uint8array:"),this.dispatch(Array.prototype.slice.call(arr))},_uint8clampedarray:function(arr){return write("uint8clampedarray:"),this.dispatch(Array.prototype.slice.call(arr))},_int8array:function(arr){return write("uint8array:"),this.dispatch(Array.prototype.slice.call(arr))},_uint16array:function(arr){return write("uint16array:"),this.dispatch(Array.prototype.slice.call(arr))},_int16array:function(arr){return write("uint16array:"),this.dispatch(Array.prototype.slice.call(arr))},_uint32array:function(arr){return write("uint32array:"),this.dispatch(Array.prototype.slice.call(arr))},_int32array:function(arr){return write("uint32array:"),this.dispatch(Array.prototype.slice.call(arr))},_float32array:function(arr){return write("float32array:"),this.dispatch(Array.prototype.slice.call(arr))},_float64array:function(arr){return write("float64array:"),this.dispatch(Array.prototype.slice.call(arr))},_arraybuffer:function(arr){return write("arraybuffer:"),this.dispatch(new Uint8Array(arr))},_url:function(url){return write("url:"+url.toString())},_map:function(map){write("map:");var arr=Array.from(map);return this._array(arr,!1!==options.unorderedSets)},_set:function(set){write("set:");var arr=Array.from(set);return this._array(arr,!1!==options.unorderedSets)},_file:function(file){return write("file:"),this.dispatch([file.name,file.size,file.type,file.lastModfied])},_blob:function(){if(options.ignoreUnknown)return write("[blob]");throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n')},_domwindow:function(){return write("domwindow")},_bigint:function(number){return write("bigint:"+number.toString())},_process:function(){return write("process")},_timer:function(){return write("timer")},_pipe:function(){return write("pipe")},_tcp:function(){return write("tcp")},_udp:function(){return write("udp")},_tty:function(){return write("tty")},_statwatcher:function(){return write("statwatcher")},_securecontext:function(){return write("securecontext")},_connection:function(){return write("connection")},_zlib:function(){return write("zlib")},_context:function(){return write("context")},_nodescript:function(){return write("nodescript")},_httpparser:function(){return write("httpparser")},_dataview:function(){return write("dataview")},_signal:function(){return write("signal")},_fsevent:function(){return write("fsevent")},_tlswrap:function(){return write("tlswrap")}}}function PassThrough(){return {buf:"",write:function(b){this.buf+=b;},end:function(b){this.buf+=b;},read:function(){return this.buf}}}exports.writeToStream=function(object,options,stream){return void 0===stream&&(stream=options,options={}),typeHasher(options=applyDefaults(object,options),stream).dispatch(object)};},"./node_modules/pirates/lib/index.js":(module,exports,__webpack_require__)=>{module=__webpack_require__.nmd(module),Object.defineProperty(exports,"__esModule",{value:!0}),exports.addHook=function(hook,opts={}){let reverted=!1;const loaders=[],oldLoaders=[];let exts;const originalJSLoader=Module._extensions[".js"],matcher=opts.matcher||null,ignoreNodeModules=!1!==opts.ignoreNodeModules;exts=opts.extensions||opts.exts||opts.extension||opts.ext||[".js"],Array.isArray(exts)||(exts=[exts]);return exts.forEach((ext=>{if("string"!=typeof ext)throw new TypeError(`Invalid Extension: ${ext}`);const oldLoader=Module._extensions[ext]||originalJSLoader;oldLoaders[ext]=Module._extensions[ext],loaders[ext]=Module._extensions[ext]=function(mod,filename){let compile;reverted||function(filename,exts,matcher,ignoreNodeModules){if("string"!=typeof filename)return !1;if(-1===exts.indexOf(_path.default.extname(filename)))return !1;const resolvedFilename=_path.default.resolve(filename);if(ignoreNodeModules&&nodeModulesRegex.test(resolvedFilename))return !1;if(matcher&&"function"==typeof matcher)return !!matcher(resolvedFilename);return !0}(filename,exts,matcher,ignoreNodeModules)&&(compile=mod._compile,mod._compile=function(code){mod._compile=compile;const newCode=hook(code,filename);if("string"!=typeof newCode)throw new Error("[Pirates] A hook returned a non-string, or nothing at all! This is a violation of intergalactic law!\n--------------------\nIf you have no idea what this means or what Pirates is, let me explain: Pirates is a module that makes is easy to implement require hooks. One of the require hooks you're using uses it. One of these require hooks didn't return anything from it's handler, so we don't know what to do. You might want to debug this.");return mod._compile(newCode,filename)}),oldLoader(mod,filename);};})),function(){reverted||(reverted=!0,exts.forEach((ext=>{Module._extensions[ext]===loaders[ext]&&(oldLoaders[ext]?Module._extensions[ext]=oldLoaders[ext]:delete Module._extensions[ext]);})));}};var _module=_interopRequireDefault(__webpack_require__("module")),_path=_interopRequireDefault(__webpack_require__("path"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}const nodeModulesRegex=/^(?:.*[\\/])?node_modules(?:[\\/].*)?$/,Module=module.constructor.length>1?module.constructor:_module.default;},"./node_modules/semver/classes/comparator.js":(module,__unused_webpack_exports,__webpack_require__)=>{const ANY=Symbol("SemVer ANY");class Comparator{static get ANY(){return ANY}constructor(comp,options){if(options=parseOptions(options),comp instanceof Comparator){if(comp.loose===!!options.loose)return comp;comp=comp.value;}debug("comparator",comp,options),this.options=options,this.loose=!!options.loose,this.parse(comp),this.semver===ANY?this.value="":this.value=this.operator+this.semver.version,debug("comp",this);}parse(comp){const r=this.options.loose?re[t.COMPARATORLOOSE]:re[t.COMPARATOR],m=comp.match(r);if(!m)throw new TypeError(`Invalid comparator: ${comp}`);this.operator=void 0!==m[1]?m[1]:"","="===this.operator&&(this.operator=""),m[2]?this.semver=new SemVer(m[2],this.options.loose):this.semver=ANY;}toString(){return this.value}test(version){if(debug("Comparator.test",version,this.options.loose),this.semver===ANY||version===ANY)return !0;if("string"==typeof version)try{version=new SemVer(version,this.options);}catch(er){return !1}return cmp(version,this.operator,this.semver,this.options)}intersects(comp,options){if(!(comp instanceof Comparator))throw new TypeError("a Comparator is required");if(options&&"object"==typeof options||(options={loose:!!options,includePrerelease:!1}),""===this.operator)return ""===this.value||new Range(comp.value,options).test(this.value);if(""===comp.operator)return ""===comp.value||new Range(this.value,options).test(comp.semver);const sameDirectionIncreasing=!(">="!==this.operator&&">"!==this.operator||">="!==comp.operator&&">"!==comp.operator),sameDirectionDecreasing=!("<="!==this.operator&&"<"!==this.operator||"<="!==comp.operator&&"<"!==comp.operator),sameSemVer=this.semver.version===comp.semver.version,differentDirectionsInclusive=!(">="!==this.operator&&"<="!==this.operator||">="!==comp.operator&&"<="!==comp.operator),oppositeDirectionsLessThan=cmp(this.semver,"<",comp.semver,options)&&(">="===this.operator||">"===this.operator)&&("<="===comp.operator||"<"===comp.operator),oppositeDirectionsGreaterThan=cmp(this.semver,">",comp.semver,options)&&("<="===this.operator||"<"===this.operator)&&(">="===comp.operator||">"===comp.operator);return sameDirectionIncreasing||sameDirectionDecreasing||sameSemVer&&differentDirectionsInclusive||oppositeDirectionsLessThan||oppositeDirectionsGreaterThan}}module.exports=Comparator;const parseOptions=__webpack_require__("./node_modules/semver/internal/parse-options.js"),{re,t}=__webpack_require__("./node_modules/semver/internal/re.js"),cmp=__webpack_require__("./node_modules/semver/functions/cmp.js"),debug=__webpack_require__("./node_modules/semver/internal/debug.js"),SemVer=__webpack_require__("./node_modules/semver/classes/semver.js"),Range=__webpack_require__("./node_modules/semver/classes/range.js");},"./node_modules/semver/classes/range.js":(module,__unused_webpack_exports,__webpack_require__)=>{class Range{constructor(range,options){if(options=parseOptions(options),range instanceof Range)return range.loose===!!options.loose&&range.includePrerelease===!!options.includePrerelease?range:new Range(range.raw,options);if(range instanceof Comparator)return this.raw=range.value,this.set=[[range]],this.format(),this;if(this.options=options,this.loose=!!options.loose,this.includePrerelease=!!options.includePrerelease,this.raw=range,this.set=range.split(/\s*\|\|\s*/).map((range=>this.parseRange(range.trim()))).filter((c=>c.length)),!this.set.length)throw new TypeError(`Invalid SemVer Range: ${range}`);if(this.set.length>1){const first=this.set[0];if(this.set=this.set.filter((c=>!isNullSet(c[0]))),0===this.set.length)this.set=[first];else if(this.set.length>1)for(const c of this.set)if(1===c.length&&isAny(c[0])){this.set=[c];break}}this.format();}format(){return this.range=this.set.map((comps=>comps.join(" ").trim())).join("||").trim(),this.range}toString(){return this.range}parseRange(range){range=range.trim();const memoKey=`parseRange:${Object.keys(this.options).join(",")}:${range}`,cached=cache.get(memoKey);if(cached)return cached;const loose=this.options.loose,hr=loose?re[t.HYPHENRANGELOOSE]:re[t.HYPHENRANGE];range=range.replace(hr,hyphenReplace(this.options.includePrerelease)),debug("hyphen replace",range),range=range.replace(re[t.COMPARATORTRIM],comparatorTrimReplace),debug("comparator trim",range,re[t.COMPARATORTRIM]),range=(range=(range=range.replace(re[t.TILDETRIM],tildeTrimReplace)).replace(re[t.CARETTRIM],caretTrimReplace)).split(/\s+/).join(" ");const compRe=loose?re[t.COMPARATORLOOSE]:re[t.COMPARATOR],rangeList=range.split(" ").map((comp=>parseComparator(comp,this.options))).join(" ").split(/\s+/).map((comp=>replaceGTE0(comp,this.options))).filter(this.options.loose?comp=>!!comp.match(compRe):()=>!0).map((comp=>new Comparator(comp,this.options))),rangeMap=(rangeList.length,new Map);for(const comp of rangeList){if(isNullSet(comp))return [comp];rangeMap.set(comp.value,comp);}rangeMap.size>1&&rangeMap.has("")&&rangeMap.delete("");const result=[...rangeMap.values()];return cache.set(memoKey,result),result}intersects(range,options){if(!(range instanceof Range))throw new TypeError("a Range is required");return this.set.some((thisComparators=>isSatisfiable(thisComparators,options)&&range.set.some((rangeComparators=>isSatisfiable(rangeComparators,options)&&thisComparators.every((thisComparator=>rangeComparators.every((rangeComparator=>thisComparator.intersects(rangeComparator,options)))))))))}test(version){if(!version)return !1;if("string"==typeof version)try{version=new SemVer(version,this.options);}catch(er){return !1}for(let i=0;i<this.set.length;i++)if(testSet(this.set[i],version,this.options))return !0;return !1}}module.exports=Range;const cache=new(__webpack_require__("./node_modules/lru-cache/index.js"))({max:1e3}),parseOptions=__webpack_require__("./node_modules/semver/internal/parse-options.js"),Comparator=__webpack_require__("./node_modules/semver/classes/comparator.js"),debug=__webpack_require__("./node_modules/semver/internal/debug.js"),SemVer=__webpack_require__("./node_modules/semver/classes/semver.js"),{re,t,comparatorTrimReplace,tildeTrimReplace,caretTrimReplace}=__webpack_require__("./node_modules/semver/internal/re.js"),isNullSet=c=>"<0.0.0-0"===c.value,isAny=c=>""===c.value,isSatisfiable=(comparators,options)=>{let result=!0;const remainingComparators=comparators.slice();let testComparator=remainingComparators.pop();for(;result&&remainingComparators.length;)result=remainingComparators.every((otherComparator=>testComparator.intersects(otherComparator,options))),testComparator=remainingComparators.pop();return result},parseComparator=(comp,options)=>(debug("comp",comp,options),comp=replaceCarets(comp,options),debug("caret",comp),comp=replaceTildes(comp,options),debug("tildes",comp),comp=replaceXRanges(comp,options),debug("xrange",comp),comp=replaceStars(comp,options),debug("stars",comp),comp),isX=id=>!id||"x"===id.toLowerCase()||"*"===id,replaceTildes=(comp,options)=>comp.trim().split(/\s+/).map((comp=>replaceTilde(comp,options))).join(" "),replaceTilde=(comp,options)=>{const r=options.loose?re[t.TILDELOOSE]:re[t.TILDE];return comp.replace(r,((_,M,m,p,pr)=>{let ret;return debug("tilde",comp,_,M,m,p,pr),isX(M)?ret="":isX(m)?ret=`>=${M}.0.0 <${+M+1}.0.0-0`:isX(p)?ret=`>=${M}.${m}.0 <${M}.${+m+1}.0-0`:pr?(debug("replaceTilde pr",pr),ret=`>=${M}.${m}.${p}-${pr} <${M}.${+m+1}.0-0`):ret=`>=${M}.${m}.${p} <${M}.${+m+1}.0-0`,debug("tilde return",ret),ret}))},replaceCarets=(comp,options)=>comp.trim().split(/\s+/).map((comp=>replaceCaret(comp,options))).join(" "),replaceCaret=(comp,options)=>{debug("caret",comp,options);const r=options.loose?re[t.CARETLOOSE]:re[t.CARET],z=options.includePrerelease?"-0":"";return comp.replace(r,((_,M,m,p,pr)=>{let ret;return debug("caret",comp,_,M,m,p,pr),isX(M)?ret="":isX(m)?ret=`>=${M}.0.0${z} <${+M+1}.0.0-0`:isX(p)?ret="0"===M?`>=${M}.${m}.0${z} <${M}.${+m+1}.0-0`:`>=${M}.${m}.0${z} <${+M+1}.0.0-0`:pr?(debug("replaceCaret pr",pr),ret="0"===M?"0"===m?`>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p+1}-0`:`>=${M}.${m}.${p}-${pr} <${M}.${+m+1}.0-0`:`>=${M}.${m}.${p}-${pr} <${+M+1}.0.0-0`):(debug("no pr"),ret="0"===M?"0"===m?`>=${M}.${m}.${p}${z} <${M}.${m}.${+p+1}-0`:`>=${M}.${m}.${p}${z} <${M}.${+m+1}.0-0`:`>=${M}.${m}.${p} <${+M+1}.0.0-0`),debug("caret return",ret),ret}))},replaceXRanges=(comp,options)=>(debug("replaceXRanges",comp,options),comp.split(/\s+/).map((comp=>replaceXRange(comp,options))).join(" ")),replaceXRange=(comp,options)=>{comp=comp.trim();const r=options.loose?re[t.XRANGELOOSE]:re[t.XRANGE];return comp.replace(r,((ret,gtlt,M,m,p,pr)=>{debug("xRange",comp,ret,gtlt,M,m,p,pr);const xM=isX(M),xm=xM||isX(m),xp=xm||isX(p),anyX=xp;return "="===gtlt&&anyX&&(gtlt=""),pr=options.includePrerelease?"-0":"",xM?ret=">"===gtlt||"<"===gtlt?"<0.0.0-0":"*":gtlt&&anyX?(xm&&(m=0),p=0,">"===gtlt?(gtlt=">=",xm?(M=+M+1,m=0,p=0):(m=+m+1,p=0)):"<="===gtlt&&(gtlt="<",xm?M=+M+1:m=+m+1),"<"===gtlt&&(pr="-0"),ret=`${gtlt+M}.${m}.${p}${pr}`):xm?ret=`>=${M}.0.0${pr} <${+M+1}.0.0-0`:xp&&(ret=`>=${M}.${m}.0${pr} <${M}.${+m+1}.0-0`),debug("xRange return",ret),ret}))},replaceStars=(comp,options)=>(debug("replaceStars",comp,options),comp.trim().replace(re[t.STAR],"")),replaceGTE0=(comp,options)=>(debug("replaceGTE0",comp,options),comp.trim().replace(re[options.includePrerelease?t.GTE0PRE:t.GTE0],"")),hyphenReplace=incPr=>($0,from,fM,fm,fp,fpr,fb,to,tM,tm,tp,tpr,tb)=>`${from=isX(fM)?"":isX(fm)?`>=${fM}.0.0${incPr?"-0":""}`:isX(fp)?`>=${fM}.${fm}.0${incPr?"-0":""}`:fpr?`>=${from}`:`>=${from}${incPr?"-0":""}`} ${to=isX(tM)?"":isX(tm)?`<${+tM+1}.0.0-0`:isX(tp)?`<${tM}.${+tm+1}.0-0`:tpr?`<=${tM}.${tm}.${tp}-${tpr}`:incPr?`<${tM}.${tm}.${+tp+1}-0`:`<=${to}`}`.trim(),testSet=(set,version,options)=>{for(let i=0;i<set.length;i++)if(!set[i].test(version))return !1;if(version.prerelease.length&&!options.includePrerelease){for(let i=0;i<set.length;i++)if(debug(set[i].semver),set[i].semver!==Comparator.ANY&&set[i].semver.prerelease.length>0){const allowed=set[i].semver;if(allowed.major===version.major&&allowed.minor===version.minor&&allowed.patch===version.patch)return !0}return !1}return !0};},"./node_modules/semver/classes/semver.js":(module,__unused_webpack_exports,__webpack_require__)=>{const debug=__webpack_require__("./node_modules/semver/internal/debug.js"),{MAX_LENGTH,MAX_SAFE_INTEGER}=__webpack_require__("./node_modules/semver/internal/constants.js"),{re,t}=__webpack_require__("./node_modules/semver/internal/re.js"),parseOptions=__webpack_require__("./node_modules/semver/internal/parse-options.js"),{compareIdentifiers}=__webpack_require__("./node_modules/semver/internal/identifiers.js");class SemVer{constructor(version,options){if(options=parseOptions(options),version instanceof SemVer){if(version.loose===!!options.loose&&version.includePrerelease===!!options.includePrerelease)return version;version=version.version;}else if("string"!=typeof version)throw new TypeError(`Invalid Version: ${version}`);if(version.length>MAX_LENGTH)throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);debug("SemVer",version,options),this.options=options,this.loose=!!options.loose,this.includePrerelease=!!options.includePrerelease;const m=version.trim().match(options.loose?re[t.LOOSE]:re[t.FULL]);if(!m)throw new TypeError(`Invalid Version: ${version}`);if(this.raw=version,this.major=+m[1],this.minor=+m[2],this.patch=+m[3],this.major>MAX_SAFE_INTEGER||this.major<0)throw new TypeError("Invalid major version");if(this.minor>MAX_SAFE_INTEGER||this.minor<0)throw new TypeError("Invalid minor version");if(this.patch>MAX_SAFE_INTEGER||this.patch<0)throw new TypeError("Invalid patch version");m[4]?this.prerelease=m[4].split(".").map((id=>{if(/^[0-9]+$/.test(id)){const num=+id;if(num>=0&&num<MAX_SAFE_INTEGER)return num}return id})):this.prerelease=[],this.build=m[5]?m[5].split("."):[],this.format();}format(){return this.version=`${this.major}.${this.minor}.${this.patch}`,this.prerelease.length&&(this.version+=`-${this.prerelease.join(".")}`),this.version}toString(){return this.version}compare(other){if(debug("SemVer.compare",this.version,this.options,other),!(other instanceof SemVer)){if("string"==typeof other&&other===this.version)return 0;other=new SemVer(other,this.options);}return other.version===this.version?0:this.compareMain(other)||this.comparePre(other)}compareMain(other){return other instanceof SemVer||(other=new SemVer(other,this.options)),compareIdentifiers(this.major,other.major)||compareIdentifiers(this.minor,other.minor)||compareIdentifiers(this.patch,other.patch)}comparePre(other){if(other instanceof SemVer||(other=new SemVer(other,this.options)),this.prerelease.length&&!other.prerelease.length)return -1;if(!this.prerelease.length&&other.prerelease.length)return 1;if(!this.prerelease.length&&!other.prerelease.length)return 0;let i=0;do{const a=this.prerelease[i],b=other.prerelease[i];if(debug("prerelease compare",i,a,b),void 0===a&&void 0===b)return 0;if(void 0===b)return 1;if(void 0===a)return -1;if(a!==b)return compareIdentifiers(a,b)}while(++i)}compareBuild(other){other instanceof SemVer||(other=new SemVer(other,this.options));let i=0;do{const a=this.build[i],b=other.build[i];if(debug("prerelease compare",i,a,b),void 0===a&&void 0===b)return 0;if(void 0===b)return 1;if(void 0===a)return -1;if(a!==b)return compareIdentifiers(a,b)}while(++i)}inc(release,identifier){switch(release){case"premajor":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc("pre",identifier);break;case"preminor":this.prerelease.length=0,this.patch=0,this.minor++,this.inc("pre",identifier);break;case"prepatch":this.prerelease.length=0,this.inc("patch",identifier),this.inc("pre",identifier);break;case"prerelease":0===this.prerelease.length&&this.inc("patch",identifier),this.inc("pre",identifier);break;case"major":0===this.minor&&0===this.patch&&0!==this.prerelease.length||this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case"minor":0===this.patch&&0!==this.prerelease.length||this.minor++,this.patch=0,this.prerelease=[];break;case"patch":0===this.prerelease.length&&this.patch++,this.prerelease=[];break;case"pre":if(0===this.prerelease.length)this.prerelease=[0];else {let i=this.prerelease.length;for(;--i>=0;)"number"==typeof this.prerelease[i]&&(this.prerelease[i]++,i=-2);-1===i&&this.prerelease.push(0);}identifier&&(this.prerelease[0]===identifier?isNaN(this.prerelease[1])&&(this.prerelease=[identifier,0]):this.prerelease=[identifier,0]);break;default:throw new Error(`invalid increment argument: ${release}`)}return this.format(),this.raw=this.version,this}}module.exports=SemVer;},"./node_modules/semver/functions/clean.js":(module,__unused_webpack_exports,__webpack_require__)=>{const parse=__webpack_require__("./node_modules/semver/functions/parse.js");module.exports=(version,options)=>{const s=parse(version.trim().replace(/^[=v]+/,""),options);return s?s.version:null};},"./node_modules/semver/functions/cmp.js":(module,__unused_webpack_exports,__webpack_require__)=>{const eq=__webpack_require__("./node_modules/semver/functions/eq.js"),neq=__webpack_require__("./node_modules/semver/functions/neq.js"),gt=__webpack_require__("./node_modules/semver/functions/gt.js"),gte=__webpack_require__("./node_modules/semver/functions/gte.js"),lt=__webpack_require__("./node_modules/semver/functions/lt.js"),lte=__webpack_require__("./node_modules/semver/functions/lte.js");module.exports=(a,op,b,loose)=>{switch(op){case"===":return "object"==typeof a&&(a=a.version),"object"==typeof b&&(b=b.version),a===b;case"!==":return "object"==typeof a&&(a=a.version),"object"==typeof b&&(b=b.version),a!==b;case"":case"=":case"==":return eq(a,b,loose);case"!=":return neq(a,b,loose);case">":return gt(a,b,loose);case">=":return gte(a,b,loose);case"<":return lt(a,b,loose);case"<=":return lte(a,b,loose);default:throw new TypeError(`Invalid operator: ${op}`)}};},"./node_modules/semver/functions/coerce.js":(module,__unused_webpack_exports,__webpack_require__)=>{const SemVer=__webpack_require__("./node_modules/semver/classes/semver.js"),parse=__webpack_require__("./node_modules/semver/functions/parse.js"),{re,t}=__webpack_require__("./node_modules/semver/internal/re.js");module.exports=(version,options)=>{if(version instanceof SemVer)return version;if("number"==typeof version&&(version=String(version)),"string"!=typeof version)return null;let match=null;if((options=options||{}).rtl){let next;for(;(next=re[t.COERCERTL].exec(version))&&(!match||match.index+match[0].length!==version.length);)match&&next.index+next[0].length===match.index+match[0].length||(match=next),re[t.COERCERTL].lastIndex=next.index+next[1].length+next[2].length;re[t.COERCERTL].lastIndex=-1;}else match=version.match(re[t.COERCE]);return null===match?null:parse(`${match[2]}.${match[3]||"0"}.${match[4]||"0"}`,options)};},"./node_modules/semver/functions/compare-build.js":(module,__unused_webpack_exports,__webpack_require__)=>{const SemVer=__webpack_require__("./node_modules/semver/classes/semver.js");module.exports=(a,b,loose)=>{const versionA=new SemVer(a,loose),versionB=new SemVer(b,loose);return versionA.compare(versionB)||versionA.compareBuild(versionB)};},"./node_modules/semver/functions/compare-loose.js":(module,__unused_webpack_exports,__webpack_require__)=>{const compare=__webpack_require__("./node_modules/semver/functions/compare.js");module.exports=(a,b)=>compare(a,b,!0);},"./node_modules/semver/functions/compare.js":(module,__unused_webpack_exports,__webpack_require__)=>{const SemVer=__webpack_require__("./node_modules/semver/classes/semver.js");module.exports=(a,b,loose)=>new SemVer(a,loose).compare(new SemVer(b,loose));},"./node_modules/semver/functions/diff.js":(module,__unused_webpack_exports,__webpack_require__)=>{const parse=__webpack_require__("./node_modules/semver/functions/parse.js"),eq=__webpack_require__("./node_modules/semver/functions/eq.js");module.exports=(version1,version2)=>{if(eq(version1,version2))return null;{const v1=parse(version1),v2=parse(version2),hasPre=v1.prerelease.length||v2.prerelease.length,prefix=hasPre?"pre":"",defaultResult=hasPre?"prerelease":"";for(const key in v1)if(("major"===key||"minor"===key||"patch"===key)&&v1[key]!==v2[key])return prefix+key;return defaultResult}};},"./node_modules/semver/functions/eq.js":(module,__unused_webpack_exports,__webpack_require__)=>{const compare=__webpack_require__("./node_modules/semver/functions/compare.js");module.exports=(a,b,loose)=>0===compare(a,b,loose);},"./node_modules/semver/functions/gt.js":(module,__unused_webpack_exports,__webpack_require__)=>{const compare=__webpack_require__("./node_modules/semver/functions/compare.js");module.exports=(a,b,loose)=>compare(a,b,loose)>0;},"./node_modules/semver/functions/gte.js":(module,__unused_webpack_exports,__webpack_require__)=>{const compare=__webpack_require__("./node_modules/semver/functions/compare.js");module.exports=(a,b,loose)=>compare(a,b,loose)>=0;},"./node_modules/semver/functions/inc.js":(module,__unused_webpack_exports,__webpack_require__)=>{const SemVer=__webpack_require__("./node_modules/semver/classes/semver.js");module.exports=(version,release,options,identifier)=>{"string"==typeof options&&(identifier=options,options=void 0);try{return new SemVer(version,options).inc(release,identifier).version}catch(er){return null}};},"./node_modules/semver/functions/lt.js":(module,__unused_webpack_exports,__webpack_require__)=>{const compare=__webpack_require__("./node_modules/semver/functions/compare.js");module.exports=(a,b,loose)=>compare(a,b,loose)<0;},"./node_modules/semver/functions/lte.js":(module,__unused_webpack_exports,__webpack_require__)=>{const compare=__webpack_require__("./node_modules/semver/functions/compare.js");module.exports=(a,b,loose)=>compare(a,b,loose)<=0;},"./node_modules/semver/functions/major.js":(module,__unused_webpack_exports,__webpack_require__)=>{const SemVer=__webpack_require__("./node_modules/semver/classes/semver.js");module.exports=(a,loose)=>new SemVer(a,loose).major;},"./node_modules/semver/functions/minor.js":(module,__unused_webpack_exports,__webpack_require__)=>{const SemVer=__webpack_require__("./node_modules/semver/classes/semver.js");module.exports=(a,loose)=>new SemVer(a,loose).minor;},"./node_modules/semver/functions/neq.js":(module,__unused_webpack_exports,__webpack_require__)=>{const compare=__webpack_require__("./node_modules/semver/functions/compare.js");module.exports=(a,b,loose)=>0!==compare(a,b,loose);},"./node_modules/semver/functions/parse.js":(module,__unused_webpack_exports,__webpack_require__)=>{const{MAX_LENGTH}=__webpack_require__("./node_modules/semver/internal/constants.js"),{re,t}=__webpack_require__("./node_modules/semver/internal/re.js"),SemVer=__webpack_require__("./node_modules/semver/classes/semver.js"),parseOptions=__webpack_require__("./node_modules/semver/internal/parse-options.js");module.exports=(version,options)=>{if(options=parseOptions(options),version instanceof SemVer)return version;if("string"!=typeof version)return null;if(version.length>MAX_LENGTH)return null;if(!(options.loose?re[t.LOOSE]:re[t.FULL]).test(version))return null;try{return new SemVer(version,options)}catch(er){return null}};},"./node_modules/semver/functions/patch.js":(module,__unused_webpack_exports,__webpack_require__)=>{const SemVer=__webpack_require__("./node_modules/semver/classes/semver.js");module.exports=(a,loose)=>new SemVer(a,loose).patch;},"./node_modules/semver/functions/prerelease.js":(module,__unused_webpack_exports,__webpack_require__)=>{const parse=__webpack_require__("./node_modules/semver/functions/parse.js");module.exports=(version,options)=>{const parsed=parse(version,options);return parsed&&parsed.prerelease.length?parsed.prerelease:null};},"./node_modules/semver/functions/rcompare.js":(module,__unused_webpack_exports,__webpack_require__)=>{const compare=__webpack_require__("./node_modules/semver/functions/compare.js");module.exports=(a,b,loose)=>compare(b,a,loose);},"./node_modules/semver/functions/rsort.js":(module,__unused_webpack_exports,__webpack_require__)=>{const compareBuild=__webpack_require__("./node_modules/semver/functions/compare-build.js");module.exports=(list,loose)=>list.sort(((a,b)=>compareBuild(b,a,loose)));},"./node_modules/semver/functions/satisfies.js":(module,__unused_webpack_exports,__webpack_require__)=>{const Range=__webpack_require__("./node_modules/semver/classes/range.js");module.exports=(version,range,options)=>{try{range=new Range(range,options);}catch(er){return !1}return range.test(version)};},"./node_modules/semver/functions/sort.js":(module,__unused_webpack_exports,__webpack_require__)=>{const compareBuild=__webpack_require__("./node_modules/semver/functions/compare-build.js");module.exports=(list,loose)=>list.sort(((a,b)=>compareBuild(a,b,loose)));},"./node_modules/semver/functions/valid.js":(module,__unused_webpack_exports,__webpack_require__)=>{const parse=__webpack_require__("./node_modules/semver/functions/parse.js");module.exports=(version,options)=>{const v=parse(version,options);return v?v.version:null};},"./node_modules/semver/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{const internalRe=__webpack_require__("./node_modules/semver/internal/re.js");module.exports={re:internalRe.re,src:internalRe.src,tokens:internalRe.t,SEMVER_SPEC_VERSION:__webpack_require__("./node_modules/semver/internal/constants.js").SEMVER_SPEC_VERSION,SemVer:__webpack_require__("./node_modules/semver/classes/semver.js"),compareIdentifiers:__webpack_require__("./node_modules/semver/internal/identifiers.js").compareIdentifiers,rcompareIdentifiers:__webpack_require__("./node_modules/semver/internal/identifiers.js").rcompareIdentifiers,parse:__webpack_require__("./node_modules/semver/functions/parse.js"),valid:__webpack_require__("./node_modules/semver/functions/valid.js"),clean:__webpack_require__("./node_modules/semver/functions/clean.js"),inc:__webpack_require__("./node_modules/semver/functions/inc.js"),diff:__webpack_require__("./node_modules/semver/functions/diff.js"),major:__webpack_require__("./node_modules/semver/functions/major.js"),minor:__webpack_require__("./node_modules/semver/functions/minor.js"),patch:__webpack_require__("./node_modules/semver/functions/patch.js"),prerelease:__webpack_require__("./node_modules/semver/functions/prerelease.js"),compare:__webpack_require__("./node_modules/semver/functions/compare.js"),rcompare:__webpack_require__("./node_modules/semver/functions/rcompare.js"),compareLoose:__webpack_require__("./node_modules/semver/functions/compare-loose.js"),compareBuild:__webpack_require__("./node_modules/semver/functions/compare-build.js"),sort:__webpack_require__("./node_modules/semver/functions/sort.js"),rsort:__webpack_require__("./node_modules/semver/functions/rsort.js"),gt:__webpack_require__("./node_modules/semver/functions/gt.js"),lt:__webpack_require__("./node_modules/semver/functions/lt.js"),eq:__webpack_require__("./node_modules/semver/functions/eq.js"),neq:__webpack_require__("./node_modules/semver/functions/neq.js"),gte:__webpack_require__("./node_modules/semver/functions/gte.js"),lte:__webpack_require__("./node_modules/semver/functions/lte.js"),cmp:__webpack_require__("./node_modules/semver/functions/cmp.js"),coerce:__webpack_require__("./node_modules/semver/functions/coerce.js"),Comparator:__webpack_require__("./node_modules/semver/classes/comparator.js"),Range:__webpack_require__("./node_modules/semver/classes/range.js"),satisfies:__webpack_require__("./node_modules/semver/functions/satisfies.js"),toComparators:__webpack_require__("./node_modules/semver/ranges/to-comparators.js"),maxSatisfying:__webpack_require__("./node_modules/semver/ranges/max-satisfying.js"),minSatisfying:__webpack_require__("./node_modules/semver/ranges/min-satisfying.js"),minVersion:__webpack_require__("./node_modules/semver/ranges/min-version.js"),validRange:__webpack_require__("./node_modules/semver/ranges/valid.js"),outside:__webpack_require__("./node_modules/semver/ranges/outside.js"),gtr:__webpack_require__("./node_modules/semver/ranges/gtr.js"),ltr:__webpack_require__("./node_modules/semver/ranges/ltr.js"),intersects:__webpack_require__("./node_modules/semver/ranges/intersects.js"),simplifyRange:__webpack_require__("./node_modules/semver/ranges/simplify.js"),subset:__webpack_require__("./node_modules/semver/ranges/subset.js")};},"./node_modules/semver/internal/constants.js":module=>{const MAX_SAFE_INTEGER=Number.MAX_SAFE_INTEGER||9007199254740991;module.exports={SEMVER_SPEC_VERSION:"2.0.0",MAX_LENGTH:256,MAX_SAFE_INTEGER,MAX_SAFE_COMPONENT_LENGTH:16};},"./node_modules/semver/internal/debug.js":module=>{const debug="object"==typeof process&&process.env&&process.env.NODE_DEBUG&&/\bsemver\b/i.test(process.env.NODE_DEBUG)?(...args)=>console.error("SEMVER",...args):()=>{};module.exports=debug;},"./node_modules/semver/internal/identifiers.js":module=>{const numeric=/^[0-9]+$/,compareIdentifiers=(a,b)=>{const anum=numeric.test(a),bnum=numeric.test(b);return anum&&bnum&&(a=+a,b=+b),a===b?0:anum&&!bnum?-1:bnum&&!anum?1:a<b?-1:1};module.exports={compareIdentifiers,rcompareIdentifiers:(a,b)=>compareIdentifiers(b,a)};},"./node_modules/semver/internal/parse-options.js":module=>{const opts=["includePrerelease","loose","rtl"];module.exports=options=>options?"object"!=typeof options?{loose:!0}:opts.filter((k=>options[k])).reduce(((options,k)=>(options[k]=!0,options)),{}):{};},"./node_modules/semver/internal/re.js":(module,exports,__webpack_require__)=>{const{MAX_SAFE_COMPONENT_LENGTH}=__webpack_require__("./node_modules/semver/internal/constants.js"),debug=__webpack_require__("./node_modules/semver/internal/debug.js"),re=(exports=module.exports={}).re=[],src=exports.src=[],t=exports.t={};let R=0;const createToken=(name,value,isGlobal)=>{const index=R++;debug(index,value),t[name]=index,src[index]=value,re[index]=new RegExp(value,isGlobal?"g":void 0);};createToken("NUMERICIDENTIFIER","0|[1-9]\\d*"),createToken("NUMERICIDENTIFIERLOOSE","[0-9]+"),createToken("NONNUMERICIDENTIFIER","\\d*[a-zA-Z-][a-zA-Z0-9-]*"),createToken("MAINVERSION",`(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`),createToken("MAINVERSIONLOOSE",`(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`),createToken("PRERELEASEIDENTIFIER",`(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`),createToken("PRERELEASEIDENTIFIERLOOSE",`(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`),createToken("PRERELEASE",`(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`),createToken("PRERELEASELOOSE",`(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`),createToken("BUILDIDENTIFIER","[0-9A-Za-z-]+"),createToken("BUILD",`(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`),createToken("FULLPLAIN",`v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`),createToken("FULL",`^${src[t.FULLPLAIN]}$`),createToken("LOOSEPLAIN",`[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`),createToken("LOOSE",`^${src[t.LOOSEPLAIN]}$`),createToken("GTLT","((?:<|>)?=?)"),createToken("XRANGEIDENTIFIERLOOSE",`${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),createToken("XRANGEIDENTIFIER",`${src[t.NUMERICIDENTIFIER]}|x|X|\\*`),createToken("XRANGEPLAIN",`[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`),createToken("XRANGEPLAINLOOSE",`[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`),createToken("XRANGE",`^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`),createToken("XRANGELOOSE",`^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`),createToken("COERCE",`(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`),createToken("COERCERTL",src[t.COERCE],!0),createToken("LONETILDE","(?:~>?)"),createToken("TILDETRIM",`(\\s*)${src[t.LONETILDE]}\\s+`,!0),exports.tildeTrimReplace="$1~",createToken("TILDE",`^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`),createToken("TILDELOOSE",`^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`),createToken("LONECARET","(?:\\^)"),createToken("CARETTRIM",`(\\s*)${src[t.LONECARET]}\\s+`,!0),exports.caretTrimReplace="$1^",createToken("CARET",`^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`),createToken("CARETLOOSE",`^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`),createToken("COMPARATORLOOSE",`^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`),createToken("COMPARATOR",`^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`),createToken("COMPARATORTRIM",`(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`,!0),exports.comparatorTrimReplace="$1$2$3",createToken("HYPHENRANGE",`^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`),createToken("HYPHENRANGELOOSE",`^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`),createToken("STAR","(<|>)?=?\\s*\\*"),createToken("GTE0","^\\s*>=\\s*0.0.0\\s*$"),createToken("GTE0PRE","^\\s*>=\\s*0.0.0-0\\s*$");},"./node_modules/semver/ranges/gtr.js":(module,__unused_webpack_exports,__webpack_require__)=>{const outside=__webpack_require__("./node_modules/semver/ranges/outside.js");module.exports=(version,range,options)=>outside(version,range,">",options);},"./node_modules/semver/ranges/intersects.js":(module,__unused_webpack_exports,__webpack_require__)=>{const Range=__webpack_require__("./node_modules/semver/classes/range.js");module.exports=(r1,r2,options)=>(r1=new Range(r1,options),r2=new Range(r2,options),r1.intersects(r2));},"./node_modules/semver/ranges/ltr.js":(module,__unused_webpack_exports,__webpack_require__)=>{const outside=__webpack_require__("./node_modules/semver/ranges/outside.js");module.exports=(version,range,options)=>outside(version,range,"<",options);},"./node_modules/semver/ranges/max-satisfying.js":(module,__unused_webpack_exports,__webpack_require__)=>{const SemVer=__webpack_require__("./node_modules/semver/classes/semver.js"),Range=__webpack_require__("./node_modules/semver/classes/range.js");module.exports=(versions,range,options)=>{let max=null,maxSV=null,rangeObj=null;try{rangeObj=new Range(range,options);}catch(er){return null}return versions.forEach((v=>{rangeObj.test(v)&&(max&&-1!==maxSV.compare(v)||(max=v,maxSV=new SemVer(max,options)));})),max};},"./node_modules/semver/ranges/min-satisfying.js":(module,__unused_webpack_exports,__webpack_require__)=>{const SemVer=__webpack_require__("./node_modules/semver/classes/semver.js"),Range=__webpack_require__("./node_modules/semver/classes/range.js");module.exports=(versions,range,options)=>{let min=null,minSV=null,rangeObj=null;try{rangeObj=new Range(range,options);}catch(er){return null}return versions.forEach((v=>{rangeObj.test(v)&&(min&&1!==minSV.compare(v)||(min=v,minSV=new SemVer(min,options)));})),min};},"./node_modules/semver/ranges/min-version.js":(module,__unused_webpack_exports,__webpack_require__)=>{const SemVer=__webpack_require__("./node_modules/semver/classes/semver.js"),Range=__webpack_require__("./node_modules/semver/classes/range.js"),gt=__webpack_require__("./node_modules/semver/functions/gt.js");module.exports=(range,loose)=>{range=new Range(range,loose);let minver=new SemVer("0.0.0");if(range.test(minver))return minver;if(minver=new SemVer("0.0.0-0"),range.test(minver))return minver;minver=null;for(let i=0;i<range.set.length;++i){const comparators=range.set[i];let setMin=null;comparators.forEach((comparator=>{const compver=new SemVer(comparator.semver.version);switch(comparator.operator){case">":0===compver.prerelease.length?compver.patch++:compver.prerelease.push(0),compver.raw=compver.format();case"":case">=":setMin&&!gt(compver,setMin)||(setMin=compver);break;case"<":case"<=":break;default:throw new Error(`Unexpected operation: ${comparator.operator}`)}})),!setMin||minver&&!gt(minver,setMin)||(minver=setMin);}return minver&&range.test(minver)?minver:null};},"./node_modules/semver/ranges/outside.js":(module,__unused_webpack_exports,__webpack_require__)=>{const SemVer=__webpack_require__("./node_modules/semver/classes/semver.js"),Comparator=__webpack_require__("./node_modules/semver/classes/comparator.js"),{ANY}=Comparator,Range=__webpack_require__("./node_modules/semver/classes/range.js"),satisfies=__webpack_require__("./node_modules/semver/functions/satisfies.js"),gt=__webpack_require__("./node_modules/semver/functions/gt.js"),lt=__webpack_require__("./node_modules/semver/functions/lt.js"),lte=__webpack_require__("./node_modules/semver/functions/lte.js"),gte=__webpack_require__("./node_modules/semver/functions/gte.js");module.exports=(version,range,hilo,options)=>{let gtfn,ltefn,ltfn,comp,ecomp;switch(version=new SemVer(version,options),range=new Range(range,options),hilo){case">":gtfn=gt,ltefn=lte,ltfn=lt,comp=">",ecomp=">=";break;case"<":gtfn=lt,ltefn=gte,ltfn=gt,comp="<",ecomp="<=";break;default:throw new TypeError('Must provide a hilo val of "<" or ">"')}if(satisfies(version,range,options))return !1;for(let i=0;i<range.set.length;++i){const comparators=range.set[i];let high=null,low=null;if(comparators.forEach((comparator=>{comparator.semver===ANY&&(comparator=new Comparator(">=0.0.0")),high=high||comparator,low=low||comparator,gtfn(comparator.semver,high.semver,options)?high=comparator:ltfn(comparator.semver,low.semver,options)&&(low=comparator);})),high.operator===comp||high.operator===ecomp)return !1;if((!low.operator||low.operator===comp)&&ltefn(version,low.semver))return !1;if(low.operator===ecomp&&ltfn(version,low.semver))return !1}return !0};},"./node_modules/semver/ranges/simplify.js":(module,__unused_webpack_exports,__webpack_require__)=>{const satisfies=__webpack_require__("./node_modules/semver/functions/satisfies.js"),compare=__webpack_require__("./node_modules/semver/functions/compare.js");module.exports=(versions,range,options)=>{const set=[];let min=null,prev=null;const v=versions.sort(((a,b)=>compare(a,b,options)));for(const version of v){satisfies(version,range,options)?(prev=version,min||(min=version)):(prev&&set.push([min,prev]),prev=null,min=null);}min&&set.push([min,null]);const ranges=[];for(const[min,max]of set)min===max?ranges.push(min):max||min!==v[0]?max?min===v[0]?ranges.push(`<=${max}`):ranges.push(`${min} - ${max}`):ranges.push(`>=${min}`):ranges.push("*");const simplified=ranges.join(" || "),original="string"==typeof range.raw?range.raw:String(range);return simplified.length<original.length?simplified:range};},"./node_modules/semver/ranges/subset.js":(module,__unused_webpack_exports,__webpack_require__)=>{const Range=__webpack_require__("./node_modules/semver/classes/range.js"),Comparator=__webpack_require__("./node_modules/semver/classes/comparator.js"),{ANY}=Comparator,satisfies=__webpack_require__("./node_modules/semver/functions/satisfies.js"),compare=__webpack_require__("./node_modules/semver/functions/compare.js"),simpleSubset=(sub,dom,options)=>{if(sub===dom)return !0;if(1===sub.length&&sub[0].semver===ANY){if(1===dom.length&&dom[0].semver===ANY)return !0;sub=options.includePrerelease?[new Comparator(">=0.0.0-0")]:[new Comparator(">=0.0.0")];}if(1===dom.length&&dom[0].semver===ANY){if(options.includePrerelease)return !0;dom=[new Comparator(">=0.0.0")];}const eqSet=new Set;let gt,lt,gtltComp,higher,lower,hasDomLT,hasDomGT;for(const c of sub)">"===c.operator||">="===c.operator?gt=higherGT(gt,c,options):"<"===c.operator||"<="===c.operator?lt=lowerLT(lt,c,options):eqSet.add(c.semver);if(eqSet.size>1)return null;if(gt&&lt){if(gtltComp=compare(gt.semver,lt.semver,options),gtltComp>0)return null;if(0===gtltComp&&(">="!==gt.operator||"<="!==lt.operator))return null}for(const eq of eqSet){if(gt&&!satisfies(eq,String(gt),options))return null;if(lt&&!satisfies(eq,String(lt),options))return null;for(const c of dom)if(!satisfies(eq,String(c),options))return !1;return !0}let needDomLTPre=!(!lt||options.includePrerelease||!lt.semver.prerelease.length)&&lt.semver,needDomGTPre=!(!gt||options.includePrerelease||!gt.semver.prerelease.length)&&gt.semver;needDomLTPre&&1===needDomLTPre.prerelease.length&&"<"===lt.operator&&0===needDomLTPre.prerelease[0]&&(needDomLTPre=!1);for(const c of dom){if(hasDomGT=hasDomGT||">"===c.operator||">="===c.operator,hasDomLT=hasDomLT||"<"===c.operator||"<="===c.operator,gt)if(needDomGTPre&&c.semver.prerelease&&c.semver.prerelease.length&&c.semver.major===needDomGTPre.major&&c.semver.minor===needDomGTPre.minor&&c.semver.patch===needDomGTPre.patch&&(needDomGTPre=!1),">"===c.operator||">="===c.operator){if(higher=higherGT(gt,c,options),higher===c&&higher!==gt)return !1}else if(">="===gt.operator&&!satisfies(gt.semver,String(c),options))return !1;if(lt)if(needDomLTPre&&c.semver.prerelease&&c.semver.prerelease.length&&c.semver.major===needDomLTPre.major&&c.semver.minor===needDomLTPre.minor&&c.semver.patch===needDomLTPre.patch&&(needDomLTPre=!1),"<"===c.operator||"<="===c.operator){if(lower=lowerLT(lt,c,options),lower===c&&lower!==lt)return !1}else if("<="===lt.operator&&!satisfies(lt.semver,String(c),options))return !1;if(!c.operator&&(lt||gt)&&0!==gtltComp)return !1}return !(gt&&hasDomLT&&!lt&&0!==gtltComp)&&(!(lt&&hasDomGT&&!gt&&0!==gtltComp)&&(!needDomGTPre&&!needDomLTPre))},higherGT=(a,b,options)=>{if(!a)return b;const comp=compare(a.semver,b.semver,options);return comp>0?a:comp<0||">"===b.operator&&">="===a.operator?b:a},lowerLT=(a,b,options)=>{if(!a)return b;const comp=compare(a.semver,b.semver,options);return comp<0?a:comp>0||"<"===b.operator&&"<="===a.operator?b:a};module.exports=(sub,dom,options={})=>{if(sub===dom)return !0;sub=new Range(sub,options),dom=new Range(dom,options);let sawNonNull=!1;OUTER:for(const simpleSub of sub.set){for(const simpleDom of dom.set){const isSub=simpleSubset(simpleSub,simpleDom,options);if(sawNonNull=sawNonNull||null!==isSub,isSub)continue OUTER}if(sawNonNull)return !1}return !0};},"./node_modules/semver/ranges/to-comparators.js":(module,__unused_webpack_exports,__webpack_require__)=>{const Range=__webpack_require__("./node_modules/semver/classes/range.js");module.exports=(range,options)=>new Range(range,options).set.map((comp=>comp.map((c=>c.value)).join(" ").trim().split(" ")));},"./node_modules/semver/ranges/valid.js":(module,__unused_webpack_exports,__webpack_require__)=>{const Range=__webpack_require__("./node_modules/semver/classes/range.js");module.exports=(range,options)=>{try{return new Range(range,options).range||"*"}catch(er){return null}};},"./node_modules/yallist/iterator.js":module=>{module.exports=function(Yallist){Yallist.prototype[Symbol.iterator]=function*(){for(let walker=this.head;walker;walker=walker.next)yield walker.value;};};},"./node_modules/yallist/yallist.js":(module,__unused_webpack_exports,__webpack_require__)=>{function Yallist(list){var self=this;if(self instanceof Yallist||(self=new Yallist),self.tail=null,self.head=null,self.length=0,list&&"function"==typeof list.forEach)list.forEach((function(item){self.push(item);}));else if(arguments.length>0)for(var i=0,l=arguments.length;i<l;i++)self.push(arguments[i]);return self}function insert(self,node,value){var inserted=node===self.head?new Node(value,null,node,self):new Node(value,node,node.next,self);return null===inserted.next&&(self.tail=inserted),null===inserted.prev&&(self.head=inserted),self.length++,inserted}function push(self,item){self.tail=new Node(item,self.tail,null,self),self.head||(self.head=self.tail),self.length++;}function unshift(self,item){self.head=new Node(item,null,self.head,self),self.tail||(self.tail=self.head),self.length++;}function Node(value,prev,next,list){if(!(this instanceof Node))return new Node(value,prev,next,list);this.list=list,this.value=value,prev?(prev.next=this,this.prev=prev):this.prev=null,next?(next.prev=this,this.next=next):this.next=null;}module.exports=Yallist,Yallist.Node=Node,Yallist.create=Yallist,Yallist.prototype.removeNode=function(node){if(node.list!==this)throw new Error("removing node which does not belong to this list");var next=node.next,prev=node.prev;return next&&(next.prev=prev),prev&&(prev.next=next),node===this.head&&(this.head=next),node===this.tail&&(this.tail=prev),node.list.length--,node.next=null,node.prev=null,node.list=null,next},Yallist.prototype.unshiftNode=function(node){if(node!==this.head){node.list&&node.list.removeNode(node);var head=this.head;node.list=this,node.next=head,head&&(head.prev=node),this.head=node,this.tail||(this.tail=node),this.length++;}},Yallist.prototype.pushNode=function(node){if(node!==this.tail){node.list&&node.list.removeNode(node);var tail=this.tail;node.list=this,node.prev=tail,tail&&(tail.next=node),this.tail=node,this.head||(this.head=node),this.length++;}},Yallist.prototype.push=function(){for(var i=0,l=arguments.length;i<l;i++)push(this,arguments[i]);return this.length},Yallist.prototype.unshift=function(){for(var i=0,l=arguments.length;i<l;i++)unshift(this,arguments[i]);return this.length},Yallist.prototype.pop=function(){if(this.tail){var res=this.tail.value;return this.tail=this.tail.prev,this.tail?this.tail.next=null:this.head=null,this.length--,res}},Yallist.prototype.shift=function(){if(this.head){var res=this.head.value;return this.head=this.head.next,this.head?this.head.prev=null:this.tail=null,this.length--,res}},Yallist.prototype.forEach=function(fn,thisp){thisp=thisp||this;for(var walker=this.head,i=0;null!==walker;i++)fn.call(thisp,walker.value,i,this),walker=walker.next;},Yallist.prototype.forEachReverse=function(fn,thisp){thisp=thisp||this;for(var walker=this.tail,i=this.length-1;null!==walker;i--)fn.call(thisp,walker.value,i,this),walker=walker.prev;},Yallist.prototype.get=function(n){for(var i=0,walker=this.head;null!==walker&&i<n;i++)walker=walker.next;if(i===n&&null!==walker)return walker.value},Yallist.prototype.getReverse=function(n){for(var i=0,walker=this.tail;null!==walker&&i<n;i++)walker=walker.prev;if(i===n&&null!==walker)return walker.value},Yallist.prototype.map=function(fn,thisp){thisp=thisp||this;for(var res=new Yallist,walker=this.head;null!==walker;)res.push(fn.call(thisp,walker.value,this)),walker=walker.next;return res},Yallist.prototype.mapReverse=function(fn,thisp){thisp=thisp||this;for(var res=new Yallist,walker=this.tail;null!==walker;)res.push(fn.call(thisp,walker.value,this)),walker=walker.prev;return res},Yallist.prototype.reduce=function(fn,initial){var acc,walker=this.head;if(arguments.length>1)acc=initial;else {if(!this.head)throw new TypeError("Reduce of empty list with no initial value");walker=this.head.next,acc=this.head.value;}for(var i=0;null!==walker;i++)acc=fn(acc,walker.value,i),walker=walker.next;return acc},Yallist.prototype.reduceReverse=function(fn,initial){var acc,walker=this.tail;if(arguments.length>1)acc=initial;else {if(!this.tail)throw new TypeError("Reduce of empty list with no initial value");walker=this.tail.prev,acc=this.tail.value;}for(var i=this.length-1;null!==walker;i--)acc=fn(acc,walker.value,i),walker=walker.prev;return acc},Yallist.prototype.toArray=function(){for(var arr=new Array(this.length),i=0,walker=this.head;null!==walker;i++)arr[i]=walker.value,walker=walker.next;return arr},Yallist.prototype.toArrayReverse=function(){for(var arr=new Array(this.length),i=0,walker=this.tail;null!==walker;i++)arr[i]=walker.value,walker=walker.prev;return arr},Yallist.prototype.slice=function(from,to){(to=to||this.length)<0&&(to+=this.length),(from=from||0)<0&&(from+=this.length);var ret=new Yallist;if(to<from||to<0)return ret;from<0&&(from=0),to>this.length&&(to=this.length);for(var i=0,walker=this.head;null!==walker&&i<from;i++)walker=walker.next;for(;null!==walker&&i<to;i++,walker=walker.next)ret.push(walker.value);return ret},Yallist.prototype.sliceReverse=function(from,to){(to=to||this.length)<0&&(to+=this.length),(from=from||0)<0&&(from+=this.length);var ret=new Yallist;if(to<from||to<0)return ret;from<0&&(from=0),to>this.length&&(to=this.length);for(var i=this.length,walker=this.tail;null!==walker&&i>to;i--)walker=walker.prev;for(;null!==walker&&i>from;i--,walker=walker.prev)ret.push(walker.value);return ret},Yallist.prototype.splice=function(start,deleteCount,...nodes){start>this.length&&(start=this.length-1),start<0&&(start=this.length+start);for(var i=0,walker=this.head;null!==walker&&i<start;i++)walker=walker.next;var ret=[];for(i=0;walker&&i<deleteCount;i++)ret.push(walker.value),walker=this.removeNode(walker);null===walker&&(walker=this.tail),walker!==this.head&&walker!==this.tail&&(walker=walker.prev);for(i=0;i<nodes.length;i++)walker=insert(this,walker,nodes[i]);return ret},Yallist.prototype.reverse=function(){for(var head=this.head,tail=this.tail,walker=head;null!==walker;walker=walker.prev){var p=walker.prev;walker.prev=walker.next,walker.next=p;}return this.head=tail,this.tail=head,this};try{__webpack_require__("./node_modules/yallist/iterator.js")(Yallist);}catch(er){}},crypto:module=>{module.exports=require$$0__default["default"];},fs:module=>{module.exports=fs__default["default"];},module:module=>{module.exports=require$$2__default["default"];},path:module=>{module.exports=require$$0__default$1["default"];},util:module=>{module.exports=require$$1__default["default"];}},__webpack_module_cache__={};function __webpack_require__(moduleId){var cachedModule=__webpack_module_cache__[moduleId];if(void 0!==cachedModule)return cachedModule.exports;var module=__webpack_module_cache__[moduleId]={id:moduleId,loaded:!1,exports:{}};return __webpack_modules__[moduleId](module,module.exports,__webpack_require__),module.loaded=!0,module.exports}__webpack_require__.n=module=>{var getter=module&&module.__esModule?()=>module.default:()=>module;return __webpack_require__.d(getter,{a:getter}),getter},__webpack_require__.d=(exports,definition)=>{for(var key in definition)__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)&&Object.defineProperty(exports,key,{enumerable:!0,get:definition[key]});},__webpack_require__.o=(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop),__webpack_require__.nmd=module=>(module.paths=[],module.children||(module.children=[]),module);var __webpack_exports__={};(()=>{__webpack_require__.d(__webpack_exports__,{default:()=>createJITI});var external_fs_=__webpack_require__("fs"),external_module_=__webpack_require__("module"),external_path_=__webpack_require__("path");const external_os_namespaceObject=require$$5__default["default"],external_vm_namespaceObject=require$$6__default["default"];var external_vm_default=__webpack_require__.n(external_vm_namespaceObject);const external_url_namespaceObject=require$$7__default["default"];var mkdirp=__webpack_require__("./node_modules/mkdirp/index.js");const suspectProtoRx=/"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/,suspectConstructorRx=/"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,JsonSigRx=/^["{[]|^-?[0-9][0-9.]{0,14}$/;function jsonParseTransform(key,value){if("__proto__"!==key&&"constructor"!==key)return value}const dist=function(val){if("string"!=typeof val)return val;const _lval=val.toLowerCase();if("true"===_lval)return !0;if("false"===_lval)return !1;if("null"===_lval)return null;if("nan"===_lval)return NaN;if("infinity"===_lval)return 1/0;if("undefined"!==_lval){if(!JsonSigRx.test(val))return val;try{return suspectProtoRx.test(val)||suspectConstructorRx.test(val)?JSON.parse(val,jsonParseTransform):JSON.parse(val)}catch(_e){return val}}};var create_require=__webpack_require__("./node_modules/create-require/create-require.js"),create_require_default=__webpack_require__.n(create_require),semver=__webpack_require__("./node_modules/semver/index.js"),lib=__webpack_require__("./node_modules/pirates/lib/index.js"),object_hash=__webpack_require__("./node_modules/object-hash/index.js"),object_hash_default=__webpack_require__.n(object_hash);const external_assert_namespaceObject=require$$8__default["default"];var external_util_=__webpack_require__("util");const BUILTIN_MODULES$1=new Set(external_module_.builtinModules);function normalizeSlash$1(str){return str.replace(/\\/g,"/")}function fileURLToPath$1(id){return "string"!=typeof id||id.startsWith("file://")?normalizeSlash$1((0, external_url_namespaceObject.fileURLToPath)(id)):normalizeSlash$1(id)}const _IS_ABSOLUTE_RE$1=/^\/|^\\|^[a-zA-Z]:[/\\]/;const isAbsolute$1=function(p){return _IS_ABSOLUTE_RE$1.test(p)};var re$b={exports:{}};var constants$1={SEMVER_SPEC_VERSION:"2.0.0",MAX_LENGTH:256,MAX_SAFE_INTEGER:Number.MAX_SAFE_INTEGER||9007199254740991,MAX_SAFE_COMPONENT_LENGTH:16};var debug_1$1="object"==typeof process&&process.env&&process.env.NODE_DEBUG&&/\bsemver\b/i.test(process.env.NODE_DEBUG)?(...args)=>console.error("SEMVER",...args):()=>{};!function(module,exports){const{MAX_SAFE_COMPONENT_LENGTH}=constants$1,debug=debug_1$1,re=(exports=module.exports={}).re=[],src=exports.src=[],t=exports.t={};let R=0;const createToken=(name,value,isGlobal)=>{const index=R++;debug(index,value),t[name]=index,src[index]=value,re[index]=new RegExp(value,isGlobal?"g":void 0);};createToken("NUMERICIDENTIFIER","0|[1-9]\\d*"),createToken("NUMERICIDENTIFIERLOOSE","[0-9]+"),createToken("NONNUMERICIDENTIFIER","\\d*[a-zA-Z-][a-zA-Z0-9-]*"),createToken("MAINVERSION",`(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`),createToken("MAINVERSIONLOOSE",`(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`),createToken("PRERELEASEIDENTIFIER",`(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`),createToken("PRERELEASEIDENTIFIERLOOSE",`(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`),createToken("PRERELEASE",`(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`),createToken("PRERELEASELOOSE",`(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`),createToken("BUILDIDENTIFIER","[0-9A-Za-z-]+"),createToken("BUILD",`(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`),createToken("FULLPLAIN",`v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`),createToken("FULL",`^${src[t.FULLPLAIN]}$`),createToken("LOOSEPLAIN",`[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`),createToken("LOOSE",`^${src[t.LOOSEPLAIN]}$`),createToken("GTLT","((?:<|>)?=?)"),createToken("XRANGEIDENTIFIERLOOSE",`${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),createToken("XRANGEIDENTIFIER",`${src[t.NUMERICIDENTIFIER]}|x|X|\\*`),createToken("XRANGEPLAIN",`[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`),createToken("XRANGEPLAINLOOSE",`[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`),createToken("XRANGE",`^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`),createToken("XRANGELOOSE",`^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`),createToken("COERCE",`(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`),createToken("COERCERTL",src[t.COERCE],!0),createToken("LONETILDE","(?:~>?)"),createToken("TILDETRIM",`(\\s*)${src[t.LONETILDE]}\\s+`,!0),exports.tildeTrimReplace="$1~",createToken("TILDE",`^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`),createToken("TILDELOOSE",`^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`),createToken("LONECARET","(?:\\^)"),createToken("CARETTRIM",`(\\s*)${src[t.LONECARET]}\\s+`,!0),exports.caretTrimReplace="$1^",createToken("CARET",`^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`),createToken("CARETLOOSE",`^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`),createToken("COMPARATORLOOSE",`^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`),createToken("COMPARATOR",`^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`),createToken("COMPARATORTRIM",`(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`,!0),exports.comparatorTrimReplace="$1$2$3",createToken("HYPHENRANGE",`^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`),createToken("HYPHENRANGELOOSE",`^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`),createToken("STAR","(<|>)?=?\\s*\\*"),createToken("GTE0","^\\s*>=\\s*0.0.0\\s*$"),createToken("GTE0PRE","^\\s*>=\\s*0.0.0-0\\s*$");}(re$b,re$b.exports);const opts$1=["includePrerelease","loose","rtl"];var parseOptions_1$1=options=>options?"object"!=typeof options?{loose:!0}:opts$1.filter((k=>options[k])).reduce(((options,k)=>(options[k]=!0,options)),{}):{};const numeric$1=/^[0-9]+$/,compareIdentifiers$3=(a,b)=>{const anum=numeric$1.test(a),bnum=numeric$1.test(b);return anum&&bnum&&(a=+a,b=+b),a===b?0:anum&&!bnum?-1:bnum&&!anum?1:a<b?-1:1};var identifiers$1={compareIdentifiers:compareIdentifiers$3,rcompareIdentifiers:(a,b)=>compareIdentifiers$3(b,a)};const debug$6=debug_1$1,{MAX_LENGTH:MAX_LENGTH$4,MAX_SAFE_INTEGER:MAX_SAFE_INTEGER$2}=constants$1,{re:re$a,t:t$9}=re$b.exports,parseOptions$8=parseOptions_1$1,{compareIdentifiers:compareIdentifiers$2}=identifiers$1;class SemVer$t{constructor(version,options){if(options=parseOptions$8(options),version instanceof SemVer$t){if(version.loose===!!options.loose&&version.includePrerelease===!!options.includePrerelease)return version;version=version.version;}else if("string"!=typeof version)throw new TypeError(`Invalid Version: ${version}`);if(version.length>MAX_LENGTH$4)throw new TypeError(`version is longer than ${MAX_LENGTH$4} characters`);debug$6("SemVer",version,options),this.options=options,this.loose=!!options.loose,this.includePrerelease=!!options.includePrerelease;const m=version.trim().match(options.loose?re$a[t$9.LOOSE]:re$a[t$9.FULL]);if(!m)throw new TypeError(`Invalid Version: ${version}`);if(this.raw=version,this.major=+m[1],this.minor=+m[2],this.patch=+m[3],this.major>MAX_SAFE_INTEGER$2||this.major<0)throw new TypeError("Invalid major version");if(this.minor>MAX_SAFE_INTEGER$2||this.minor<0)throw new TypeError("Invalid minor version");if(this.patch>MAX_SAFE_INTEGER$2||this.patch<0)throw new TypeError("Invalid patch version");m[4]?this.prerelease=m[4].split(".").map((id=>{if(/^[0-9]+$/.test(id)){const num=+id;if(num>=0&&num<MAX_SAFE_INTEGER$2)return num}return id})):this.prerelease=[],this.build=m[5]?m[5].split("."):[],this.format();}format(){return this.version=`${this.major}.${this.minor}.${this.patch}`,this.prerelease.length&&(this.version+=`-${this.prerelease.join(".")}`),this.version}toString(){return this.version}compare(other){if(debug$6("SemVer.compare",this.version,this.options,other),!(other instanceof SemVer$t)){if("string"==typeof other&&other===this.version)return 0;other=new SemVer$t(other,this.options);}return other.version===this.version?0:this.compareMain(other)||this.comparePre(other)}compareMain(other){return other instanceof SemVer$t||(other=new SemVer$t(other,this.options)),compareIdentifiers$2(this.major,other.major)||compareIdentifiers$2(this.minor,other.minor)||compareIdentifiers$2(this.patch,other.patch)}comparePre(other){if(other instanceof SemVer$t||(other=new SemVer$t(other,this.options)),this.prerelease.length&&!other.prerelease.length)return -1;if(!this.prerelease.length&&other.prerelease.length)return 1;if(!this.prerelease.length&&!other.prerelease.length)return 0;let i=0;do{const a=this.prerelease[i],b=other.prerelease[i];if(debug$6("prerelease compare",i,a,b),void 0===a&&void 0===b)return 0;if(void 0===b)return 1;if(void 0===a)return -1;if(a!==b)return compareIdentifiers$2(a,b)}while(++i)}compareBuild(other){other instanceof SemVer$t||(other=new SemVer$t(other,this.options));let i=0;do{const a=this.build[i],b=other.build[i];if(debug$6("prerelease compare",i,a,b),void 0===a&&void 0===b)return 0;if(void 0===b)return 1;if(void 0===a)return -1;if(a!==b)return compareIdentifiers$2(a,b)}while(++i)}inc(release,identifier){switch(release){case"premajor":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc("pre",identifier);break;case"preminor":this.prerelease.length=0,this.patch=0,this.minor++,this.inc("pre",identifier);break;case"prepatch":this.prerelease.length=0,this.inc("patch",identifier),this.inc("pre",identifier);break;case"prerelease":0===this.prerelease.length&&this.inc("patch",identifier),this.inc("pre",identifier);break;case"major":0===this.minor&&0===this.patch&&0!==this.prerelease.length||this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case"minor":0===this.patch&&0!==this.prerelease.length||this.minor++,this.patch=0,this.prerelease=[];break;case"patch":0===this.prerelease.length&&this.patch++,this.prerelease=[];break;case"pre":if(0===this.prerelease.length)this.prerelease=[0];else {let i=this.prerelease.length;for(;--i>=0;)"number"==typeof this.prerelease[i]&&(this.prerelease[i]++,i=-2);-1===i&&this.prerelease.push(0);}identifier&&(this.prerelease[0]===identifier?isNaN(this.prerelease[1])&&(this.prerelease=[identifier,0]):this.prerelease=[identifier,0]);break;default:throw new Error(`invalid increment argument: ${release}`)}return this.format(),this.raw=this.version,this}}var semver$5=SemVer$t;const{MAX_LENGTH:MAX_LENGTH$3}=constants$1,{re:re$9,t:t$8}=re$b.exports,SemVer$s=semver$5,parseOptions$7=parseOptions_1$1;var parse_1$1=(version,options)=>{if(options=parseOptions$7(options),version instanceof SemVer$s)return version;if("string"!=typeof version)return null;if(version.length>MAX_LENGTH$3)return null;if(!(options.loose?re$9[t$8.LOOSE]:re$9[t$8.FULL]).test(version))return null;try{return new SemVer$s(version,options)}catch(er){return null}};const parse$b=parse_1$1;var valid_1$1=(version,options)=>{const v=parse$b(version,options);return v?v.version:null};const parse$a=parse_1$1;var clean_1$1=(version,options)=>{const s=parse$a(version.trim().replace(/^[=v]+/,""),options);return s?s.version:null};const SemVer$r=semver$5;var inc_1$1=(version,release,options,identifier)=>{"string"==typeof options&&(identifier=options,options=void 0);try{return new SemVer$r(version,options).inc(release,identifier).version}catch(er){return null}};const SemVer$q=semver$5;var compare_1$1=(a,b,loose)=>new SemVer$q(a,loose).compare(new SemVer$q(b,loose));const compare$k=compare_1$1;var eq_1$1=(a,b,loose)=>0===compare$k(a,b,loose);const parse$9=parse_1$1,eq$4=eq_1$1;var diff_1$1=(version1,version2)=>{if(eq$4(version1,version2))return null;{const v1=parse$9(version1),v2=parse$9(version2),hasPre=v1.prerelease.length||v2.prerelease.length,prefix=hasPre?"pre":"",defaultResult=hasPre?"prerelease":"";for(const key in v1)if(("major"===key||"minor"===key||"patch"===key)&&v1[key]!==v2[key])return prefix+key;return defaultResult}};const SemVer$p=semver$5;var major_1$1=(a,loose)=>new SemVer$p(a,loose).major;const SemVer$o=semver$5;var minor_1$1=(a,loose)=>new SemVer$o(a,loose).minor;const SemVer$n=semver$5;var patch_1$1=(a,loose)=>new SemVer$n(a,loose).patch;const parse$8=parse_1$1;var prerelease_1$1=(version,options)=>{const parsed=parse$8(version,options);return parsed&&parsed.prerelease.length?parsed.prerelease:null};const compare$j=compare_1$1;var rcompare_1$1=(a,b,loose)=>compare$j(b,a,loose);const compare$i=compare_1$1;var compareLoose_1$1=(a,b)=>compare$i(a,b,!0);const SemVer$m=semver$5;var compareBuild_1$1=(a,b,loose)=>{const versionA=new SemVer$m(a,loose),versionB=new SemVer$m(b,loose);return versionA.compare(versionB)||versionA.compareBuild(versionB)};const compareBuild$4=compareBuild_1$1;var sort_1$1=(list,loose)=>list.sort(((a,b)=>compareBuild$4(a,b,loose)));const compareBuild$3=compareBuild_1$1;var rsort_1$1=(list,loose)=>list.sort(((a,b)=>compareBuild$3(b,a,loose)));const compare$h=compare_1$1;var gt_1$1=(a,b,loose)=>compare$h(a,b,loose)>0;const compare$g=compare_1$1;var lt_1$1=(a,b,loose)=>compare$g(a,b,loose)<0;const compare$f=compare_1$1;var neq_1$1=(a,b,loose)=>0!==compare$f(a,b,loose);const compare$e=compare_1$1;var gte_1$1=(a,b,loose)=>compare$e(a,b,loose)>=0;const compare$d=compare_1$1;var lte_1$1=(a,b,loose)=>compare$d(a,b,loose)<=0;const eq$3=eq_1$1,neq$2=neq_1$1,gt$6=gt_1$1,gte$4=gte_1$1,lt$4=lt_1$1,lte$4=lte_1$1;var cmp_1$1=(a,op,b,loose)=>{switch(op){case"===":return "object"==typeof a&&(a=a.version),"object"==typeof b&&(b=b.version),a===b;case"!==":return "object"==typeof a&&(a=a.version),"object"==typeof b&&(b=b.version),a!==b;case"":case"=":case"==":return eq$3(a,b,loose);case"!=":return neq$2(a,b,loose);case">":return gt$6(a,b,loose);case">=":return gte$4(a,b,loose);case"<":return lt$4(a,b,loose);case"<=":return lte$4(a,b,loose);default:throw new TypeError(`Invalid operator: ${op}`)}};const SemVer$l=semver$5,parse$7=parse_1$1,{re:re$8,t:t$7}=re$b.exports;var coerce_1$1=(version,options)=>{if(version instanceof SemVer$l)return version;if("number"==typeof version&&(version=String(version)),"string"!=typeof version)return null;let match=null;if((options=options||{}).rtl){let next;for(;(next=re$8[t$7.COERCERTL].exec(version))&&(!match||match.index+match[0].length!==version.length);)match&&next.index+next[0].length===match.index+match[0].length||(match=next),re$8[t$7.COERCERTL].lastIndex=next.index+next[1].length+next[2].length;re$8[t$7.COERCERTL].lastIndex=-1;}else match=version.match(re$8[t$7.COERCE]);return null===match?null:parse$7(`${match[2]}.${match[3]||"0"}.${match[4]||"0"}`,options)},yallist$1=Yallist$3;function Yallist$3(list){var self=this;if(self instanceof Yallist$3||(self=new Yallist$3),self.tail=null,self.head=null,self.length=0,list&&"function"==typeof list.forEach)list.forEach((function(item){self.push(item);}));else if(arguments.length>0)for(var i=0,l=arguments.length;i<l;i++)self.push(arguments[i]);return self}function insert$1(self,node,value){var inserted=node===self.head?new Node$1(value,null,node,self):new Node$1(value,node,node.next,self);return null===inserted.next&&(self.tail=inserted),null===inserted.prev&&(self.head=inserted),self.length++,inserted}function push$1(self,item){self.tail=new Node$1(item,self.tail,null,self),self.head||(self.head=self.tail),self.length++;}function unshift$1(self,item){self.head=new Node$1(item,null,self.head,self),self.tail||(self.tail=self.head),self.length++;}function Node$1(value,prev,next,list){if(!(this instanceof Node$1))return new Node$1(value,prev,next,list);this.list=list,this.value=value,prev?(prev.next=this,this.prev=prev):this.prev=null,next?(next.prev=this,this.next=next):this.next=null;}Yallist$3.Node=Node$1,Yallist$3.create=Yallist$3,Yallist$3.prototype.removeNode=function(node){if(node.list!==this)throw new Error("removing node which does not belong to this list");var next=node.next,prev=node.prev;return next&&(next.prev=prev),prev&&(prev.next=next),node===this.head&&(this.head=next),node===this.tail&&(this.tail=prev),node.list.length--,node.next=null,node.prev=null,node.list=null,next},Yallist$3.prototype.unshiftNode=function(node){if(node!==this.head){node.list&&node.list.removeNode(node);var head=this.head;node.list=this,node.next=head,head&&(head.prev=node),this.head=node,this.tail||(this.tail=node),this.length++;}},Yallist$3.prototype.pushNode=function(node){if(node!==this.tail){node.list&&node.list.removeNode(node);var tail=this.tail;node.list=this,node.prev=tail,tail&&(tail.next=node),this.tail=node,this.head||(this.head=node),this.length++;}},Yallist$3.prototype.push=function(){for(var i=0,l=arguments.length;i<l;i++)push$1(this,arguments[i]);return this.length},Yallist$3.prototype.unshift=function(){for(var i=0,l=arguments.length;i<l;i++)unshift$1(this,arguments[i]);return this.length},Yallist$3.prototype.pop=function(){if(this.tail){var res=this.tail.value;return this.tail=this.tail.prev,this.tail?this.tail.next=null:this.head=null,this.length--,res}},Yallist$3.prototype.shift=function(){if(this.head){var res=this.head.value;return this.head=this.head.next,this.head?this.head.prev=null:this.tail=null,this.length--,res}},Yallist$3.prototype.forEach=function(fn,thisp){thisp=thisp||this;for(var walker=this.head,i=0;null!==walker;i++)fn.call(thisp,walker.value,i,this),walker=walker.next;},Yallist$3.prototype.forEachReverse=function(fn,thisp){thisp=thisp||this;for(var walker=this.tail,i=this.length-1;null!==walker;i--)fn.call(thisp,walker.value,i,this),walker=walker.prev;},Yallist$3.prototype.get=function(n){for(var i=0,walker=this.head;null!==walker&&i<n;i++)walker=walker.next;if(i===n&&null!==walker)return walker.value},Yallist$3.prototype.getReverse=function(n){for(var i=0,walker=this.tail;null!==walker&&i<n;i++)walker=walker.prev;if(i===n&&null!==walker)return walker.value},Yallist$3.prototype.map=function(fn,thisp){thisp=thisp||this;for(var res=new Yallist$3,walker=this.head;null!==walker;)res.push(fn.call(thisp,walker.value,this)),walker=walker.next;return res},Yallist$3.prototype.mapReverse=function(fn,thisp){thisp=thisp||this;for(var res=new Yallist$3,walker=this.tail;null!==walker;)res.push(fn.call(thisp,walker.value,this)),walker=walker.prev;return res},Yallist$3.prototype.reduce=function(fn,initial){var acc,walker=this.head;if(arguments.length>1)acc=initial;else {if(!this.head)throw new TypeError("Reduce of empty list with no initial value");walker=this.head.next,acc=this.head.value;}for(var i=0;null!==walker;i++)acc=fn(acc,walker.value,i),walker=walker.next;return acc},Yallist$3.prototype.reduceReverse=function(fn,initial){var acc,walker=this.tail;if(arguments.length>1)acc=initial;else {if(!this.tail)throw new TypeError("Reduce of empty list with no initial value");walker=this.tail.prev,acc=this.tail.value;}for(var i=this.length-1;null!==walker;i--)acc=fn(acc,walker.value,i),walker=walker.prev;return acc},Yallist$3.prototype.toArray=function(){for(var arr=new Array(this.length),i=0,walker=this.head;null!==walker;i++)arr[i]=walker.value,walker=walker.next;return arr},Yallist$3.prototype.toArrayReverse=function(){for(var arr=new Array(this.length),i=0,walker=this.tail;null!==walker;i++)arr[i]=walker.value,walker=walker.prev;return arr},Yallist$3.prototype.slice=function(from,to){(to=to||this.length)<0&&(to+=this.length),(from=from||0)<0&&(from+=this.length);var ret=new Yallist$3;if(to<from||to<0)return ret;from<0&&(from=0),to>this.length&&(to=this.length);for(var i=0,walker=this.head;null!==walker&&i<from;i++)walker=walker.next;for(;null!==walker&&i<to;i++,walker=walker.next)ret.push(walker.value);return ret},Yallist$3.prototype.sliceReverse=function(from,to){(to=to||this.length)<0&&(to+=this.length),(from=from||0)<0&&(from+=this.length);var ret=new Yallist$3;if(to<from||to<0)return ret;from<0&&(from=0),to>this.length&&(to=this.length);for(var i=this.length,walker=this.tail;null!==walker&&i>to;i--)walker=walker.prev;for(;null!==walker&&i>from;i--,walker=walker.prev)ret.push(walker.value);return ret},Yallist$3.prototype.splice=function(start,deleteCount,...nodes){start>this.length&&(start=this.length-1),start<0&&(start=this.length+start);for(var i=0,walker=this.head;null!==walker&&i<start;i++)walker=walker.next;var ret=[];for(i=0;walker&&i<deleteCount;i++)ret.push(walker.value),walker=this.removeNode(walker);null===walker&&(walker=this.tail),walker!==this.head&&walker!==this.tail&&(walker=walker.prev);for(i=0;i<nodes.length;i++)walker=insert$1(this,walker,nodes[i]);return ret},Yallist$3.prototype.reverse=function(){for(var head=this.head,tail=this.tail,walker=head;null!==walker;walker=walker.prev){var p=walker.prev;walker.prev=walker.next,walker.next=p;}return this.head=tail,this.tail=head,this};try{require("./iterator.js")(Yallist$3);}catch(er){}const Yallist$2=yallist$1,MAX$1=Symbol("max"),LENGTH$1=Symbol("length"),LENGTH_CALCULATOR$1=Symbol("lengthCalculator"),ALLOW_STALE$1=Symbol("allowStale"),MAX_AGE$1=Symbol("maxAge"),DISPOSE$1=Symbol("dispose"),NO_DISPOSE_ON_SET$1=Symbol("noDisposeOnSet"),LRU_LIST$1=Symbol("lruList"),CACHE$1=Symbol("cache"),UPDATE_AGE_ON_GET$1=Symbol("updateAgeOnGet"),naiveLength$1=()=>1;const get$1=(self,key,doUse)=>{const node=self[CACHE$1].get(key);if(node){const hit=node.value;if(isStale$1(self,hit)){if(del$1(self,node),!self[ALLOW_STALE$1])return}else doUse&&(self[UPDATE_AGE_ON_GET$1]&&(node.value.now=Date.now()),self[LRU_LIST$1].unshiftNode(node));return hit.value}},isStale$1=(self,hit)=>{if(!hit||!hit.maxAge&&!self[MAX_AGE$1])return !1;const diff=Date.now()-hit.now;return hit.maxAge?diff>hit.maxAge:self[MAX_AGE$1]&&diff>self[MAX_AGE$1]},trim$1=self=>{if(self[LENGTH$1]>self[MAX$1])for(let walker=self[LRU_LIST$1].tail;self[LENGTH$1]>self[MAX$1]&&null!==walker;){const prev=walker.prev;del$1(self,walker),walker=prev;}},del$1=(self,node)=>{if(node){const hit=node.value;self[DISPOSE$1]&&self[DISPOSE$1](hit.key,hit.value),self[LENGTH$1]-=hit.length,self[CACHE$1].delete(hit.key),self[LRU_LIST$1].removeNode(node);}};class Entry$1{constructor(key,value,length,now,maxAge){this.key=key,this.value=value,this.length=length,this.now=now,this.maxAge=maxAge||0;}}const forEachStep$1=(self,fn,node,thisp)=>{let hit=node.value;isStale$1(self,hit)&&(del$1(self,node),self[ALLOW_STALE$1]||(hit=void 0)),hit&&fn.call(thisp,hit.value,hit.key,self);};var lruCache$1=class{constructor(options){if("number"==typeof options&&(options={max:options}),options||(options={}),options.max&&("number"!=typeof options.max||options.max<0))throw new TypeError("max must be a non-negative number");this[MAX$1]=options.max||1/0;const lc=options.length||naiveLength$1;if(this[LENGTH_CALCULATOR$1]="function"!=typeof lc?naiveLength$1:lc,this[ALLOW_STALE$1]=options.stale||!1,options.maxAge&&"number"!=typeof options.maxAge)throw new TypeError("maxAge must be a number");this[MAX_AGE$1]=options.maxAge||0,this[DISPOSE$1]=options.dispose,this[NO_DISPOSE_ON_SET$1]=options.noDisposeOnSet||!1,this[UPDATE_AGE_ON_GET$1]=options.updateAgeOnGet||!1,this.reset();}set max(mL){if("number"!=typeof mL||mL<0)throw new TypeError("max must be a non-negative number");this[MAX$1]=mL||1/0,trim$1(this);}get max(){return this[MAX$1]}set allowStale(allowStale){this[ALLOW_STALE$1]=!!allowStale;}get allowStale(){return this[ALLOW_STALE$1]}set maxAge(mA){if("number"!=typeof mA)throw new TypeError("maxAge must be a non-negative number");this[MAX_AGE$1]=mA,trim$1(this);}get maxAge(){return this[MAX_AGE$1]}set lengthCalculator(lC){"function"!=typeof lC&&(lC=naiveLength$1),lC!==this[LENGTH_CALCULATOR$1]&&(this[LENGTH_CALCULATOR$1]=lC,this[LENGTH$1]=0,this[LRU_LIST$1].forEach((hit=>{hit.length=this[LENGTH_CALCULATOR$1](hit.value,hit.key),this[LENGTH$1]+=hit.length;}))),trim$1(this);}get lengthCalculator(){return this[LENGTH_CALCULATOR$1]}get length(){return this[LENGTH$1]}get itemCount(){return this[LRU_LIST$1].length}rforEach(fn,thisp){thisp=thisp||this;for(let walker=this[LRU_LIST$1].tail;null!==walker;){const prev=walker.prev;forEachStep$1(this,fn,walker,thisp),walker=prev;}}forEach(fn,thisp){thisp=thisp||this;for(let walker=this[LRU_LIST$1].head;null!==walker;){const next=walker.next;forEachStep$1(this,fn,walker,thisp),walker=next;}}keys(){return this[LRU_LIST$1].toArray().map((k=>k.key))}values(){return this[LRU_LIST$1].toArray().map((k=>k.value))}reset(){this[DISPOSE$1]&&this[LRU_LIST$1]&&this[LRU_LIST$1].length&&this[LRU_LIST$1].forEach((hit=>this[DISPOSE$1](hit.key,hit.value))),this[CACHE$1]=new Map,this[LRU_LIST$1]=new Yallist$2,this[LENGTH$1]=0;}dump(){return this[LRU_LIST$1].map((hit=>!isStale$1(this,hit)&&{k:hit.key,v:hit.value,e:hit.now+(hit.maxAge||0)})).toArray().filter((h=>h))}dumpLru(){return this[LRU_LIST$1]}set(key,value,maxAge){if((maxAge=maxAge||this[MAX_AGE$1])&&"number"!=typeof maxAge)throw new TypeError("maxAge must be a number");const now=maxAge?Date.now():0,len=this[LENGTH_CALCULATOR$1](value,key);if(this[CACHE$1].has(key)){if(len>this[MAX$1])return del$1(this,this[CACHE$1].get(key)),!1;const item=this[CACHE$1].get(key).value;return this[DISPOSE$1]&&(this[NO_DISPOSE_ON_SET$1]||this[DISPOSE$1](key,item.value)),item.now=now,item.maxAge=maxAge,item.value=value,this[LENGTH$1]+=len-item.length,item.length=len,this.get(key),trim$1(this),!0}const hit=new Entry$1(key,value,len,now,maxAge);return hit.length>this[MAX$1]?(this[DISPOSE$1]&&this[DISPOSE$1](key,value),!1):(this[LENGTH$1]+=hit.length,this[LRU_LIST$1].unshift(hit),this[CACHE$1].set(key,this[LRU_LIST$1].head),trim$1(this),!0)}has(key){if(!this[CACHE$1].has(key))return !1;const hit=this[CACHE$1].get(key).value;return !isStale$1(this,hit)}get(key){return get$1(this,key,!0)}peek(key){return get$1(this,key,!1)}pop(){const node=this[LRU_LIST$1].tail;return node?(del$1(this,node),node.value):null}del(key){del$1(this,this[CACHE$1].get(key));}load(arr){this.reset();const now=Date.now();for(let l=arr.length-1;l>=0;l--){const hit=arr[l],expiresAt=hit.e||0;if(0===expiresAt)this.set(hit.k,hit.v);else {const maxAge=expiresAt-now;maxAge>0&&this.set(hit.k,hit.v,maxAge);}}}prune(){this[CACHE$1].forEach(((value,key)=>get$1(this,key,!1)));}};class Range$l{constructor(range,options){if(options=parseOptions$6(options),range instanceof Range$l)return range.loose===!!options.loose&&range.includePrerelease===!!options.includePrerelease?range:new Range$l(range.raw,options);if(range instanceof Comparator$7)return this.raw=range.value,this.set=[[range]],this.format(),this;if(this.options=options,this.loose=!!options.loose,this.includePrerelease=!!options.includePrerelease,this.raw=range,this.set=range.split(/\s*\|\|\s*/).map((range=>this.parseRange(range.trim()))).filter((c=>c.length)),!this.set.length)throw new TypeError(`Invalid SemVer Range: ${range}`);if(this.set.length>1){const first=this.set[0];if(this.set=this.set.filter((c=>!isNullSet$1(c[0]))),0===this.set.length)this.set=[first];else if(this.set.length>1)for(const c of this.set)if(1===c.length&&isAny$1(c[0])){this.set=[c];break}}this.format();}format(){return this.range=this.set.map((comps=>comps.join(" ").trim())).join("||").trim(),this.range}toString(){return this.range}parseRange(range){range=range.trim();const memoKey=`parseRange:${Object.keys(this.options).join(",")}:${range}`,cached=cache$1.get(memoKey);if(cached)return cached;const loose=this.options.loose,hr=loose?re$7[t$6.HYPHENRANGELOOSE]:re$7[t$6.HYPHENRANGE];range=range.replace(hr,hyphenReplace$1(this.options.includePrerelease)),debug$5("hyphen replace",range),range=range.replace(re$7[t$6.COMPARATORTRIM],comparatorTrimReplace$1),debug$5("comparator trim",range,re$7[t$6.COMPARATORTRIM]),range=(range=(range=range.replace(re$7[t$6.TILDETRIM],tildeTrimReplace$1)).replace(re$7[t$6.CARETTRIM],caretTrimReplace$1)).split(/\s+/).join(" ");const compRe=loose?re$7[t$6.COMPARATORLOOSE]:re$7[t$6.COMPARATOR],rangeList=range.split(" ").map((comp=>parseComparator$1(comp,this.options))).join(" ").split(/\s+/).map((comp=>replaceGTE0$1(comp,this.options))).filter(this.options.loose?comp=>!!comp.match(compRe):()=>!0).map((comp=>new Comparator$7(comp,this.options)));rangeList.length;const rangeMap=new Map;for(const comp of rangeList){if(isNullSet$1(comp))return [comp];rangeMap.set(comp.value,comp);}rangeMap.size>1&&rangeMap.has("")&&rangeMap.delete("");const result=[...rangeMap.values()];return cache$1.set(memoKey,result),result}intersects(range,options){if(!(range instanceof Range$l))throw new TypeError("a Range is required");return this.set.some((thisComparators=>isSatisfiable$1(thisComparators,options)&&range.set.some((rangeComparators=>isSatisfiable$1(rangeComparators,options)&&thisComparators.every((thisComparator=>rangeComparators.every((rangeComparator=>thisComparator.intersects(rangeComparator,options)))))))))}test(version){if(!version)return !1;if("string"==typeof version)try{version=new SemVer$k(version,this.options);}catch(er){return !1}for(let i=0;i<this.set.length;i++)if(testSet$1(this.set[i],version,this.options))return !0;return !1}}var range$1=Range$l;const cache$1=new lruCache$1({max:1e3}),parseOptions$6=parseOptions_1$1,Comparator$7=comparator$1,debug$5=debug_1$1,SemVer$k=semver$5,{re:re$7,t:t$6,comparatorTrimReplace:comparatorTrimReplace$1,tildeTrimReplace:tildeTrimReplace$1,caretTrimReplace:caretTrimReplace$1}=re$b.exports,isNullSet$1=c=>"<0.0.0-0"===c.value,isAny$1=c=>""===c.value,isSatisfiable$1=(comparators,options)=>{let result=!0;const remainingComparators=comparators.slice();let testComparator=remainingComparators.pop();for(;result&&remainingComparators.length;)result=remainingComparators.every((otherComparator=>testComparator.intersects(otherComparator,options))),testComparator=remainingComparators.pop();return result},parseComparator$1=(comp,options)=>(debug$5("comp",comp,options),comp=replaceCarets$1(comp,options),debug$5("caret",comp),comp=replaceTildes$1(comp,options),debug$5("tildes",comp),comp=replaceXRanges$1(comp,options),debug$5("xrange",comp),comp=replaceStars$1(comp,options),debug$5("stars",comp),comp),isX$1=id=>!id||"x"===id.toLowerCase()||"*"===id,replaceTildes$1=(comp,options)=>comp.trim().split(/\s+/).map((comp=>replaceTilde$1(comp,options))).join(" "),replaceTilde$1=(comp,options)=>{const r=options.loose?re$7[t$6.TILDELOOSE]:re$7[t$6.TILDE];return comp.replace(r,((_,M,m,p,pr)=>{let ret;return debug$5("tilde",comp,_,M,m,p,pr),isX$1(M)?ret="":isX$1(m)?ret=`>=${M}.0.0 <${+M+1}.0.0-0`:isX$1(p)?ret=`>=${M}.${m}.0 <${M}.${+m+1}.0-0`:pr?(debug$5("replaceTilde pr",pr),ret=`>=${M}.${m}.${p}-${pr} <${M}.${+m+1}.0-0`):ret=`>=${M}.${m}.${p} <${M}.${+m+1}.0-0`,debug$5("tilde return",ret),ret}))},replaceCarets$1=(comp,options)=>comp.trim().split(/\s+/).map((comp=>replaceCaret$1(comp,options))).join(" "),replaceCaret$1=(comp,options)=>{debug$5("caret",comp,options);const r=options.loose?re$7[t$6.CARETLOOSE]:re$7[t$6.CARET],z=options.includePrerelease?"-0":"";return comp.replace(r,((_,M,m,p,pr)=>{let ret;return debug$5("caret",comp,_,M,m,p,pr),isX$1(M)?ret="":isX$1(m)?ret=`>=${M}.0.0${z} <${+M+1}.0.0-0`:isX$1(p)?ret="0"===M?`>=${M}.${m}.0${z} <${M}.${+m+1}.0-0`:`>=${M}.${m}.0${z} <${+M+1}.0.0-0`:pr?(debug$5("replaceCaret pr",pr),ret="0"===M?"0"===m?`>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p+1}-0`:`>=${M}.${m}.${p}-${pr} <${M}.${+m+1}.0-0`:`>=${M}.${m}.${p}-${pr} <${+M+1}.0.0-0`):(debug$5("no pr"),ret="0"===M?"0"===m?`>=${M}.${m}.${p}${z} <${M}.${m}.${+p+1}-0`:`>=${M}.${m}.${p}${z} <${M}.${+m+1}.0-0`:`>=${M}.${m}.${p} <${+M+1}.0.0-0`),debug$5("caret return",ret),ret}))},replaceXRanges$1=(comp,options)=>(debug$5("replaceXRanges",comp,options),comp.split(/\s+/).map((comp=>replaceXRange$1(comp,options))).join(" ")),replaceXRange$1=(comp,options)=>{comp=comp.trim();const r=options.loose?re$7[t$6.XRANGELOOSE]:re$7[t$6.XRANGE];return comp.replace(r,((ret,gtlt,M,m,p,pr)=>{debug$5("xRange",comp,ret,gtlt,M,m,p,pr);const xM=isX$1(M),xm=xM||isX$1(m),xp=xm||isX$1(p),anyX=xp;return "="===gtlt&&anyX&&(gtlt=""),pr=options.includePrerelease?"-0":"",xM?ret=">"===gtlt||"<"===gtlt?"<0.0.0-0":"*":gtlt&&anyX?(xm&&(m=0),p=0,">"===gtlt?(gtlt=">=",xm?(M=+M+1,m=0,p=0):(m=+m+1,p=0)):"<="===gtlt&&(gtlt="<",xm?M=+M+1:m=+m+1),"<"===gtlt&&(pr="-0"),ret=`${gtlt+M}.${m}.${p}${pr}`):xm?ret=`>=${M}.0.0${pr} <${+M+1}.0.0-0`:xp&&(ret=`>=${M}.${m}.0${pr} <${M}.${+m+1}.0-0`),debug$5("xRange return",ret),ret}))},replaceStars$1=(comp,options)=>(debug$5("replaceStars",comp,options),comp.trim().replace(re$7[t$6.STAR],"")),replaceGTE0$1=(comp,options)=>(debug$5("replaceGTE0",comp,options),comp.trim().replace(re$7[options.includePrerelease?t$6.GTE0PRE:t$6.GTE0],"")),hyphenReplace$1=incPr=>($0,from,fM,fm,fp,fpr,fb,to,tM,tm,tp,tpr,tb)=>`${from=isX$1(fM)?"":isX$1(fm)?`>=${fM}.0.0${incPr?"-0":""}`:isX$1(fp)?`>=${fM}.${fm}.0${incPr?"-0":""}`:fpr?`>=${from}`:`>=${from}${incPr?"-0":""}`} ${to=isX$1(tM)?"":isX$1(tm)?`<${+tM+1}.0.0-0`:isX$1(tp)?`<${tM}.${+tm+1}.0-0`:tpr?`<=${tM}.${tm}.${tp}-${tpr}`:incPr?`<${tM}.${tm}.${+tp+1}-0`:`<=${to}`}`.trim(),testSet$1=(set,version,options)=>{for(let i=0;i<set.length;i++)if(!set[i].test(version))return !1;if(version.prerelease.length&&!options.includePrerelease){for(let i=0;i<set.length;i++)if(debug$5(set[i].semver),set[i].semver!==Comparator$7.ANY&&set[i].semver.prerelease.length>0){const allowed=set[i].semver;if(allowed.major===version.major&&allowed.minor===version.minor&&allowed.patch===version.patch)return !0}return !1}return !0},ANY$5=Symbol("SemVer ANY");class Comparator$6{static get ANY(){return ANY$5}constructor(comp,options){if(options=parseOptions$5(options),comp instanceof Comparator$6){if(comp.loose===!!options.loose)return comp;comp=comp.value;}debug$4("comparator",comp,options),this.options=options,this.loose=!!options.loose,this.parse(comp),this.semver===ANY$5?this.value="":this.value=this.operator+this.semver.version,debug$4("comp",this);}parse(comp){const r=this.options.loose?re$6[t$5.COMPARATORLOOSE]:re$6[t$5.COMPARATOR],m=comp.match(r);if(!m)throw new TypeError(`Invalid comparator: ${comp}`);this.operator=void 0!==m[1]?m[1]:"","="===this.operator&&(this.operator=""),m[2]?this.semver=new SemVer$j(m[2],this.options.loose):this.semver=ANY$5;}toString(){return this.value}test(version){if(debug$4("Comparator.test",version,this.options.loose),this.semver===ANY$5||version===ANY$5)return !0;if("string"==typeof version)try{version=new SemVer$j(version,this.options);}catch(er){return !1}return cmp$2(version,this.operator,this.semver,this.options)}intersects(comp,options){if(!(comp instanceof Comparator$6))throw new TypeError("a Comparator is required");if(options&&"object"==typeof options||(options={loose:!!options,includePrerelease:!1}),""===this.operator)return ""===this.value||new Range$k(comp.value,options).test(this.value);if(""===comp.operator)return ""===comp.value||new Range$k(this.value,options).test(comp.semver);const sameDirectionIncreasing=!(">="!==this.operator&&">"!==this.operator||">="!==comp.operator&&">"!==comp.operator),sameDirectionDecreasing=!("<="!==this.operator&&"<"!==this.operator||"<="!==comp.operator&&"<"!==comp.operator),sameSemVer=this.semver.version===comp.semver.version,differentDirectionsInclusive=!(">="!==this.operator&&"<="!==this.operator||">="!==comp.operator&&"<="!==comp.operator),oppositeDirectionsLessThan=cmp$2(this.semver,"<",comp.semver,options)&&(">="===this.operator||">"===this.operator)&&("<="===comp.operator||"<"===comp.operator),oppositeDirectionsGreaterThan=cmp$2(this.semver,">",comp.semver,options)&&("<="===this.operator||"<"===this.operator)&&(">="===comp.operator||">"===comp.operator);return sameDirectionIncreasing||sameDirectionDecreasing||sameSemVer&&differentDirectionsInclusive||oppositeDirectionsLessThan||oppositeDirectionsGreaterThan}}var comparator$1=Comparator$6;const parseOptions$5=parseOptions_1$1,{re:re$6,t:t$5}=re$b.exports,cmp$2=cmp_1$1,debug$4=debug_1$1,SemVer$j=semver$5,Range$k=range$1,Range$j=range$1;var satisfies_1$1=(version,range,options)=>{try{range=new Range$j(range,options);}catch(er){return !1}return range.test(version)};const Range$i=range$1;var toComparators_1$1=(range,options)=>new Range$i(range,options).set.map((comp=>comp.map((c=>c.value)).join(" ").trim().split(" ")));const SemVer$i=semver$5,Range$h=range$1;var maxSatisfying_1$1=(versions,range,options)=>{let max=null,maxSV=null,rangeObj=null;try{rangeObj=new Range$h(range,options);}catch(er){return null}return versions.forEach((v=>{rangeObj.test(v)&&(max&&-1!==maxSV.compare(v)||(max=v,maxSV=new SemVer$i(max,options)));})),max};const SemVer$h=semver$5,Range$g=range$1;var minSatisfying_1$1=(versions,range,options)=>{let min=null,minSV=null,rangeObj=null;try{rangeObj=new Range$g(range,options);}catch(er){return null}return versions.forEach((v=>{rangeObj.test(v)&&(min&&1!==minSV.compare(v)||(min=v,minSV=new SemVer$h(min,options)));})),min};const SemVer$g=semver$5,Range$f=range$1,gt$5=gt_1$1;var minVersion_1$1=(range,loose)=>{range=new Range$f(range,loose);let minver=new SemVer$g("0.0.0");if(range.test(minver))return minver;if(minver=new SemVer$g("0.0.0-0"),range.test(minver))return minver;minver=null;for(let i=0;i<range.set.length;++i){const comparators=range.set[i];let setMin=null;comparators.forEach((comparator=>{const compver=new SemVer$g(comparator.semver.version);switch(comparator.operator){case">":0===compver.prerelease.length?compver.patch++:compver.prerelease.push(0),compver.raw=compver.format();case"":case">=":setMin&&!gt$5(compver,setMin)||(setMin=compver);break;case"<":case"<=":break;default:throw new Error(`Unexpected operation: ${comparator.operator}`)}})),!setMin||minver&&!gt$5(minver,setMin)||(minver=setMin);}return minver&&range.test(minver)?minver:null};const Range$e=range$1;var valid$2=(range,options)=>{try{return new Range$e(range,options).range||"*"}catch(er){return null}};const SemVer$f=semver$5,Comparator$5=comparator$1,{ANY:ANY$4}=Comparator$5,Range$d=range$1,satisfies$6=satisfies_1$1,gt$4=gt_1$1,lt$3=lt_1$1,lte$3=lte_1$1,gte$3=gte_1$1;var outside_1$1=(version,range,hilo,options)=>{let gtfn,ltefn,ltfn,comp,ecomp;switch(version=new SemVer$f(version,options),range=new Range$d(range,options),hilo){case">":gtfn=gt$4,ltefn=lte$3,ltfn=lt$3,comp=">",ecomp=">=";break;case"<":gtfn=lt$3,ltefn=gte$3,ltfn=gt$4,comp="<",ecomp="<=";break;default:throw new TypeError('Must provide a hilo val of "<" or ">"')}if(satisfies$6(version,range,options))return !1;for(let i=0;i<range.set.length;++i){const comparators=range.set[i];let high=null,low=null;if(comparators.forEach((comparator=>{comparator.semver===ANY$4&&(comparator=new Comparator$5(">=0.0.0")),high=high||comparator,low=low||comparator,gtfn(comparator.semver,high.semver,options)?high=comparator:ltfn(comparator.semver,low.semver,options)&&(low=comparator);})),high.operator===comp||high.operator===ecomp)return !1;if((!low.operator||low.operator===comp)&&ltefn(version,low.semver))return !1;if(low.operator===ecomp&&ltfn(version,low.semver))return !1}return !0};const outside$4=outside_1$1;var gtr_1$1=(version,range,options)=>outside$4(version,range,">",options);const outside$3=outside_1$1;var ltr_1$1=(version,range,options)=>outside$3(version,range,"<",options);const Range$c=range$1;var intersects_1$1=(r1,r2,options)=>(r1=new Range$c(r1,options),r2=new Range$c(r2,options),r1.intersects(r2));const satisfies$5=satisfies_1$1,compare$c=compare_1$1;const Range$b=range$1,Comparator$4=comparator$1,{ANY:ANY$3}=Comparator$4,satisfies$4=satisfies_1$1,compare$b=compare_1$1,simpleSubset$1=(sub,dom,options)=>{if(sub===dom)return !0;if(1===sub.length&&sub[0].semver===ANY$3){if(1===dom.length&&dom[0].semver===ANY$3)return !0;sub=options.includePrerelease?[new Comparator$4(">=0.0.0-0")]:[new Comparator$4(">=0.0.0")];}if(1===dom.length&&dom[0].semver===ANY$3){if(options.includePrerelease)return !0;dom=[new Comparator$4(">=0.0.0")];}const eqSet=new Set;let gt,lt,gtltComp,higher,lower,hasDomLT,hasDomGT;for(const c of sub)">"===c.operator||">="===c.operator?gt=higherGT$1(gt,c,options):"<"===c.operator||"<="===c.operator?lt=lowerLT$1(lt,c,options):eqSet.add(c.semver);if(eqSet.size>1)return null;if(gt&&lt){if(gtltComp=compare$b(gt.semver,lt.semver,options),gtltComp>0)return null;if(0===gtltComp&&(">="!==gt.operator||"<="!==lt.operator))return null}for(const eq of eqSet){if(gt&&!satisfies$4(eq,String(gt),options))return null;if(lt&&!satisfies$4(eq,String(lt),options))return null;for(const c of dom)if(!satisfies$4(eq,String(c),options))return !1;return !0}let needDomLTPre=!(!lt||options.includePrerelease||!lt.semver.prerelease.length)&&lt.semver,needDomGTPre=!(!gt||options.includePrerelease||!gt.semver.prerelease.length)&&gt.semver;needDomLTPre&&1===needDomLTPre.prerelease.length&&"<"===lt.operator&&0===needDomLTPre.prerelease[0]&&(needDomLTPre=!1);for(const c of dom){if(hasDomGT=hasDomGT||">"===c.operator||">="===c.operator,hasDomLT=hasDomLT||"<"===c.operator||"<="===c.operator,gt)if(needDomGTPre&&c.semver.prerelease&&c.semver.prerelease.length&&c.semver.major===needDomGTPre.major&&c.semver.minor===needDomGTPre.minor&&c.semver.patch===needDomGTPre.patch&&(needDomGTPre=!1),">"===c.operator||">="===c.operator){if(higher=higherGT$1(gt,c,options),higher===c&&higher!==gt)return !1}else if(">="===gt.operator&&!satisfies$4(gt.semver,String(c),options))return !1;if(lt)if(needDomLTPre&&c.semver.prerelease&&c.semver.prerelease.length&&c.semver.major===needDomLTPre.major&&c.semver.minor===needDomLTPre.minor&&c.semver.patch===needDomLTPre.patch&&(needDomLTPre=!1),"<"===c.operator||"<="===c.operator){if(lower=lowerLT$1(lt,c,options),lower===c&&lower!==lt)return !1}else if("<="===lt.operator&&!satisfies$4(lt.semver,String(c),options))return !1;if(!c.operator&&(lt||gt)&&0!==gtltComp)return !1}return !(gt&&hasDomLT&&!lt&&0!==gtltComp)&&(!(lt&&hasDomGT&&!gt&&0!==gtltComp)&&(!needDomGTPre&&!needDomLTPre))},higherGT$1=(a,b,options)=>{if(!a)return b;const comp=compare$b(a.semver,b.semver,options);return comp>0?a:comp<0||">"===b.operator&&">="===a.operator?b:a},lowerLT$1=(a,b,options)=>{if(!a)return b;const comp=compare$b(a.semver,b.semver,options);return comp<0?a:comp>0||"<"===b.operator&&"<="===a.operator?b:a};var subset_1$1=(sub,dom,options={})=>{if(sub===dom)return !0;sub=new Range$b(sub,options),dom=new Range$b(dom,options);let sawNonNull=!1;OUTER:for(const simpleSub of sub.set){for(const simpleDom of dom.set){const isSub=simpleSubset$1(simpleSub,simpleDom,options);if(sawNonNull=sawNonNull||null!==isSub,isSub)continue OUTER}if(sawNonNull)return !1}return !0};const internalRe$1=re$b.exports;var semver$4={re:internalRe$1.re,src:internalRe$1.src,tokens:internalRe$1.t,SEMVER_SPEC_VERSION:constants$1.SEMVER_SPEC_VERSION,SemVer:semver$5,compareIdentifiers:identifiers$1.compareIdentifiers,rcompareIdentifiers:identifiers$1.rcompareIdentifiers,parse:parse_1$1,valid:valid_1$1,clean:clean_1$1,inc:inc_1$1,diff:diff_1$1,major:major_1$1,minor:minor_1$1,patch:patch_1$1,prerelease:prerelease_1$1,compare:compare_1$1,rcompare:rcompare_1$1,compareLoose:compareLoose_1$1,compareBuild:compareBuild_1$1,sort:sort_1$1,rsort:rsort_1$1,gt:gt_1$1,lt:lt_1$1,eq:eq_1$1,neq:neq_1$1,gte:gte_1$1,lte:lte_1$1,cmp:cmp_1$1,coerce:coerce_1$1,Comparator:comparator$1,Range:range$1,satisfies:satisfies_1$1,toComparators:toComparators_1$1,maxSatisfying:maxSatisfying_1$1,minSatisfying:minSatisfying_1$1,minVersion:minVersion_1$1,validRange:valid$2,outside:outside_1$1,gtr:gtr_1$1,ltr:ltr_1$1,intersects:intersects_1$1,simplifyRange:(versions,range,options)=>{const set=[];let min=null,prev=null;const v=versions.sort(((a,b)=>compare$c(a,b,options)));for(const version of v){satisfies$5(version,range,options)?(prev=version,min||(min=version)):(prev&&set.push([min,prev]),prev=null,min=null);}min&&set.push([min,null]);const ranges=[];for(const[min,max]of set)min===max?ranges.push(min):max||min!==v[0]?max?min===v[0]?ranges.push(`<=${max}`):ranges.push(`${min} - ${max}`):ranges.push(`>=${min}`):ranges.push("*");const simplified=ranges.join(" || "),original="string"==typeof range.raw?range.raw:String(range);return simplified.length<original.length?simplified:range},subset:subset_1$1},semver$3=semver$4;const packageJsonReader$1={read:function(jsonPath){return find$1(external_path_.dirname(jsonPath))}};function find$1(dir){try{return {string:external_fs_.readFileSync(external_path_.toNamespacedPath(external_path_.join(dir,"package.json")),"utf8")}}catch(error){if("ENOENT"===error.code){const parent=external_path_.dirname(dir);return dir!==parent?find$1(parent):{string:void 0}}throw error}}const isWindows$1="win32"===process.platform,own$3={}.hasOwnProperty,codes$1={},messages$1=new Map;let userStackTraceLimit$1;function createError$1(sym,value,def){return messages$1.set(sym,value),function(Base,key){return NodeError;function NodeError(...args){const limit=Error.stackTraceLimit;isErrorStackTraceLimitWritable$1()&&(Error.stackTraceLimit=0);const error=new Base;isErrorStackTraceLimitWritable$1()&&(Error.stackTraceLimit=limit);const message=function(key,args,self){const message=messages$1.get(key);if("function"==typeof message)return external_assert_namespaceObject(message.length<=args.length,`Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${message.length}).`),Reflect.apply(message,self,args);const expectedLength=(message.match(/%[dfijoOs]/g)||[]).length;return external_assert_namespaceObject(expectedLength===args.length,`Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`),0===args.length?message:(args.unshift(message),Reflect.apply(external_util_.format,null,args))}(key,args,error);return Object.defineProperty(error,"message",{value:message,enumerable:!1,writable:!0,configurable:!0}),Object.defineProperty(error,"toString",{value(){return `${this.name} [${key}]: ${this.message}`},enumerable:!1,writable:!0,configurable:!0}),addCodeToName$1(error,Base.name,key),error.code=key,error}}(def,sym)}codes$1.ERR_INVALID_MODULE_SPECIFIER=createError$1("ERR_INVALID_MODULE_SPECIFIER",((request,reason,base)=>`Invalid module "${request}" ${reason}${base?` imported from ${base}`:""}`),TypeError),codes$1.ERR_INVALID_PACKAGE_CONFIG=createError$1("ERR_INVALID_PACKAGE_CONFIG",((path,base,message)=>`Invalid package config ${path}${base?` while importing ${base}`:""}${message?`. ${message}`:""}`),Error),codes$1.ERR_INVALID_PACKAGE_TARGET=createError$1("ERR_INVALID_PACKAGE_TARGET",((pkgPath,key,target,isImport=!1,base)=>{const relError="string"==typeof target&&!isImport&&target.length>0&&!target.startsWith("./");return "."===key?(external_assert_namespaceObject(!1===isImport),`Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${pkgPath}package.json${base?` imported from ${base}`:""}${relError?'; targets must start with "./"':""}`):`Invalid "${isImport?"imports":"exports"}" target ${JSON.stringify(target)} defined for '${key}' in the package config ${pkgPath}package.json${base?` imported from ${base}`:""}${relError?'; targets must start with "./"':""}`}),Error),codes$1.ERR_MODULE_NOT_FOUND=createError$1("ERR_MODULE_NOT_FOUND",((path,base,type="package")=>`Cannot find ${type} '${path}' imported from ${base}`),Error),codes$1.ERR_PACKAGE_IMPORT_NOT_DEFINED=createError$1("ERR_PACKAGE_IMPORT_NOT_DEFINED",((specifier,packagePath,base)=>`Package import specifier "${specifier}" is not defined${packagePath?` in package ${packagePath}package.json`:""} imported from ${base}`),TypeError),codes$1.ERR_PACKAGE_PATH_NOT_EXPORTED=createError$1("ERR_PACKAGE_PATH_NOT_EXPORTED",((pkgPath,subpath,base)=>"."===subpath?`No "exports" main defined in ${pkgPath}package.json${base?` imported from ${base}`:""}`:`Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${base?` imported from ${base}`:""}`),Error),codes$1.ERR_UNSUPPORTED_DIR_IMPORT=createError$1("ERR_UNSUPPORTED_DIR_IMPORT","Directory import '%s' is not supported resolving ES modules imported from %s",Error),codes$1.ERR_UNKNOWN_FILE_EXTENSION=createError$1("ERR_UNKNOWN_FILE_EXTENSION",'Unknown file extension "%s" for %s',TypeError),codes$1.ERR_INVALID_ARG_VALUE=createError$1("ERR_INVALID_ARG_VALUE",((name,value,reason="is invalid")=>{let inspected=(0, external_util_.inspect)(value);inspected.length>128&&(inspected=`${inspected.slice(0,128)}...`);return `The ${name.includes(".")?"property":"argument"} '${name}' ${reason}. Received ${inspected}`}),TypeError),codes$1.ERR_UNSUPPORTED_ESM_URL_SCHEME=createError$1("ERR_UNSUPPORTED_ESM_URL_SCHEME",(url=>{let message="Only file and data URLs are supported by the default ESM loader";return isWindows$1&&2===url.protocol.length&&(message+=". On Windows, absolute paths must be valid file:// URLs"),message+=`. Received protocol '${url.protocol}'`,message}),Error);const addCodeToName$1=hideStackFrames$1((function(error,name,code){(error=captureLargerStackTrace$1(error)).name=`${name} [${code}]`,error.stack,"SystemError"===name?Object.defineProperty(error,"name",{value:name,enumerable:!1,writable:!0,configurable:!0}):delete error.name;}));function isErrorStackTraceLimitWritable$1(){const desc=Object.getOwnPropertyDescriptor(Error,"stackTraceLimit");return void 0===desc?Object.isExtensible(Error):own$3.call(desc,"writable")?desc.writable:void 0!==desc.set}function hideStackFrames$1(fn){const hidden="__node_internal_"+fn.name;return Object.defineProperty(fn,"name",{value:hidden}),fn}const captureLargerStackTrace$1=hideStackFrames$1((function(error){const stackTraceLimitIsWritable=isErrorStackTraceLimitWritable$1();return stackTraceLimitIsWritable&&(userStackTraceLimit$1=Error.stackTraceLimit,Error.stackTraceLimit=Number.POSITIVE_INFINITY),Error.captureStackTrace(error),stackTraceLimitIsWritable&&(Error.stackTraceLimit=userStackTraceLimit$1),error}));const{ERR_UNKNOWN_FILE_EXTENSION:ERR_UNKNOWN_FILE_EXTENSION$1}=codes$1,extensionFormatMap$1={__proto__:null,".cjs":"commonjs",".js":"module",".mjs":"module"};function defaultGetFormat$1(url){if(url.startsWith("node:"))return {format:"builtin"};const parsed=new external_url_namespaceObject.URL(url);if("data:"===parsed.protocol){const{1:mime}=/^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname)||[null,null];return {format:"text/javascript"===mime?"module":null}}if("file:"===parsed.protocol){const ext=external_path_.extname(parsed.pathname);let format;if(format=".js"===ext?"module"===function(url){return getPackageScopeConfig$1(url).type}(parsed.href)?"module":"commonjs":extensionFormatMap$1[ext],!format)throw new ERR_UNKNOWN_FILE_EXTENSION$1(ext,(0, external_url_namespaceObject.fileURLToPath)(url));return {format:format||null}}return {format:null}}!function({version=process.version,experimental=!1}={}){var coreModules=["assert","buffer","child_process","cluster","console","constants","crypto","dgram","dns","domain","events","fs","http","https","module","net","os","path","punycode","querystring","readline","repl","stream","string_decoder","sys","timers","tls","tty","url","util","vm","zlib"];semver$3.lt(version,"6.0.0")&&coreModules.push("freelist"),semver$3.gte(version,"1.0.0")&&coreModules.push("v8"),semver$3.gte(version,"1.1.0")&&coreModules.push("process"),semver$3.gte(version,"8.0.0")&&coreModules.push("inspector"),semver$3.gte(version,"8.1.0")&&coreModules.push("async_hooks"),semver$3.gte(version,"8.4.0")&&coreModules.push("http2"),semver$3.gte(version,"8.5.0")&&coreModules.push("perf_hooks"),semver$3.gte(version,"10.0.0")&&coreModules.push("trace_events"),semver$3.gte(version,"10.5.0")&&(experimental||semver$3.gte(version,"12.0.0"))&&coreModules.push("worker_threads"),semver$3.gte(version,"12.16.0")&&experimental&&coreModules.push("wasi");}();const{ERR_INVALID_MODULE_SPECIFIER:ERR_INVALID_MODULE_SPECIFIER$1,ERR_INVALID_PACKAGE_CONFIG:ERR_INVALID_PACKAGE_CONFIG$1,ERR_INVALID_PACKAGE_TARGET:ERR_INVALID_PACKAGE_TARGET$1,ERR_MODULE_NOT_FOUND:ERR_MODULE_NOT_FOUND$1,ERR_PACKAGE_IMPORT_NOT_DEFINED:ERR_PACKAGE_IMPORT_NOT_DEFINED$1,ERR_PACKAGE_PATH_NOT_EXPORTED:ERR_PACKAGE_PATH_NOT_EXPORTED$1,ERR_UNSUPPORTED_DIR_IMPORT:ERR_UNSUPPORTED_DIR_IMPORT$1,ERR_UNSUPPORTED_ESM_URL_SCHEME:ERR_UNSUPPORTED_ESM_URL_SCHEME$1,ERR_INVALID_ARG_VALUE:ERR_INVALID_ARG_VALUE$1}=codes$1,own$2={}.hasOwnProperty;Object.freeze(["node","import"]);const invalidSegmentRegEx$1=/(^|\\|\/)(\.\.?|node_modules)(\\|\/|$)/,patternRegEx$1=/\*/g,encodedSepRegEx$1=/%2f|%2c/i,emittedPackageWarnings$1=new Set,packageJsonCache$1=new Map;function emitFolderMapDeprecation$1(match,pjsonUrl,isExports,base){const pjsonPath=(0, external_url_namespaceObject.fileURLToPath)(pjsonUrl);emittedPackageWarnings$1.has(pjsonPath+"|"+match)||(emittedPackageWarnings$1.add(pjsonPath+"|"+match),process.emitWarning(`Use of deprecated folder mapping "${match}" in the ${isExports?'"exports"':'"imports"'} field module resolution of the package at ${pjsonPath}${base?` imported from ${(0, external_url_namespaceObject.fileURLToPath)(base)}`:""}.\nUpdate this package.json to use a subpath pattern like "${match}*".`,"DeprecationWarning","DEP0148"));}function emitLegacyIndexDeprecation$1(url,packageJsonUrl,base,main){const{format}=defaultGetFormat$1(url.href);if("module"!==format)return;const path=(0, external_url_namespaceObject.fileURLToPath)(url.href),pkgPath=(0, external_url_namespaceObject.fileURLToPath)(new external_url_namespaceObject.URL(".",packageJsonUrl)),basePath=(0, external_url_namespaceObject.fileURLToPath)(base);main?process.emitWarning(`Package ${pkgPath} has a "main" field set to ${JSON.stringify(main)}, excluding the full filename and extension to the resolved file at "${path.slice(pkgPath.length)}", imported from ${basePath}.\n Automatic extension resolution of the "main" field isdeprecated for ES modules.`,"DeprecationWarning","DEP0151"):process.emitWarning(`No "main" or "exports" field defined in the package.json for ${pkgPath} resolving the main entry point "${path.slice(pkgPath.length)}", imported from ${basePath}.\nDefault "index" lookups for the main are deprecated for ES modules.`,"DeprecationWarning","DEP0151");}function tryStatSync$1(path){try{return (0,external_fs_.statSync)(path)}catch{return new external_fs_.Stats}}function getPackageConfig$1(path,specifier,base){const existing=packageJsonCache$1.get(path);if(void 0!==existing)return existing;const source=packageJsonReader$1.read(path).string;if(void 0===source){const packageConfig={pjsonPath:path,exists:!1,main:void 0,name:void 0,type:"none",exports:void 0,imports:void 0};return packageJsonCache$1.set(path,packageConfig),packageConfig}let packageJson;try{packageJson=JSON.parse(source);}catch(error){throw new ERR_INVALID_PACKAGE_CONFIG$1(path,(base?`"${specifier}" from `:"")+(0, external_url_namespaceObject.fileURLToPath)(base||specifier),error.message)}const{exports,imports,main,name,type}=packageJson,packageConfig={pjsonPath:path,exists:!0,main:"string"==typeof main?main:void 0,name:"string"==typeof name?name:void 0,type:"module"===type||"commonjs"===type?type:"none",exports,imports:imports&&"object"==typeof imports?imports:void 0};return packageJsonCache$1.set(path,packageConfig),packageConfig}function getPackageScopeConfig$1(resolved){let packageJsonUrl=new external_url_namespaceObject.URL("./package.json",resolved);for(;;){if(packageJsonUrl.pathname.endsWith("node_modules/package.json"))break;const packageConfig=getPackageConfig$1((0, external_url_namespaceObject.fileURLToPath)(packageJsonUrl),resolved);if(packageConfig.exists)return packageConfig;const lastPackageJsonUrl=packageJsonUrl;if(packageJsonUrl=new external_url_namespaceObject.URL("../package.json",packageJsonUrl),packageJsonUrl.pathname===lastPackageJsonUrl.pathname)break}const packageJsonPath=(0, external_url_namespaceObject.fileURLToPath)(packageJsonUrl),packageConfig={pjsonPath:packageJsonPath,exists:!1,main:void 0,name:void 0,type:"none",exports:void 0,imports:void 0};return packageJsonCache$1.set(packageJsonPath,packageConfig),packageConfig}function fileExists$1(url){return tryStatSync$1((0, external_url_namespaceObject.fileURLToPath)(url)).isFile()}function legacyMainResolve$1(packageJsonUrl,packageConfig,base){let guess;if(void 0!==packageConfig.main){if(guess=new external_url_namespaceObject.URL(`./${packageConfig.main}`,packageJsonUrl),fileExists$1(guess))return guess;const tries=[`./${packageConfig.main}.js`,`./${packageConfig.main}.json`,`./${packageConfig.main}.node`,`./${packageConfig.main}/index.js`,`./${packageConfig.main}/index.json`,`./${packageConfig.main}/index.node`];let i=-1;for(;++i<tries.length&&(guess=new external_url_namespaceObject.URL(tries[i],packageJsonUrl),!fileExists$1(guess));)guess=void 0;if(guess)return emitLegacyIndexDeprecation$1(guess,packageJsonUrl,base,packageConfig.main),guess}const tries=["./index.js","./index.json","./index.node"];let i=-1;for(;++i<tries.length&&(guess=new external_url_namespaceObject.URL(tries[i],packageJsonUrl),!fileExists$1(guess));)guess=void 0;if(guess)return emitLegacyIndexDeprecation$1(guess,packageJsonUrl,base,packageConfig.main),guess;throw new ERR_MODULE_NOT_FOUND$1((0, external_url_namespaceObject.fileURLToPath)(new external_url_namespaceObject.URL(".",packageJsonUrl)),(0, external_url_namespaceObject.fileURLToPath)(base))}function throwExportsNotFound$1(subpath,packageJsonUrl,base){throw new ERR_PACKAGE_PATH_NOT_EXPORTED$1((0, external_url_namespaceObject.fileURLToPath)(new external_url_namespaceObject.URL(".",packageJsonUrl)),subpath,base&&(0, external_url_namespaceObject.fileURLToPath)(base))}function throwInvalidPackageTarget$1(subpath,target,packageJsonUrl,internal,base){throw target="object"==typeof target&&null!==target?JSON.stringify(target,null,""):`${target}`,new ERR_INVALID_PACKAGE_TARGET$1((0, external_url_namespaceObject.fileURLToPath)(new external_url_namespaceObject.URL(".",packageJsonUrl)),subpath,target,internal,base&&(0, external_url_namespaceObject.fileURLToPath)(base))}function resolvePackageTargetString$1(target,subpath,match,packageJsonUrl,base,pattern,internal,conditions){if(""===subpath||pattern||"/"===target[target.length-1]||throwInvalidPackageTarget$1(match,target,packageJsonUrl,internal,base),!target.startsWith("./")){if(internal&&!target.startsWith("../")&&!target.startsWith("/")){let isURL=!1;try{new external_url_namespaceObject.URL(target),isURL=!0;}catch{}if(!isURL){return packageResolve$1(pattern?target.replace(patternRegEx$1,subpath):target+subpath,packageJsonUrl,conditions)}}throwInvalidPackageTarget$1(match,target,packageJsonUrl,internal,base);}invalidSegmentRegEx$1.test(target.slice(2))&&throwInvalidPackageTarget$1(match,target,packageJsonUrl,internal,base);const resolved=new external_url_namespaceObject.URL(target,packageJsonUrl),resolvedPath=resolved.pathname,packagePath=new external_url_namespaceObject.URL(".",packageJsonUrl).pathname;return resolvedPath.startsWith(packagePath)||throwInvalidPackageTarget$1(match,target,packageJsonUrl,internal,base),""===subpath?resolved:(invalidSegmentRegEx$1.test(subpath)&&function(subpath,packageJsonUrl,internal,base){const reason=`request is not a valid subpath for the "${internal?"imports":"exports"}" resolution of ${(0, external_url_namespaceObject.fileURLToPath)(packageJsonUrl)}`;throw new ERR_INVALID_MODULE_SPECIFIER$1(subpath,reason,base&&(0, external_url_namespaceObject.fileURLToPath)(base))}(match+subpath,packageJsonUrl,internal,base),pattern?new external_url_namespaceObject.URL(resolved.href.replace(patternRegEx$1,subpath)):new external_url_namespaceObject.URL(subpath,resolved))}function isArrayIndex$1(key){const keyNumber=Number(key);return `${keyNumber}`===key&&(keyNumber>=0&&keyNumber<4294967295)}function resolvePackageTarget$1(packageJsonUrl,target,subpath,packageSubpath,base,pattern,internal,conditions){if("string"==typeof target)return resolvePackageTargetString$1(target,subpath,packageSubpath,packageJsonUrl,base,pattern,internal,conditions);if(Array.isArray(target)){const targetList=target;if(0===targetList.length)return null;let lastException,i=-1;for(;++i<targetList.length;){const targetItem=targetList[i];let resolved;try{resolved=resolvePackageTarget$1(packageJsonUrl,targetItem,subpath,packageSubpath,base,pattern,internal,conditions);}catch(error){if(lastException=error,"ERR_INVALID_PACKAGE_TARGET"===error.code)continue;throw error}if(void 0!==resolved){if(null!==resolved)return resolved;lastException=null;}}if(null==lastException)return lastException;throw lastException}if("object"!=typeof target||null===target){if(null===target)return null;throwInvalidPackageTarget$1(packageSubpath,target,packageJsonUrl,internal,base);}else {const keys=Object.getOwnPropertyNames(target);let i=-1;for(;++i<keys.length;){if(isArrayIndex$1(keys[i]))throw new ERR_INVALID_PACKAGE_CONFIG$1((0, external_url_namespaceObject.fileURLToPath)(packageJsonUrl),base,'"exports" cannot contain numeric property keys.')}for(i=-1;++i<keys.length;){const key=keys[i];if("default"===key||conditions&&conditions.has(key)){const resolved=resolvePackageTarget$1(packageJsonUrl,target[key],subpath,packageSubpath,base,pattern,internal,conditions);if(void 0===resolved)continue;return resolved}}}}function packageExportsResolve$1(packageJsonUrl,packageSubpath,packageConfig,base,conditions){let exports=packageConfig.exports;if(function(exports,packageJsonUrl,base){if("string"==typeof exports||Array.isArray(exports))return !0;if("object"!=typeof exports||null===exports)return !1;const keys=Object.getOwnPropertyNames(exports);let isConditionalSugar=!1,i=0,j=-1;for(;++j<keys.length;){const key=keys[j],curIsConditionalSugar=""===key||"."!==key[0];if(0==i++)isConditionalSugar=curIsConditionalSugar;else if(isConditionalSugar!==curIsConditionalSugar)throw new ERR_INVALID_PACKAGE_CONFIG$1((0, external_url_namespaceObject.fileURLToPath)(packageJsonUrl),base,"\"exports\" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.")}return isConditionalSugar}(exports,packageJsonUrl,base)&&(exports={".":exports}),own$2.call(exports,packageSubpath)){const resolved=resolvePackageTarget$1(packageJsonUrl,exports[packageSubpath],"",packageSubpath,base,!1,!1,conditions);return null==resolved&&throwExportsNotFound$1(packageSubpath,packageJsonUrl,base),{resolved,exact:!0}}let bestMatch="";const keys=Object.getOwnPropertyNames(exports);let i=-1;for(;++i<keys.length;){const key=keys[i];("*"===key[key.length-1]&&packageSubpath.startsWith(key.slice(0,-1))&&packageSubpath.length>=key.length&&key.length>bestMatch.length||"/"===key[key.length-1]&&packageSubpath.startsWith(key)&&key.length>bestMatch.length)&&(bestMatch=key);}if(bestMatch){const target=exports[bestMatch],pattern="*"===bestMatch[bestMatch.length-1],resolved=resolvePackageTarget$1(packageJsonUrl,target,packageSubpath.slice(bestMatch.length-(pattern?1:0)),bestMatch,base,pattern,!1,conditions);return null==resolved&&throwExportsNotFound$1(packageSubpath,packageJsonUrl,base),pattern||emitFolderMapDeprecation$1(bestMatch,packageJsonUrl,!0,base),{resolved,exact:pattern}}throwExportsNotFound$1(packageSubpath,packageJsonUrl,base);}function packageImportsResolve$1(name,base,conditions){if("#"===name||name.startsWith("#/")){throw new ERR_INVALID_MODULE_SPECIFIER$1(name,"is not a valid internal imports specifier name",(0, external_url_namespaceObject.fileURLToPath)(base))}let packageJsonUrl;const packageConfig=getPackageScopeConfig$1(base);if(packageConfig.exists){packageJsonUrl=(0, external_url_namespaceObject.pathToFileURL)(packageConfig.pjsonPath);const imports=packageConfig.imports;if(imports)if(own$2.call(imports,name)){const resolved=resolvePackageTarget$1(packageJsonUrl,imports[name],"",name,base,!1,!0,conditions);if(null!==resolved)return {resolved,exact:!0}}else {let bestMatch="";const keys=Object.getOwnPropertyNames(imports);let i=-1;for(;++i<keys.length;){const key=keys[i];("*"===key[key.length-1]&&name.startsWith(key.slice(0,-1))&&name.length>=key.length&&key.length>bestMatch.length||"/"===key[key.length-1]&&name.startsWith(key)&&key.length>bestMatch.length)&&(bestMatch=key);}if(bestMatch){const target=imports[bestMatch],pattern="*"===bestMatch[bestMatch.length-1],resolved=resolvePackageTarget$1(packageJsonUrl,target,name.slice(bestMatch.length-(pattern?1:0)),bestMatch,base,pattern,!0,conditions);if(null!==resolved)return pattern||emitFolderMapDeprecation$1(bestMatch,packageJsonUrl,!1,base),{resolved,exact:pattern}}}}!function(specifier,packageJsonUrl,base){throw new ERR_PACKAGE_IMPORT_NOT_DEFINED$1(specifier,packageJsonUrl&&(0, external_url_namespaceObject.fileURLToPath)(new external_url_namespaceObject.URL(".",packageJsonUrl)),(0, external_url_namespaceObject.fileURLToPath)(base))}(name,packageJsonUrl,base);}function packageResolve$1(specifier,base,conditions){const{packageName,packageSubpath,isScoped}=function(specifier,base){let separatorIndex=specifier.indexOf("/"),validPackageName=!0,isScoped=!1;"@"===specifier[0]&&(isScoped=!0,-1===separatorIndex||0===specifier.length?validPackageName=!1:separatorIndex=specifier.indexOf("/",separatorIndex+1));const packageName=-1===separatorIndex?specifier:specifier.slice(0,separatorIndex);let i=-1;for(;++i<packageName.length;)if("%"===packageName[i]||"\\"===packageName[i]){validPackageName=!1;break}if(!validPackageName)throw new ERR_INVALID_MODULE_SPECIFIER$1(specifier,"is not a valid package name",(0, external_url_namespaceObject.fileURLToPath)(base));return {packageName,packageSubpath:"."+(-1===separatorIndex?"":specifier.slice(separatorIndex)),isScoped}}(specifier,base),packageConfig=getPackageScopeConfig$1(base);if(packageConfig.exists){const packageJsonUrl=(0, external_url_namespaceObject.pathToFileURL)(packageConfig.pjsonPath);if(packageConfig.name===packageName&&void 0!==packageConfig.exports&&null!==packageConfig.exports)return packageExportsResolve$1(packageJsonUrl,packageSubpath,packageConfig,base,conditions).resolved}let lastPath,packageJsonUrl=new external_url_namespaceObject.URL("./node_modules/"+packageName+"/package.json",base),packageJsonPath=(0, external_url_namespaceObject.fileURLToPath)(packageJsonUrl);do{if(!tryStatSync$1(packageJsonPath.slice(0,-13)).isDirectory()){lastPath=packageJsonPath,packageJsonUrl=new external_url_namespaceObject.URL((isScoped?"../../../../node_modules/":"../../../node_modules/")+packageName+"/package.json",packageJsonUrl),packageJsonPath=(0, external_url_namespaceObject.fileURLToPath)(packageJsonUrl);continue}const packageConfig=getPackageConfig$1(packageJsonPath,specifier,base);return void 0!==packageConfig.exports&&null!==packageConfig.exports?packageExportsResolve$1(packageJsonUrl,packageSubpath,packageConfig,base,conditions).resolved:"."===packageSubpath?legacyMainResolve$1(packageJsonUrl,packageConfig,base):new external_url_namespaceObject.URL(packageSubpath,packageJsonUrl)}while(packageJsonPath.length!==lastPath.length);throw new ERR_MODULE_NOT_FOUND$1(packageName,(0, external_url_namespaceObject.fileURLToPath)(base))}function moduleResolve$1(specifier,base,conditions){let resolved;if(function(specifier){return ""!==specifier&&("/"===specifier[0]||function(specifier){if("."===specifier[0]){if(1===specifier.length||"/"===specifier[1])return !0;if("."===specifier[1]&&(2===specifier.length||"/"===specifier[2]))return !0}return !1}(specifier))}(specifier))resolved=new external_url_namespaceObject.URL(specifier,base);else if("#"===specifier[0])({resolved}=packageImportsResolve$1(specifier,base,conditions));else try{resolved=new external_url_namespaceObject.URL(specifier);}catch{resolved=packageResolve$1(specifier,base,conditions);}return function(resolved,base){if(encodedSepRegEx$1.test(resolved.pathname))throw new ERR_INVALID_MODULE_SPECIFIER$1(resolved.pathname,'must not include encoded "/" or "\\" characters',(0, external_url_namespaceObject.fileURLToPath)(base));const path=(0, external_url_namespaceObject.fileURLToPath)(resolved),stats=tryStatSync$1(path.endsWith("/")?path.slice(-1):path);if(stats.isDirectory()){const error=new ERR_UNSUPPORTED_DIR_IMPORT$1(path,(0, external_url_namespaceObject.fileURLToPath)(base));throw error.url=String(resolved),error}if(!stats.isFile())throw new ERR_MODULE_NOT_FOUND$1(path||resolved.pathname,base&&(0, external_url_namespaceObject.fileURLToPath)(base),"module");return resolved}(resolved,base)}const DEFAULT_CONDITIONS_SET$1=new Set(["node","import"]),DEFAULT_URL$1=(0, external_url_namespaceObject.pathToFileURL)(process.cwd()),DEFAULT_EXTENSIONS$1=[".mjs",".cjs",".js",".json"],NOT_FOUND_ERRORS$1=new Set(["ERR_MODULE_NOT_FOUND","ERR_UNSUPPORTED_DIR_IMPORT","MODULE_NOT_FOUND"]);function _tryModuleResolve$1(id,url,conditions){try{return moduleResolve$1(id,url,conditions)}catch(err){if(!NOT_FOUND_ERRORS$1.has(err.code))throw err;return null}}function _resolve$1(id,opts={}){if(/(node|data|http|https):/.test(id))return id;if(BUILTIN_MODULES$1.has(id))return "node:"+id;if(isAbsolute$1(id)&&(0, external_fs_.existsSync)(id)){const realPath2=(0, external_fs_.realpathSync)(fileURLToPath$1(id));return (0, external_url_namespaceObject.pathToFileURL)(realPath2).toString()}const conditionsSet=opts.conditions?new Set(opts.conditions):DEFAULT_CONDITIONS_SET$1,_urls=(Array.isArray(opts.url)?opts.url:[opts.url]).filter(Boolean).map((u=>new URL(function(id){return "string"!=typeof id&&(id=id.toString()),/(node|data|http|https|file):/.test(id)?id:BUILTIN_MODULES$1.has(id)?"node:"+id:"file://"+normalizeSlash$1(id)}(u.toString()))));_urls.length||_urls.push(DEFAULT_URL$1);const urls=[..._urls];for(const url of _urls)if("file:"===url.protocol&&!url.pathname.includes("node_modules")){const newURL=new URL(url);newURL.pathname+="/node_modules",urls.push(newURL);}let resolved;for(const url of urls){if(resolved=_tryModuleResolve$1(id,url,conditionsSet),resolved)break;for(const prefix of ["","/index"]){for(const ext of opts.extensions||DEFAULT_EXTENSIONS$1)if(resolved=_tryModuleResolve$1(id+prefix+ext,url,conditionsSet),resolved)break;if(resolved)break}}if(!resolved){const err=new Error(`Cannot find module ${id} imported from ${urls.join(", ")}`);throw err.code="ERR_MODULE_NOT_FOUND",err}const realPath=(0, external_fs_.realpathSync)(fileURLToPath$1(resolved));return (0, external_url_namespaceObject.pathToFileURL)(realPath).toString()}function resolveSync$1(id,opts){return _resolve$1(id,opts)}function resolvePathSync$1(id,opts){return fileURLToPath$1(resolveSync$1(id,opts))}var ParseOptions;!function(ParseOptions){ParseOptions.DEFAULT={allowTrailingComma:!1};}(ParseOptions||(ParseOptions={}));new Set(external_module_.builtinModules);var re$5={exports:{}};var constants={SEMVER_SPEC_VERSION:"2.0.0",MAX_LENGTH:256,MAX_SAFE_INTEGER:Number.MAX_SAFE_INTEGER||9007199254740991,MAX_SAFE_COMPONENT_LENGTH:16};var debug_1="object"==typeof process&&process.env&&process.env.NODE_DEBUG&&/\bsemver\b/i.test(process.env.NODE_DEBUG)?(...args)=>console.error("SEMVER",...args):()=>{};!function(module,exports){const{MAX_SAFE_COMPONENT_LENGTH}=constants,debug=debug_1,re=(exports=module.exports={}).re=[],src=exports.src=[],t=exports.t={};let R=0;const createToken=(name,value,isGlobal)=>{const index=R++;debug(index,value),t[name]=index,src[index]=value,re[index]=new RegExp(value,isGlobal?"g":void 0);};createToken("NUMERICIDENTIFIER","0|[1-9]\\d*"),createToken("NUMERICIDENTIFIERLOOSE","[0-9]+"),createToken("NONNUMERICIDENTIFIER","\\d*[a-zA-Z-][a-zA-Z0-9-]*"),createToken("MAINVERSION",`(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`),createToken("MAINVERSIONLOOSE",`(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`),createToken("PRERELEASEIDENTIFIER",`(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`),createToken("PRERELEASEIDENTIFIERLOOSE",`(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`),createToken("PRERELEASE",`(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`),createToken("PRERELEASELOOSE",`(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`),createToken("BUILDIDENTIFIER","[0-9A-Za-z-]+"),createToken("BUILD",`(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`),createToken("FULLPLAIN",`v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`),createToken("FULL",`^${src[t.FULLPLAIN]}$`),createToken("LOOSEPLAIN",`[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`),createToken("LOOSE",`^${src[t.LOOSEPLAIN]}$`),createToken("GTLT","((?:<|>)?=?)"),createToken("XRANGEIDENTIFIERLOOSE",`${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),createToken("XRANGEIDENTIFIER",`${src[t.NUMERICIDENTIFIER]}|x|X|\\*`),createToken("XRANGEPLAIN",`[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`),createToken("XRANGEPLAINLOOSE",`[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`),createToken("XRANGE",`^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`),createToken("XRANGELOOSE",`^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`),createToken("COERCE",`(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`),createToken("COERCERTL",src[t.COERCE],!0),createToken("LONETILDE","(?:~>?)"),createToken("TILDETRIM",`(\\s*)${src[t.LONETILDE]}\\s+`,!0),exports.tildeTrimReplace="$1~",createToken("TILDE",`^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`),createToken("TILDELOOSE",`^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`),createToken("LONECARET","(?:\\^)"),createToken("CARETTRIM",`(\\s*)${src[t.LONECARET]}\\s+`,!0),exports.caretTrimReplace="$1^",createToken("CARET",`^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`),createToken("CARETLOOSE",`^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`),createToken("COMPARATORLOOSE",`^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`),createToken("COMPARATOR",`^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`),createToken("COMPARATORTRIM",`(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`,!0),exports.comparatorTrimReplace="$1$2$3",createToken("HYPHENRANGE",`^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`),createToken("HYPHENRANGELOOSE",`^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`),createToken("STAR","(<|>)?=?\\s*\\*"),createToken("GTE0","^\\s*>=\\s*0.0.0\\s*$"),createToken("GTE0PRE","^\\s*>=\\s*0.0.0-0\\s*$");}(re$5,re$5.exports);const opts=["includePrerelease","loose","rtl"];var parseOptions_1=options=>options?"object"!=typeof options?{loose:!0}:opts.filter((k=>options[k])).reduce(((options,k)=>(options[k]=!0,options)),{}):{};const numeric=/^[0-9]+$/,compareIdentifiers$1=(a,b)=>{const anum=numeric.test(a),bnum=numeric.test(b);return anum&&bnum&&(a=+a,b=+b),a===b?0:anum&&!bnum?-1:bnum&&!anum?1:a<b?-1:1};var identifiers={compareIdentifiers:compareIdentifiers$1,rcompareIdentifiers:(a,b)=>compareIdentifiers$1(b,a)};const debug$2=debug_1,{MAX_LENGTH:MAX_LENGTH$1,MAX_SAFE_INTEGER}=constants,{re:re$4,t:t$4}=re$5.exports,parseOptions$3=parseOptions_1,{compareIdentifiers}=identifiers;class SemVer$e{constructor(version,options){if(options=parseOptions$3(options),version instanceof SemVer$e){if(version.loose===!!options.loose&&version.includePrerelease===!!options.includePrerelease)return version;version=version.version;}else if("string"!=typeof version)throw new TypeError(`Invalid Version: ${version}`);if(version.length>MAX_LENGTH$1)throw new TypeError(`version is longer than ${MAX_LENGTH$1} characters`);debug$2("SemVer",version,options),this.options=options,this.loose=!!options.loose,this.includePrerelease=!!options.includePrerelease;const m=version.trim().match(options.loose?re$4[t$4.LOOSE]:re$4[t$4.FULL]);if(!m)throw new TypeError(`Invalid Version: ${version}`);if(this.raw=version,this.major=+m[1],this.minor=+m[2],this.patch=+m[3],this.major>MAX_SAFE_INTEGER||this.major<0)throw new TypeError("Invalid major version");if(this.minor>MAX_SAFE_INTEGER||this.minor<0)throw new TypeError("Invalid minor version");if(this.patch>MAX_SAFE_INTEGER||this.patch<0)throw new TypeError("Invalid patch version");m[4]?this.prerelease=m[4].split(".").map((id=>{if(/^[0-9]+$/.test(id)){const num=+id;if(num>=0&&num<MAX_SAFE_INTEGER)return num}return id})):this.prerelease=[],this.build=m[5]?m[5].split("."):[],this.format();}format(){return this.version=`${this.major}.${this.minor}.${this.patch}`,this.prerelease.length&&(this.version+=`-${this.prerelease.join(".")}`),this.version}toString(){return this.version}compare(other){if(debug$2("SemVer.compare",this.version,this.options,other),!(other instanceof SemVer$e)){if("string"==typeof other&&other===this.version)return 0;other=new SemVer$e(other,this.options);}return other.version===this.version?0:this.compareMain(other)||this.comparePre(other)}compareMain(other){return other instanceof SemVer$e||(other=new SemVer$e(other,this.options)),compareIdentifiers(this.major,other.major)||compareIdentifiers(this.minor,other.minor)||compareIdentifiers(this.patch,other.patch)}comparePre(other){if(other instanceof SemVer$e||(other=new SemVer$e(other,this.options)),this.prerelease.length&&!other.prerelease.length)return -1;if(!this.prerelease.length&&other.prerelease.length)return 1;if(!this.prerelease.length&&!other.prerelease.length)return 0;let i=0;do{const a=this.prerelease[i],b=other.prerelease[i];if(debug$2("prerelease compare",i,a,b),void 0===a&&void 0===b)return 0;if(void 0===b)return 1;if(void 0===a)return -1;if(a!==b)return compareIdentifiers(a,b)}while(++i)}compareBuild(other){other instanceof SemVer$e||(other=new SemVer$e(other,this.options));let i=0;do{const a=this.build[i],b=other.build[i];if(debug$2("prerelease compare",i,a,b),void 0===a&&void 0===b)return 0;if(void 0===b)return 1;if(void 0===a)return -1;if(a!==b)return compareIdentifiers(a,b)}while(++i)}inc(release,identifier){switch(release){case"premajor":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc("pre",identifier);break;case"preminor":this.prerelease.length=0,this.patch=0,this.minor++,this.inc("pre",identifier);break;case"prepatch":this.prerelease.length=0,this.inc("patch",identifier),this.inc("pre",identifier);break;case"prerelease":0===this.prerelease.length&&this.inc("patch",identifier),this.inc("pre",identifier);break;case"major":0===this.minor&&0===this.patch&&0!==this.prerelease.length||this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case"minor":0===this.patch&&0!==this.prerelease.length||this.minor++,this.patch=0,this.prerelease=[];break;case"patch":0===this.prerelease.length&&this.patch++,this.prerelease=[];break;case"pre":if(0===this.prerelease.length)this.prerelease=[0];else {let i=this.prerelease.length;for(;--i>=0;)"number"==typeof this.prerelease[i]&&(this.prerelease[i]++,i=-2);-1===i&&this.prerelease.push(0);}identifier&&(this.prerelease[0]===identifier?isNaN(this.prerelease[1])&&(this.prerelease=[identifier,0]):this.prerelease=[identifier,0]);break;default:throw new Error(`invalid increment argument: ${release}`)}return this.format(),this.raw=this.version,this}}var semver$2=SemVer$e;const{MAX_LENGTH}=constants,{re:re$3,t:t$3}=re$5.exports,SemVer$d=semver$2,parseOptions$2=parseOptions_1;var parse_1=(version,options)=>{if(options=parseOptions$2(options),version instanceof SemVer$d)return version;if("string"!=typeof version)return null;if(version.length>MAX_LENGTH)return null;if(!(options.loose?re$3[t$3.LOOSE]:re$3[t$3.FULL]).test(version))return null;try{return new SemVer$d(version,options)}catch(er){return null}};const parse$4=parse_1;var valid_1=(version,options)=>{const v=parse$4(version,options);return v?v.version:null};const parse$3=parse_1;var clean_1=(version,options)=>{const s=parse$3(version.trim().replace(/^[=v]+/,""),options);return s?s.version:null};const SemVer$c=semver$2;var inc_1=(version,release,options,identifier)=>{"string"==typeof options&&(identifier=options,options=void 0);try{return new SemVer$c(version,options).inc(release,identifier).version}catch(er){return null}};const SemVer$b=semver$2;var compare_1=(a,b,loose)=>new SemVer$b(a,loose).compare(new SemVer$b(b,loose));const compare$9=compare_1;var eq_1=(a,b,loose)=>0===compare$9(a,b,loose);const parse$2=parse_1,eq$1=eq_1;var diff_1=(version1,version2)=>{if(eq$1(version1,version2))return null;{const v1=parse$2(version1),v2=parse$2(version2),hasPre=v1.prerelease.length||v2.prerelease.length,prefix=hasPre?"pre":"",defaultResult=hasPre?"prerelease":"";for(const key in v1)if(("major"===key||"minor"===key||"patch"===key)&&v1[key]!==v2[key])return prefix+key;return defaultResult}};const SemVer$a=semver$2;var major_1=(a,loose)=>new SemVer$a(a,loose).major;const SemVer$9=semver$2;var minor_1=(a,loose)=>new SemVer$9(a,loose).minor;const SemVer$8=semver$2;var patch_1=(a,loose)=>new SemVer$8(a,loose).patch;const parse$1=parse_1;var prerelease_1=(version,options)=>{const parsed=parse$1(version,options);return parsed&&parsed.prerelease.length?parsed.prerelease:null};const compare$8=compare_1;var rcompare_1=(a,b,loose)=>compare$8(b,a,loose);const compare$7=compare_1;var compareLoose_1=(a,b)=>compare$7(a,b,!0);const SemVer$7=semver$2;var compareBuild_1=(a,b,loose)=>{const versionA=new SemVer$7(a,loose),versionB=new SemVer$7(b,loose);return versionA.compare(versionB)||versionA.compareBuild(versionB)};const compareBuild$1=compareBuild_1;var sort_1=(list,loose)=>list.sort(((a,b)=>compareBuild$1(a,b,loose)));const compareBuild=compareBuild_1;var rsort_1=(list,loose)=>list.sort(((a,b)=>compareBuild(b,a,loose)));const compare$6=compare_1;var gt_1=(a,b,loose)=>compare$6(a,b,loose)>0;const compare$5=compare_1;var lt_1=(a,b,loose)=>compare$5(a,b,loose)<0;const compare$4=compare_1;var neq_1=(a,b,loose)=>0!==compare$4(a,b,loose);const compare$3=compare_1;var gte_1=(a,b,loose)=>compare$3(a,b,loose)>=0;const compare$2=compare_1;var lte_1=(a,b,loose)=>compare$2(a,b,loose)<=0;const eq=eq_1,neq=neq_1,gt$2=gt_1,gte$1=gte_1,lt$1=lt_1,lte$1=lte_1;var cmp_1=(a,op,b,loose)=>{switch(op){case"===":return "object"==typeof a&&(a=a.version),"object"==typeof b&&(b=b.version),a===b;case"!==":return "object"==typeof a&&(a=a.version),"object"==typeof b&&(b=b.version),a!==b;case"":case"=":case"==":return eq(a,b,loose);case"!=":return neq(a,b,loose);case">":return gt$2(a,b,loose);case">=":return gte$1(a,b,loose);case"<":return lt$1(a,b,loose);case"<=":return lte$1(a,b,loose);default:throw new TypeError(`Invalid operator: ${op}`)}};const SemVer$6=semver$2,parse=parse_1,{re:re$2,t:t$2}=re$5.exports;var coerce_1=(version,options)=>{if(version instanceof SemVer$6)return version;if("number"==typeof version&&(version=String(version)),"string"!=typeof version)return null;let match=null;if((options=options||{}).rtl){let next;for(;(next=re$2[t$2.COERCERTL].exec(version))&&(!match||match.index+match[0].length!==version.length);)match&&next.index+next[0].length===match.index+match[0].length||(match=next),re$2[t$2.COERCERTL].lastIndex=next.index+next[1].length+next[2].length;re$2[t$2.COERCERTL].lastIndex=-1;}else match=version.match(re$2[t$2.COERCE]);return null===match?null:parse(`${match[2]}.${match[3]||"0"}.${match[4]||"0"}`,options)},yallist=Yallist$1;function Yallist$1(list){var self=this;if(self instanceof Yallist$1||(self=new Yallist$1),self.tail=null,self.head=null,self.length=0,list&&"function"==typeof list.forEach)list.forEach((function(item){self.push(item);}));else if(arguments.length>0)for(var i=0,l=arguments.length;i<l;i++)self.push(arguments[i]);return self}function insert(self,node,value){var inserted=node===self.head?new Node(value,null,node,self):new Node(value,node,node.next,self);return null===inserted.next&&(self.tail=inserted),null===inserted.prev&&(self.head=inserted),self.length++,inserted}function push(self,item){self.tail=new Node(item,self.tail,null,self),self.head||(self.head=self.tail),self.length++;}function unshift(self,item){self.head=new Node(item,null,self.head,self),self.tail||(self.tail=self.head),self.length++;}function Node(value,prev,next,list){if(!(this instanceof Node))return new Node(value,prev,next,list);this.list=list,this.value=value,prev?(prev.next=this,this.prev=prev):this.prev=null,next?(next.prev=this,this.next=next):this.next=null;}Yallist$1.Node=Node,Yallist$1.create=Yallist$1,Yallist$1.prototype.removeNode=function(node){if(node.list!==this)throw new Error("removing node which does not belong to this list");var next=node.next,prev=node.prev;return next&&(next.prev=prev),prev&&(prev.next=next),node===this.head&&(this.head=next),node===this.tail&&(this.tail=prev),node.list.length--,node.next=null,node.prev=null,node.list=null,next},Yallist$1.prototype.unshiftNode=function(node){if(node!==this.head){node.list&&node.list.removeNode(node);var head=this.head;node.list=this,node.next=head,head&&(head.prev=node),this.head=node,this.tail||(this.tail=node),this.length++;}},Yallist$1.prototype.pushNode=function(node){if(node!==this.tail){node.list&&node.list.removeNode(node);var tail=this.tail;node.list=this,node.prev=tail,tail&&(tail.next=node),this.tail=node,this.head||(this.head=node),this.length++;}},Yallist$1.prototype.push=function(){for(var i=0,l=arguments.length;i<l;i++)push(this,arguments[i]);return this.length},Yallist$1.prototype.unshift=function(){for(var i=0,l=arguments.length;i<l;i++)unshift(this,arguments[i]);return this.length},Yallist$1.prototype.pop=function(){if(this.tail){var res=this.tail.value;return this.tail=this.tail.prev,this.tail?this.tail.next=null:this.head=null,this.length--,res}},Yallist$1.prototype.shift=function(){if(this.head){var res=this.head.value;return this.head=this.head.next,this.head?this.head.prev=null:this.tail=null,this.length--,res}},Yallist$1.prototype.forEach=function(fn,thisp){thisp=thisp||this;for(var walker=this.head,i=0;null!==walker;i++)fn.call(thisp,walker.value,i,this),walker=walker.next;},Yallist$1.prototype.forEachReverse=function(fn,thisp){thisp=thisp||this;for(var walker=this.tail,i=this.length-1;null!==walker;i--)fn.call(thisp,walker.value,i,this),walker=walker.prev;},Yallist$1.prototype.get=function(n){for(var i=0,walker=this.head;null!==walker&&i<n;i++)walker=walker.next;if(i===n&&null!==walker)return walker.value},Yallist$1.prototype.getReverse=function(n){for(var i=0,walker=this.tail;null!==walker&&i<n;i++)walker=walker.prev;if(i===n&&null!==walker)return walker.value},Yallist$1.prototype.map=function(fn,thisp){thisp=thisp||this;for(var res=new Yallist$1,walker=this.head;null!==walker;)res.push(fn.call(thisp,walker.value,this)),walker=walker.next;return res},Yallist$1.prototype.mapReverse=function(fn,thisp){thisp=thisp||this;for(var res=new Yallist$1,walker=this.tail;null!==walker;)res.push(fn.call(thisp,walker.value,this)),walker=walker.prev;return res},Yallist$1.prototype.reduce=function(fn,initial){var acc,walker=this.head;if(arguments.length>1)acc=initial;else {if(!this.head)throw new TypeError("Reduce of empty list with no initial value");walker=this.head.next,acc=this.head.value;}for(var i=0;null!==walker;i++)acc=fn(acc,walker.value,i),walker=walker.next;return acc},Yallist$1.prototype.reduceReverse=function(fn,initial){var acc,walker=this.tail;if(arguments.length>1)acc=initial;else {if(!this.tail)throw new TypeError("Reduce of empty list with no initial value");walker=this.tail.prev,acc=this.tail.value;}for(var i=this.length-1;null!==walker;i--)acc=fn(acc,walker.value,i),walker=walker.prev;return acc},Yallist$1.prototype.toArray=function(){for(var arr=new Array(this.length),i=0,walker=this.head;null!==walker;i++)arr[i]=walker.value,walker=walker.next;return arr},Yallist$1.prototype.toArrayReverse=function(){for(var arr=new Array(this.length),i=0,walker=this.tail;null!==walker;i++)arr[i]=walker.value,walker=walker.prev;return arr},Yallist$1.prototype.slice=function(from,to){(to=to||this.length)<0&&(to+=this.length),(from=from||0)<0&&(from+=this.length);var ret=new Yallist$1;if(to<from||to<0)return ret;from<0&&(from=0),to>this.length&&(to=this.length);for(var i=0,walker=this.head;null!==walker&&i<from;i++)walker=walker.next;for(;null!==walker&&i<to;i++,walker=walker.next)ret.push(walker.value);return ret},Yallist$1.prototype.sliceReverse=function(from,to){(to=to||this.length)<0&&(to+=this.length),(from=from||0)<0&&(from+=this.length);var ret=new Yallist$1;if(to<from||to<0)return ret;from<0&&(from=0),to>this.length&&(to=this.length);for(var i=this.length,walker=this.tail;null!==walker&&i>to;i--)walker=walker.prev;for(;null!==walker&&i>from;i--,walker=walker.prev)ret.push(walker.value);return ret},Yallist$1.prototype.splice=function(start,deleteCount,...nodes){start>this.length&&(start=this.length-1),start<0&&(start=this.length+start);for(var i=0,walker=this.head;null!==walker&&i<start;i++)walker=walker.next;var ret=[];for(i=0;walker&&i<deleteCount;i++)ret.push(walker.value),walker=this.removeNode(walker);null===walker&&(walker=this.tail),walker!==this.head&&walker!==this.tail&&(walker=walker.prev);for(i=0;i<nodes.length;i++)walker=insert(this,walker,nodes[i]);return ret},Yallist$1.prototype.reverse=function(){for(var head=this.head,tail=this.tail,walker=head;null!==walker;walker=walker.prev){var p=walker.prev;walker.prev=walker.next,walker.next=p;}return this.head=tail,this.tail=head,this};try{require("./iterator.js")(Yallist$1);}catch(er){}const Yallist=yallist,MAX=Symbol("max"),LENGTH=Symbol("length"),LENGTH_CALCULATOR=Symbol("lengthCalculator"),ALLOW_STALE=Symbol("allowStale"),MAX_AGE=Symbol("maxAge"),DISPOSE=Symbol("dispose"),NO_DISPOSE_ON_SET=Symbol("noDisposeOnSet"),LRU_LIST=Symbol("lruList"),CACHE=Symbol("cache"),UPDATE_AGE_ON_GET=Symbol("updateAgeOnGet"),naiveLength=()=>1;const get=(self,key,doUse)=>{const node=self[CACHE].get(key);if(node){const hit=node.value;if(isStale(self,hit)){if(del(self,node),!self[ALLOW_STALE])return}else doUse&&(self[UPDATE_AGE_ON_GET]&&(node.value.now=Date.now()),self[LRU_LIST].unshiftNode(node));return hit.value}},isStale=(self,hit)=>{if(!hit||!hit.maxAge&&!self[MAX_AGE])return !1;const diff=Date.now()-hit.now;return hit.maxAge?diff>hit.maxAge:self[MAX_AGE]&&diff>self[MAX_AGE]},trim=self=>{if(self[LENGTH]>self[MAX])for(let walker=self[LRU_LIST].tail;self[LENGTH]>self[MAX]&&null!==walker;){const prev=walker.prev;del(self,walker),walker=prev;}},del=(self,node)=>{if(node){const hit=node.value;self[DISPOSE]&&self[DISPOSE](hit.key,hit.value),self[LENGTH]-=hit.length,self[CACHE].delete(hit.key),self[LRU_LIST].removeNode(node);}};class Entry{constructor(key,value,length,now,maxAge){this.key=key,this.value=value,this.length=length,this.now=now,this.maxAge=maxAge||0;}}const forEachStep=(self,fn,node,thisp)=>{let hit=node.value;isStale(self,hit)&&(del(self,node),self[ALLOW_STALE]||(hit=void 0)),hit&&fn.call(thisp,hit.value,hit.key,self);};var lruCache=class{constructor(options){if("number"==typeof options&&(options={max:options}),options||(options={}),options.max&&("number"!=typeof options.max||options.max<0))throw new TypeError("max must be a non-negative number");this[MAX]=options.max||1/0;const lc=options.length||naiveLength;if(this[LENGTH_CALCULATOR]="function"!=typeof lc?naiveLength:lc,this[ALLOW_STALE]=options.stale||!1,options.maxAge&&"number"!=typeof options.maxAge)throw new TypeError("maxAge must be a number");this[MAX_AGE]=options.maxAge||0,this[DISPOSE]=options.dispose,this[NO_DISPOSE_ON_SET]=options.noDisposeOnSet||!1,this[UPDATE_AGE_ON_GET]=options.updateAgeOnGet||!1,this.reset();}set max(mL){if("number"!=typeof mL||mL<0)throw new TypeError("max must be a non-negative number");this[MAX]=mL||1/0,trim(this);}get max(){return this[MAX]}set allowStale(allowStale){this[ALLOW_STALE]=!!allowStale;}get allowStale(){return this[ALLOW_STALE]}set maxAge(mA){if("number"!=typeof mA)throw new TypeError("maxAge must be a non-negative number");this[MAX_AGE]=mA,trim(this);}get maxAge(){return this[MAX_AGE]}set lengthCalculator(lC){"function"!=typeof lC&&(lC=naiveLength),lC!==this[LENGTH_CALCULATOR]&&(this[LENGTH_CALCULATOR]=lC,this[LENGTH]=0,this[LRU_LIST].forEach((hit=>{hit.length=this[LENGTH_CALCULATOR](hit.value,hit.key),this[LENGTH]+=hit.length;}))),trim(this);}get lengthCalculator(){return this[LENGTH_CALCULATOR]}get length(){return this[LENGTH]}get itemCount(){return this[LRU_LIST].length}rforEach(fn,thisp){thisp=thisp||this;for(let walker=this[LRU_LIST].tail;null!==walker;){const prev=walker.prev;forEachStep(this,fn,walker,thisp),walker=prev;}}forEach(fn,thisp){thisp=thisp||this;for(let walker=this[LRU_LIST].head;null!==walker;){const next=walker.next;forEachStep(this,fn,walker,thisp),walker=next;}}keys(){return this[LRU_LIST].toArray().map((k=>k.key))}values(){return this[LRU_LIST].toArray().map((k=>k.value))}reset(){this[DISPOSE]&&this[LRU_LIST]&&this[LRU_LIST].length&&this[LRU_LIST].forEach((hit=>this[DISPOSE](hit.key,hit.value))),this[CACHE]=new Map,this[LRU_LIST]=new Yallist,this[LENGTH]=0;}dump(){return this[LRU_LIST].map((hit=>!isStale(this,hit)&&{k:hit.key,v:hit.value,e:hit.now+(hit.maxAge||0)})).toArray().filter((h=>h))}dumpLru(){return this[LRU_LIST]}set(key,value,maxAge){if((maxAge=maxAge||this[MAX_AGE])&&"number"!=typeof maxAge)throw new TypeError("maxAge must be a number");const now=maxAge?Date.now():0,len=this[LENGTH_CALCULATOR](value,key);if(this[CACHE].has(key)){if(len>this[MAX])return del(this,this[CACHE].get(key)),!1;const item=this[CACHE].get(key).value;return this[DISPOSE]&&(this[NO_DISPOSE_ON_SET]||this[DISPOSE](key,item.value)),item.now=now,item.maxAge=maxAge,item.value=value,this[LENGTH]+=len-item.length,item.length=len,this.get(key),trim(this),!0}const hit=new Entry(key,value,len,now,maxAge);return hit.length>this[MAX]?(this[DISPOSE]&&this[DISPOSE](key,value),!1):(this[LENGTH]+=hit.length,this[LRU_LIST].unshift(hit),this[CACHE].set(key,this[LRU_LIST].head),trim(this),!0)}has(key){if(!this[CACHE].has(key))return !1;const hit=this[CACHE].get(key).value;return !isStale(this,hit)}get(key){return get(this,key,!0)}peek(key){return get(this,key,!1)}pop(){const node=this[LRU_LIST].tail;return node?(del(this,node),node.value):null}del(key){del(this,this[CACHE].get(key));}load(arr){this.reset();const now=Date.now();for(let l=arr.length-1;l>=0;l--){const hit=arr[l],expiresAt=hit.e||0;if(0===expiresAt)this.set(hit.k,hit.v);else {const maxAge=expiresAt-now;maxAge>0&&this.set(hit.k,hit.v,maxAge);}}}prune(){this[CACHE].forEach(((value,key)=>get(this,key,!1)));}};class Range$a{constructor(range,options){if(options=parseOptions$1(options),range instanceof Range$a)return range.loose===!!options.loose&&range.includePrerelease===!!options.includePrerelease?range:new Range$a(range.raw,options);if(range instanceof Comparator$3)return this.raw=range.value,this.set=[[range]],this.format(),this;if(this.options=options,this.loose=!!options.loose,this.includePrerelease=!!options.includePrerelease,this.raw=range,this.set=range.split(/\s*\|\|\s*/).map((range=>this.parseRange(range.trim()))).filter((c=>c.length)),!this.set.length)throw new TypeError(`Invalid SemVer Range: ${range}`);if(this.set.length>1){const first=this.set[0];if(this.set=this.set.filter((c=>!isNullSet(c[0]))),0===this.set.length)this.set=[first];else if(this.set.length>1)for(const c of this.set)if(1===c.length&&isAny(c[0])){this.set=[c];break}}this.format();}format(){return this.range=this.set.map((comps=>comps.join(" ").trim())).join("||").trim(),this.range}toString(){return this.range}parseRange(range){range=range.trim();const memoKey=`parseRange:${Object.keys(this.options).join(",")}:${range}`,cached=cache.get(memoKey);if(cached)return cached;const loose=this.options.loose,hr=loose?re$1[t$1.HYPHENRANGELOOSE]:re$1[t$1.HYPHENRANGE];range=range.replace(hr,hyphenReplace(this.options.includePrerelease)),debug$1("hyphen replace",range),range=range.replace(re$1[t$1.COMPARATORTRIM],comparatorTrimReplace),debug$1("comparator trim",range,re$1[t$1.COMPARATORTRIM]),range=(range=(range=range.replace(re$1[t$1.TILDETRIM],tildeTrimReplace)).replace(re$1[t$1.CARETTRIM],caretTrimReplace)).split(/\s+/).join(" ");const compRe=loose?re$1[t$1.COMPARATORLOOSE]:re$1[t$1.COMPARATOR],rangeList=range.split(" ").map((comp=>parseComparator(comp,this.options))).join(" ").split(/\s+/).map((comp=>replaceGTE0(comp,this.options))).filter(this.options.loose?comp=>!!comp.match(compRe):()=>!0).map((comp=>new Comparator$3(comp,this.options)));rangeList.length;const rangeMap=new Map;for(const comp of rangeList){if(isNullSet(comp))return [comp];rangeMap.set(comp.value,comp);}rangeMap.size>1&&rangeMap.has("")&&rangeMap.delete("");const result=[...rangeMap.values()];return cache.set(memoKey,result),result}intersects(range,options){if(!(range instanceof Range$a))throw new TypeError("a Range is required");return this.set.some((thisComparators=>isSatisfiable(thisComparators,options)&&range.set.some((rangeComparators=>isSatisfiable(rangeComparators,options)&&thisComparators.every((thisComparator=>rangeComparators.every((rangeComparator=>thisComparator.intersects(rangeComparator,options)))))))))}test(version){if(!version)return !1;if("string"==typeof version)try{version=new SemVer$5(version,this.options);}catch(er){return !1}for(let i=0;i<this.set.length;i++)if(testSet(this.set[i],version,this.options))return !0;return !1}}var range=Range$a;const cache=new lruCache({max:1e3}),parseOptions$1=parseOptions_1,Comparator$3=comparator,debug$1=debug_1,SemVer$5=semver$2,{re:re$1,t:t$1,comparatorTrimReplace,tildeTrimReplace,caretTrimReplace}=re$5.exports,isNullSet=c=>"<0.0.0-0"===c.value,isAny=c=>""===c.value,isSatisfiable=(comparators,options)=>{let result=!0;const remainingComparators=comparators.slice();let testComparator=remainingComparators.pop();for(;result&&remainingComparators.length;)result=remainingComparators.every((otherComparator=>testComparator.intersects(otherComparator,options))),testComparator=remainingComparators.pop();return result},parseComparator=(comp,options)=>(debug$1("comp",comp,options),comp=replaceCarets(comp,options),debug$1("caret",comp),comp=replaceTildes(comp,options),debug$1("tildes",comp),comp=replaceXRanges(comp,options),debug$1("xrange",comp),comp=replaceStars(comp,options),debug$1("stars",comp),comp),isX=id=>!id||"x"===id.toLowerCase()||"*"===id,replaceTildes=(comp,options)=>comp.trim().split(/\s+/).map((comp=>replaceTilde(comp,options))).join(" "),replaceTilde=(comp,options)=>{const r=options.loose?re$1[t$1.TILDELOOSE]:re$1[t$1.TILDE];return comp.replace(r,((_,M,m,p,pr)=>{let ret;return debug$1("tilde",comp,_,M,m,p,pr),isX(M)?ret="":isX(m)?ret=`>=${M}.0.0 <${+M+1}.0.0-0`:isX(p)?ret=`>=${M}.${m}.0 <${M}.${+m+1}.0-0`:pr?(debug$1("replaceTilde pr",pr),ret=`>=${M}.${m}.${p}-${pr} <${M}.${+m+1}.0-0`):ret=`>=${M}.${m}.${p} <${M}.${+m+1}.0-0`,debug$1("tilde return",ret),ret}))},replaceCarets=(comp,options)=>comp.trim().split(/\s+/).map((comp=>replaceCaret(comp,options))).join(" "),replaceCaret=(comp,options)=>{debug$1("caret",comp,options);const r=options.loose?re$1[t$1.CARETLOOSE]:re$1[t$1.CARET],z=options.includePrerelease?"-0":"";return comp.replace(r,((_,M,m,p,pr)=>{let ret;return debug$1("caret",comp,_,M,m,p,pr),isX(M)?ret="":isX(m)?ret=`>=${M}.0.0${z} <${+M+1}.0.0-0`:isX(p)?ret="0"===M?`>=${M}.${m}.0${z} <${M}.${+m+1}.0-0`:`>=${M}.${m}.0${z} <${+M+1}.0.0-0`:pr?(debug$1("replaceCaret pr",pr),ret="0"===M?"0"===m?`>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p+1}-0`:`>=${M}.${m}.${p}-${pr} <${M}.${+m+1}.0-0`:`>=${M}.${m}.${p}-${pr} <${+M+1}.0.0-0`):(debug$1("no pr"),ret="0"===M?"0"===m?`>=${M}.${m}.${p}${z} <${M}.${m}.${+p+1}-0`:`>=${M}.${m}.${p}${z} <${M}.${+m+1}.0-0`:`>=${M}.${m}.${p} <${+M+1}.0.0-0`),debug$1("caret return",ret),ret}))},replaceXRanges=(comp,options)=>(debug$1("replaceXRanges",comp,options),comp.split(/\s+/).map((comp=>replaceXRange(comp,options))).join(" ")),replaceXRange=(comp,options)=>{comp=comp.trim();const r=options.loose?re$1[t$1.XRANGELOOSE]:re$1[t$1.XRANGE];return comp.replace(r,((ret,gtlt,M,m,p,pr)=>{debug$1("xRange",comp,ret,gtlt,M,m,p,pr);const xM=isX(M),xm=xM||isX(m),xp=xm||isX(p),anyX=xp;return "="===gtlt&&anyX&&(gtlt=""),pr=options.includePrerelease?"-0":"",xM?ret=">"===gtlt||"<"===gtlt?"<0.0.0-0":"*":gtlt&&anyX?(xm&&(m=0),p=0,">"===gtlt?(gtlt=">=",xm?(M=+M+1,m=0,p=0):(m=+m+1,p=0)):"<="===gtlt&&(gtlt="<",xm?M=+M+1:m=+m+1),"<"===gtlt&&(pr="-0"),ret=`${gtlt+M}.${m}.${p}${pr}`):xm?ret=`>=${M}.0.0${pr} <${+M+1}.0.0-0`:xp&&(ret=`>=${M}.${m}.0${pr} <${M}.${+m+1}.0-0`),debug$1("xRange return",ret),ret}))},replaceStars=(comp,options)=>(debug$1("replaceStars",comp,options),comp.trim().replace(re$1[t$1.STAR],"")),replaceGTE0=(comp,options)=>(debug$1("replaceGTE0",comp,options),comp.trim().replace(re$1[options.includePrerelease?t$1.GTE0PRE:t$1.GTE0],"")),hyphenReplace=incPr=>($0,from,fM,fm,fp,fpr,fb,to,tM,tm,tp,tpr,tb)=>`${from=isX(fM)?"":isX(fm)?`>=${fM}.0.0${incPr?"-0":""}`:isX(fp)?`>=${fM}.${fm}.0${incPr?"-0":""}`:fpr?`>=${from}`:`>=${from}${incPr?"-0":""}`} ${to=isX(tM)?"":isX(tm)?`<${+tM+1}.0.0-0`:isX(tp)?`<${tM}.${+tm+1}.0-0`:tpr?`<=${tM}.${tm}.${tp}-${tpr}`:incPr?`<${tM}.${tm}.${+tp+1}-0`:`<=${to}`}`.trim(),testSet=(set,version,options)=>{for(let i=0;i<set.length;i++)if(!set[i].test(version))return !1;if(version.prerelease.length&&!options.includePrerelease){for(let i=0;i<set.length;i++)if(debug$1(set[i].semver),set[i].semver!==Comparator$3.ANY&&set[i].semver.prerelease.length>0){const allowed=set[i].semver;if(allowed.major===version.major&&allowed.minor===version.minor&&allowed.patch===version.patch)return !0}return !1}return !0},ANY$2=Symbol("SemVer ANY");class Comparator$2{static get ANY(){return ANY$2}constructor(comp,options){if(options=parseOptions(options),comp instanceof Comparator$2){if(comp.loose===!!options.loose)return comp;comp=comp.value;}debug("comparator",comp,options),this.options=options,this.loose=!!options.loose,this.parse(comp),this.semver===ANY$2?this.value="":this.value=this.operator+this.semver.version,debug("comp",this);}parse(comp){const r=this.options.loose?re[t.COMPARATORLOOSE]:re[t.COMPARATOR],m=comp.match(r);if(!m)throw new TypeError(`Invalid comparator: ${comp}`);this.operator=void 0!==m[1]?m[1]:"","="===this.operator&&(this.operator=""),m[2]?this.semver=new SemVer$4(m[2],this.options.loose):this.semver=ANY$2;}toString(){return this.value}test(version){if(debug("Comparator.test",version,this.options.loose),this.semver===ANY$2||version===ANY$2)return !0;if("string"==typeof version)try{version=new SemVer$4(version,this.options);}catch(er){return !1}return cmp(version,this.operator,this.semver,this.options)}intersects(comp,options){if(!(comp instanceof Comparator$2))throw new TypeError("a Comparator is required");if(options&&"object"==typeof options||(options={loose:!!options,includePrerelease:!1}),""===this.operator)return ""===this.value||new Range$9(comp.value,options).test(this.value);if(""===comp.operator)return ""===comp.value||new Range$9(this.value,options).test(comp.semver);const sameDirectionIncreasing=!(">="!==this.operator&&">"!==this.operator||">="!==comp.operator&&">"!==comp.operator),sameDirectionDecreasing=!("<="!==this.operator&&"<"!==this.operator||"<="!==comp.operator&&"<"!==comp.operator),sameSemVer=this.semver.version===comp.semver.version,differentDirectionsInclusive=!(">="!==this.operator&&"<="!==this.operator||">="!==comp.operator&&"<="!==comp.operator),oppositeDirectionsLessThan=cmp(this.semver,"<",comp.semver,options)&&(">="===this.operator||">"===this.operator)&&("<="===comp.operator||"<"===comp.operator),oppositeDirectionsGreaterThan=cmp(this.semver,">",comp.semver,options)&&("<="===this.operator||"<"===this.operator)&&(">="===comp.operator||">"===comp.operator);return sameDirectionIncreasing||sameDirectionDecreasing||sameSemVer&&differentDirectionsInclusive||oppositeDirectionsLessThan||oppositeDirectionsGreaterThan}}var comparator=Comparator$2;const parseOptions=parseOptions_1,{re,t}=re$5.exports,cmp=cmp_1,debug=debug_1,SemVer$4=semver$2,Range$9=range,Range$8=range;var satisfies_1=(version,range,options)=>{try{range=new Range$8(range,options);}catch(er){return !1}return range.test(version)};const Range$7=range;var toComparators_1=(range,options)=>new Range$7(range,options).set.map((comp=>comp.map((c=>c.value)).join(" ").trim().split(" ")));const SemVer$3=semver$2,Range$6=range;var maxSatisfying_1=(versions,range,options)=>{let max=null,maxSV=null,rangeObj=null;try{rangeObj=new Range$6(range,options);}catch(er){return null}return versions.forEach((v=>{rangeObj.test(v)&&(max&&-1!==maxSV.compare(v)||(max=v,maxSV=new SemVer$3(max,options)));})),max};const SemVer$2=semver$2,Range$5=range;var minSatisfying_1=(versions,range,options)=>{let min=null,minSV=null,rangeObj=null;try{rangeObj=new Range$5(range,options);}catch(er){return null}return versions.forEach((v=>{rangeObj.test(v)&&(min&&1!==minSV.compare(v)||(min=v,minSV=new SemVer$2(min,options)));})),min};const SemVer$1=semver$2,Range$4=range,gt$1=gt_1;var minVersion_1=(range,loose)=>{range=new Range$4(range,loose);let minver=new SemVer$1("0.0.0");if(range.test(minver))return minver;if(minver=new SemVer$1("0.0.0-0"),range.test(minver))return minver;minver=null;for(let i=0;i<range.set.length;++i){const comparators=range.set[i];let setMin=null;comparators.forEach((comparator=>{const compver=new SemVer$1(comparator.semver.version);switch(comparator.operator){case">":0===compver.prerelease.length?compver.patch++:compver.prerelease.push(0),compver.raw=compver.format();case"":case">=":setMin&&!gt$1(compver,setMin)||(setMin=compver);break;case"<":case"<=":break;default:throw new Error(`Unexpected operation: ${comparator.operator}`)}})),!setMin||minver&&!gt$1(minver,setMin)||(minver=setMin);}return minver&&range.test(minver)?minver:null};const Range$3=range;var valid=(range,options)=>{try{return new Range$3(range,options).range||"*"}catch(er){return null}};const SemVer=semver$2,Comparator$1=comparator,{ANY:ANY$1}=Comparator$1,Range$2=range,satisfies$2=satisfies_1,gt=gt_1,lt=lt_1,lte=lte_1,gte=gte_1;var outside_1=(version,range,hilo,options)=>{let gtfn,ltefn,ltfn,comp,ecomp;switch(version=new SemVer(version,options),range=new Range$2(range,options),hilo){case">":gtfn=gt,ltefn=lte,ltfn=lt,comp=">",ecomp=">=";break;case"<":gtfn=lt,ltefn=gte,ltfn=gt,comp="<",ecomp="<=";break;default:throw new TypeError('Must provide a hilo val of "<" or ">"')}if(satisfies$2(version,range,options))return !1;for(let i=0;i<range.set.length;++i){const comparators=range.set[i];let high=null,low=null;if(comparators.forEach((comparator=>{comparator.semver===ANY$1&&(comparator=new Comparator$1(">=0.0.0")),high=high||comparator,low=low||comparator,gtfn(comparator.semver,high.semver,options)?high=comparator:ltfn(comparator.semver,low.semver,options)&&(low=comparator);})),high.operator===comp||high.operator===ecomp)return !1;if((!low.operator||low.operator===comp)&&ltefn(version,low.semver))return !1;if(low.operator===ecomp&&ltfn(version,low.semver))return !1}return !0};const outside$1=outside_1;var gtr_1=(version,range,options)=>outside$1(version,range,">",options);const outside=outside_1;var ltr_1=(version,range,options)=>outside(version,range,"<",options);const Range$1=range;var intersects_1=(r1,r2,options)=>(r1=new Range$1(r1,options),r2=new Range$1(r2,options),r1.intersects(r2));const satisfies$1=satisfies_1,compare$1=compare_1;const Range=range,Comparator=comparator,{ANY}=Comparator,satisfies=satisfies_1,compare=compare_1,simpleSubset=(sub,dom,options)=>{if(sub===dom)return !0;if(1===sub.length&&sub[0].semver===ANY){if(1===dom.length&&dom[0].semver===ANY)return !0;sub=options.includePrerelease?[new Comparator(">=0.0.0-0")]:[new Comparator(">=0.0.0")];}if(1===dom.length&&dom[0].semver===ANY){if(options.includePrerelease)return !0;dom=[new Comparator(">=0.0.0")];}const eqSet=new Set;let gt,lt,gtltComp,higher,lower,hasDomLT,hasDomGT;for(const c of sub)">"===c.operator||">="===c.operator?gt=higherGT(gt,c,options):"<"===c.operator||"<="===c.operator?lt=lowerLT(lt,c,options):eqSet.add(c.semver);if(eqSet.size>1)return null;if(gt&&lt){if(gtltComp=compare(gt.semver,lt.semver,options),gtltComp>0)return null;if(0===gtltComp&&(">="!==gt.operator||"<="!==lt.operator))return null}for(const eq of eqSet){if(gt&&!satisfies(eq,String(gt),options))return null;if(lt&&!satisfies(eq,String(lt),options))return null;for(const c of dom)if(!satisfies(eq,String(c),options))return !1;return !0}let needDomLTPre=!(!lt||options.includePrerelease||!lt.semver.prerelease.length)&&lt.semver,needDomGTPre=!(!gt||options.includePrerelease||!gt.semver.prerelease.length)&&gt.semver;needDomLTPre&&1===needDomLTPre.prerelease.length&&"<"===lt.operator&&0===needDomLTPre.prerelease[0]&&(needDomLTPre=!1);for(const c of dom){if(hasDomGT=hasDomGT||">"===c.operator||">="===c.operator,hasDomLT=hasDomLT||"<"===c.operator||"<="===c.operator,gt)if(needDomGTPre&&c.semver.prerelease&&c.semver.prerelease.length&&c.semver.major===needDomGTPre.major&&c.semver.minor===needDomGTPre.minor&&c.semver.patch===needDomGTPre.patch&&(needDomGTPre=!1),">"===c.operator||">="===c.operator){if(higher=higherGT(gt,c,options),higher===c&&higher!==gt)return !1}else if(">="===gt.operator&&!satisfies(gt.semver,String(c),options))return !1;if(lt)if(needDomLTPre&&c.semver.prerelease&&c.semver.prerelease.length&&c.semver.major===needDomLTPre.major&&c.semver.minor===needDomLTPre.minor&&c.semver.patch===needDomLTPre.patch&&(needDomLTPre=!1),"<"===c.operator||"<="===c.operator){if(lower=lowerLT(lt,c,options),lower===c&&lower!==lt)return !1}else if("<="===lt.operator&&!satisfies(lt.semver,String(c),options))return !1;if(!c.operator&&(lt||gt)&&0!==gtltComp)return !1}return !(gt&&hasDomLT&&!lt&&0!==gtltComp)&&(!(lt&&hasDomGT&&!gt&&0!==gtltComp)&&(!needDomGTPre&&!needDomLTPre))},higherGT=(a,b,options)=>{if(!a)return b;const comp=compare(a.semver,b.semver,options);return comp>0?a:comp<0||">"===b.operator&&">="===a.operator?b:a},lowerLT=(a,b,options)=>{if(!a)return b;const comp=compare(a.semver,b.semver,options);return comp<0?a:comp>0||"<"===b.operator&&"<="===a.operator?b:a};var subset_1=(sub,dom,options={})=>{if(sub===dom)return !0;sub=new Range(sub,options),dom=new Range(dom,options);let sawNonNull=!1;OUTER:for(const simpleSub of sub.set){for(const simpleDom of dom.set){const isSub=simpleSubset(simpleSub,simpleDom,options);if(sawNonNull=sawNonNull||null!==isSub,isSub)continue OUTER}if(sawNonNull)return !1}return !0};const internalRe=re$5.exports;var semver$1={re:internalRe.re,src:internalRe.src,tokens:internalRe.t,SEMVER_SPEC_VERSION:constants.SEMVER_SPEC_VERSION,SemVer:semver$2,compareIdentifiers:identifiers.compareIdentifiers,rcompareIdentifiers:identifiers.rcompareIdentifiers,parse:parse_1,valid:valid_1,clean:clean_1,inc:inc_1,diff:diff_1,major:major_1,minor:minor_1,patch:patch_1,prerelease:prerelease_1,compare:compare_1,rcompare:rcompare_1,compareLoose:compareLoose_1,compareBuild:compareBuild_1,sort:sort_1,rsort:rsort_1,gt:gt_1,lt:lt_1,eq:eq_1,neq:neq_1,gte:gte_1,lte:lte_1,cmp:cmp_1,coerce:coerce_1,Comparator:comparator,Range:range,satisfies:satisfies_1,toComparators:toComparators_1,maxSatisfying:maxSatisfying_1,minSatisfying:minSatisfying_1,minVersion:minVersion_1,validRange:valid,outside:outside_1,gtr:gtr_1,ltr:ltr_1,intersects:intersects_1,simplifyRange:(versions,range,options)=>{const set=[];let min=null,prev=null;const v=versions.sort(((a,b)=>compare$1(a,b,options)));for(const version of v){satisfies$1(version,range,options)?(prev=version,min||(min=version)):(prev&&set.push([min,prev]),prev=null,min=null);}min&&set.push([min,null]);const ranges=[];for(const[min,max]of set)min===max?ranges.push(min):max||min!==v[0]?max?min===v[0]?ranges.push(`<=${max}`):ranges.push(`${min} - ${max}`):ranges.push(`>=${min}`):ranges.push("*");const simplified=ranges.join(" || "),original="string"==typeof range.raw?range.raw:String(range);return simplified.length<original.length?simplified:range},subset:subset_1},dist_semver=semver$1;const isWindows="win32"===process.platform,own$1={}.hasOwnProperty,messages=new Map;let userStackTraceLimit;function createError(sym,value,def){return messages.set(sym,value),function(Base,key){return NodeError;function NodeError(...args){const limit=Error.stackTraceLimit;isErrorStackTraceLimitWritable()&&(Error.stackTraceLimit=0);const error=new Base;isErrorStackTraceLimitWritable()&&(Error.stackTraceLimit=limit);const message=function(key,args,self){const message=messages.get(key);if("function"==typeof message)return external_assert_namespaceObject(message.length<=args.length,`Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${message.length}).`),Reflect.apply(message,self,args);const expectedLength=(message.match(/%[dfijoOs]/g)||[]).length;return external_assert_namespaceObject(expectedLength===args.length,`Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`),0===args.length?message:(args.unshift(message),Reflect.apply(external_util_.format,null,args))}(key,args,error);return Object.defineProperty(error,"message",{value:message,enumerable:!1,writable:!0,configurable:!0}),Object.defineProperty(error,"toString",{value(){return `${this.name} [${key}]: ${this.message}`},enumerable:!1,writable:!0,configurable:!0}),addCodeToName(error,Base.name,key),error.code=key,error}}(def,sym)}createError("ERR_INVALID_MODULE_SPECIFIER",((request,reason,base)=>`Invalid module "${request}" ${reason}${base?` imported from ${base}`:""}`),TypeError),createError("ERR_INVALID_PACKAGE_CONFIG",((path,base,message)=>`Invalid package config ${path}${base?` while importing ${base}`:""}${message?`. ${message}`:""}`),Error),createError("ERR_INVALID_PACKAGE_TARGET",((pkgPath,key,target,isImport=!1,base)=>{const relError="string"==typeof target&&!isImport&&target.length>0&&!target.startsWith("./");return "."===key?(external_assert_namespaceObject(!1===isImport),`Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${pkgPath}package.json${base?` imported from ${base}`:""}${relError?'; targets must start with "./"':""}`):`Invalid "${isImport?"imports":"exports"}" target ${JSON.stringify(target)} defined for '${key}' in the package config ${pkgPath}package.json${base?` imported from ${base}`:""}${relError?'; targets must start with "./"':""}`}),Error),createError("ERR_MODULE_NOT_FOUND",((path,base,type="package")=>`Cannot find ${type} '${path}' imported from ${base}`),Error),createError("ERR_PACKAGE_IMPORT_NOT_DEFINED",((specifier,packagePath,base)=>`Package import specifier "${specifier}" is not defined${packagePath?` in package ${packagePath}package.json`:""} imported from ${base}`),TypeError),createError("ERR_PACKAGE_PATH_NOT_EXPORTED",((pkgPath,subpath,base)=>"."===subpath?`No "exports" main defined in ${pkgPath}package.json${base?` imported from ${base}`:""}`:`Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${base?` imported from ${base}`:""}`),Error),createError("ERR_UNSUPPORTED_DIR_IMPORT","Directory import '%s' is not supported resolving ES modules imported from %s",Error),createError("ERR_UNKNOWN_FILE_EXTENSION",'Unknown file extension "%s" for %s',TypeError),createError("ERR_INVALID_ARG_VALUE",((name,value,reason="is invalid")=>{let inspected=(0, external_util_.inspect)(value);inspected.length>128&&(inspected=`${inspected.slice(0,128)}...`);return `The ${name.includes(".")?"property":"argument"} '${name}' ${reason}. Received ${inspected}`}),TypeError),createError("ERR_UNSUPPORTED_ESM_URL_SCHEME",(url=>{let message="Only file and data URLs are supported by the default ESM loader";return isWindows&&2===url.protocol.length&&(message+=". On Windows, absolute paths must be valid file:// URLs"),message+=`. Received protocol '${url.protocol}'`,message}),Error);const addCodeToName=hideStackFrames((function(error,name,code){(error=captureLargerStackTrace(error)).name=`${name} [${code}]`,error.stack,"SystemError"===name?Object.defineProperty(error,"name",{value:name,enumerable:!1,writable:!0,configurable:!0}):delete error.name;}));function isErrorStackTraceLimitWritable(){const desc=Object.getOwnPropertyDescriptor(Error,"stackTraceLimit");return void 0===desc?Object.isExtensible(Error):own$1.call(desc,"writable")?desc.writable:void 0!==desc.set}function hideStackFrames(fn){const hidden="__node_internal_"+fn.name;return Object.defineProperty(fn,"name",{value:hidden}),fn}const captureLargerStackTrace=hideStackFrames((function(error){const stackTraceLimitIsWritable=isErrorStackTraceLimitWritable();return stackTraceLimitIsWritable&&(userStackTraceLimit=Error.stackTraceLimit,Error.stackTraceLimit=Number.POSITIVE_INFINITY),Error.captureStackTrace(error),stackTraceLimitIsWritable&&(Error.stackTraceLimit=userStackTraceLimit),error}));!function({version=process.version,experimental=!1}={}){var coreModules=["assert","buffer","child_process","cluster","console","constants","crypto","dgram","dns","domain","events","fs","http","https","module","net","os","path","punycode","querystring","readline","repl","stream","string_decoder","sys","timers","tls","tty","url","util","vm","zlib"];dist_semver.lt(version,"6.0.0")&&coreModules.push("freelist"),dist_semver.gte(version,"1.0.0")&&coreModules.push("v8"),dist_semver.gte(version,"1.1.0")&&coreModules.push("process"),dist_semver.gte(version,"8.0.0")&&coreModules.push("inspector"),dist_semver.gte(version,"8.1.0")&&coreModules.push("async_hooks"),dist_semver.gte(version,"8.4.0")&&coreModules.push("http2"),dist_semver.gte(version,"8.5.0")&&coreModules.push("perf_hooks"),dist_semver.gte(version,"10.0.0")&&coreModules.push("trace_events"),dist_semver.gte(version,"10.5.0")&&(experimental||dist_semver.gte(version,"12.0.0"))&&coreModules.push("worker_threads"),dist_semver.gte(version,"12.16.0")&&experimental&&coreModules.push("wasi");}();Object.freeze(["node","import"]);(0, external_url_namespaceObject.pathToFileURL)(process.cwd());const ESM_RE=/([\s;]|^)(import[\w,{}\s*]*from|import\s*['"*{]|export\b\s*(?:[*{]|default|type|function|const|var|let|async function)|import\.meta\b)/m;function hasESMSyntax(code){return ESM_RE.test(code)}var external_crypto_=__webpack_require__("crypto");function md5(content,len=8){return (0, external_crypto_.createHash)("md5").update(content).digest("hex").slice(0,len)}const _EnvDebug=dist(process.env.JITI_DEBUG),_EnvCache=dist(process.env.JITI_CACHE),_EnvESMReolve=dist(process.env.JITI_ESM_RESOLVE),_EnvRequireCache=dist(process.env.JITI_REQUIRE_CACHE),_EnvSourceMaps=dist(process.env.JITI_SOURCE_MAPS),jiti_isWindows="win32"===(0, external_os_namespaceObject.platform)(),defaults={debug:_EnvDebug,cache:void 0===_EnvCache||!!_EnvCache,requireCache:void 0===_EnvRequireCache||!!_EnvRequireCache,sourceMaps:void 0!==_EnvSourceMaps&&!!_EnvSourceMaps,interopDefault:!1,esmResolve:_EnvESMReolve||!1,cacheVersion:"6",legacy:(0, semver.lt)(process.version||"0.0.0","14.0.0"),extensions:[".js",".mjs",".cjs",".ts"]};function createJITI(_filename,opts={},parentModule){function debug(...args){opts.debug&&console.log("[jiti]",...args);}if((opts=Object.assign(Object.assign({},defaults),opts)).legacy&&(opts.cacheVersion+="-legacy"),opts.transformOptions&&(opts.cacheVersion+="-"+object_hash_default()(opts.transformOptions)),_filename||(_filename=process.cwd()),function(filename){try{return (0,external_fs_.lstatSync)(filename).isDirectory()}catch(e){return !1}}(_filename)&&(_filename=(0, external_path_.join)(_filename,"index.js")),!0===opts.cache&&(opts.cache=(0, external_path_.join)((0, external_os_namespaceObject.tmpdir)(),"node-jiti")),opts.cache)try{if((0,mkdirp.sync)(opts.cache),!function(filename){try{return (0,external_fs_.accessSync)(filename,external_fs_.constants.W_OK),!0}catch(e){return !1}}(opts.cache))throw new Error("directory is not writable")}catch(err){debug("Error creating cache directory at ",opts.cache,err),opts.cache=!1;}const nativeRequire=create_require_default()(jiti_isWindows?_filename.replace(/\//g,"\\"):_filename),tryResolve=(id,options)=>{try{return nativeRequire.resolve(id,options)}catch(e){}},_url=(0, external_url_namespaceObject.pathToFileURL)(_filename),_additionalExts=[...opts.extensions].filter((ext=>".js"!==ext)),_resolve=(id,options)=>{let resolved,err;if(opts.esmResolve){try{resolved=resolvePathSync$1(id,{url:_url,conditions:["node","require","import"]});}catch(_err){err=_err;}if(resolved)return resolved}if(opts.extensions.includes((0, external_path_.extname)(id)))return nativeRequire.resolve(id,options);try{return nativeRequire.resolve(id,options)}catch(_err){err=_err;}for(const ext of _additionalExts)if(resolved=tryResolve(id+ext,options)||tryResolve(id+"/index"+ext,options),resolved)return resolved;throw err};function transform(topts){let code=function(filename,source,get){if(!opts.cache||!filename)return get();const sourceHash=` /* v${opts.cacheVersion}-${md5(source,16)} */`,filebase=(0, external_path_.basename)((0, external_path_.dirname)(filename))+"-"+(0, external_path_.basename)(filename),cacheFile=(0, external_path_.join)(opts.cache,filebase+"."+md5(filename)+".js");if((0, external_fs_.existsSync)(cacheFile)){const cacheSource=(0, external_fs_.readFileSync)(cacheFile,"utf-8");if(cacheSource.endsWith(sourceHash))return debug("[cache hit]",filename,"~>",cacheFile),cacheSource}debug("[cache miss]",filename);const result=get();return result.includes("__JITI_ERROR__")||(0, external_fs_.writeFileSync)(cacheFile,result+sourceHash,"utf-8"),result}(topts.filename,topts.source,(()=>{var _a;const res=opts.transform(Object.assign(Object.assign(Object.assign({legacy:opts.legacy},opts.transformOptions),{babel:Object.assign(Object.assign({},opts.sourceMaps?{sourceFileName:topts.filename,sourceMaps:"inline"}:{}),null===(_a=opts.transformOptions)||void 0===_a?void 0:_a.babel)}),topts));return res.error&&opts.debug&&debug(res.error),res.code}));return code.startsWith("#!")&&(code="// "+code),code}function _interopDefault(mod){return opts.interopDefault?function(sourceModule){if(null===(val=sourceModule)||"object"!=typeof val||!("default"in sourceModule))return sourceModule;var val;const newModule=sourceModule.default;for(const key in sourceModule)if("default"===key)try{key in newModule||Object.defineProperty(newModule,key,{enumerable:!1,configurable:!1,get:()=>newModule});}catch(_err){}else try{key in newModule||Object.defineProperty(newModule,key,{enumerable:!0,configurable:!0,get:()=>sourceModule[key]});}catch(_err){}return newModule}(mod):mod}function jiti(id){var _a;if(id.startsWith("node:")?id=id.substr(5):id.startsWith("file:")&&(id=(0, external_url_namespaceObject.fileURLToPath)(id)),external_module_.builtinModules.includes(id)||".pnp.js"===id)return nativeRequire(id);const filename=_resolve(id),ext=(0, external_path_.extname)(filename);if(ext&&!opts.extensions.includes(ext))return debug("[unknown]",filename),nativeRequire(id);if(opts.requireCache&&nativeRequire.cache[filename])return _interopDefault(null===(_a=nativeRequire.cache[filename])||void 0===_a?void 0:_a.exports);let source=(0, external_fs_.readFileSync)(filename,"utf-8");const isTypescript=".ts"===ext;if(!(".cjs"===ext)&&(isTypescript||".mjs"===ext||hasESMSyntax(source)||opts.legacy&&source.match(/\?\.|\?\?/)||filename.includes("node_modules/config/")))debug("[transpile]",filename),source=transform({filename,source,ts:isTypescript});else try{return debug("[native]",filename),_interopDefault(nativeRequire(id))}catch(err){debug("Native require error:",err),debug("[fallback]",filename),source=transform({filename,source,ts:isTypescript});}const mod=new external_module_.Module(filename);let compiled;mod.filename=filename,parentModule&&(mod.parent=parentModule,Array.isArray(parentModule.children)&&!parentModule.children.includes(mod)&&parentModule.children.push(mod)),mod.require=createJITI(filename,opts,mod),mod.path=(0, external_path_.dirname)(filename),mod.paths=external_module_.Module._nodeModulePaths(mod.path),opts.requireCache&&(nativeRequire.cache[filename]=mod);try{compiled=external_vm_default().runInThisContext(external_module_.Module.wrap(source),{filename,lineOffset:0,displayErrors:!1});}catch(err){opts.requireCache&&delete nativeRequire.cache[filename],opts.onError(err);}try{compiled(mod.exports,mod.require,mod,mod.filename,(0,external_path_.dirname)(mod.filename));}catch(err){opts.requireCache&&delete nativeRequire.cache[filename],opts.onError(err);}if(mod.exports&&mod.exports.__JITI_ERROR__){const{filename,line,column,code,message}=mod.exports.__JITI_ERROR__,err=new Error(`${code}: ${message} \n ${`${filename}:${line}:${column}`}`);Error.captureStackTrace(err,jiti),opts.onError(err);}mod.loaded=!0;return _interopDefault(mod.exports)}return _resolve.paths=nativeRequire.resolve.paths,jiti.resolve=_resolve,jiti.cache=opts.requireCache?nativeRequire.cache:{},jiti.extensions=nativeRequire.extensions,jiti.main=nativeRequire.main,jiti.transform=transform,jiti.register=function(){return (0, lib.addHook)(((source,filename)=>jiti.transform({source,filename,ts:!!filename.match(/.ts$/)})),{exts:opts.extensions})},jiti}})(),module.exports=__webpack_exports__.default;})();
}(jiti$1));

var babel = {exports: {}};

/*! For license information please see babel.js.LICENSE.txt */

(function (module) {
(()=>{var __webpack_modules__={"./node_modules/@babel/core/lib/config/cache-contexts.js":()=>{},"./node_modules/@babel/core/lib/config/caching.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _gensync(){const data=__webpack_require__("./node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.assertSimpleType=assertSimpleType,exports.makeStrongCache=makeStrongCache,exports.makeStrongCacheSync=function(handler){return synchronize(makeStrongCache(handler))},exports.makeWeakCache=makeWeakCache,exports.makeWeakCacheSync=function(handler){return synchronize(makeWeakCache(handler))};var _async=__webpack_require__("./node_modules/@babel/core/lib/gensync-utils/async.js"),_util=__webpack_require__("./node_modules/@babel/core/lib/config/util.js");const synchronize=gen=>_gensync()(gen).sync;function*genTrue(){return !0}function makeWeakCache(handler){return makeCachedFunction(WeakMap,handler)}function makeStrongCache(handler){return makeCachedFunction(Map,handler)}function makeCachedFunction(CallCache,handler){const callCacheSync=new CallCache,callCacheAsync=new CallCache,futureCache=new CallCache;return function*(arg,data){const asyncContext=yield*(0, _async.isAsync)(),callCache=asyncContext?callCacheAsync:callCacheSync,cached=yield*function*(asyncContext,callCache,futureCache,arg,data){const cached=yield*getCachedValue(callCache,arg,data);if(cached.valid)return cached;if(asyncContext){const cached=yield*getCachedValue(futureCache,arg,data);if(cached.valid){return {valid:!0,value:yield*(0, _async.waitFor)(cached.value.promise)}}}return {valid:!1,value:null}}(asyncContext,callCache,futureCache,arg,data);if(cached.valid)return cached.value;const cache=new CacheConfigurator(data),handlerResult=handler(arg,cache);let finishLock,value;if((0, _util.isIterableIterator)(handlerResult)){const gen=handlerResult;value=yield*(0, _async.onFirstPause)(gen,(()=>{finishLock=function(config,futureCache,arg){const finishLock=new Lock;return updateFunctionCache(futureCache,config,arg,finishLock),finishLock}(cache,futureCache,arg);}));}else value=handlerResult;return updateFunctionCache(callCache,cache,arg,value),finishLock&&(futureCache.delete(arg),finishLock.release(value)),value}}function*getCachedValue(cache,arg,data){const cachedValue=cache.get(arg);if(cachedValue)for(const{value,valid}of cachedValue)if(yield*valid(data))return {valid:!0,value};return {valid:!1,value:null}}function updateFunctionCache(cache,config,arg,value){config.configured()||config.forever();let cachedValue=cache.get(arg);switch(config.deactivate(),config.mode()){case"forever":cachedValue=[{value,valid:genTrue}],cache.set(arg,cachedValue);break;case"invalidate":cachedValue=[{value,valid:config.validator()}],cache.set(arg,cachedValue);break;case"valid":cachedValue?cachedValue.push({value,valid:config.validator()}):(cachedValue=[{value,valid:config.validator()}],cache.set(arg,cachedValue));}}class CacheConfigurator{constructor(data){this._active=!0,this._never=!1,this._forever=!1,this._invalidate=!1,this._configured=!1,this._pairs=[],this._data=void 0,this._data=data;}simple(){return function(cache){function cacheFn(val){if("boolean"!=typeof val)return cache.using((()=>assertSimpleType(val())));val?cache.forever():cache.never();}return cacheFn.forever=()=>cache.forever(),cacheFn.never=()=>cache.never(),cacheFn.using=cb=>cache.using((()=>assertSimpleType(cb()))),cacheFn.invalidate=cb=>cache.invalidate((()=>assertSimpleType(cb()))),cacheFn}(this)}mode(){return this._never?"never":this._forever?"forever":this._invalidate?"invalidate":"valid"}forever(){if(!this._active)throw new Error("Cannot change caching after evaluation has completed.");if(this._never)throw new Error("Caching has already been configured with .never()");this._forever=!0,this._configured=!0;}never(){if(!this._active)throw new Error("Cannot change caching after evaluation has completed.");if(this._forever)throw new Error("Caching has already been configured with .forever()");this._never=!0,this._configured=!0;}using(handler){if(!this._active)throw new Error("Cannot change caching after evaluation has completed.");if(this._never||this._forever)throw new Error("Caching has already been configured with .never or .forever()");this._configured=!0;const key=handler(this._data),fn=(0, _async.maybeAsync)(handler,"You appear to be using an async cache handler, but Babel has been called synchronously");return (0, _async.isThenable)(key)?key.then((key=>(this._pairs.push([key,fn]),key))):(this._pairs.push([key,fn]),key)}invalidate(handler){return this._invalidate=!0,this.using(handler)}validator(){const pairs=this._pairs;return function*(data){for(const[key,fn]of pairs)if(key!==(yield*fn(data)))return !1;return !0}}deactivate(){this._active=!1;}configured(){return this._configured}}function assertSimpleType(value){if((0, _async.isThenable)(value))throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously handle your caching logic.");if(null!=value&&"string"!=typeof value&&"boolean"!=typeof value&&"number"!=typeof value)throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");return value}class Lock{constructor(){this.released=!1,this.promise=void 0,this._resolve=void 0,this.promise=new Promise((resolve=>{this._resolve=resolve;}));}release(value){this.released=!0,this._resolve(value);}}},"./node_modules/@babel/core/lib/config/config-chain.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}function _debug(){const data=__webpack_require__("./node_modules/debug/src/index.js");return _debug=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.buildPresetChain=function*(arg,context){const chain=yield*buildPresetChainWalker(arg,context);return chain?{plugins:dedupDescriptors(chain.plugins),presets:dedupDescriptors(chain.presets),options:chain.options.map((o=>normalizeOptions(o))),files:new Set}:null},exports.buildPresetChainWalker=void 0,exports.buildRootChain=function*(opts,context){let configReport,babelRcReport;const programmaticLogger=new _printer.ConfigPrinter,programmaticChain=yield*loadProgrammaticChain({options:opts,dirname:context.cwd},context,void 0,programmaticLogger);if(!programmaticChain)return null;const programmaticReport=yield*programmaticLogger.output();let configFile;"string"==typeof opts.configFile?configFile=yield*(0, _files.loadConfig)(opts.configFile,context.cwd,context.envName,context.caller):!1!==opts.configFile&&(configFile=yield*(0, _files.findRootConfig)(context.root,context.envName,context.caller));let{babelrc,babelrcRoots}=opts,babelrcRootsDirectory=context.cwd;const configFileChain=emptyChain(),configFileLogger=new _printer.ConfigPrinter;if(configFile){const validatedFile=validateConfigFile(configFile),result=yield*loadFileChain(validatedFile,context,void 0,configFileLogger);if(!result)return null;configReport=yield*configFileLogger.output(),void 0===babelrc&&(babelrc=validatedFile.options.babelrc),void 0===babelrcRoots&&(babelrcRootsDirectory=validatedFile.dirname,babelrcRoots=validatedFile.options.babelrcRoots),mergeChain(configFileChain,result);}let ignoreFile,babelrcFile,isIgnored=!1;const fileChain=emptyChain();if((!0===babelrc||void 0===babelrc)&&"string"==typeof context.filename){const pkgData=yield*(0, _files.findPackageData)(context.filename);if(pkgData&&function(context,pkgData,babelrcRoots,babelrcRootsDirectory){if("boolean"==typeof babelrcRoots)return babelrcRoots;const absoluteRoot=context.root;if(void 0===babelrcRoots)return -1!==pkgData.directories.indexOf(absoluteRoot);let babelrcPatterns=babelrcRoots;Array.isArray(babelrcPatterns)||(babelrcPatterns=[babelrcPatterns]);if(babelrcPatterns=babelrcPatterns.map((pat=>"string"==typeof pat?_path().resolve(babelrcRootsDirectory,pat):pat)),1===babelrcPatterns.length&&babelrcPatterns[0]===absoluteRoot)return -1!==pkgData.directories.indexOf(absoluteRoot);return babelrcPatterns.some((pat=>("string"==typeof pat&&(pat=(0, _patternToRegex.default)(pat,babelrcRootsDirectory)),pkgData.directories.some((directory=>matchPattern(pat,babelrcRootsDirectory,directory,context))))))}(context,pkgData,babelrcRoots,babelrcRootsDirectory)){if(({ignore:ignoreFile,config:babelrcFile}=yield*(0, _files.findRelativeConfig)(pkgData,context.envName,context.caller)),ignoreFile&&fileChain.files.add(ignoreFile.filepath),ignoreFile&&shouldIgnore(context,ignoreFile.ignore,null,ignoreFile.dirname)&&(isIgnored=!0),babelrcFile&&!isIgnored){const validatedFile=validateBabelrcFile(babelrcFile),babelrcLogger=new _printer.ConfigPrinter,result=yield*loadFileChain(validatedFile,context,void 0,babelrcLogger);result?(babelRcReport=yield*babelrcLogger.output(),mergeChain(fileChain,result)):isIgnored=!0;}babelrcFile&&isIgnored&&fileChain.files.add(babelrcFile.filepath);}}context.showConfig&&console.log(`Babel configs on "${context.filename}" (ascending priority):\n`+[configReport,babelRcReport,programmaticReport].filter((x=>!!x)).join("\n\n")+"\n-----End Babel configs-----");const chain=mergeChain(mergeChain(mergeChain(emptyChain(),configFileChain),fileChain),programmaticChain);return {plugins:isIgnored?[]:dedupDescriptors(chain.plugins),presets:isIgnored?[]:dedupDescriptors(chain.presets),options:isIgnored?[]:chain.options.map((o=>normalizeOptions(o))),fileHandling:isIgnored?"ignored":"transpile",ignore:ignoreFile||void 0,babelrc:babelrcFile||void 0,config:configFile||void 0,files:chain.files}};var _options=__webpack_require__("./node_modules/@babel/core/lib/config/validation/options.js"),_patternToRegex=__webpack_require__("./node_modules/@babel/core/lib/config/pattern-to-regex.js"),_printer=__webpack_require__("./node_modules/@babel/core/lib/config/printer.js"),_files=__webpack_require__("./node_modules/@babel/core/lib/config/files/index.js"),_caching=__webpack_require__("./node_modules/@babel/core/lib/config/caching.js"),_configDescriptors=__webpack_require__("./node_modules/@babel/core/lib/config/config-descriptors.js");const debug=_debug()("babel:config:config-chain");const buildPresetChainWalker=makeChainWalker({root:preset=>loadPresetDescriptors(preset),env:(preset,envName)=>loadPresetEnvDescriptors(preset)(envName),overrides:(preset,index)=>loadPresetOverridesDescriptors(preset)(index),overridesEnv:(preset,index,envName)=>loadPresetOverridesEnvDescriptors(preset)(index)(envName),createLogger:()=>()=>{}});exports.buildPresetChainWalker=buildPresetChainWalker;const loadPresetDescriptors=(0, _caching.makeWeakCacheSync)((preset=>buildRootDescriptors(preset,preset.alias,_configDescriptors.createUncachedDescriptors))),loadPresetEnvDescriptors=(0, _caching.makeWeakCacheSync)((preset=>(0, _caching.makeStrongCacheSync)((envName=>buildEnvDescriptors(preset,preset.alias,_configDescriptors.createUncachedDescriptors,envName))))),loadPresetOverridesDescriptors=(0, _caching.makeWeakCacheSync)((preset=>(0, _caching.makeStrongCacheSync)((index=>buildOverrideDescriptors(preset,preset.alias,_configDescriptors.createUncachedDescriptors,index))))),loadPresetOverridesEnvDescriptors=(0, _caching.makeWeakCacheSync)((preset=>(0, _caching.makeStrongCacheSync)((index=>(0, _caching.makeStrongCacheSync)((envName=>buildOverrideEnvDescriptors(preset,preset.alias,_configDescriptors.createUncachedDescriptors,index,envName)))))));const validateConfigFile=(0, _caching.makeWeakCacheSync)((file=>({filepath:file.filepath,dirname:file.dirname,options:(0, _options.validate)("configfile",file.options)}))),validateBabelrcFile=(0, _caching.makeWeakCacheSync)((file=>({filepath:file.filepath,dirname:file.dirname,options:(0, _options.validate)("babelrcfile",file.options)}))),validateExtendFile=(0, _caching.makeWeakCacheSync)((file=>({filepath:file.filepath,dirname:file.dirname,options:(0, _options.validate)("extendsfile",file.options)}))),loadProgrammaticChain=makeChainWalker({root:input=>buildRootDescriptors(input,"base",_configDescriptors.createCachedDescriptors),env:(input,envName)=>buildEnvDescriptors(input,"base",_configDescriptors.createCachedDescriptors,envName),overrides:(input,index)=>buildOverrideDescriptors(input,"base",_configDescriptors.createCachedDescriptors,index),overridesEnv:(input,index,envName)=>buildOverrideEnvDescriptors(input,"base",_configDescriptors.createCachedDescriptors,index,envName),createLogger:(input,context,baseLogger)=>function(_,context,baseLogger){var _context$caller;if(!baseLogger)return ()=>{};return baseLogger.configure(context.showConfig,_printer.ChainFormatter.Programmatic,{callerName:null==(_context$caller=context.caller)?void 0:_context$caller.name})}(0,context,baseLogger)}),loadFileChainWalker=makeChainWalker({root:file=>loadFileDescriptors(file),env:(file,envName)=>loadFileEnvDescriptors(file)(envName),overrides:(file,index)=>loadFileOverridesDescriptors(file)(index),overridesEnv:(file,index,envName)=>loadFileOverridesEnvDescriptors(file)(index)(envName),createLogger:(file,context,baseLogger)=>function(filepath,context,baseLogger){if(!baseLogger)return ()=>{};return baseLogger.configure(context.showConfig,_printer.ChainFormatter.Config,{filepath})}(file.filepath,context,baseLogger)});function*loadFileChain(input,context,files,baseLogger){const chain=yield*loadFileChainWalker(input,context,files,baseLogger);return chain&&chain.files.add(input.filepath),chain}const loadFileDescriptors=(0, _caching.makeWeakCacheSync)((file=>buildRootDescriptors(file,file.filepath,_configDescriptors.createUncachedDescriptors))),loadFileEnvDescriptors=(0, _caching.makeWeakCacheSync)((file=>(0, _caching.makeStrongCacheSync)((envName=>buildEnvDescriptors(file,file.filepath,_configDescriptors.createUncachedDescriptors,envName))))),loadFileOverridesDescriptors=(0, _caching.makeWeakCacheSync)((file=>(0, _caching.makeStrongCacheSync)((index=>buildOverrideDescriptors(file,file.filepath,_configDescriptors.createUncachedDescriptors,index))))),loadFileOverridesEnvDescriptors=(0, _caching.makeWeakCacheSync)((file=>(0, _caching.makeStrongCacheSync)((index=>(0, _caching.makeStrongCacheSync)((envName=>buildOverrideEnvDescriptors(file,file.filepath,_configDescriptors.createUncachedDescriptors,index,envName)))))));function buildRootDescriptors({dirname,options},alias,descriptors){return descriptors(dirname,options,alias)}function buildEnvDescriptors({dirname,options},alias,descriptors,envName){const opts=options.env&&options.env[envName];return opts?descriptors(dirname,opts,`${alias}.env["${envName}"]`):null}function buildOverrideDescriptors({dirname,options},alias,descriptors,index){const opts=options.overrides&&options.overrides[index];if(!opts)throw new Error("Assertion failure - missing override");return descriptors(dirname,opts,`${alias}.overrides[${index}]`)}function buildOverrideEnvDescriptors({dirname,options},alias,descriptors,index,envName){const override=options.overrides&&options.overrides[index];if(!override)throw new Error("Assertion failure - missing override");const opts=override.env&&override.env[envName];return opts?descriptors(dirname,opts,`${alias}.overrides[${index}].env["${envName}"]`):null}function makeChainWalker({root,env,overrides,overridesEnv,createLogger}){return function*(input,context,files=new Set,baseLogger){const{dirname}=input,flattenedConfigs=[],rootOpts=root(input);if(configIsApplicable(rootOpts,dirname,context)){flattenedConfigs.push({config:rootOpts,envName:void 0,index:void 0});const envOpts=env(input,context.envName);envOpts&&configIsApplicable(envOpts,dirname,context)&&flattenedConfigs.push({config:envOpts,envName:context.envName,index:void 0}),(rootOpts.options.overrides||[]).forEach(((_,index)=>{const overrideOps=overrides(input,index);if(configIsApplicable(overrideOps,dirname,context)){flattenedConfigs.push({config:overrideOps,index,envName:void 0});const overrideEnvOpts=overridesEnv(input,index,context.envName);overrideEnvOpts&&configIsApplicable(overrideEnvOpts,dirname,context)&&flattenedConfigs.push({config:overrideEnvOpts,index,envName:context.envName});}}));}if(flattenedConfigs.some((({config:{options:{ignore,only}}})=>shouldIgnore(context,ignore,only,dirname))))return null;const chain=emptyChain(),logger=createLogger(input,context,baseLogger);for(const{config,index,envName}of flattenedConfigs){if(!(yield*mergeExtendsChain(chain,config.options,dirname,context,files,baseLogger)))return null;logger(config,index,envName),yield*mergeChainOpts(chain,config);}return chain}}function*mergeExtendsChain(chain,opts,dirname,context,files,baseLogger){if(void 0===opts.extends)return !0;const file=yield*(0, _files.loadConfig)(opts.extends,dirname,context.envName,context.caller);if(files.has(file))throw new Error(`Configuration cycle detected loading ${file.filepath}.\nFile already loaded following the config chain:\n`+Array.from(files,(file=>` - ${file.filepath}`)).join("\n"));files.add(file);const fileChain=yield*loadFileChain(validateExtendFile(file),context,files,baseLogger);return files.delete(file),!!fileChain&&(mergeChain(chain,fileChain),!0)}function mergeChain(target,source){target.options.push(...source.options),target.plugins.push(...source.plugins),target.presets.push(...source.presets);for(const file of source.files)target.files.add(file);return target}function*mergeChainOpts(target,{options,plugins,presets}){return target.options.push(options),target.plugins.push(...yield*plugins()),target.presets.push(...yield*presets()),target}function emptyChain(){return {options:[],presets:[],plugins:[],files:new Set}}function normalizeOptions(opts){const options=Object.assign({},opts);return delete options.extends,delete options.env,delete options.overrides,delete options.plugins,delete options.presets,delete options.passPerPreset,delete options.ignore,delete options.only,delete options.test,delete options.include,delete options.exclude,Object.prototype.hasOwnProperty.call(options,"sourceMap")&&(options.sourceMaps=options.sourceMap,delete options.sourceMap),options}function dedupDescriptors(items){const map=new Map,descriptors=[];for(const item of items)if("function"==typeof item.value){const fnKey=item.value;let nameMap=map.get(fnKey);nameMap||(nameMap=new Map,map.set(fnKey,nameMap));let desc=nameMap.get(item.name);desc?desc.value=item:(desc={value:item},descriptors.push(desc),item.ownPass||nameMap.set(item.name,desc));}else descriptors.push({value:item});return descriptors.reduce(((acc,desc)=>(acc.push(desc.value),acc)),[])}function configIsApplicable({options},dirname,context){return (void 0===options.test||configFieldIsApplicable(context,options.test,dirname))&&(void 0===options.include||configFieldIsApplicable(context,options.include,dirname))&&(void 0===options.exclude||!configFieldIsApplicable(context,options.exclude,dirname))}function configFieldIsApplicable(context,test,dirname){return matchesPatterns(context,Array.isArray(test)?test:[test],dirname)}function ignoreListReplacer(_key,value){return value instanceof RegExp?String(value):value}function shouldIgnore(context,ignore,only,dirname){if(ignore&&matchesPatterns(context,ignore,dirname)){var _context$filename;const message=`No config is applied to "${null!=(_context$filename=context.filename)?_context$filename:"(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(ignore,ignoreListReplacer)}\` from "${dirname}"`;return debug(message),context.showConfig&&console.log(message),!0}if(only&&!matchesPatterns(context,only,dirname)){var _context$filename2;const message=`No config is applied to "${null!=(_context$filename2=context.filename)?_context$filename2:"(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(only,ignoreListReplacer)}\` from "${dirname}"`;return debug(message),context.showConfig&&console.log(message),!0}return !1}function matchesPatterns(context,patterns,dirname){return patterns.some((pattern=>matchPattern(pattern,dirname,context.filename,context)))}function matchPattern(pattern,dirname,pathToTest,context){if("function"==typeof pattern)return !!pattern(pathToTest,{dirname,envName:context.envName,caller:context.caller});if("string"!=typeof pathToTest)throw new Error("Configuration contains string/RegExp pattern, but no filename was passed to Babel");return "string"==typeof pattern&&(pattern=(0, _patternToRegex.default)(pattern,dirname)),pattern.test(pathToTest)}},"./node_modules/@babel/core/lib/config/config-descriptors.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _gensync(){const data=__webpack_require__("./node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.createCachedDescriptors=function(dirname,options,alias){const{plugins,presets,passPerPreset}=options;return {options:optionsWithResolvedBrowserslistConfigFile(options,dirname),plugins:plugins?()=>createCachedPluginDescriptors(plugins,dirname)(alias):()=>handlerOf([]),presets:presets?()=>createCachedPresetDescriptors(presets,dirname)(alias)(!!passPerPreset):()=>handlerOf([])}},exports.createDescriptor=createDescriptor,exports.createUncachedDescriptors=function(dirname,options,alias){let plugins,presets;return {options:optionsWithResolvedBrowserslistConfigFile(options,dirname),*plugins(){return plugins||(plugins=yield*createPluginDescriptors(options.plugins||[],dirname,alias)),plugins},*presets(){return presets||(presets=yield*createPresetDescriptors(options.presets||[],dirname,alias,!!options.passPerPreset)),presets}}};var _files=__webpack_require__("./node_modules/@babel/core/lib/config/files/index.js"),_item=__webpack_require__("./node_modules/@babel/core/lib/config/item.js"),_caching=__webpack_require__("./node_modules/@babel/core/lib/config/caching.js"),_resolveTargets=__webpack_require__("./node_modules/@babel/core/lib/config/resolve-targets.js");function*handlerOf(value){return value}function optionsWithResolvedBrowserslistConfigFile(options,dirname){return "string"==typeof options.browserslistConfigFile&&(options.browserslistConfigFile=(0, _resolveTargets.resolveBrowserslistConfigFile)(options.browserslistConfigFile,dirname)),options}const PRESET_DESCRIPTOR_CACHE=new WeakMap,createCachedPresetDescriptors=(0, _caching.makeWeakCacheSync)(((items,cache)=>{const dirname=cache.using((dir=>dir));return (0, _caching.makeStrongCacheSync)((alias=>(0, _caching.makeStrongCache)((function*(passPerPreset){return (yield*createPresetDescriptors(items,dirname,alias,passPerPreset)).map((desc=>loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE,desc)))}))))})),PLUGIN_DESCRIPTOR_CACHE=new WeakMap,createCachedPluginDescriptors=(0, _caching.makeWeakCacheSync)(((items,cache)=>{const dirname=cache.using((dir=>dir));return (0, _caching.makeStrongCache)((function*(alias){return (yield*createPluginDescriptors(items,dirname,alias)).map((desc=>loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE,desc)))}))})),DEFAULT_OPTIONS={};function loadCachedDescriptor(cache,desc){const{value,options=DEFAULT_OPTIONS}=desc;if(!1===options)return desc;let cacheByOptions=cache.get(value);cacheByOptions||(cacheByOptions=new WeakMap,cache.set(value,cacheByOptions));let possibilities=cacheByOptions.get(options);if(possibilities||(possibilities=[],cacheByOptions.set(options,possibilities)),-1===possibilities.indexOf(desc)){const matches=possibilities.filter((possibility=>{return b=desc,(a=possibility).name===b.name&&a.value===b.value&&a.options===b.options&&a.dirname===b.dirname&&a.alias===b.alias&&a.ownPass===b.ownPass&&(a.file&&a.file.request)===(b.file&&b.file.request)&&(a.file&&a.file.resolved)===(b.file&&b.file.resolved);var a,b;}));if(matches.length>0)return matches[0];possibilities.push(desc);}return desc}function*createPresetDescriptors(items,dirname,alias,passPerPreset){return yield*createDescriptors("preset",items,dirname,alias,passPerPreset)}function*createPluginDescriptors(items,dirname,alias){return yield*createDescriptors("plugin",items,dirname,alias)}function*createDescriptors(type,items,dirname,alias,ownPass){const descriptors=yield*_gensync().all(items.map(((item,index)=>createDescriptor(item,dirname,{type,alias:`${alias}$${index}`,ownPass:!!ownPass}))));return function(items){const map=new Map;for(const item of items){if("function"!=typeof item.value)continue;let nameMap=map.get(item.value);if(nameMap||(nameMap=new Set,map.set(item.value,nameMap)),nameMap.has(item.name)){const conflicts=items.filter((i=>i.value===item.value));throw new Error(["Duplicate plugin/preset detected.","If you'd like to use two separate instances of a plugin,","they need separate names, e.g.","","  plugins: [","    ['some-plugin', {}],","    ['some-plugin', {}, 'some unique name'],","  ]","","Duplicates detected are:",`${JSON.stringify(conflicts,null,2)}`].join("\n"))}nameMap.add(item.name);}}(descriptors),descriptors}function*createDescriptor(pair,dirname,{type,alias,ownPass}){const desc=(0, _item.getItemDescriptor)(pair);if(desc)return desc;let name,options,file,value=pair;Array.isArray(value)&&(3===value.length?[value,options,name]=value:[value,options]=value);let filepath=null;if("string"==typeof value){if("string"!=typeof type)throw new Error("To resolve a string-based item, the type of item must be given");const resolver="plugin"===type?_files.loadPlugin:_files.loadPreset,request=value;(({filepath,value}=yield*resolver(value,dirname))),file={request,resolved:filepath};}if(!value)throw new Error(`Unexpected falsy value: ${String(value)}`);if("object"==typeof value&&value.__esModule){if(!value.default)throw new Error("Must export a default export when using ES6 modules.");value=value.default;}if("object"!=typeof value&&"function"!=typeof value)throw new Error(`Unsupported format: ${typeof value}. Expected an object or a function.`);if(null!==filepath&&"object"==typeof value&&value)throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${filepath}`);return {name,alias:filepath||alias,value,options,dirname,ownPass,file}}},"./node_modules/@babel/core/lib/config/files/configuration.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _debug(){const data=__webpack_require__("./node_modules/debug/src/index.js");return _debug=function(){return data},data}function _fs(){const data=__webpack_require__("fs");return _fs=function(){return data},data}function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}function _json(){const data=__webpack_require__("./node_modules/json5/dist/index.mjs");return _json=function(){return data},data}function _gensync(){const data=__webpack_require__("./node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.ROOT_CONFIG_FILENAMES=void 0,exports.findConfigUpwards=function(rootDir){let dirname=rootDir;for(;;){for(const filename of ROOT_CONFIG_FILENAMES)if(_fs().existsSync(_path().join(dirname,filename)))return dirname;const nextDir=_path().dirname(dirname);if(dirname===nextDir)break;dirname=nextDir;}return null},exports.findRelativeConfig=function*(packageData,envName,caller){let config=null,ignore=null;const dirname=_path().dirname(packageData.filepath);for(const loc of packageData.directories){var _packageData$pkg;if(!config)config=yield*loadOneConfig(RELATIVE_CONFIG_FILENAMES,loc,envName,caller,(null==(_packageData$pkg=packageData.pkg)?void 0:_packageData$pkg.dirname)===loc?packageToBabelConfig(packageData.pkg):null);if(!ignore){const ignoreLoc=_path().join(loc,".babelignore");ignore=yield*readIgnoreConfig(ignoreLoc),ignore&&debug("Found ignore %o from %o.",ignore.filepath,dirname);}}return {config,ignore}},exports.findRootConfig=function(dirname,envName,caller){return loadOneConfig(ROOT_CONFIG_FILENAMES,dirname,envName,caller)},exports.loadConfig=function*(name,dirname,envName,caller){const filepath=(v=process.versions.node,w="8.9",v=v.split("."),w=w.split("."),+v[0]>+w[0]||v[0]==w[0]&&+v[1]>=+w[1]?__webpack_require__("./node_modules/@babel/core/lib/config/files sync recursive").resolve:(r,{paths:[b]},M=__webpack_require__("module"))=>{let f=M._findPath(r,M._nodeModulePaths(b).concat(b));if(f)return f;throw f=new Error(`Cannot resolve module '${r}'`),f.code="MODULE_NOT_FOUND",f})(name,{paths:[dirname]}),conf=yield*readConfig(filepath,envName,caller);var v,w;if(!conf)throw new Error(`Config file ${filepath} contains no configuration data`);return debug("Loaded config %o from %o.",name,dirname),conf},exports.resolveShowConfigPath=function*(dirname){const targetPath=process.env.BABEL_SHOW_CONFIG_FOR;if(null!=targetPath){const absolutePath=_path().resolve(dirname,targetPath);if(!(yield*fs.stat(absolutePath)).isFile())throw new Error(`${absolutePath}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`);return absolutePath}return null};var _caching=__webpack_require__("./node_modules/@babel/core/lib/config/caching.js"),_configApi=__webpack_require__("./node_modules/@babel/core/lib/config/helpers/config-api.js"),_utils=__webpack_require__("./node_modules/@babel/core/lib/config/files/utils.js"),_moduleTypes=__webpack_require__("./node_modules/@babel/core/lib/config/files/module-types.js"),_patternToRegex=__webpack_require__("./node_modules/@babel/core/lib/config/pattern-to-regex.js"),fs=__webpack_require__("./node_modules/@babel/core/lib/gensync-utils/fs.js");const debug=_debug()("babel:config:loading:files:configuration"),ROOT_CONFIG_FILENAMES=["babel.config.js","babel.config.cjs","babel.config.mjs","babel.config.json"];exports.ROOT_CONFIG_FILENAMES=ROOT_CONFIG_FILENAMES;const RELATIVE_CONFIG_FILENAMES=[".babelrc",".babelrc.js",".babelrc.cjs",".babelrc.mjs",".babelrc.json"];function*loadOneConfig(names,dirname,envName,caller,previousConfig=null){const config=(yield*_gensync().all(names.map((filename=>readConfig(_path().join(dirname,filename),envName,caller))))).reduce(((previousConfig,config)=>{if(config&&previousConfig)throw new Error(`Multiple configuration files found. Please remove one:\n - ${_path().basename(previousConfig.filepath)}\n - ${config.filepath}\nfrom ${dirname}`);return config||previousConfig}),previousConfig);return config&&debug("Found configuration %o from %o.",config.filepath,dirname),config}function readConfig(filepath,envName,caller){const ext=_path().extname(filepath);return ".js"===ext||".cjs"===ext||".mjs"===ext?readConfigJS(filepath,{envName,caller}):readConfigJSON5(filepath)}const LOADING_CONFIGS=new Set,readConfigJS=(0, _caching.makeStrongCache)((function*(filepath,cache){if(!_fs().existsSync(filepath))return cache.never(),null;if(LOADING_CONFIGS.has(filepath))return cache.never(),debug("Auto-ignoring usage of config %o.",filepath),{filepath,dirname:_path().dirname(filepath),options:{}};let options;try{LOADING_CONFIGS.add(filepath),options=yield*(0,_moduleTypes.default)(filepath,"You appear to be using a native ECMAScript module configuration file, which is only supported when running Babel asynchronously.");}catch(err){throw err.message=`${filepath}: Error while loading config - ${err.message}`,err}finally{LOADING_CONFIGS.delete(filepath);}let assertCache=!1;if("function"==typeof options&&(yield*[],options=options((0, _configApi.makeConfigAPI)(cache)),assertCache=!0),!options||"object"!=typeof options||Array.isArray(options))throw new Error(`${filepath}: Configuration should be an exported JavaScript object.`);if("function"==typeof options.then)throw new Error("You appear to be using an async configuration, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously return your config.");return assertCache&&!cache.configured()&&function(){throw new Error('Caching was left unconfigured. Babel\'s plugins, presets, and .babelrc.js files can be configured\nfor various types of caching, using the first param of their handler functions:\n\nmodule.exports = function(api) {\n  // The API exposes the following:\n\n  // Cache the returned value forever and don\'t call this function again.\n  api.cache(true);\n\n  // Don\'t cache at all. Not recommended because it will be very slow.\n  api.cache(false);\n\n  // Cached based on the value of some function. If this function returns a value different from\n  // a previously-encountered value, the plugins will re-evaluate.\n  var env = api.cache(() => process.env.NODE_ENV);\n\n  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for\n  // any possible NODE_ENV value that might come up during plugin execution.\n  var isProd = api.cache(() => process.env.NODE_ENV === "production");\n\n  // .cache(fn) will perform a linear search though instances to find the matching plugin based\n  // based on previous instantiated plugins. If you want to recreate the plugin and discard the\n  // previous instance whenever something changes, you may use:\n  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");\n\n  // Note, we also expose the following more-verbose versions of the above examples:\n  api.cache.forever(); // api.cache(true)\n  api.cache.never();   // api.cache(false)\n  api.cache.using(fn); // api.cache(fn)\n\n  // Return the value that will be cached.\n  return { };\n};')}(),{filepath,dirname:_path().dirname(filepath),options}})),packageToBabelConfig=(0, _caching.makeWeakCacheSync)((file=>{const babel=file.options.babel;if(void 0===babel)return null;if("object"!=typeof babel||Array.isArray(babel)||null===babel)throw new Error(`${file.filepath}: .babel property must be an object`);return {filepath:file.filepath,dirname:file.dirname,options:babel}})),readConfigJSON5=(0, _utils.makeStaticFileCache)(((filepath,content)=>{let options;try{options=_json().parse(content);}catch(err){throw err.message=`${filepath}: Error while parsing config - ${err.message}`,err}if(!options)throw new Error(`${filepath}: No config detected`);if("object"!=typeof options)throw new Error(`${filepath}: Config returned typeof ${typeof options}`);if(Array.isArray(options))throw new Error(`${filepath}: Expected config object but found array`);return delete options.$schema,{filepath,dirname:_path().dirname(filepath),options}})),readIgnoreConfig=(0, _utils.makeStaticFileCache)(((filepath,content)=>{const ignoreDir=_path().dirname(filepath),ignorePatterns=content.split("\n").map((line=>line.replace(/#(.*?)$/,"").trim())).filter((line=>!!line));for(const pattern of ignorePatterns)if("!"===pattern[0])throw new Error("Negation of file paths is not supported.");return {filepath,dirname:_path().dirname(filepath),ignore:ignorePatterns.map((pattern=>(0, _patternToRegex.default)(pattern,ignoreDir)))}}));},"./node_modules/@babel/core/lib/config/files/import-meta-resolve.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(_x,_x2){return _resolve.apply(this,arguments)};var _importMetaResolve=__webpack_require__("./node_modules/@babel/core/lib/vendor/import-meta-resolve.js");function asyncGeneratorStep(gen,resolve,reject,_next,_throw,key,arg){try{var info=gen[key](arg),value=info.value;}catch(error){return void reject(error)}info.done?resolve(value):Promise.resolve(value).then(_next,_throw);}function _asyncToGenerator(fn){return function(){var self=this,args=arguments;return new Promise((function(resolve,reject){var gen=fn.apply(self,args);function _next(value){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"next",value);}function _throw(err){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"throw",err);}_next(void 0);}))}}let import_;try{import_=__webpack_require__("./node_modules/@babel/core/lib/config/files/import.js").Z;}catch(_unused){}const importMetaResolveP=import_&&process.execArgv.includes("--experimental-import-meta-resolve")?import_("data:text/javascript,export default import.meta.resolve").then((m=>m.default||_importMetaResolve.resolve),(()=>_importMetaResolve.resolve)):Promise.resolve(_importMetaResolve.resolve);function _resolve(){return (_resolve=_asyncToGenerator((function*(specifier,parent){return (yield importMetaResolveP)(specifier,parent)}))).apply(this,arguments)}},"./node_modules/@babel/core/lib/config/files/import.js":(__unused_webpack_module,exports,__webpack_require__)=>{exports.Z=function(filepath){return __webpack_require__("./node_modules/@babel/core/lib/config/files lazy recursive")(filepath)};},"./node_modules/@babel/core/lib/config/files/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"ROOT_CONFIG_FILENAMES",{enumerable:!0,get:function(){return _configuration.ROOT_CONFIG_FILENAMES}}),Object.defineProperty(exports,"findConfigUpwards",{enumerable:!0,get:function(){return _configuration.findConfigUpwards}}),Object.defineProperty(exports,"findPackageData",{enumerable:!0,get:function(){return _package.findPackageData}}),Object.defineProperty(exports,"findRelativeConfig",{enumerable:!0,get:function(){return _configuration.findRelativeConfig}}),Object.defineProperty(exports,"findRootConfig",{enumerable:!0,get:function(){return _configuration.findRootConfig}}),Object.defineProperty(exports,"loadConfig",{enumerable:!0,get:function(){return _configuration.loadConfig}}),Object.defineProperty(exports,"loadPlugin",{enumerable:!0,get:function(){return plugins.loadPlugin}}),Object.defineProperty(exports,"loadPreset",{enumerable:!0,get:function(){return plugins.loadPreset}}),exports.resolvePreset=exports.resolvePlugin=void 0,Object.defineProperty(exports,"resolveShowConfigPath",{enumerable:!0,get:function(){return _configuration.resolveShowConfigPath}});var _package=__webpack_require__("./node_modules/@babel/core/lib/config/files/package.js"),_configuration=__webpack_require__("./node_modules/@babel/core/lib/config/files/configuration.js"),plugins=__webpack_require__("./node_modules/@babel/core/lib/config/files/plugins.js");function _gensync(){const data=__webpack_require__("./node_modules/gensync/index.js");return _gensync=function(){return data},data}const resolvePlugin=_gensync()(plugins.resolvePlugin).sync;exports.resolvePlugin=resolvePlugin;const resolvePreset=_gensync()(plugins.resolvePreset).sync;exports.resolvePreset=resolvePreset;},"./node_modules/@babel/core/lib/config/files/module-types.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function*(filepath,asyncError,fallbackToTranspiledModule=!1){switch(function(filename){switch(_path().extname(filename)){case".cjs":return "cjs";case".mjs":return "mjs";default:return "unknown"}}(filepath)){case"cjs":return loadCjsDefault(filepath,fallbackToTranspiledModule);case"unknown":try{return loadCjsDefault(filepath,fallbackToTranspiledModule)}catch(e){if("ERR_REQUIRE_ESM"!==e.code)throw e}case"mjs":if(yield*(0, _async.isAsync)())return yield*(0, _async.waitFor)(function(_x){return _loadMjsDefault.apply(this,arguments)}(filepath));throw new Error(asyncError)}},exports.supportsESM=void 0;var _async=__webpack_require__("./node_modules/@babel/core/lib/gensync-utils/async.js");function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}function _url(){const data=__webpack_require__("url");return _url=function(){return data},data}function asyncGeneratorStep(gen,resolve,reject,_next,_throw,key,arg){try{var info=gen[key](arg),value=info.value;}catch(error){return void reject(error)}info.done?resolve(value):Promise.resolve(value).then(_next,_throw);}function _asyncToGenerator(fn){return function(){var self=this,args=arguments;return new Promise((function(resolve,reject){var gen=fn.apply(self,args);function _next(value){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"next",value);}function _throw(err){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"throw",err);}_next(void 0);}))}}let import_;try{import_=__webpack_require__("./node_modules/@babel/core/lib/config/files/import.js").Z;}catch(_unused){}const supportsESM=!!import_;function loadCjsDefault(filepath,fallbackToTranspiledModule){const module=__webpack_require__("./node_modules/@babel/core/lib/config/files sync recursive")(filepath);return null!=module&&module.__esModule?module.default||(fallbackToTranspiledModule?module:void 0):module}function _loadMjsDefault(){return (_loadMjsDefault=_asyncToGenerator((function*(filepath){if(!import_)throw new Error("Internal error: Native ECMAScript modules aren't supported by this platform.\n");return (yield import_((0, _url().pathToFileURL)(filepath))).default}))).apply(this,arguments)}exports.supportsESM=supportsESM;},"./node_modules/@babel/core/lib/config/files/package.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.findPackageData=function*(filepath){let pkg=null;const directories=[];let isPackage=!0,dirname=_path().dirname(filepath);for(;!pkg&&"node_modules"!==_path().basename(dirname);){directories.push(dirname),pkg=yield*readConfigPackage(_path().join(dirname,"package.json"));const nextLoc=_path().dirname(dirname);if(dirname===nextLoc){isPackage=!1;break}dirname=nextLoc;}return {filepath,directories,pkg,isPackage}};var _utils=__webpack_require__("./node_modules/@babel/core/lib/config/files/utils.js");const readConfigPackage=(0, _utils.makeStaticFileCache)(((filepath,content)=>{let options;try{options=JSON.parse(content);}catch(err){throw err.message=`${filepath}: Error while parsing JSON - ${err.message}`,err}if(!options)throw new Error(`${filepath}: No config detected`);if("object"!=typeof options)throw new Error(`${filepath}: Config returned typeof ${typeof options}`);if(Array.isArray(options))throw new Error(`${filepath}: Expected config object but found array`);return {filepath,dirname:_path().dirname(filepath),options}}));},"./node_modules/@babel/core/lib/config/files/plugins.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _debug(){const data=__webpack_require__("./node_modules/debug/src/index.js");return _debug=function(){return data},data}function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}function _gensync(){const data=__webpack_require__("./node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.loadPlugin=function*(name,dirname){const filepath=yield*resolvePlugin(name,dirname),value=yield*requireModule("plugin",filepath);return debug("Loaded plugin %o from %o.",name,dirname),{filepath,value}},exports.loadPreset=function*(name,dirname){const filepath=yield*resolvePreset(name,dirname),value=yield*requireModule("preset",filepath);return debug("Loaded preset %o from %o.",name,dirname),{filepath,value}},exports.resolvePlugin=resolvePlugin,exports.resolvePreset=resolvePreset;var _async=__webpack_require__("./node_modules/@babel/core/lib/gensync-utils/async.js"),_moduleTypes=__webpack_require__("./node_modules/@babel/core/lib/config/files/module-types.js");function _url(){const data=__webpack_require__("url");return _url=function(){return data},data}var _importMetaResolve=__webpack_require__("./node_modules/@babel/core/lib/config/files/import-meta-resolve.js");function asyncGeneratorStep(gen,resolve,reject,_next,_throw,key,arg){try{var info=gen[key](arg),value=info.value;}catch(error){return void reject(error)}info.done?resolve(value):Promise.resolve(value).then(_next,_throw);}function _asyncToGenerator(fn){return function(){var self=this,args=arguments;return new Promise((function(resolve,reject){var gen=fn.apply(self,args);function _next(value){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"next",value);}function _throw(err){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"throw",err);}_next(void 0);}))}}const debug=_debug()("babel:config:loading:files:plugins"),EXACT_RE=/^module:/,BABEL_PLUGIN_PREFIX_RE=/^(?!@|module:|[^/]+\/|babel-plugin-)/,BABEL_PRESET_PREFIX_RE=/^(?!@|module:|[^/]+\/|babel-preset-)/,BABEL_PLUGIN_ORG_RE=/^(@babel\/)(?!plugin-|[^/]+\/)/,BABEL_PRESET_ORG_RE=/^(@babel\/)(?!preset-|[^/]+\/)/,OTHER_PLUGIN_ORG_RE=/^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/,OTHER_PRESET_ORG_RE=/^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/,OTHER_ORG_DEFAULT_RE=/^(@(?!babel$)[^/]+)$/;function*resolvePlugin(name,dirname){return yield*resolveStandardizedName("plugin",name,dirname)}function*resolvePreset(name,dirname){return yield*resolveStandardizedName("preset",name,dirname)}function standardizeName(type,name){if(_path().isAbsolute(name))return name;const isPreset="preset"===type;return name.replace(isPreset?BABEL_PRESET_PREFIX_RE:BABEL_PLUGIN_PREFIX_RE,`babel-${type}-`).replace(isPreset?BABEL_PRESET_ORG_RE:BABEL_PLUGIN_ORG_RE,`$1${type}-`).replace(isPreset?OTHER_PRESET_ORG_RE:OTHER_PLUGIN_ORG_RE,`$1babel-${type}-`).replace(OTHER_ORG_DEFAULT_RE,`$1/babel-${type}`).replace(EXACT_RE,"")}function*resolveAlternativesHelper(type,name){const standardizedName=standardizeName(type,name),{error,value}=yield standardizedName;if(!error)return value;if("MODULE_NOT_FOUND"!==error.code)throw error;standardizedName===name||(yield name).error||(error.message+=`\n- If you want to resolve "${name}", use "module:${name}"`),(yield standardizeName(type,"@babel/"+name)).error||(error.message+=`\n- Did you mean "@babel/${name}"?`);const oppositeType="preset"===type?"plugin":"preset";throw (yield standardizeName(oppositeType,name)).error||(error.message+=`\n- Did you accidentally pass a ${oppositeType} as a ${type}?`),error}function tryRequireResolve(id,{paths:[dirname]}){try{return {error:null,value:(v=process.versions.node,w="8.9",v=v.split("."),w=w.split("."),+v[0]>+w[0]||v[0]==w[0]&&+v[1]>=+w[1]?__webpack_require__("./node_modules/@babel/core/lib/config/files sync recursive").resolve:(r,{paths:[b]},M=__webpack_require__("module"))=>{let f=M._findPath(r,M._nodeModulePaths(b).concat(b));if(f)return f;throw f=new Error(`Cannot resolve module '${r}'`),f.code="MODULE_NOT_FOUND",f})(id,{paths:[dirname]})}}catch(error){return {error,value:null}}var v,w;}function tryImportMetaResolve(_x,_x2){return _tryImportMetaResolve.apply(this,arguments)}function _tryImportMetaResolve(){return (_tryImportMetaResolve=_asyncToGenerator((function*(id,options){try{return {error:null,value:yield (0,_importMetaResolve.default)(id,options)}}catch(error){return {error,value:null}}}))).apply(this,arguments)}function resolveStandardizedNameForRequrie(type,name,dirname){const it=resolveAlternativesHelper(type,name);let res=it.next();for(;!res.done;)res=it.next(tryRequireResolve(res.value,{paths:[dirname]}));return res.value}function _resolveStandardizedNameForImport(){return (_resolveStandardizedNameForImport=_asyncToGenerator((function*(type,name,dirname){const parentUrl=(0, _url().pathToFileURL)(_path().join(dirname,"./babel-virtual-resolve-base.js")).href,it=resolveAlternativesHelper(type,name);let res=it.next();for(;!res.done;)res=it.next(yield tryImportMetaResolve(res.value,parentUrl));return (0, _url().fileURLToPath)(res.value)}))).apply(this,arguments)}const resolveStandardizedName=_gensync()({sync:(type,name,dirname=process.cwd())=>resolveStandardizedNameForRequrie(type,name,dirname),async:(type,name,dirname=process.cwd())=>_asyncToGenerator((function*(){if(!_moduleTypes.supportsESM)return resolveStandardizedNameForRequrie(type,name,dirname);try{return yield function(_x3,_x4,_x5){return _resolveStandardizedNameForImport.apply(this,arguments)}(type,name,dirname)}catch(e){try{return resolveStandardizedNameForRequrie(type,name,dirname)}catch(e2){if("MODULE_NOT_FOUND"===e.type)throw e;if("MODULE_NOT_FOUND"===e2.type)throw e2;throw e}}}))()});var LOADING_MODULES=new Set;function*requireModule(type,name){if(!(yield*(0, _async.isAsync)())&&LOADING_MODULES.has(name))throw new Error(`Reentrant ${type} detected trying to load "${name}". This module is not ignored and is trying to load itself while compiling itself, leading to a dependency cycle. We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.`);try{return LOADING_MODULES.add(name),yield*(0,_moduleTypes.default)(name,`You appear to be using a native ECMAScript module ${type}, which is only supported when running Babel asynchronously.`,!0)}catch(err){throw err.message=`[BABEL]: ${err.message} (While processing: ${name})`,err}finally{LOADING_MODULES.delete(name);}}},"./node_modules/@babel/core/lib/config/files/utils.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.makeStaticFileCache=function(fn){return (0, _caching.makeStrongCache)((function*(filepath,cache){const cached=cache.invalidate((()=>function(filepath){if(!_fs2().existsSync(filepath))return null;try{return +_fs2().statSync(filepath).mtime}catch(e){if("ENOENT"!==e.code&&"ENOTDIR"!==e.code)throw e}return null}(filepath)));return null===cached?null:fn(filepath,yield*fs.readFile(filepath,"utf8"))}))};var _caching=__webpack_require__("./node_modules/@babel/core/lib/config/caching.js"),fs=__webpack_require__("./node_modules/@babel/core/lib/gensync-utils/fs.js");function _fs2(){const data=__webpack_require__("fs");return _fs2=function(){return data},data}},"./node_modules/@babel/core/lib/config/files lazy recursive":module=>{function webpackEmptyAsyncContext(req){return Promise.resolve().then((()=>{var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}))}webpackEmptyAsyncContext.keys=()=>[],webpackEmptyAsyncContext.resolve=webpackEmptyAsyncContext,webpackEmptyAsyncContext.id="./node_modules/@babel/core/lib/config/files lazy recursive",module.exports=webpackEmptyAsyncContext;},"./node_modules/@babel/core/lib/config/files sync recursive":module=>{function webpackEmptyContext(req){var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}webpackEmptyContext.keys=()=>[],webpackEmptyContext.resolve=webpackEmptyContext,webpackEmptyContext.id="./node_modules/@babel/core/lib/config/files sync recursive",module.exports=webpackEmptyContext;},"./node_modules/@babel/core/lib/config/full.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _gensync(){const data=__webpack_require__("./node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _async=__webpack_require__("./node_modules/@babel/core/lib/gensync-utils/async.js"),_util=__webpack_require__("./node_modules/@babel/core/lib/config/util.js"),context=__webpack_require__("./node_modules/@babel/core/lib/index.js"),_plugin=__webpack_require__("./node_modules/@babel/core/lib/config/plugin.js"),_item=__webpack_require__("./node_modules/@babel/core/lib/config/item.js"),_configChain=__webpack_require__("./node_modules/@babel/core/lib/config/config-chain.js");function _traverse(){const data=__webpack_require__("./node_modules/@babel/traverse/lib/index.js");return _traverse=function(){return data},data}var _caching=__webpack_require__("./node_modules/@babel/core/lib/config/caching.js"),_options=__webpack_require__("./node_modules/@babel/core/lib/config/validation/options.js"),_plugins=__webpack_require__("./node_modules/@babel/core/lib/config/validation/plugins.js"),_configApi=__webpack_require__("./node_modules/@babel/core/lib/config/helpers/config-api.js"),_partial=__webpack_require__("./node_modules/@babel/core/lib/config/partial.js"),_default=(__webpack_require__("./node_modules/@babel/core/lib/config/cache-contexts.js"),_gensync()((function*(inputOpts){var _opts$assumptions;const result=yield*(0, _partial.default)(inputOpts);if(!result)return null;const{options,context,fileHandling}=result;if("ignored"===fileHandling)return null;const optionDefaults={},{plugins,presets}=options;if(!plugins||!presets)throw new Error("Assertion failure - plugins and presets exist");const presetContext=Object.assign({},context,{targets:options.targets}),toDescriptor=item=>{const desc=(0, _item.getItemDescriptor)(item);if(!desc)throw new Error("Assertion failure - must be config item");return desc},presetsDescriptors=presets.map(toDescriptor),initialPluginsDescriptors=plugins.map(toDescriptor),pluginDescriptorsByPass=[[]],passes=[],ignored=yield*enhanceError(context,(function*recursePresetDescriptors(rawPresets,pluginDescriptorsPass){const presets=[];for(let i=0;i<rawPresets.length;i++){const descriptor=rawPresets[i];if(!1!==descriptor.options)try{descriptor.ownPass?presets.push({preset:yield*loadPresetDescriptor(descriptor,presetContext),pass:[]}):presets.unshift({preset:yield*loadPresetDescriptor(descriptor,presetContext),pass:pluginDescriptorsPass});}catch(e){throw "BABEL_UNKNOWN_OPTION"===e.code&&(0,_options.checkNoUnwrappedItemOptionPairs)(rawPresets,i,"preset",e),e}}if(presets.length>0){pluginDescriptorsByPass.splice(1,0,...presets.map((o=>o.pass)).filter((p=>p!==pluginDescriptorsPass)));for(const{preset,pass}of presets){if(!preset)return !0;pass.push(...preset.plugins);if(yield*recursePresetDescriptors(preset.presets,pass))return !0;preset.options.forEach((opts=>{(0,_util.mergeOptions)(optionDefaults,opts);}));}}}))(presetsDescriptors,pluginDescriptorsByPass[0]);if(ignored)return null;const opts=optionDefaults;(0, _util.mergeOptions)(opts,options);const pluginContext=Object.assign({},presetContext,{assumptions:null!=(_opts$assumptions=opts.assumptions)?_opts$assumptions:{}});return yield*enhanceError(context,(function*(){pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors);for(const descs of pluginDescriptorsByPass){const pass=[];passes.push(pass);for(let i=0;i<descs.length;i++){const descriptor=descs[i];if(!1!==descriptor.options)try{pass.push(yield*loadPluginDescriptor(descriptor,pluginContext));}catch(e){throw "BABEL_UNKNOWN_PLUGIN_PROPERTY"===e.code&&(0,_options.checkNoUnwrappedItemOptionPairs)(descs,i,"plugin",e),e}}}}))(),opts.plugins=passes[0],opts.presets=passes.slice(1).filter((plugins=>plugins.length>0)).map((plugins=>({plugins}))),opts.passPerPreset=opts.presets.length>0,{options:opts,passes}})));function enhanceError(context,fn){return function*(arg1,arg2){try{return yield*fn(arg1,arg2)}catch(e){throw /^\[BABEL\]/.test(e.message)||(e.message=`[BABEL] ${context.filename||"unknown"}: ${e.message}`),e}}}exports.default=_default;const makeDescriptorLoader=apiFactory=>(0, _caching.makeWeakCache)((function*({value,options,dirname,alias},cache){if(!1===options)throw new Error("Assertion failure");options=options||{};let item=value;if("function"==typeof value){const factory=(0, _async.maybeAsync)(value,"You appear to be using an async plugin/preset, but Babel has been called synchronously"),api=Object.assign({},context,apiFactory(cache));try{item=yield*factory(api,options,dirname);}catch(e){throw alias&&(e.message+=` (While processing: ${JSON.stringify(alias)})`),e}}if(!item||"object"!=typeof item)throw new Error("Plugin/Preset did not return an object.");if((0, _async.isThenable)(item))throw yield*[],new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". (While processing: ${JSON.stringify(alias)})`);return {value:item,options,dirname,alias}})),pluginDescriptorLoader=makeDescriptorLoader(_configApi.makePluginAPI),presetDescriptorLoader=makeDescriptorLoader(_configApi.makePresetAPI);function*loadPluginDescriptor(descriptor,context){if(descriptor.value instanceof _plugin.default){if(descriptor.options)throw new Error("Passed options to an existing Plugin instance will not work.");return descriptor.value}return yield*instantiatePlugin(yield*pluginDescriptorLoader(descriptor,context),context)}const instantiatePlugin=(0, _caching.makeWeakCache)((function*({value,options,dirname,alias},cache){const pluginObj=(0, _plugins.validatePluginObject)(value),plugin=Object.assign({},pluginObj);if(plugin.visitor&&(plugin.visitor=_traverse().default.explode(Object.assign({},plugin.visitor))),plugin.inherits){const inheritsDescriptor={name:void 0,alias:`${alias}$inherits`,value:plugin.inherits,options,dirname},inherits=yield*(0, _async.forwardAsync)(loadPluginDescriptor,(run=>cache.invalidate((data=>run(inheritsDescriptor,data)))));plugin.pre=chain(inherits.pre,plugin.pre),plugin.post=chain(inherits.post,plugin.post),plugin.manipulateOptions=chain(inherits.manipulateOptions,plugin.manipulateOptions),plugin.visitor=_traverse().default.visitors.merge([inherits.visitor||{},plugin.visitor||{}]);}return new _plugin.default(plugin,options,alias)})),validateIfOptionNeedsFilename=(options,descriptor)=>{if(options.test||options.include||options.exclude){const formattedPresetName=descriptor.name?`"${descriptor.name}"`:"/* your preset */";throw new Error([`Preset ${formattedPresetName} requires a filename to be set when babel is called directly,`,"```",`babel.transform(code, { filename: 'file.ts', presets: [${formattedPresetName}] });`,"```","See https://babeljs.io/docs/en/options#filename for more information."].join("\n"))}};function*loadPresetDescriptor(descriptor,context){const preset=instantiatePreset(yield*presetDescriptorLoader(descriptor,context));return ((preset,context,descriptor)=>{if(!context.filename){const{options}=preset;validateIfOptionNeedsFilename(options,descriptor),options.overrides&&options.overrides.forEach((overrideOptions=>validateIfOptionNeedsFilename(overrideOptions,descriptor)));}})(preset,context,descriptor),yield*(0, _configChain.buildPresetChain)(preset,context)}const instantiatePreset=(0, _caching.makeWeakCacheSync)((({value,dirname,alias})=>({options:(0, _options.validate)("preset",value),alias,dirname})));function chain(a,b){const fns=[a,b].filter(Boolean);return fns.length<=1?fns[0]:function(...args){for(const fn of fns)fn.apply(this,args);}}},"./node_modules/@babel/core/lib/config/helpers/config-api.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _semver(){const data=__webpack_require__("./node_modules/@babel/core/node_modules/semver/semver.js");return _semver=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.makeConfigAPI=makeConfigAPI,exports.makePluginAPI=function(cache){return Object.assign({},makePresetAPI(cache),{assumption:name=>cache.using((data=>data.assumptions[name]))})},exports.makePresetAPI=makePresetAPI;var _=__webpack_require__("./node_modules/@babel/core/lib/index.js"),_caching=__webpack_require__("./node_modules/@babel/core/lib/config/caching.js");__webpack_require__("./node_modules/@babel/core/lib/config/cache-contexts.js");function makeConfigAPI(cache){return {version:_.version,cache:cache.simple(),env:value=>cache.using((data=>void 0===value?data.envName:"function"==typeof value?(0, _caching.assertSimpleType)(value(data.envName)):(Array.isArray(value)||(value=[value]),value.some((entry=>{if("string"!=typeof entry)throw new Error("Unexpected non-string value");return entry===data.envName}))))),async:()=>!1,caller:cb=>cache.using((data=>(0, _caching.assertSimpleType)(cb(data.caller)))),assertVersion}}function makePresetAPI(cache){return Object.assign({},makeConfigAPI(cache),{targets:()=>JSON.parse(cache.using((data=>JSON.stringify(data.targets))))})}function assertVersion(range){if("number"==typeof range){if(!Number.isInteger(range))throw new Error("Expected string or integer value.");range=`^${range}.0.0-0`;}if("string"!=typeof range)throw new Error("Expected string or integer value.");if(_semver().satisfies(_.version,range))return;const limit=Error.stackTraceLimit;"number"==typeof limit&&limit<25&&(Error.stackTraceLimit=25);const err=new Error(`Requires Babel "${range}", but was loaded with "${_.version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);throw "number"==typeof limit&&(Error.stackTraceLimit=limit),Object.assign(err,{code:"BABEL_VERSION_UNSUPPORTED",version:_.version,range})}},"./node_modules/@babel/core/lib/config/helpers/environment.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.getEnv=function(defaultValue="development"){return process.env.BABEL_ENV||process.env.NODE_ENV||defaultValue};},"./node_modules/@babel/core/lib/config/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _gensync(){const data=__webpack_require__("./node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.createConfigItem=function(target,options,callback){return void 0!==callback?createConfigItemRunner.errback(target,options,callback):"function"==typeof options?createConfigItemRunner.errback(target,void 0,callback):createConfigItemRunner.sync(target,options)},exports.createConfigItemSync=exports.createConfigItemAsync=void 0,Object.defineProperty(exports,"default",{enumerable:!0,get:function(){return _full.default}}),exports.loadPartialConfigSync=exports.loadPartialConfigAsync=exports.loadPartialConfig=exports.loadOptionsSync=exports.loadOptionsAsync=exports.loadOptions=void 0;var _full=__webpack_require__("./node_modules/@babel/core/lib/config/full.js"),_partial=__webpack_require__("./node_modules/@babel/core/lib/config/partial.js"),_item=__webpack_require__("./node_modules/@babel/core/lib/config/item.js");const loadOptionsRunner=_gensync()((function*(opts){var _config$options;const config=yield*(0, _full.default)(opts);return null!=(_config$options=null==config?void 0:config.options)?_config$options:null})),createConfigItemRunner=_gensync()(_item.createConfigItem),maybeErrback=runner=>(opts,callback)=>(void 0===callback&&"function"==typeof opts&&(callback=opts,opts=void 0),callback?runner.errback(opts,callback):runner.sync(opts)),loadPartialConfig=maybeErrback(_partial.loadPartialConfig);exports.loadPartialConfig=loadPartialConfig;const loadPartialConfigSync=_partial.loadPartialConfig.sync;exports.loadPartialConfigSync=loadPartialConfigSync;const loadPartialConfigAsync=_partial.loadPartialConfig.async;exports.loadPartialConfigAsync=loadPartialConfigAsync;const loadOptions=maybeErrback(loadOptionsRunner);exports.loadOptions=loadOptions;const loadOptionsSync=loadOptionsRunner.sync;exports.loadOptionsSync=loadOptionsSync;const loadOptionsAsync=loadOptionsRunner.async;exports.loadOptionsAsync=loadOptionsAsync;const createConfigItemSync=createConfigItemRunner.sync;exports.createConfigItemSync=createConfigItemSync;const createConfigItemAsync=createConfigItemRunner.async;exports.createConfigItemAsync=createConfigItemAsync;},"./node_modules/@babel/core/lib/config/item.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.createConfigItem=function*(value,{dirname=".",type}={}){return createItemFromDescriptor(yield*(0, _configDescriptors.createDescriptor)(value,_path().resolve(dirname),{type,alias:"programmatic item"}))},exports.createItemFromDescriptor=createItemFromDescriptor,exports.getItemDescriptor=function(item){if(null!=item&&item[CONFIG_ITEM_BRAND])return item._descriptor;return};var _configDescriptors=__webpack_require__("./node_modules/@babel/core/lib/config/config-descriptors.js");function createItemFromDescriptor(desc){return new ConfigItem(desc)}const CONFIG_ITEM_BRAND=Symbol.for("@babel/core@7 - ConfigItem");class ConfigItem{constructor(descriptor){this._descriptor=void 0,this[CONFIG_ITEM_BRAND]=!0,this.value=void 0,this.options=void 0,this.dirname=void 0,this.name=void 0,this.file=void 0,this._descriptor=descriptor,Object.defineProperty(this,"_descriptor",{enumerable:!1}),Object.defineProperty(this,CONFIG_ITEM_BRAND,{enumerable:!1}),this.value=this._descriptor.value,this.options=this._descriptor.options,this.dirname=this._descriptor.dirname,this.name=this._descriptor.name,this.file=this._descriptor.file?{request:this._descriptor.file.request,resolved:this._descriptor.file.resolved}:void 0,Object.freeze(this);}}Object.freeze(ConfigItem.prototype);},"./node_modules/@babel/core/lib/config/partial.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}function _gensync(){const data=__webpack_require__("./node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=loadPrivatePartialConfig,exports.loadPartialConfig=void 0;var _plugin=__webpack_require__("./node_modules/@babel/core/lib/config/plugin.js"),_util=__webpack_require__("./node_modules/@babel/core/lib/config/util.js"),_item=__webpack_require__("./node_modules/@babel/core/lib/config/item.js"),_configChain=__webpack_require__("./node_modules/@babel/core/lib/config/config-chain.js"),_environment=__webpack_require__("./node_modules/@babel/core/lib/config/helpers/environment.js"),_options=__webpack_require__("./node_modules/@babel/core/lib/config/validation/options.js"),_files=__webpack_require__("./node_modules/@babel/core/lib/config/files/index.js"),_resolveTargets=__webpack_require__("./node_modules/@babel/core/lib/config/resolve-targets.js");const _excluded=["showIgnoredFiles"];function*loadPrivatePartialConfig(inputOpts){if(null!=inputOpts&&("object"!=typeof inputOpts||Array.isArray(inputOpts)))throw new Error("Babel options must be an object, null, or undefined");const args=inputOpts?(0, _options.validate)("arguments",inputOpts):{},{envName=(0, _environment.getEnv)(),cwd=".",root:rootDir=".",rootMode="root",caller,cloneInputAst=!0}=args,absoluteCwd=_path().resolve(cwd),absoluteRootDir=function(rootDir,rootMode){switch(rootMode){case"root":return rootDir;case"upward-optional":{const upwardRootDir=(0, _files.findConfigUpwards)(rootDir);return null===upwardRootDir?rootDir:upwardRootDir}case"upward":{const upwardRootDir=(0, _files.findConfigUpwards)(rootDir);if(null!==upwardRootDir)return upwardRootDir;throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${rootDir}".\nOne of the following config files must be in the directory tree: "${_files.ROOT_CONFIG_FILENAMES.join(", ")}".`),{code:"BABEL_ROOT_NOT_FOUND",dirname:rootDir})}default:throw new Error("Assertion failure - unknown rootMode value.")}}(_path().resolve(absoluteCwd,rootDir),rootMode),filename="string"==typeof args.filename?_path().resolve(cwd,args.filename):void 0,context={filename,cwd:absoluteCwd,root:absoluteRootDir,envName,caller,showConfig:(yield*(0, _files.resolveShowConfigPath)(absoluteCwd))===filename},configChain=yield*(0, _configChain.buildRootChain)(args,context);if(!configChain)return null;const merged={assumptions:{}};configChain.options.forEach((opts=>{(0, _util.mergeOptions)(merged,opts);}));return {options:Object.assign({},merged,{targets:(0, _resolveTargets.resolveTargets)(merged,absoluteRootDir),cloneInputAst,babelrc:!1,configFile:!1,browserslistConfigFile:!1,passPerPreset:!1,envName:context.envName,cwd:context.cwd,root:context.root,rootMode:"root",filename:"string"==typeof context.filename?context.filename:void 0,plugins:configChain.plugins.map((descriptor=>(0, _item.createItemFromDescriptor)(descriptor))),presets:configChain.presets.map((descriptor=>(0, _item.createItemFromDescriptor)(descriptor)))}),context,fileHandling:configChain.fileHandling,ignore:configChain.ignore,babelrc:configChain.babelrc,config:configChain.config,files:configChain.files}}const loadPartialConfig=_gensync()((function*(opts){let showIgnoredFiles=!1;if("object"==typeof opts&&null!==opts&&!Array.isArray(opts)){var _opts=opts;(({showIgnoredFiles}=_opts)),opts=function(source,excluded){if(null==source)return {};var key,i,target={},sourceKeys=Object.keys(source);for(i=0;i<sourceKeys.length;i++)key=sourceKeys[i],excluded.indexOf(key)>=0||(target[key]=source[key]);return target}(_opts,_excluded);}const result=yield*loadPrivatePartialConfig(opts);if(!result)return null;const{options,babelrc,ignore,config,fileHandling,files}=result;return "ignored"!==fileHandling||showIgnoredFiles?((options.plugins||[]).forEach((item=>{if(item.value instanceof _plugin.default)throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()")})),new PartialConfig(options,babelrc?babelrc.filepath:void 0,ignore?ignore.filepath:void 0,config?config.filepath:void 0,fileHandling,files)):null}));exports.loadPartialConfig=loadPartialConfig;class PartialConfig{constructor(options,babelrc,ignore,config,fileHandling,files){this.options=void 0,this.babelrc=void 0,this.babelignore=void 0,this.config=void 0,this.fileHandling=void 0,this.files=void 0,this.options=options,this.babelignore=ignore,this.babelrc=babelrc,this.config=config,this.fileHandling=fileHandling,this.files=files,Object.freeze(this);}hasFilesystemConfig(){return void 0!==this.babelrc||void 0!==this.config}}Object.freeze(PartialConfig.prototype);},"./node_modules/@babel/core/lib/config/pattern-to-regex.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(pattern,dirname){const parts=_path().resolve(dirname,pattern).split(_path().sep);return new RegExp(["^",...parts.map(((part,i)=>{const last=i===parts.length-1;return "**"===part?last?starStarPatLast:starStarPat:"*"===part?last?starPatLast:starPat:0===part.indexOf("*.")?substitution+escapeRegExp(part.slice(1))+(last?endSep:sep):escapeRegExp(part)+(last?endSep:sep)}))].join(""))};const sep=`\\${_path().sep}`,endSep=`(?:${sep}|$)`,substitution=`[^${sep}]+`,starPat=`(?:${substitution}${sep})`,starPatLast=`(?:${substitution}${endSep})`,starStarPat=`${starPat}*?`,starStarPatLast=`${starPat}*?${starPatLast}?`;function escapeRegExp(string){return string.replace(/[|\\{}()[\]^$+*?.]/g,"\\$&")}},"./node_modules/@babel/core/lib/config/plugin.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;exports.default=class{constructor(plugin,options,key){this.key=void 0,this.manipulateOptions=void 0,this.post=void 0,this.pre=void 0,this.visitor=void 0,this.parserOverride=void 0,this.generatorOverride=void 0,this.options=void 0,this.key=plugin.name||key,this.manipulateOptions=plugin.manipulateOptions,this.post=plugin.post,this.pre=plugin.pre,this.visitor=plugin.visitor||{},this.parserOverride=plugin.parserOverride,this.generatorOverride=plugin.generatorOverride,this.options=options;}};},"./node_modules/@babel/core/lib/config/printer.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _gensync(){const data=__webpack_require__("./node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.ConfigPrinter=exports.ChainFormatter=void 0;const ChainFormatter={Programmatic:0,Config:1};exports.ChainFormatter=ChainFormatter;const Formatter={title(type,callerName,filepath){let title="";return type===ChainFormatter.Programmatic?(title="programmatic options",callerName&&(title+=" from "+callerName)):title="config "+filepath,title},loc(index,envName){let loc="";return null!=index&&(loc+=`.overrides[${index}]`),null!=envName&&(loc+=`.env["${envName}"]`),loc},*optionsAndDescriptors(opt){const content=Object.assign({},opt.options);delete content.overrides,delete content.env;const pluginDescriptors=[...yield*opt.plugins()];pluginDescriptors.length&&(content.plugins=pluginDescriptors.map((d=>descriptorToConfig(d))));const presetDescriptors=[...yield*opt.presets()];return presetDescriptors.length&&(content.presets=[...presetDescriptors].map((d=>descriptorToConfig(d)))),JSON.stringify(content,void 0,2)}};function descriptorToConfig(d){var _d$file;let name=null==(_d$file=d.file)?void 0:_d$file.request;return null==name&&("object"==typeof d.value?name=d.value:"function"==typeof d.value&&(name=`[Function: ${d.value.toString().substr(0,50)} ... ]`)),null==name&&(name="[Unknown]"),void 0===d.options?name:null==d.name?[name,d.options]:[name,d.options,d.name]}class ConfigPrinter{constructor(){this._stack=[];}configure(enabled,type,{callerName,filepath}){return enabled?(content,index,envName)=>{this._stack.push({type,callerName,filepath,content,index,envName});}:()=>{}}static*format(config){let title=Formatter.title(config.type,config.callerName,config.filepath);const loc=Formatter.loc(config.index,config.envName);loc&&(title+=` ${loc}`);return `${title}\n${yield*Formatter.optionsAndDescriptors(config.content)}`}*output(){if(0===this._stack.length)return "";return (yield*_gensync().all(this._stack.map((s=>ConfigPrinter.format(s))))).join("\n\n")}}exports.ConfigPrinter=ConfigPrinter;},"./node_modules/@babel/core/lib/config/resolve-targets.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}function _helperCompilationTargets(){const data=__webpack_require__("./stubs/helper_compilation_targets.js");return _helperCompilationTargets=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.resolveBrowserslistConfigFile=function(browserslistConfigFile,configFileDir){return _path().resolve(configFileDir,browserslistConfigFile)},exports.resolveTargets=function(options,root){let targets=options.targets;("string"==typeof targets||Array.isArray(targets))&&(targets={browsers:targets});targets&&targets.esmodules&&(targets=Object.assign({},targets,{esmodules:"intersect"}));const{browserslistConfigFile}=options;let configFile,ignoreBrowserslistConfig=!1;"string"==typeof browserslistConfigFile?configFile=browserslistConfigFile:ignoreBrowserslistConfig=!1===browserslistConfigFile;return (0, _helperCompilationTargets().default)(targets,{ignoreBrowserslistConfig,configFile,configPath:root,browserslistEnv:options.browserslistEnv})};},"./node_modules/@babel/core/lib/config/util.js":(__unused_webpack_module,exports)=>{function mergeDefaultFields(target,source){for(const k of Object.keys(source)){const val=source[k];void 0!==val&&(target[k]=val);}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.isIterableIterator=function(value){return !!value&&"function"==typeof value.next&&"function"==typeof value[Symbol.iterator]},exports.mergeOptions=function(target,source){for(const k of Object.keys(source))if("parserOpts"!==k&&"generatorOpts"!==k&&"assumptions"!==k||!source[k]){const val=source[k];void 0!==val&&(target[k]=val);}else {const parserOpts=source[k];mergeDefaultFields(target[k]||(target[k]={}),parserOpts);}};},"./node_modules/@babel/core/lib/config/validation/option-assertions.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _helperCompilationTargets(){const data=__webpack_require__("./stubs/helper_compilation_targets.js");return _helperCompilationTargets=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.access=access,exports.assertArray=assertArray,exports.assertAssumptions=function(loc,value){if(void 0===value)return;if("object"!=typeof value||null===value)throw new Error(`${msg(loc)} must be an object or undefined.`);let root=loc;do{root=root.parent;}while("root"!==root.type);const inPreset="preset"===root.source;for(const name of Object.keys(value)){const subLoc=access(loc,name);if(!_options.assumptionsNames.has(name))throw new Error(`${msg(subLoc)} is not a supported assumption.`);if("boolean"!=typeof value[name])throw new Error(`${msg(subLoc)} must be a boolean.`);if(inPreset&&!1===value[name])throw new Error(`${msg(subLoc)} cannot be set to 'false' inside presets.`)}return value},exports.assertBabelrcSearch=function(loc,value){if(void 0===value||"boolean"==typeof value)return value;if(Array.isArray(value))value.forEach(((item,i)=>{if(!checkValidTest(item))throw new Error(`${msg(access(loc,i))} must be a string/Function/RegExp.`)}));else if(!checkValidTest(value))throw new Error(`${msg(loc)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(value)}`);return value},exports.assertBoolean=assertBoolean,exports.assertCallerMetadata=function(loc,value){const obj=assertObject(loc,value);if(obj){if("string"!=typeof obj.name)throw new Error(`${msg(loc)} set but does not contain "name" property string`);for(const prop of Object.keys(obj)){const propLoc=access(loc,prop),value=obj[prop];if(null!=value&&"boolean"!=typeof value&&"string"!=typeof value&&"number"!=typeof value)throw new Error(`${msg(propLoc)} must be null, undefined, a boolean, a string, or a number.`)}}return value},exports.assertCompact=function(loc,value){if(void 0!==value&&"boolean"!=typeof value&&"auto"!==value)throw new Error(`${msg(loc)} must be a boolean, "auto", or undefined`);return value},exports.assertConfigApplicableTest=function(loc,value){if(void 0===value)return value;if(Array.isArray(value))value.forEach(((item,i)=>{if(!checkValidTest(item))throw new Error(`${msg(access(loc,i))} must be a string/Function/RegExp.`)}));else if(!checkValidTest(value))throw new Error(`${msg(loc)} must be a string/Function/RegExp, or an array of those`);return value},exports.assertConfigFileSearch=function(loc,value){if(void 0!==value&&"boolean"!=typeof value&&"string"!=typeof value)throw new Error(`${msg(loc)} must be a undefined, a boolean, a string, got ${JSON.stringify(value)}`);return value},exports.assertFunction=function(loc,value){if(void 0!==value&&"function"!=typeof value)throw new Error(`${msg(loc)} must be a function, or undefined`);return value},exports.assertIgnoreList=function(loc,value){const arr=assertArray(loc,value);arr&&arr.forEach(((item,i)=>function(loc,value){if("string"!=typeof value&&"function"!=typeof value&&!(value instanceof RegExp))throw new Error(`${msg(loc)} must be an array of string/Function/RegExp values, or undefined`);return value}(access(loc,i),item)));return arr},exports.assertInputSourceMap=function(loc,value){if(void 0!==value&&"boolean"!=typeof value&&("object"!=typeof value||!value))throw new Error(`${msg(loc)} must be a boolean, object, or undefined`);return value},exports.assertObject=assertObject,exports.assertPluginList=function(loc,value){const arr=assertArray(loc,value);arr&&arr.forEach(((item,i)=>function(loc,value){if(Array.isArray(value)){if(0===value.length)throw new Error(`${msg(loc)} must include an object`);if(value.length>3)throw new Error(`${msg(loc)} may only be a two-tuple or three-tuple`);if(assertPluginTarget(access(loc,0),value[0]),value.length>1){const opts=value[1];if(void 0!==opts&&!1!==opts&&("object"!=typeof opts||Array.isArray(opts)||null===opts))throw new Error(`${msg(access(loc,1))} must be an object, false, or undefined`)}if(3===value.length){const name=value[2];if(void 0!==name&&"string"!=typeof name)throw new Error(`${msg(access(loc,2))} must be a string, or undefined`)}}else assertPluginTarget(loc,value);return value}(access(loc,i),item)));return arr},exports.assertRootMode=function(loc,value){if(void 0!==value&&"root"!==value&&"upward"!==value&&"upward-optional"!==value)throw new Error(`${msg(loc)} must be a "root", "upward", "upward-optional" or undefined`);return value},exports.assertSourceMaps=function(loc,value){if(void 0!==value&&"boolean"!=typeof value&&"inline"!==value&&"both"!==value)throw new Error(`${msg(loc)} must be a boolean, "inline", "both", or undefined`);return value},exports.assertSourceType=function(loc,value){if(void 0!==value&&"module"!==value&&"script"!==value&&"unambiguous"!==value)throw new Error(`${msg(loc)} must be "module", "script", "unambiguous", or undefined`);return value},exports.assertString=function(loc,value){if(void 0!==value&&"string"!=typeof value)throw new Error(`${msg(loc)} must be a string, or undefined`);return value},exports.assertTargets=function(loc,value){if((0, _helperCompilationTargets().isBrowsersQueryValid)(value))return value;if("object"!=typeof value||!value||Array.isArray(value))throw new Error(`${msg(loc)} must be a string, an array of strings or an object`);const browsersLoc=access(loc,"browsers"),esmodulesLoc=access(loc,"esmodules");assertBrowsersList(browsersLoc,value.browsers),assertBoolean(esmodulesLoc,value.esmodules);for(const key of Object.keys(value)){const val=value[key],subLoc=access(loc,key);if("esmodules"===key)assertBoolean(subLoc,val);else if("browsers"===key)assertBrowsersList(subLoc,val);else {if(!Object.hasOwnProperty.call(_helperCompilationTargets().TargetNames,key)){const validTargets=Object.keys(_helperCompilationTargets().TargetNames).join(", ");throw new Error(`${msg(subLoc)} is not a valid target. Supported targets are ${validTargets}`)}assertBrowserVersion(subLoc,val);}}return value},exports.msg=msg;var _options=__webpack_require__("./node_modules/@babel/core/lib/config/validation/options.js");function msg(loc){switch(loc.type){case"root":return "";case"env":return `${msg(loc.parent)}.env["${loc.name}"]`;case"overrides":return `${msg(loc.parent)}.overrides[${loc.index}]`;case"option":return `${msg(loc.parent)}.${loc.name}`;case"access":return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;default:throw new Error(`Assertion failure: Unknown type ${loc.type}`)}}function access(loc,name){return {type:"access",name,parent:loc}}function assertBoolean(loc,value){if(void 0!==value&&"boolean"!=typeof value)throw new Error(`${msg(loc)} must be a boolean, or undefined`);return value}function assertObject(loc,value){if(void 0!==value&&("object"!=typeof value||Array.isArray(value)||!value))throw new Error(`${msg(loc)} must be an object, or undefined`);return value}function assertArray(loc,value){if(null!=value&&!Array.isArray(value))throw new Error(`${msg(loc)} must be an array, or undefined`);return value}function checkValidTest(value){return "string"==typeof value||"function"==typeof value||value instanceof RegExp}function assertPluginTarget(loc,value){if(("object"!=typeof value||!value)&&"string"!=typeof value&&"function"!=typeof value)throw new Error(`${msg(loc)} must be a string, object, function`);return value}function assertBrowsersList(loc,value){if(void 0!==value&&!(0, _helperCompilationTargets().isBrowsersQueryValid)(value))throw new Error(`${msg(loc)} must be undefined, a string or an array of strings`)}function assertBrowserVersion(loc,value){if(("number"!=typeof value||Math.round(value)!==value)&&"string"!=typeof value)throw new Error(`${msg(loc)} must be a string or an integer number`)}},"./node_modules/@babel/core/lib/config/validation/options.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.assumptionsNames=void 0,exports.checkNoUnwrappedItemOptionPairs=function(items,index,type,e){if(0===index)return;const lastItem=items[index-1],thisItem=items[index];lastItem.file&&void 0===lastItem.options&&"object"==typeof thisItem.value&&(e.message+=`\n- Maybe you meant to use\n"${type}s": [\n  ["${lastItem.file.request}", ${JSON.stringify(thisItem.value,void 0,2)}]\n]\nTo be a valid ${type}, its name and options should be wrapped in a pair of brackets`);},exports.validate=function(type,opts){return validateNested({type:"root",source:type},opts)};__webpack_require__("./node_modules/@babel/core/lib/config/plugin.js");var _removed=__webpack_require__("./node_modules/@babel/core/lib/config/validation/removed.js"),_optionAssertions=__webpack_require__("./node_modules/@babel/core/lib/config/validation/option-assertions.js");const ROOT_VALIDATORS={cwd:_optionAssertions.assertString,root:_optionAssertions.assertString,rootMode:_optionAssertions.assertRootMode,configFile:_optionAssertions.assertConfigFileSearch,caller:_optionAssertions.assertCallerMetadata,filename:_optionAssertions.assertString,filenameRelative:_optionAssertions.assertString,code:_optionAssertions.assertBoolean,ast:_optionAssertions.assertBoolean,cloneInputAst:_optionAssertions.assertBoolean,envName:_optionAssertions.assertString},BABELRC_VALIDATORS={babelrc:_optionAssertions.assertBoolean,babelrcRoots:_optionAssertions.assertBabelrcSearch},NONPRESET_VALIDATORS={extends:_optionAssertions.assertString,ignore:_optionAssertions.assertIgnoreList,only:_optionAssertions.assertIgnoreList,targets:_optionAssertions.assertTargets,browserslistConfigFile:_optionAssertions.assertConfigFileSearch,browserslistEnv:_optionAssertions.assertString},COMMON_VALIDATORS={inputSourceMap:_optionAssertions.assertInputSourceMap,presets:_optionAssertions.assertPluginList,plugins:_optionAssertions.assertPluginList,passPerPreset:_optionAssertions.assertBoolean,assumptions:_optionAssertions.assertAssumptions,env:function(loc,value){if("env"===loc.parent.type)throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside of another .env block`);const parent=loc.parent,obj=(0, _optionAssertions.assertObject)(loc,value);if(obj)for(const envName of Object.keys(obj)){const env=(0, _optionAssertions.assertObject)((0, _optionAssertions.access)(loc,envName),obj[envName]);if(!env)continue;validateNested({type:"env",name:envName,parent},env);}return obj},overrides:function(loc,value){if("env"===loc.parent.type)throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .env block`);if("overrides"===loc.parent.type)throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .overrides block`);const parent=loc.parent,arr=(0, _optionAssertions.assertArray)(loc,value);if(arr)for(const[index,item]of arr.entries()){const objLoc=(0, _optionAssertions.access)(loc,index),env=(0, _optionAssertions.assertObject)(objLoc,item);if(!env)throw new Error(`${(0, _optionAssertions.msg)(objLoc)} must be an object`);validateNested({type:"overrides",index,parent},env);}return arr},test:_optionAssertions.assertConfigApplicableTest,include:_optionAssertions.assertConfigApplicableTest,exclude:_optionAssertions.assertConfigApplicableTest,retainLines:_optionAssertions.assertBoolean,comments:_optionAssertions.assertBoolean,shouldPrintComment:_optionAssertions.assertFunction,compact:_optionAssertions.assertCompact,minified:_optionAssertions.assertBoolean,auxiliaryCommentBefore:_optionAssertions.assertString,auxiliaryCommentAfter:_optionAssertions.assertString,sourceType:_optionAssertions.assertSourceType,wrapPluginVisitorMethod:_optionAssertions.assertFunction,highlightCode:_optionAssertions.assertBoolean,sourceMaps:_optionAssertions.assertSourceMaps,sourceMap:_optionAssertions.assertSourceMaps,sourceFileName:_optionAssertions.assertString,sourceRoot:_optionAssertions.assertString,parserOpts:_optionAssertions.assertObject,generatorOpts:_optionAssertions.assertObject};Object.assign(COMMON_VALIDATORS,{getModuleId:_optionAssertions.assertFunction,moduleRoot:_optionAssertions.assertString,moduleIds:_optionAssertions.assertBoolean,moduleId:_optionAssertions.assertString});const assumptionsNames=new Set(["arrayLikeIsIterable","constantReexports","constantSuper","enumerableModuleMeta","ignoreFunctionLength","ignoreToPrimitiveHint","iterableIsArray","mutableTemplateObject","noClassCalls","noDocumentAll","noIncompleteNsImportDetection","noNewArrows","objectRestNoSymbols","privateFieldsAsProperties","pureGetters","setClassMethods","setComputedProperties","setPublicClassFields","setSpreadProperties","skipForOfIteratorClosing","superIsCallableConstructor"]);function getSource(loc){return "root"===loc.type?loc.source:getSource(loc.parent)}function validateNested(loc,opts){const type=getSource(loc);return function(opts){if(has(opts,"sourceMap")&&has(opts,"sourceMaps"))throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both")}(opts),Object.keys(opts).forEach((key=>{const optLoc={type:"option",name:key,parent:loc};if("preset"===type&&NONPRESET_VALIDATORS[key])throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in preset options`);if("arguments"!==type&&ROOT_VALIDATORS[key])throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options`);if("arguments"!==type&&"configfile"!==type&&BABELRC_VALIDATORS[key]){if("babelrcfile"===type||"extendsfile"===type)throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, or babel.config.js/config file options`);throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options, or babel.config.js/config file options`)}(COMMON_VALIDATORS[key]||NONPRESET_VALIDATORS[key]||BABELRC_VALIDATORS[key]||ROOT_VALIDATORS[key]||throwUnknownError)(optLoc,opts[key]);})),opts}function throwUnknownError(loc){const key=loc.name;if(_removed.default[key]){const{message,version=5}=_removed.default[key];throw new Error(`Using removed Babel ${version} option: ${(0, _optionAssertions.msg)(loc)} - ${message}`)}{const unknownOptErr=new Error(`Unknown option: ${(0, _optionAssertions.msg)(loc)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);throw unknownOptErr.code="BABEL_UNKNOWN_OPTION",unknownOptErr}}function has(obj,key){return Object.prototype.hasOwnProperty.call(obj,key)}exports.assumptionsNames=assumptionsNames;},"./node_modules/@babel/core/lib/config/validation/plugins.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.validatePluginObject=function(obj){const rootPath={type:"root",source:"plugin"};return Object.keys(obj).forEach((key=>{const validator=VALIDATORS[key];if(!validator){const invalidPluginPropertyError=new Error(`.${key} is not a valid Plugin property`);throw invalidPluginPropertyError.code="BABEL_UNKNOWN_PLUGIN_PROPERTY",invalidPluginPropertyError}validator({type:"option",name:key,parent:rootPath},obj[key]);})),obj};var _optionAssertions=__webpack_require__("./node_modules/@babel/core/lib/config/validation/option-assertions.js");const VALIDATORS={name:_optionAssertions.assertString,manipulateOptions:_optionAssertions.assertFunction,pre:_optionAssertions.assertFunction,post:_optionAssertions.assertFunction,inherits:_optionAssertions.assertFunction,visitor:function(loc,value){const obj=(0, _optionAssertions.assertObject)(loc,value);if(obj&&(Object.keys(obj).forEach((prop=>function(key,value){if(value&&"object"==typeof value)Object.keys(value).forEach((handler=>{if("enter"!==handler&&"exit"!==handler)throw new Error(`.visitor["${key}"] may only have .enter and/or .exit handlers.`)}));else if("function"!=typeof value)throw new Error(`.visitor["${key}"] must be a function`);return value}(prop,obj[prop]))),obj.enter||obj.exit))throw new Error(`${(0, _optionAssertions.msg)(loc)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);return obj},parserOverride:_optionAssertions.assertFunction,generatorOverride:_optionAssertions.assertFunction};},"./node_modules/@babel/core/lib/config/validation/removed.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;exports.default={auxiliaryComment:{message:"Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"},blacklist:{message:"Put the specific transforms you want in the `plugins` option"},breakConfig:{message:"This is not a necessary option in Babel 6"},experimental:{message:"Put the specific transforms you want in the `plugins` option"},externalHelpers:{message:"Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/"},extra:{message:""},jsxPragma:{message:"use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/"},loose:{message:"Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option."},metadataUsedHelpers:{message:"Not required anymore as this is enabled by default"},modules:{message:"Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules"},nonStandard:{message:"Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"},optional:{message:"Put the specific transforms you want in the `plugins` option"},sourceMapName:{message:"The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."},stage:{message:"Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"},whitelist:{message:"Put the specific transforms you want in the `plugins` option"},resolveModuleSource:{version:6,message:"Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"},metadata:{version:6,message:"Generated plugin metadata is always included in the output result"},sourceMapTarget:{version:6,message:"The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."}};},"./node_modules/@babel/core/lib/gensync-utils/async.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _gensync(){const data=__webpack_require__("./node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.forwardAsync=function(action,cb){const g=_gensync()(action);return withKind((kind=>{const adapted=g[kind];return cb(adapted)}))},exports.isAsync=void 0,exports.isThenable=isThenable,exports.maybeAsync=function(fn,message){return _gensync()({sync(...args){const result=fn.apply(this,args);if(isThenable(result))throw new Error(message);return result},async(...args){return Promise.resolve(fn.apply(this,args))}})},exports.waitFor=exports.onFirstPause=void 0;const id=x=>x,runGenerator=_gensync()((function*(item){return yield*item})),isAsync=_gensync()({sync:()=>!1,errback:cb=>cb(null,!0)});exports.isAsync=isAsync;const withKind=_gensync()({sync:cb=>cb("sync"),async:cb=>cb("async")});const onFirstPause=_gensync()({name:"onFirstPause",arity:2,sync:function(item){return runGenerator.sync(item)},errback:function(item,firstPause,cb){let completed=!1;runGenerator.errback(item,((err,value)=>{completed=!0,cb(err,value);})),completed||firstPause();}});exports.onFirstPause=onFirstPause;const waitFor=_gensync()({sync:id,async:id});function isThenable(val){return !(!val||"object"!=typeof val&&"function"!=typeof val||!val.then||"function"!=typeof val.then)}exports.waitFor=waitFor;},"./node_modules/@babel/core/lib/gensync-utils/fs.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _fs(){const data=__webpack_require__("fs");return _fs=function(){return data},data}function _gensync(){const data=__webpack_require__("./node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.stat=exports.readFile=void 0;const readFile=_gensync()({sync:_fs().readFileSync,errback:_fs().readFile});exports.readFile=readFile;const stat=_gensync()({sync:_fs().statSync,errback:_fs().stat});exports.stat=stat;},"./node_modules/@babel/core/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.DEFAULT_EXTENSIONS=void 0,Object.defineProperty(exports,"File",{enumerable:!0,get:function(){return _file.default}}),exports.OptionManager=void 0,exports.Plugin=function(alias){throw new Error(`The (${alias}) Babel 5 plugin is being run with an unsupported Babel version.`)},Object.defineProperty(exports,"buildExternalHelpers",{enumerable:!0,get:function(){return _buildExternalHelpers.default}}),Object.defineProperty(exports,"createConfigItem",{enumerable:!0,get:function(){return _config.createConfigItem}}),Object.defineProperty(exports,"createConfigItemAsync",{enumerable:!0,get:function(){return _config.createConfigItemAsync}}),Object.defineProperty(exports,"createConfigItemSync",{enumerable:!0,get:function(){return _config.createConfigItemSync}}),Object.defineProperty(exports,"getEnv",{enumerable:!0,get:function(){return _environment.getEnv}}),Object.defineProperty(exports,"loadOptions",{enumerable:!0,get:function(){return _config.loadOptions}}),Object.defineProperty(exports,"loadOptionsAsync",{enumerable:!0,get:function(){return _config.loadOptionsAsync}}),Object.defineProperty(exports,"loadOptionsSync",{enumerable:!0,get:function(){return _config.loadOptionsSync}}),Object.defineProperty(exports,"loadPartialConfig",{enumerable:!0,get:function(){return _config.loadPartialConfig}}),Object.defineProperty(exports,"loadPartialConfigAsync",{enumerable:!0,get:function(){return _config.loadPartialConfigAsync}}),Object.defineProperty(exports,"loadPartialConfigSync",{enumerable:!0,get:function(){return _config.loadPartialConfigSync}}),Object.defineProperty(exports,"parse",{enumerable:!0,get:function(){return _parse.parse}}),Object.defineProperty(exports,"parseAsync",{enumerable:!0,get:function(){return _parse.parseAsync}}),Object.defineProperty(exports,"parseSync",{enumerable:!0,get:function(){return _parse.parseSync}}),Object.defineProperty(exports,"resolvePlugin",{enumerable:!0,get:function(){return _files.resolvePlugin}}),Object.defineProperty(exports,"resolvePreset",{enumerable:!0,get:function(){return _files.resolvePreset}}),Object.defineProperty(exports,"template",{enumerable:!0,get:function(){return _template().default}}),Object.defineProperty(exports,"tokTypes",{enumerable:!0,get:function(){return _parser().tokTypes}}),Object.defineProperty(exports,"transform",{enumerable:!0,get:function(){return _transform.transform}}),Object.defineProperty(exports,"transformAsync",{enumerable:!0,get:function(){return _transform.transformAsync}}),Object.defineProperty(exports,"transformFile",{enumerable:!0,get:function(){return _transformFile.transformFile}}),Object.defineProperty(exports,"transformFileAsync",{enumerable:!0,get:function(){return _transformFile.transformFileAsync}}),Object.defineProperty(exports,"transformFileSync",{enumerable:!0,get:function(){return _transformFile.transformFileSync}}),Object.defineProperty(exports,"transformFromAst",{enumerable:!0,get:function(){return _transformAst.transformFromAst}}),Object.defineProperty(exports,"transformFromAstAsync",{enumerable:!0,get:function(){return _transformAst.transformFromAstAsync}}),Object.defineProperty(exports,"transformFromAstSync",{enumerable:!0,get:function(){return _transformAst.transformFromAstSync}}),Object.defineProperty(exports,"transformSync",{enumerable:!0,get:function(){return _transform.transformSync}}),Object.defineProperty(exports,"traverse",{enumerable:!0,get:function(){return _traverse().default}}),exports.version=exports.types=void 0;var _file=__webpack_require__("./node_modules/@babel/core/lib/transformation/file/file.js"),_buildExternalHelpers=__webpack_require__("./node_modules/@babel/core/lib/tools/build-external-helpers.js"),_files=__webpack_require__("./node_modules/@babel/core/lib/config/files/index.js"),_environment=__webpack_require__("./node_modules/@babel/core/lib/config/helpers/environment.js");function _types(){const data=__webpack_require__("./node_modules/@babel/types/lib/index.js");return _types=function(){return data},data}function _parser(){const data=__webpack_require__("./node_modules/@babel/parser/lib/index.js");return _parser=function(){return data},data}function _traverse(){const data=__webpack_require__("./node_modules/@babel/traverse/lib/index.js");return _traverse=function(){return data},data}function _template(){const data=__webpack_require__("./node_modules/@babel/template/lib/index.js");return _template=function(){return data},data}Object.defineProperty(exports,"types",{enumerable:!0,get:function(){return _types()}});var _config=__webpack_require__("./node_modules/@babel/core/lib/config/index.js"),_transform=__webpack_require__("./node_modules/@babel/core/lib/transform.js"),_transformFile=__webpack_require__("./node_modules/@babel/core/lib/transform-file.js"),_transformAst=__webpack_require__("./node_modules/@babel/core/lib/transform-ast.js"),_parse=__webpack_require__("./node_modules/@babel/core/lib/parse.js");exports.version="7.16.12";const DEFAULT_EXTENSIONS=Object.freeze([".js",".jsx",".es6",".es",".mjs",".cjs"]);exports.DEFAULT_EXTENSIONS=DEFAULT_EXTENSIONS;exports.OptionManager=class{init(opts){return (0, _config.loadOptions)(opts)}};},"./node_modules/@babel/core/lib/parse.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _gensync(){const data=__webpack_require__("./node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.parseSync=exports.parseAsync=exports.parse=void 0;var _config=__webpack_require__("./node_modules/@babel/core/lib/config/index.js"),_parser=__webpack_require__("./node_modules/@babel/core/lib/parser/index.js"),_normalizeOpts=__webpack_require__("./node_modules/@babel/core/lib/transformation/normalize-opts.js");const parseRunner=_gensync()((function*(code,opts){const config=yield*(0, _config.default)(opts);return null===config?null:yield*(0, _parser.default)(config.passes,(0, _normalizeOpts.default)(config),code)}));exports.parse=function(code,opts,callback){if("function"==typeof opts&&(callback=opts,opts=void 0),void 0===callback)return parseRunner.sync(code,opts);parseRunner.errback(code,opts,callback);};const parseSync=parseRunner.sync;exports.parseSync=parseSync;const parseAsync=parseRunner.async;exports.parseAsync=parseAsync;},"./node_modules/@babel/core/lib/parser/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _parser(){const data=__webpack_require__("./node_modules/@babel/parser/lib/index.js");return _parser=function(){return data},data}function _codeFrame(){const data=__webpack_require__("./stubs/babel_codeframe.js");return _codeFrame=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function*(pluginPasses,{parserOpts,highlightCode=!0,filename="unknown"},code){try{const results=[];for(const plugins of pluginPasses)for(const plugin of plugins){const{parserOverride}=plugin;if(parserOverride){const ast=parserOverride(code,parserOpts,_parser().parse);void 0!==ast&&results.push(ast);}}if(0===results.length)return (0,_parser().parse)(code,parserOpts);if(1===results.length){if(yield*[],"function"==typeof results[0].then)throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");return results[0]}throw new Error("More than one plugin attempted to override parsing.")}catch(err){"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"===err.code&&(err.message+="\nConsider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.");const{loc,missingPlugin}=err;if(loc){const codeFrame=(0, _codeFrame().codeFrameColumns)(code,{start:{line:loc.line,column:loc.column+1}},{highlightCode});err.message=missingPlugin?`${filename}: `+(0, _missingPluginHelper.default)(missingPlugin[0],loc,codeFrame):`${filename}: ${err.message}\n\n`+codeFrame,err.code="BABEL_PARSE_ERROR";}throw err}};var _missingPluginHelper=__webpack_require__("./node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js");},"./node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(missingPluginName,loc,codeFrame){let helpMessage=`Support for the experimental syntax '${missingPluginName}' isn't currently enabled (${loc.line}:${loc.column+1}):\n\n`+codeFrame;const pluginInfo=pluginNameMap[missingPluginName];if(pluginInfo){const{syntax:syntaxPlugin,transform:transformPlugin}=pluginInfo;if(syntaxPlugin){const syntaxPluginInfo=getNameURLCombination(syntaxPlugin);if(transformPlugin){const transformPluginInfo=getNameURLCombination(transformPlugin),sectionType=transformPlugin.name.startsWith("@babel/plugin")?"plugins":"presets";helpMessage+=`\n\nAdd ${transformPluginInfo} to the '${sectionType}' section of your Babel config to enable transformation.\nIf you want to leave it as-is, add ${syntaxPluginInfo} to the 'plugins' section to enable parsing.`;}else helpMessage+=`\n\nAdd ${syntaxPluginInfo} to the 'plugins' section of your Babel config to enable parsing.`;}}return helpMessage};const pluginNameMap={asyncDoExpressions:{syntax:{name:"@babel/plugin-syntax-async-do-expressions",url:"https://git.io/JYer8"}},classProperties:{syntax:{name:"@babel/plugin-syntax-class-properties",url:"https://git.io/vb4yQ"},transform:{name:"@babel/plugin-proposal-class-properties",url:"https://git.io/vb4SL"}},classPrivateProperties:{syntax:{name:"@babel/plugin-syntax-class-properties",url:"https://git.io/vb4yQ"},transform:{name:"@babel/plugin-proposal-class-properties",url:"https://git.io/vb4SL"}},classPrivateMethods:{syntax:{name:"@babel/plugin-syntax-class-properties",url:"https://git.io/vb4yQ"},transform:{name:"@babel/plugin-proposal-private-methods",url:"https://git.io/JvpRG"}},classStaticBlock:{syntax:{name:"@babel/plugin-syntax-class-static-block",url:"https://git.io/JTLB6"},transform:{name:"@babel/plugin-proposal-class-static-block",url:"https://git.io/JTLBP"}},decimal:{syntax:{name:"@babel/plugin-syntax-decimal",url:"https://git.io/JfKOH"}},decorators:{syntax:{name:"@babel/plugin-syntax-decorators",url:"https://git.io/vb4y9"},transform:{name:"@babel/plugin-proposal-decorators",url:"https://git.io/vb4ST"}},doExpressions:{syntax:{name:"@babel/plugin-syntax-do-expressions",url:"https://git.io/vb4yh"},transform:{name:"@babel/plugin-proposal-do-expressions",url:"https://git.io/vb4S3"}},dynamicImport:{syntax:{name:"@babel/plugin-syntax-dynamic-import",url:"https://git.io/vb4Sv"}},exportDefaultFrom:{syntax:{name:"@babel/plugin-syntax-export-default-from",url:"https://git.io/vb4SO"},transform:{name:"@babel/plugin-proposal-export-default-from",url:"https://git.io/vb4yH"}},exportNamespaceFrom:{syntax:{name:"@babel/plugin-syntax-export-namespace-from",url:"https://git.io/vb4Sf"},transform:{name:"@babel/plugin-proposal-export-namespace-from",url:"https://git.io/vb4SG"}},flow:{syntax:{name:"@babel/plugin-syntax-flow",url:"https://git.io/vb4yb"},transform:{name:"@babel/preset-flow",url:"https://git.io/JfeDn"}},functionBind:{syntax:{name:"@babel/plugin-syntax-function-bind",url:"https://git.io/vb4y7"},transform:{name:"@babel/plugin-proposal-function-bind",url:"https://git.io/vb4St"}},functionSent:{syntax:{name:"@babel/plugin-syntax-function-sent",url:"https://git.io/vb4yN"},transform:{name:"@babel/plugin-proposal-function-sent",url:"https://git.io/vb4SZ"}},importMeta:{syntax:{name:"@babel/plugin-syntax-import-meta",url:"https://git.io/vbKK6"}},jsx:{syntax:{name:"@babel/plugin-syntax-jsx",url:"https://git.io/vb4yA"},transform:{name:"@babel/preset-react",url:"https://git.io/JfeDR"}},importAssertions:{syntax:{name:"@babel/plugin-syntax-import-assertions",url:"https://git.io/JUbkv"}},moduleStringNames:{syntax:{name:"@babel/plugin-syntax-module-string-names",url:"https://git.io/JTL8G"}},numericSeparator:{syntax:{name:"@babel/plugin-syntax-numeric-separator",url:"https://git.io/vb4Sq"},transform:{name:"@babel/plugin-proposal-numeric-separator",url:"https://git.io/vb4yS"}},optionalChaining:{syntax:{name:"@babel/plugin-syntax-optional-chaining",url:"https://git.io/vb4Sc"},transform:{name:"@babel/plugin-proposal-optional-chaining",url:"https://git.io/vb4Sk"}},pipelineOperator:{syntax:{name:"@babel/plugin-syntax-pipeline-operator",url:"https://git.io/vb4yj"},transform:{name:"@babel/plugin-proposal-pipeline-operator",url:"https://git.io/vb4SU"}},privateIn:{syntax:{name:"@babel/plugin-syntax-private-property-in-object",url:"https://git.io/JfK3q"},transform:{name:"@babel/plugin-proposal-private-property-in-object",url:"https://git.io/JfK3O"}},recordAndTuple:{syntax:{name:"@babel/plugin-syntax-record-and-tuple",url:"https://git.io/JvKp3"}},throwExpressions:{syntax:{name:"@babel/plugin-syntax-throw-expressions",url:"https://git.io/vb4SJ"},transform:{name:"@babel/plugin-proposal-throw-expressions",url:"https://git.io/vb4yF"}},typescript:{syntax:{name:"@babel/plugin-syntax-typescript",url:"https://git.io/vb4SC"},transform:{name:"@babel/preset-typescript",url:"https://git.io/JfeDz"}},asyncGenerators:{syntax:{name:"@babel/plugin-syntax-async-generators",url:"https://git.io/vb4SY"},transform:{name:"@babel/plugin-proposal-async-generator-functions",url:"https://git.io/vb4yp"}},logicalAssignment:{syntax:{name:"@babel/plugin-syntax-logical-assignment-operators",url:"https://git.io/vAlBp"},transform:{name:"@babel/plugin-proposal-logical-assignment-operators",url:"https://git.io/vAlRe"}},nullishCoalescingOperator:{syntax:{name:"@babel/plugin-syntax-nullish-coalescing-operator",url:"https://git.io/vb4yx"},transform:{name:"@babel/plugin-proposal-nullish-coalescing-operator",url:"https://git.io/vb4Se"}},objectRestSpread:{syntax:{name:"@babel/plugin-syntax-object-rest-spread",url:"https://git.io/vb4y5"},transform:{name:"@babel/plugin-proposal-object-rest-spread",url:"https://git.io/vb4Ss"}},optionalCatchBinding:{syntax:{name:"@babel/plugin-syntax-optional-catch-binding",url:"https://git.io/vb4Sn"},transform:{name:"@babel/plugin-proposal-optional-catch-binding",url:"https://git.io/vb4SI"}}};pluginNameMap.privateIn.syntax=pluginNameMap.privateIn.transform;const getNameURLCombination=({name,url})=>`${name} (${url})`;},"./node_modules/@babel/core/lib/tools/build-external-helpers.js":(__unused_webpack_module,exports,__webpack_require__)=>{function helpers(){const data=__webpack_require__("./node_modules/@babel/helpers/lib/index.js");return helpers=function(){return data},data}function _generator(){const data=__webpack_require__("./node_modules/@babel/generator/lib/index.js");return _generator=function(){return data},data}function _template(){const data=__webpack_require__("./node_modules/@babel/template/lib/index.js");return _template=function(){return data},data}function _t(){const data=__webpack_require__("./node_modules/@babel/types/lib/index.js");return _t=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(allowlist,outputType="global"){let tree;const build={global:buildGlobal,module:buildModule,umd:buildUmd,var:buildVar}[outputType];if(!build)throw new Error(`Unsupported output type ${outputType}`);tree=build(allowlist);return (0, _generator().default)(tree).code};var _file=__webpack_require__("./node_modules/@babel/core/lib/transformation/file/file.js");const{arrayExpression,assignmentExpression,binaryExpression,blockStatement,callExpression,cloneNode,conditionalExpression,exportNamedDeclaration,exportSpecifier,expressionStatement,functionExpression,identifier,memberExpression,objectExpression,program,stringLiteral,unaryExpression,variableDeclaration,variableDeclarator}=_t();function buildGlobal(allowlist){const namespace=identifier("babelHelpers"),body=[],container=functionExpression(null,[identifier("global")],blockStatement(body)),tree=program([expressionStatement(callExpression(container,[conditionalExpression(binaryExpression("===",unaryExpression("typeof",identifier("global")),stringLiteral("undefined")),identifier("self"),identifier("global"))]))]);return body.push(variableDeclaration("var",[variableDeclarator(namespace,assignmentExpression("=",memberExpression(identifier("global"),namespace),objectExpression([])))])),buildHelpers(body,namespace,allowlist),tree}function buildModule(allowlist){const body=[],refs=buildHelpers(body,null,allowlist);return body.unshift(exportNamedDeclaration(null,Object.keys(refs).map((name=>exportSpecifier(cloneNode(refs[name]),identifier(name)))))),program(body,[],"module")}function buildUmd(allowlist){const namespace=identifier("babelHelpers"),body=[];return body.push(variableDeclaration("var",[variableDeclarator(namespace,identifier("global"))])),buildHelpers(body,namespace,allowlist),program([(replacements={FACTORY_PARAMETERS:identifier("global"),BROWSER_ARGUMENTS:assignmentExpression("=",memberExpression(identifier("root"),namespace),objectExpression([])),COMMON_ARGUMENTS:identifier("exports"),AMD_ARGUMENTS:arrayExpression([stringLiteral("exports")]),FACTORY_BODY:body,UMD_ROOT:identifier("this")},_template().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(replacements))]);var replacements;}function buildVar(allowlist){const namespace=identifier("babelHelpers"),body=[];body.push(variableDeclaration("var",[variableDeclarator(namespace,objectExpression([]))]));const tree=program(body);return buildHelpers(body,namespace,allowlist),body.push(expressionStatement(namespace)),tree}function buildHelpers(body,namespace,allowlist){const getHelperReference=name=>namespace?memberExpression(namespace,identifier(name)):identifier(`_${name}`),refs={};return helpers().list.forEach((function(name){if(allowlist&&allowlist.indexOf(name)<0)return;const ref=refs[name]=getHelperReference(name);helpers().ensure(name,_file.default);const{nodes}=helpers().get(name,getHelperReference,ref);body.push(...nodes);})),refs}},"./node_modules/@babel/core/lib/transform-ast.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _gensync(){const data=__webpack_require__("./node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.transformFromAstSync=exports.transformFromAstAsync=exports.transformFromAst=void 0;var _config=__webpack_require__("./node_modules/@babel/core/lib/config/index.js"),_transformation=__webpack_require__("./node_modules/@babel/core/lib/transformation/index.js");const transformFromAstRunner=_gensync()((function*(ast,code,opts){const config=yield*(0, _config.default)(opts);if(null===config)return null;if(!ast)throw new Error("No AST given");return yield*(0, _transformation.run)(config,code,ast)}));exports.transformFromAst=function(ast,code,opts,callback){if("function"==typeof opts&&(callback=opts,opts=void 0),void 0===callback)return transformFromAstRunner.sync(ast,code,opts);transformFromAstRunner.errback(ast,code,opts,callback);};const transformFromAstSync=transformFromAstRunner.sync;exports.transformFromAstSync=transformFromAstSync;const transformFromAstAsync=transformFromAstRunner.async;exports.transformFromAstAsync=transformFromAstAsync;},"./node_modules/@babel/core/lib/transform-file.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _gensync(){const data=__webpack_require__("./node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.transformFileSync=exports.transformFileAsync=exports.transformFile=void 0;var _config=__webpack_require__("./node_modules/@babel/core/lib/config/index.js"),_transformation=__webpack_require__("./node_modules/@babel/core/lib/transformation/index.js"),fs=__webpack_require__("./node_modules/@babel/core/lib/gensync-utils/fs.js");const transformFileRunner=_gensync()((function*(filename,opts){const options=Object.assign({},opts,{filename}),config=yield*(0, _config.default)(options);if(null===config)return null;const code=yield*fs.readFile(filename,"utf8");return yield*(0, _transformation.run)(config,code)})),transformFile=transformFileRunner.errback;exports.transformFile=transformFile;const transformFileSync=transformFileRunner.sync;exports.transformFileSync=transformFileSync;const transformFileAsync=transformFileRunner.async;exports.transformFileAsync=transformFileAsync;},"./node_modules/@babel/core/lib/transform.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _gensync(){const data=__webpack_require__("./node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.transformSync=exports.transformAsync=exports.transform=void 0;var _config=__webpack_require__("./node_modules/@babel/core/lib/config/index.js"),_transformation=__webpack_require__("./node_modules/@babel/core/lib/transformation/index.js");const transformRunner=_gensync()((function*(code,opts){const config=yield*(0, _config.default)(opts);return null===config?null:yield*(0, _transformation.run)(config,code)}));exports.transform=function(code,opts,callback){if("function"==typeof opts&&(callback=opts,opts=void 0),void 0===callback)return transformRunner.sync(code,opts);transformRunner.errback(code,opts,callback);};const transformSync=transformRunner.sync;exports.transformSync=transformSync;const transformAsync=transformRunner.async;exports.transformAsync=transformAsync;},"./node_modules/@babel/core/lib/transformation/block-hoist-plugin.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _traverse(){const data=__webpack_require__("./node_modules/@babel/traverse/lib/index.js");return _traverse=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(){LOADED_PLUGIN||(LOADED_PLUGIN=new _plugin.default(Object.assign({},blockHoistPlugin,{visitor:_traverse().default.explode(blockHoistPlugin.visitor)}),{}));return LOADED_PLUGIN};var _plugin=__webpack_require__("./node_modules/@babel/core/lib/config/plugin.js");let LOADED_PLUGIN;function priority(bodyNode){const priority=null==bodyNode?void 0:bodyNode._blockHoist;return null==priority?1:!0===priority?2:priority}const blockHoistPlugin={name:"internal.blockHoist",visitor:{Block:{exit({node}){const{body}=node;let max=Math.pow(2,30)-1,hasChange=!1;for(let i=0;i<body.length;i++){const p=priority(body[i]);if(p>max){hasChange=!0;break}max=p;}hasChange&&(node.body=function(body){const buckets=Object.create(null);for(let i=0;i<body.length;i++){const n=body[i],p=priority(n);(buckets[p]||(buckets[p]=[])).push(n);}const keys=Object.keys(buckets).map((k=>+k)).sort(((a,b)=>b-a));let index=0;for(const key of keys){const bucket=buckets[key];for(const n of bucket)body[index++]=n;}return body}(body.slice()));}}}};},"./node_modules/@babel/core/lib/transformation/file/file.js":(__unused_webpack_module,exports,__webpack_require__)=>{function helpers(){const data=__webpack_require__("./node_modules/@babel/helpers/lib/index.js");return helpers=function(){return data},data}function _traverse(){const data=__webpack_require__("./node_modules/@babel/traverse/lib/index.js");return _traverse=function(){return data},data}function _codeFrame(){const data=__webpack_require__("./stubs/babel_codeframe.js");return _codeFrame=function(){return data},data}function _t(){const data=__webpack_require__("./node_modules/@babel/types/lib/index.js");return _t=function(){return data},data}function _helperModuleTransforms(){const data=__webpack_require__("./node_modules/@babel/helper-module-transforms/lib/index.js");return _helperModuleTransforms=function(){return data},data}function _semver(){const data=__webpack_require__("./node_modules/@babel/core/node_modules/semver/semver.js");return _semver=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;const{cloneNode,interpreterDirective}=_t(),errorVisitor={enter(path,state){const loc=path.node.loc;loc&&(state.loc=loc,path.stop());}};class File{constructor(options,{code,ast,inputMap}){this._map=new Map,this.opts=void 0,this.declarations={},this.path=null,this.ast={},this.scope=void 0,this.metadata={},this.code="",this.inputMap=null,this.hub={file:this,getCode:()=>this.code,getScope:()=>this.scope,addHelper:this.addHelper.bind(this),buildError:this.buildCodeFrameError.bind(this)},this.opts=options,this.code=code,this.ast=ast,this.inputMap=inputMap,this.path=_traverse().NodePath.get({hub:this.hub,parentPath:null,parent:this.ast,container:this.ast,key:"program"}).setContext(),this.scope=this.path.scope;}get shebang(){const{interpreter}=this.path.node;return interpreter?interpreter.value:""}set shebang(value){value?this.path.get("interpreter").replaceWith(interpreterDirective(value)):this.path.get("interpreter").remove();}set(key,val){if("helpersNamespace"===key)throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'.");this._map.set(key,val);}get(key){return this._map.get(key)}has(key){return this._map.has(key)}getModuleName(){return (0, _helperModuleTransforms().getModuleName)(this.opts,this.opts)}addImport(){throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-module-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.")}availableHelper(name,versionRange){let minVersion;try{minVersion=helpers().minVersion(name);}catch(err){if("BABEL_HELPER_UNKNOWN"!==err.code)throw err;return !1}return "string"!=typeof versionRange||(_semver().valid(versionRange)&&(versionRange=`^${versionRange}`),!_semver().intersects(`<${minVersion}`,versionRange)&&!_semver().intersects(">=8.0.0",versionRange))}addHelper(name){const declar=this.declarations[name];if(declar)return cloneNode(declar);const generator=this.get("helperGenerator");if(generator){const res=generator(name);if(res)return res}helpers().ensure(name,File);const uid=this.declarations[name]=this.scope.generateUidIdentifier(name),dependencies={};for(const dep of helpers().getDependencies(name))dependencies[dep]=this.addHelper(dep);const{nodes,globals}=helpers().get(name,(dep=>dependencies[dep]),uid,Object.keys(this.scope.getAllBindings()));return globals.forEach((name=>{this.path.scope.hasBinding(name,!0)&&this.path.scope.rename(name);})),nodes.forEach((node=>{node._compact=!0;})),this.path.unshiftContainer("body",nodes),this.path.get("body").forEach((path=>{-1!==nodes.indexOf(path.node)&&path.isVariableDeclaration()&&this.scope.registerDeclaration(path);})),uid}addTemplateObject(){throw new Error("This function has been moved into the template literal transform itself.")}buildCodeFrameError(node,msg,_Error=SyntaxError){let loc=node&&(node.loc||node._loc);if(!loc&&node){const state={loc:null};(0, _traverse().default)(node,errorVisitor,this.scope,state),loc=state.loc;let txt="This is an error on an internal node. Probably an internal error.";loc&&(txt+=" Location has been estimated."),msg+=` (${txt})`;}if(loc){const{highlightCode=!0}=this.opts;msg+="\n"+(0, _codeFrame().codeFrameColumns)(this.code,{start:{line:loc.start.line,column:loc.start.column+1},end:loc.end&&loc.start.line===loc.end.line?{line:loc.end.line,column:loc.end.column+1}:void 0},{highlightCode});}return new _Error(msg)}}exports.default=File;},"./node_modules/@babel/core/lib/transformation/file/generate.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _convertSourceMap(){const data=__webpack_require__("./node_modules/convert-source-map/index.js");return _convertSourceMap=function(){return data},data}function _generator(){const data=__webpack_require__("./node_modules/@babel/generator/lib/index.js");return _generator=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(pluginPasses,file){const{opts,ast,code,inputMap}=file,results=[];for(const plugins of pluginPasses)for(const plugin of plugins){const{generatorOverride}=plugin;if(generatorOverride){const result=generatorOverride(ast,opts.generatorOpts,code,_generator().default);void 0!==result&&results.push(result);}}let result;if(0===results.length)result=(0, _generator().default)(ast,opts.generatorOpts,code);else {if(1!==results.length)throw new Error("More than one plugin attempted to override codegen.");if(result=results[0],"function"==typeof result.then)throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.")}let{code:outputCode,map:outputMap}=result;outputMap&&inputMap&&(outputMap=(0, _mergeMap.default)(inputMap.toObject(),outputMap));"inline"!==opts.sourceMaps&&"both"!==opts.sourceMaps||(outputCode+="\n"+_convertSourceMap().fromObject(outputMap).toComment());"inline"===opts.sourceMaps&&(outputMap=null);return {outputCode,outputMap}};var _mergeMap=__webpack_require__("./node_modules/@babel/core/lib/transformation/file/merge-map.js");},"./node_modules/@babel/core/lib/transformation/file/merge-map.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _sourceMap(){const data=__webpack_require__("./node_modules/@babel/core/node_modules/source-map/source-map.js");return _sourceMap=function(){return data},data}function makeMappingKey(item){return `${item.line}/${item.columnStart}`}function buildMappingData(map){const consumer=new(_sourceMap().SourceMapConsumer)(Object.assign({},map,{sourceRoot:null})),sources=new Map,mappings=new Map;let last=null;return consumer.computeColumnSpans(),consumer.eachMapping((m=>{if(null===m.originalLine)return;let source=sources.get(m.source);source||(source={path:m.source,content:consumer.sourceContentFor(m.source,!0)},sources.set(m.source,source));let sourceData=mappings.get(source);sourceData||(sourceData={source,mappings:[]},mappings.set(source,sourceData));const obj={line:m.originalLine,columnStart:m.originalColumn,columnEnd:1/0,name:m.name};last&&last.source===source&&last.mapping.line===m.originalLine&&(last.mapping.columnEnd=m.originalColumn),last={source,mapping:obj},sourceData.mappings.push({original:obj,generated:consumer.allGeneratedPositionsFor({source:m.source,line:m.originalLine,column:m.originalColumn}).map((item=>({line:item.line,columnStart:item.column,columnEnd:item.lastColumn+1})))});}),null,_sourceMap().SourceMapConsumer.ORIGINAL_ORDER),{file:map.file,sourceRoot:map.sourceRoot,sources:Array.from(mappings.values())}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(inputMap,map){const input=buildMappingData(inputMap),output=buildMappingData(map),mergedGenerator=new(_sourceMap().SourceMapGenerator);for(const{source}of input.sources)"string"==typeof source.content&&mergedGenerator.setSourceContent(source.path,source.content);if(1===output.sources.length){const defaultSource=output.sources[0],insertedMappings=new Map;!function(map,callback){for(const{source,mappings}of map.sources)for(const{original,generated}of mappings)for(const item of generated)callback(item,original,source);}(input,((generated,original,source)=>{!function(outputFile,inputGeneratedRange,callback){const overlappingOriginal=function({mappings},{line,columnStart,columnEnd}){return function(array,callback){const start=function(array,callback){let left=0,right=array.length;for(;left<right;){const mid=Math.floor((left+right)/2),result=callback(array[mid]);if(0===result){left=mid;break}result>=0?right=mid:left=mid+1;}let i=left;if(i<array.length){for(;i>=0&&callback(array[i])>=0;)i--;return i+1}return i}(array,callback),results=[];for(let i=start;i<array.length&&0===callback(array[i]);i++)results.push(array[i]);return results}(mappings,(({original:outOriginal})=>line>outOriginal.line?-1:line<outOriginal.line?1:columnStart>=outOriginal.columnEnd?-1:columnEnd<=outOriginal.columnStart?1:0))}(outputFile,inputGeneratedRange);for(const{generated}of overlappingOriginal)for(const item of generated)callback(item);}(defaultSource,generated,(item=>{const key=makeMappingKey(item);insertedMappings.has(key)||(insertedMappings.set(key,item),mergedGenerator.addMapping({source:source.path,original:{line:original.line,column:original.columnStart},generated:{line:item.line,column:item.columnStart},name:original.name}));}));}));for(const item of insertedMappings.values()){if(item.columnEnd===1/0)continue;const clearItem={line:item.line,columnStart:item.columnEnd},key=makeMappingKey(clearItem);insertedMappings.has(key)||mergedGenerator.addMapping({generated:{line:clearItem.line,column:clearItem.columnStart}});}}const result=mergedGenerator.toJSON();"string"==typeof input.sourceRoot&&(result.sourceRoot=input.sourceRoot);return result};},"./node_modules/@babel/core/lib/transformation/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _traverse(){const data=__webpack_require__("./node_modules/@babel/traverse/lib/index.js");return _traverse=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.run=function*(config,code,ast){const file=yield*(0, _normalizeFile.default)(config.passes,(0, _normalizeOpts.default)(config),code,ast),opts=file.opts;try{yield*function*(file,pluginPasses){for(const pluginPairs of pluginPasses){const passPairs=[],passes=[],visitors=[];for(const plugin of pluginPairs.concat([(0,_blockHoistPlugin.default)()])){const pass=new _pluginPass.default(file,plugin.key,plugin.options);passPairs.push([plugin,pass]),passes.push(pass),visitors.push(plugin.visitor);}for(const[plugin,pass]of passPairs){const fn=plugin.pre;if(fn){const result=fn.call(pass,file);if(yield*[],isThenable(result))throw new Error("You appear to be using an plugin with an async .pre, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.")}}const visitor=_traverse().default.visitors.merge(visitors,passes,file.opts.wrapPluginVisitorMethod);(0,_traverse().default)(file.ast,visitor,file.scope);for(const[plugin,pass]of passPairs){const fn=plugin.post;if(fn){const result=fn.call(pass,file);if(yield*[],isThenable(result))throw new Error("You appear to be using an plugin with an async .post, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.")}}}}(file,config.passes);}catch(e){var _opts$filename;throw e.message=`${null!=(_opts$filename=opts.filename)?_opts$filename:"unknown"}: ${e.message}`,e.code||(e.code="BABEL_TRANSFORM_ERROR"),e}let outputCode,outputMap;try{!1!==opts.code&&({outputCode,outputMap}=(0,_generate.default)(config.passes,file));}catch(e){var _opts$filename2;throw e.message=`${null!=(_opts$filename2=opts.filename)?_opts$filename2:"unknown"}: ${e.message}`,e.code||(e.code="BABEL_GENERATE_ERROR"),e}return {metadata:file.metadata,options:opts,ast:!0===opts.ast?file.ast:null,code:void 0===outputCode?null:outputCode,map:void 0===outputMap?null:outputMap,sourceType:file.ast.program.sourceType}};var _pluginPass=__webpack_require__("./node_modules/@babel/core/lib/transformation/plugin-pass.js"),_blockHoistPlugin=__webpack_require__("./node_modules/@babel/core/lib/transformation/block-hoist-plugin.js"),_normalizeOpts=__webpack_require__("./node_modules/@babel/core/lib/transformation/normalize-opts.js"),_normalizeFile=__webpack_require__("./node_modules/@babel/core/lib/transformation/normalize-file.js"),_generate=__webpack_require__("./node_modules/@babel/core/lib/transformation/file/generate.js");function isThenable(val){return !(!val||"object"!=typeof val&&"function"!=typeof val||!val.then||"function"!=typeof val.then)}},"./node_modules/@babel/core/lib/transformation/normalize-file.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _fs(){const data=__webpack_require__("fs");return _fs=function(){return data},data}function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}function _debug(){const data=__webpack_require__("./node_modules/debug/src/index.js");return _debug=function(){return data},data}function _t(){const data=__webpack_require__("./node_modules/@babel/types/lib/index.js");return _t=function(){return data},data}function _convertSourceMap(){const data=__webpack_require__("./node_modules/convert-source-map/index.js");return _convertSourceMap=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function*(pluginPasses,options,code,ast){if(code=`${code||""}`,ast){if("Program"===ast.type)ast=file(ast,[],[]);else if("File"!==ast.type)throw new Error("AST root must be a Program or File node");options.cloneInputAst&&(ast=(0, _cloneDeep.default)(ast));}else ast=yield*(0, _parser.default)(pluginPasses,options,code);let inputMap=null;if(!1!==options.inputSourceMap){if("object"==typeof options.inputSourceMap&&(inputMap=_convertSourceMap().fromObject(options.inputSourceMap)),!inputMap){const lastComment=extractComments(INLINE_SOURCEMAP_REGEX,ast);if(lastComment)try{inputMap=_convertSourceMap().fromComment(lastComment);}catch(err){debug("discarding unknown inline input sourcemap",err);}}if(!inputMap){const lastComment=extractComments(EXTERNAL_SOURCEMAP_REGEX,ast);if("string"==typeof options.filename&&lastComment)try{const match=EXTERNAL_SOURCEMAP_REGEX.exec(lastComment),inputMapContent=_fs().readFileSync(_path().resolve(_path().dirname(options.filename),match[1]));inputMapContent.length>1e6?debug("skip merging input map > 1 MB"):inputMap=_convertSourceMap().fromJSON(inputMapContent);}catch(err){debug("discarding unknown file input sourcemap",err);}else lastComment&&debug("discarding un-loadable file input sourcemap");}}return new _file.default(options,{code,ast,inputMap})};var _file=__webpack_require__("./node_modules/@babel/core/lib/transformation/file/file.js"),_parser=__webpack_require__("./node_modules/@babel/core/lib/parser/index.js"),_cloneDeep=__webpack_require__("./node_modules/@babel/core/lib/transformation/util/clone-deep.js");const{file,traverseFast}=_t(),debug=_debug()("babel:transform:file");const INLINE_SOURCEMAP_REGEX=/^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/,EXTERNAL_SOURCEMAP_REGEX=/^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;function extractCommentsFromList(regex,comments,lastComment){return comments&&(comments=comments.filter((({value})=>!regex.test(value)||(lastComment=value,!1)))),[comments,lastComment]}function extractComments(regex,ast){let lastComment=null;return traverseFast(ast,(node=>{[node.leadingComments,lastComment]=extractCommentsFromList(regex,node.leadingComments,lastComment),[node.innerComments,lastComment]=extractCommentsFromList(regex,node.innerComments,lastComment),[node.trailingComments,lastComment]=extractCommentsFromList(regex,node.trailingComments,lastComment);})),lastComment}},"./node_modules/@babel/core/lib/transformation/normalize-opts.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(config){const{filename,cwd,filenameRelative="string"==typeof filename?_path().relative(cwd,filename):"unknown",sourceType="module",inputSourceMap,sourceMaps=!!inputSourceMap,sourceRoot=config.options.moduleRoot,sourceFileName=_path().basename(filenameRelative),comments=!0,compact="auto"}=config.options,opts=config.options,options=Object.assign({},opts,{parserOpts:Object.assign({sourceType:".mjs"===_path().extname(filenameRelative)?"module":sourceType,sourceFileName:filename,plugins:[]},opts.parserOpts),generatorOpts:Object.assign({filename,auxiliaryCommentBefore:opts.auxiliaryCommentBefore,auxiliaryCommentAfter:opts.auxiliaryCommentAfter,retainLines:opts.retainLines,comments,shouldPrintComment:opts.shouldPrintComment,compact,minified:opts.minified,sourceMaps,sourceRoot,sourceFileName},opts.generatorOpts)});for(const plugins of config.passes)for(const plugin of plugins)plugin.manipulateOptions&&plugin.manipulateOptions(options,options.parserOpts);return options};},"./node_modules/@babel/core/lib/transformation/plugin-pass.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;class PluginPass{constructor(file,key,options){this._map=new Map,this.key=void 0,this.file=void 0,this.opts=void 0,this.cwd=void 0,this.filename=void 0,this.key=key,this.file=file,this.opts=options||{},this.cwd=file.opts.cwd,this.filename=file.opts.filename;}set(key,val){this._map.set(key,val);}get(key){return this._map.get(key)}availableHelper(name,versionRange){return this.file.availableHelper(name,versionRange)}addHelper(name){return this.file.addHelper(name)}addImport(){return this.file.addImport()}buildCodeFrameError(node,msg,_Error){return this.file.buildCodeFrameError(node,msg,_Error)}}exports.default=PluginPass,PluginPass.prototype.getModuleName=function(){return this.file.getModuleName()};},"./node_modules/@babel/core/lib/transformation/util/clone-deep-browser.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(value){return JSON.parse(JSON.stringify(value,serialize),revive)};const serialized="$$ babel internal serialized type"+Math.random();function serialize(key,value){return "bigint"!=typeof value?value:{[serialized]:"BigInt",value:value.toString()}}function revive(key,value){return value&&"object"==typeof value?"BigInt"!==value[serialized]?value:BigInt(value.value):value}},"./node_modules/@babel/core/lib/transformation/util/clone-deep.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _v(){const data=__webpack_require__("v8");return _v=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(value){if(_v().deserialize&&_v().serialize)return _v().deserialize(_v().serialize(value));return (0, _cloneDeepBrowser.default)(value)};var _cloneDeepBrowser=__webpack_require__("./node_modules/@babel/core/lib/transformation/util/clone-deep-browser.js");},"./node_modules/@babel/core/lib/vendor/import-meta-resolve.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _url(){const data=__webpack_require__("url");return _url=function(){return data},data}function _fs(){const data=function(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;if(null===obj||"object"!=typeof obj&&"function"!=typeof obj)return {default:obj};var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj))return cache.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key];}newObj.default=obj,cache&&cache.set(obj,newObj);return newObj}(__webpack_require__("fs"),!0);return _fs=function(){return data},data}function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}function _assert(){const data=__webpack_require__("assert");return _assert=function(){return data},data}function _util(){const data=__webpack_require__("util");return _util=function(){return data},data}function _getRequireWildcardCache(nodeInterop){if("function"!=typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return (_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop)}function asyncGeneratorStep(gen,resolve,reject,_next,_throw,key,arg){try{var info=gen[key](arg),value=info.value;}catch(error){return void reject(error)}info.done?resolve(value):Promise.resolve(value).then(_next,_throw);}function _asyncToGenerator(fn){return function(){var self=this,args=arguments;return new Promise((function(resolve,reject){var gen=fn.apply(self,args);function _next(value){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"next",value);}function _throw(err){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"throw",err);}_next(void 0);}))}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.moduleResolve=moduleResolve,exports.resolve=function(_x,_x2){return _resolve.apply(this,arguments)};var constants={SEMVER_SPEC_VERSION:"2.0.0",MAX_LENGTH:256,MAX_SAFE_INTEGER:Number.MAX_SAFE_INTEGER||9007199254740991,MAX_SAFE_COMPONENT_LENGTH:16};var debug_1="object"==typeof process&&process.env&&process.env.NODE_DEBUG&&/\bsemver\b/i.test(process.env.NODE_DEBUG)?(...args)=>console.error("SEMVER",...args):()=>{},re_1=function(fn){var module={exports:{}};return fn(module,module.exports),module.exports}((function(module,exports){const{MAX_SAFE_COMPONENT_LENGTH}=constants,re=(exports=module.exports={}).re=[],src=exports.src=[],t=exports.t={};let R=0;const createToken=(name,value,isGlobal)=>{const index=R++;debug_1(index,value),t[name]=index,src[index]=value,re[index]=new RegExp(value,isGlobal?"g":void 0);};createToken("NUMERICIDENTIFIER","0|[1-9]\\d*"),createToken("NUMERICIDENTIFIERLOOSE","[0-9]+"),createToken("NONNUMERICIDENTIFIER","\\d*[a-zA-Z-][a-zA-Z0-9-]*"),createToken("MAINVERSION",`(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`),createToken("MAINVERSIONLOOSE",`(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`),createToken("PRERELEASEIDENTIFIER",`(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`),createToken("PRERELEASEIDENTIFIERLOOSE",`(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`),createToken("PRERELEASE",`(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`),createToken("PRERELEASELOOSE",`(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`),createToken("BUILDIDENTIFIER","[0-9A-Za-z-]+"),createToken("BUILD",`(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`),createToken("FULLPLAIN",`v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`),createToken("FULL",`^${src[t.FULLPLAIN]}$`),createToken("LOOSEPLAIN",`[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`),createToken("LOOSE",`^${src[t.LOOSEPLAIN]}$`),createToken("GTLT","((?:<|>)?=?)"),createToken("XRANGEIDENTIFIERLOOSE",`${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),createToken("XRANGEIDENTIFIER",`${src[t.NUMERICIDENTIFIER]}|x|X|\\*`),createToken("XRANGEPLAIN",`[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`),createToken("XRANGEPLAINLOOSE",`[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`),createToken("XRANGE",`^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`),createToken("XRANGELOOSE",`^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`),createToken("COERCE",`(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`),createToken("COERCERTL",src[t.COERCE],!0),createToken("LONETILDE","(?:~>?)"),createToken("TILDETRIM",`(\\s*)${src[t.LONETILDE]}\\s+`,!0),exports.tildeTrimReplace="$1~",createToken("TILDE",`^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`),createToken("TILDELOOSE",`^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`),createToken("LONECARET","(?:\\^)"),createToken("CARETTRIM",`(\\s*)${src[t.LONECARET]}\\s+`,!0),exports.caretTrimReplace="$1^",createToken("CARET",`^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`),createToken("CARETLOOSE",`^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`),createToken("COMPARATORLOOSE",`^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`),createToken("COMPARATOR",`^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`),createToken("COMPARATORTRIM",`(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`,!0),exports.comparatorTrimReplace="$1$2$3",createToken("HYPHENRANGE",`^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`),createToken("HYPHENRANGELOOSE",`^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`),createToken("STAR","(<|>)?=?\\s*\\*"),createToken("GTE0","^\\s*>=\\s*0.0.0\\s*$"),createToken("GTE0PRE","^\\s*>=\\s*0.0.0-0\\s*$");}));const opts=["includePrerelease","loose","rtl"];var parseOptions_1=options=>options?"object"!=typeof options?{loose:!0}:opts.filter((k=>options[k])).reduce(((options,k)=>(options[k]=!0,options)),{}):{};const numeric=/^[0-9]+$/,compareIdentifiers$1=(a,b)=>{const anum=numeric.test(a),bnum=numeric.test(b);return anum&&bnum&&(a=+a,b=+b),a===b?0:anum&&!bnum?-1:bnum&&!anum?1:a<b?-1:1};var identifiers={compareIdentifiers:compareIdentifiers$1,rcompareIdentifiers:(a,b)=>compareIdentifiers$1(b,a)};const{MAX_LENGTH:MAX_LENGTH$1,MAX_SAFE_INTEGER}=constants,{re:re$4,t:t$4}=re_1,{compareIdentifiers}=identifiers;class SemVer{constructor(version,options){if(options=parseOptions_1(options),version instanceof SemVer){if(version.loose===!!options.loose&&version.includePrerelease===!!options.includePrerelease)return version;version=version.version;}else if("string"!=typeof version)throw new TypeError(`Invalid Version: ${version}`);if(version.length>MAX_LENGTH$1)throw new TypeError(`version is longer than ${MAX_LENGTH$1} characters`);debug_1("SemVer",version,options),this.options=options,this.loose=!!options.loose,this.includePrerelease=!!options.includePrerelease;const m=version.trim().match(options.loose?re$4[t$4.LOOSE]:re$4[t$4.FULL]);if(!m)throw new TypeError(`Invalid Version: ${version}`);if(this.raw=version,this.major=+m[1],this.minor=+m[2],this.patch=+m[3],this.major>MAX_SAFE_INTEGER||this.major<0)throw new TypeError("Invalid major version");if(this.minor>MAX_SAFE_INTEGER||this.minor<0)throw new TypeError("Invalid minor version");if(this.patch>MAX_SAFE_INTEGER||this.patch<0)throw new TypeError("Invalid patch version");m[4]?this.prerelease=m[4].split(".").map((id=>{if(/^[0-9]+$/.test(id)){const num=+id;if(num>=0&&num<MAX_SAFE_INTEGER)return num}return id})):this.prerelease=[],this.build=m[5]?m[5].split("."):[],this.format();}format(){return this.version=`${this.major}.${this.minor}.${this.patch}`,this.prerelease.length&&(this.version+=`-${this.prerelease.join(".")}`),this.version}toString(){return this.version}compare(other){if(debug_1("SemVer.compare",this.version,this.options,other),!(other instanceof SemVer)){if("string"==typeof other&&other===this.version)return 0;other=new SemVer(other,this.options);}return other.version===this.version?0:this.compareMain(other)||this.comparePre(other)}compareMain(other){return other instanceof SemVer||(other=new SemVer(other,this.options)),compareIdentifiers(this.major,other.major)||compareIdentifiers(this.minor,other.minor)||compareIdentifiers(this.patch,other.patch)}comparePre(other){if(other instanceof SemVer||(other=new SemVer(other,this.options)),this.prerelease.length&&!other.prerelease.length)return -1;if(!this.prerelease.length&&other.prerelease.length)return 1;if(!this.prerelease.length&&!other.prerelease.length)return 0;let i=0;do{const a=this.prerelease[i],b=other.prerelease[i];if(debug_1("prerelease compare",i,a,b),void 0===a&&void 0===b)return 0;if(void 0===b)return 1;if(void 0===a)return -1;if(a!==b)return compareIdentifiers(a,b)}while(++i)}compareBuild(other){other instanceof SemVer||(other=new SemVer(other,this.options));let i=0;do{const a=this.build[i],b=other.build[i];if(debug_1("prerelease compare",i,a,b),void 0===a&&void 0===b)return 0;if(void 0===b)return 1;if(void 0===a)return -1;if(a!==b)return compareIdentifiers(a,b)}while(++i)}inc(release,identifier){switch(release){case"premajor":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc("pre",identifier);break;case"preminor":this.prerelease.length=0,this.patch=0,this.minor++,this.inc("pre",identifier);break;case"prepatch":this.prerelease.length=0,this.inc("patch",identifier),this.inc("pre",identifier);break;case"prerelease":0===this.prerelease.length&&this.inc("patch",identifier),this.inc("pre",identifier);break;case"major":0===this.minor&&0===this.patch&&0!==this.prerelease.length||this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case"minor":0===this.patch&&0!==this.prerelease.length||this.minor++,this.patch=0,this.prerelease=[];break;case"patch":0===this.prerelease.length&&this.patch++,this.prerelease=[];break;case"pre":if(0===this.prerelease.length)this.prerelease=[0];else {let i=this.prerelease.length;for(;--i>=0;)"number"==typeof this.prerelease[i]&&(this.prerelease[i]++,i=-2);-1===i&&this.prerelease.push(0);}identifier&&(this.prerelease[0]===identifier?isNaN(this.prerelease[1])&&(this.prerelease=[identifier,0]):this.prerelease=[identifier,0]);break;default:throw new Error(`invalid increment argument: ${release}`)}return this.format(),this.raw=this.version,this}}var semver$1=SemVer;const{MAX_LENGTH}=constants,{re:re$3,t:t$3}=re_1;var parse_1=(version,options)=>{if(options=parseOptions_1(options),version instanceof semver$1)return version;if("string"!=typeof version)return null;if(version.length>MAX_LENGTH)return null;if(!(options.loose?re$3[t$3.LOOSE]:re$3[t$3.FULL]).test(version))return null;try{return new semver$1(version,options)}catch(er){return null}};var valid_1=(version,options)=>{const v=parse_1(version,options);return v?v.version:null};var clean_1=(version,options)=>{const s=parse_1(version.trim().replace(/^[=v]+/,""),options);return s?s.version:null};var inc_1=(version,release,options,identifier)=>{"string"==typeof options&&(identifier=options,options=void 0);try{return new semver$1(version,options).inc(release,identifier).version}catch(er){return null}};var compare_1=(a,b,loose)=>new semver$1(a,loose).compare(new semver$1(b,loose));var eq_1=(a,b,loose)=>0===compare_1(a,b,loose);var diff_1=(version1,version2)=>{if(eq_1(version1,version2))return null;{const v1=parse_1(version1),v2=parse_1(version2),hasPre=v1.prerelease.length||v2.prerelease.length,prefix=hasPre?"pre":"",defaultResult=hasPre?"prerelease":"";for(const key in v1)if(("major"===key||"minor"===key||"patch"===key)&&v1[key]!==v2[key])return prefix+key;return defaultResult}};var major_1=(a,loose)=>new semver$1(a,loose).major;var minor_1=(a,loose)=>new semver$1(a,loose).minor;var patch_1=(a,loose)=>new semver$1(a,loose).patch;var prerelease_1=(version,options)=>{const parsed=parse_1(version,options);return parsed&&parsed.prerelease.length?parsed.prerelease:null};var rcompare_1=(a,b,loose)=>compare_1(b,a,loose);var compareLoose_1=(a,b)=>compare_1(a,b,!0);var compareBuild_1=(a,b,loose)=>{const versionA=new semver$1(a,loose),versionB=new semver$1(b,loose);return versionA.compare(versionB)||versionA.compareBuild(versionB)};var sort_1=(list,loose)=>list.sort(((a,b)=>compareBuild_1(a,b,loose)));var rsort_1=(list,loose)=>list.sort(((a,b)=>compareBuild_1(b,a,loose)));var gt_1=(a,b,loose)=>compare_1(a,b,loose)>0;var lt_1=(a,b,loose)=>compare_1(a,b,loose)<0;var neq_1=(a,b,loose)=>0!==compare_1(a,b,loose);var gte_1=(a,b,loose)=>compare_1(a,b,loose)>=0;var lte_1=(a,b,loose)=>compare_1(a,b,loose)<=0;var cmp_1=(a,op,b,loose)=>{switch(op){case"===":return "object"==typeof a&&(a=a.version),"object"==typeof b&&(b=b.version),a===b;case"!==":return "object"==typeof a&&(a=a.version),"object"==typeof b&&(b=b.version),a!==b;case"":case"=":case"==":return eq_1(a,b,loose);case"!=":return neq_1(a,b,loose);case">":return gt_1(a,b,loose);case">=":return gte_1(a,b,loose);case"<":return lt_1(a,b,loose);case"<=":return lte_1(a,b,loose);default:throw new TypeError(`Invalid operator: ${op}`)}};const{re:re$2,t:t$2}=re_1;var coerce_1=(version,options)=>{if(version instanceof semver$1)return version;if("number"==typeof version&&(version=String(version)),"string"!=typeof version)return null;let match=null;if((options=options||{}).rtl){let next;for(;(next=re$2[t$2.COERCERTL].exec(version))&&(!match||match.index+match[0].length!==version.length);)match&&next.index+next[0].length===match.index+match[0].length||(match=next),re$2[t$2.COERCERTL].lastIndex=next.index+next[1].length+next[2].length;re$2[t$2.COERCERTL].lastIndex=-1;}else match=version.match(re$2[t$2.COERCE]);return null===match?null:parse_1(`${match[2]}.${match[3]||"0"}.${match[4]||"0"}`,options)},yallist=Yallist;function Yallist(list){var self=this;if(self instanceof Yallist||(self=new Yallist),self.tail=null,self.head=null,self.length=0,list&&"function"==typeof list.forEach)list.forEach((function(item){self.push(item);}));else if(arguments.length>0)for(var i=0,l=arguments.length;i<l;i++)self.push(arguments[i]);return self}function insert(self,node,value){var inserted=node===self.head?new Node(value,null,node,self):new Node(value,node,node.next,self);return null===inserted.next&&(self.tail=inserted),null===inserted.prev&&(self.head=inserted),self.length++,inserted}function push(self,item){self.tail=new Node(item,self.tail,null,self),self.head||(self.head=self.tail),self.length++;}function unshift(self,item){self.head=new Node(item,null,self.head,self),self.tail||(self.tail=self.head),self.length++;}function Node(value,prev,next,list){if(!(this instanceof Node))return new Node(value,prev,next,list);this.list=list,this.value=value,prev?(prev.next=this,this.prev=prev):this.prev=null,next?(next.prev=this,this.next=next):this.next=null;}Yallist.Node=Node,Yallist.create=Yallist,Yallist.prototype.removeNode=function(node){if(node.list!==this)throw new Error("removing node which does not belong to this list");var next=node.next,prev=node.prev;return next&&(next.prev=prev),prev&&(prev.next=next),node===this.head&&(this.head=next),node===this.tail&&(this.tail=prev),node.list.length--,node.next=null,node.prev=null,node.list=null,next},Yallist.prototype.unshiftNode=function(node){if(node!==this.head){node.list&&node.list.removeNode(node);var head=this.head;node.list=this,node.next=head,head&&(head.prev=node),this.head=node,this.tail||(this.tail=node),this.length++;}},Yallist.prototype.pushNode=function(node){if(node!==this.tail){node.list&&node.list.removeNode(node);var tail=this.tail;node.list=this,node.prev=tail,tail&&(tail.next=node),this.tail=node,this.head||(this.head=node),this.length++;}},Yallist.prototype.push=function(){for(var i=0,l=arguments.length;i<l;i++)push(this,arguments[i]);return this.length},Yallist.prototype.unshift=function(){for(var i=0,l=arguments.length;i<l;i++)unshift(this,arguments[i]);return this.length},Yallist.prototype.pop=function(){if(this.tail){var res=this.tail.value;return this.tail=this.tail.prev,this.tail?this.tail.next=null:this.head=null,this.length--,res}},Yallist.prototype.shift=function(){if(this.head){var res=this.head.value;return this.head=this.head.next,this.head?this.head.prev=null:this.tail=null,this.length--,res}},Yallist.prototype.forEach=function(fn,thisp){thisp=thisp||this;for(var walker=this.head,i=0;null!==walker;i++)fn.call(thisp,walker.value,i,this),walker=walker.next;},Yallist.prototype.forEachReverse=function(fn,thisp){thisp=thisp||this;for(var walker=this.tail,i=this.length-1;null!==walker;i--)fn.call(thisp,walker.value,i,this),walker=walker.prev;},Yallist.prototype.get=function(n){for(var i=0,walker=this.head;null!==walker&&i<n;i++)walker=walker.next;if(i===n&&null!==walker)return walker.value},Yallist.prototype.getReverse=function(n){for(var i=0,walker=this.tail;null!==walker&&i<n;i++)walker=walker.prev;if(i===n&&null!==walker)return walker.value},Yallist.prototype.map=function(fn,thisp){thisp=thisp||this;for(var res=new Yallist,walker=this.head;null!==walker;)res.push(fn.call(thisp,walker.value,this)),walker=walker.next;return res},Yallist.prototype.mapReverse=function(fn,thisp){thisp=thisp||this;for(var res=new Yallist,walker=this.tail;null!==walker;)res.push(fn.call(thisp,walker.value,this)),walker=walker.prev;return res},Yallist.prototype.reduce=function(fn,initial){var acc,walker=this.head;if(arguments.length>1)acc=initial;else {if(!this.head)throw new TypeError("Reduce of empty list with no initial value");walker=this.head.next,acc=this.head.value;}for(var i=0;null!==walker;i++)acc=fn(acc,walker.value,i),walker=walker.next;return acc},Yallist.prototype.reduceReverse=function(fn,initial){var acc,walker=this.tail;if(arguments.length>1)acc=initial;else {if(!this.tail)throw new TypeError("Reduce of empty list with no initial value");walker=this.tail.prev,acc=this.tail.value;}for(var i=this.length-1;null!==walker;i--)acc=fn(acc,walker.value,i),walker=walker.prev;return acc},Yallist.prototype.toArray=function(){for(var arr=new Array(this.length),i=0,walker=this.head;null!==walker;i++)arr[i]=walker.value,walker=walker.next;return arr},Yallist.prototype.toArrayReverse=function(){for(var arr=new Array(this.length),i=0,walker=this.tail;null!==walker;i++)arr[i]=walker.value,walker=walker.prev;return arr},Yallist.prototype.slice=function(from,to){(to=to||this.length)<0&&(to+=this.length),(from=from||0)<0&&(from+=this.length);var ret=new Yallist;if(to<from||to<0)return ret;from<0&&(from=0),to>this.length&&(to=this.length);for(var i=0,walker=this.head;null!==walker&&i<from;i++)walker=walker.next;for(;null!==walker&&i<to;i++,walker=walker.next)ret.push(walker.value);return ret},Yallist.prototype.sliceReverse=function(from,to){(to=to||this.length)<0&&(to+=this.length),(from=from||0)<0&&(from+=this.length);var ret=new Yallist;if(to<from||to<0)return ret;from<0&&(from=0),to>this.length&&(to=this.length);for(var i=this.length,walker=this.tail;null!==walker&&i>to;i--)walker=walker.prev;for(;null!==walker&&i>from;i--,walker=walker.prev)ret.push(walker.value);return ret},Yallist.prototype.splice=function(start,deleteCount,...nodes){start>this.length&&(start=this.length-1),start<0&&(start=this.length+start);for(var i=0,walker=this.head;null!==walker&&i<start;i++)walker=walker.next;var ret=[];for(i=0;walker&&i<deleteCount;i++)ret.push(walker.value),walker=this.removeNode(walker);null===walker&&(walker=this.tail),walker!==this.head&&walker!==this.tail&&(walker=walker.prev);for(i=0;i<nodes.length;i++)walker=insert(this,walker,nodes[i]);return ret},Yallist.prototype.reverse=function(){for(var head=this.head,tail=this.tail,walker=head;null!==walker;walker=walker.prev){var p=walker.prev;walker.prev=walker.next,walker.next=p;}return this.head=tail,this.tail=head,this};try{!function(Yallist){Yallist.prototype[Symbol.iterator]=function*(){for(let walker=this.head;walker;walker=walker.next)yield walker.value;};}(Yallist);}catch(er){}const MAX=Symbol("max"),LENGTH=Symbol("length"),LENGTH_CALCULATOR=Symbol("lengthCalculator"),ALLOW_STALE=Symbol("allowStale"),MAX_AGE=Symbol("maxAge"),DISPOSE=Symbol("dispose"),NO_DISPOSE_ON_SET=Symbol("noDisposeOnSet"),LRU_LIST=Symbol("lruList"),CACHE=Symbol("cache"),UPDATE_AGE_ON_GET=Symbol("updateAgeOnGet"),naiveLength=()=>1;const get=(self,key,doUse)=>{const node=self[CACHE].get(key);if(node){const hit=node.value;if(isStale(self,hit)){if(del(self,node),!self[ALLOW_STALE])return}else doUse&&(self[UPDATE_AGE_ON_GET]&&(node.value.now=Date.now()),self[LRU_LIST].unshiftNode(node));return hit.value}},isStale=(self,hit)=>{if(!hit||!hit.maxAge&&!self[MAX_AGE])return !1;const diff=Date.now()-hit.now;return hit.maxAge?diff>hit.maxAge:self[MAX_AGE]&&diff>self[MAX_AGE]},trim=self=>{if(self[LENGTH]>self[MAX])for(let walker=self[LRU_LIST].tail;self[LENGTH]>self[MAX]&&null!==walker;){const prev=walker.prev;del(self,walker),walker=prev;}},del=(self,node)=>{if(node){const hit=node.value;self[DISPOSE]&&self[DISPOSE](hit.key,hit.value),self[LENGTH]-=hit.length,self[CACHE].delete(hit.key),self[LRU_LIST].removeNode(node);}};class Entry{constructor(key,value,length,now,maxAge){this.key=key,this.value=value,this.length=length,this.now=now,this.maxAge=maxAge||0;}}const forEachStep=(self,fn,node,thisp)=>{let hit=node.value;isStale(self,hit)&&(del(self,node),self[ALLOW_STALE]||(hit=void 0)),hit&&fn.call(thisp,hit.value,hit.key,self);};var lruCache=class{constructor(options){if("number"==typeof options&&(options={max:options}),options||(options={}),options.max&&("number"!=typeof options.max||options.max<0))throw new TypeError("max must be a non-negative number");this[MAX]=options.max||1/0;const lc=options.length||naiveLength;if(this[LENGTH_CALCULATOR]="function"!=typeof lc?naiveLength:lc,this[ALLOW_STALE]=options.stale||!1,options.maxAge&&"number"!=typeof options.maxAge)throw new TypeError("maxAge must be a number");this[MAX_AGE]=options.maxAge||0,this[DISPOSE]=options.dispose,this[NO_DISPOSE_ON_SET]=options.noDisposeOnSet||!1,this[UPDATE_AGE_ON_GET]=options.updateAgeOnGet||!1,this.reset();}set max(mL){if("number"!=typeof mL||mL<0)throw new TypeError("max must be a non-negative number");this[MAX]=mL||1/0,trim(this);}get max(){return this[MAX]}set allowStale(allowStale){this[ALLOW_STALE]=!!allowStale;}get allowStale(){return this[ALLOW_STALE]}set maxAge(mA){if("number"!=typeof mA)throw new TypeError("maxAge must be a non-negative number");this[MAX_AGE]=mA,trim(this);}get maxAge(){return this[MAX_AGE]}set lengthCalculator(lC){"function"!=typeof lC&&(lC=naiveLength),lC!==this[LENGTH_CALCULATOR]&&(this[LENGTH_CALCULATOR]=lC,this[LENGTH]=0,this[LRU_LIST].forEach((hit=>{hit.length=this[LENGTH_CALCULATOR](hit.value,hit.key),this[LENGTH]+=hit.length;}))),trim(this);}get lengthCalculator(){return this[LENGTH_CALCULATOR]}get length(){return this[LENGTH]}get itemCount(){return this[LRU_LIST].length}rforEach(fn,thisp){thisp=thisp||this;for(let walker=this[LRU_LIST].tail;null!==walker;){const prev=walker.prev;forEachStep(this,fn,walker,thisp),walker=prev;}}forEach(fn,thisp){thisp=thisp||this;for(let walker=this[LRU_LIST].head;null!==walker;){const next=walker.next;forEachStep(this,fn,walker,thisp),walker=next;}}keys(){return this[LRU_LIST].toArray().map((k=>k.key))}values(){return this[LRU_LIST].toArray().map((k=>k.value))}reset(){this[DISPOSE]&&this[LRU_LIST]&&this[LRU_LIST].length&&this[LRU_LIST].forEach((hit=>this[DISPOSE](hit.key,hit.value))),this[CACHE]=new Map,this[LRU_LIST]=new yallist,this[LENGTH]=0;}dump(){return this[LRU_LIST].map((hit=>!isStale(this,hit)&&{k:hit.key,v:hit.value,e:hit.now+(hit.maxAge||0)})).toArray().filter((h=>h))}dumpLru(){return this[LRU_LIST]}set(key,value,maxAge){if((maxAge=maxAge||this[MAX_AGE])&&"number"!=typeof maxAge)throw new TypeError("maxAge must be a number");const now=maxAge?Date.now():0,len=this[LENGTH_CALCULATOR](value,key);if(this[CACHE].has(key)){if(len>this[MAX])return del(this,this[CACHE].get(key)),!1;const item=this[CACHE].get(key).value;return this[DISPOSE]&&(this[NO_DISPOSE_ON_SET]||this[DISPOSE](key,item.value)),item.now=now,item.maxAge=maxAge,item.value=value,this[LENGTH]+=len-item.length,item.length=len,this.get(key),trim(this),!0}const hit=new Entry(key,value,len,now,maxAge);return hit.length>this[MAX]?(this[DISPOSE]&&this[DISPOSE](key,value),!1):(this[LENGTH]+=hit.length,this[LRU_LIST].unshift(hit),this[CACHE].set(key,this[LRU_LIST].head),trim(this),!0)}has(key){if(!this[CACHE].has(key))return !1;const hit=this[CACHE].get(key).value;return !isStale(this,hit)}get(key){return get(this,key,!0)}peek(key){return get(this,key,!1)}pop(){const node=this[LRU_LIST].tail;return node?(del(this,node),node.value):null}del(key){del(this,this[CACHE].get(key));}load(arr){this.reset();const now=Date.now();for(let l=arr.length-1;l>=0;l--){const hit=arr[l],expiresAt=hit.e||0;if(0===expiresAt)this.set(hit.k,hit.v);else {const maxAge=expiresAt-now;maxAge>0&&this.set(hit.k,hit.v,maxAge);}}}prune(){this[CACHE].forEach(((value,key)=>get(this,key,!1)));}};class Range{constructor(range,options){if(options=parseOptions_1(options),range instanceof Range)return range.loose===!!options.loose&&range.includePrerelease===!!options.includePrerelease?range:new Range(range.raw,options);if(range instanceof comparator)return this.raw=range.value,this.set=[[range]],this.format(),this;if(this.options=options,this.loose=!!options.loose,this.includePrerelease=!!options.includePrerelease,this.raw=range,this.set=range.split(/\s*\|\|\s*/).map((range=>this.parseRange(range.trim()))).filter((c=>c.length)),!this.set.length)throw new TypeError(`Invalid SemVer Range: ${range}`);if(this.set.length>1){const first=this.set[0];if(this.set=this.set.filter((c=>!isNullSet(c[0]))),0===this.set.length)this.set=[first];else if(this.set.length>1)for(const c of this.set)if(1===c.length&&isAny(c[0])){this.set=[c];break}}this.format();}format(){return this.range=this.set.map((comps=>comps.join(" ").trim())).join("||").trim(),this.range}toString(){return this.range}parseRange(range){range=range.trim();const memoKey=`parseRange:${Object.keys(this.options).join(",")}:${range}`,cached=cache.get(memoKey);if(cached)return cached;const loose=this.options.loose,hr=loose?re$1[t$1.HYPHENRANGELOOSE]:re$1[t$1.HYPHENRANGE];range=range.replace(hr,hyphenReplace(this.options.includePrerelease)),debug_1("hyphen replace",range),range=range.replace(re$1[t$1.COMPARATORTRIM],comparatorTrimReplace),debug_1("comparator trim",range,re$1[t$1.COMPARATORTRIM]),range=(range=(range=range.replace(re$1[t$1.TILDETRIM],tildeTrimReplace)).replace(re$1[t$1.CARETTRIM],caretTrimReplace)).split(/\s+/).join(" ");const compRe=loose?re$1[t$1.COMPARATORLOOSE]:re$1[t$1.COMPARATOR],rangeList=range.split(" ").map((comp=>parseComparator(comp,this.options))).join(" ").split(/\s+/).map((comp=>replaceGTE0(comp,this.options))).filter(this.options.loose?comp=>!!comp.match(compRe):()=>!0).map((comp=>new comparator(comp,this.options)));rangeList.length;const rangeMap=new Map;for(const comp of rangeList){if(isNullSet(comp))return [comp];rangeMap.set(comp.value,comp);}rangeMap.size>1&&rangeMap.has("")&&rangeMap.delete("");const result=[...rangeMap.values()];return cache.set(memoKey,result),result}intersects(range,options){if(!(range instanceof Range))throw new TypeError("a Range is required");return this.set.some((thisComparators=>isSatisfiable(thisComparators,options)&&range.set.some((rangeComparators=>isSatisfiable(rangeComparators,options)&&thisComparators.every((thisComparator=>rangeComparators.every((rangeComparator=>thisComparator.intersects(rangeComparator,options)))))))))}test(version){if(!version)return !1;if("string"==typeof version)try{version=new semver$1(version,this.options);}catch(er){return !1}for(let i=0;i<this.set.length;i++)if(testSet(this.set[i],version,this.options))return !0;return !1}}var range=Range;const cache=new lruCache({max:1e3}),{re:re$1,t:t$1,comparatorTrimReplace,tildeTrimReplace,caretTrimReplace}=re_1,isNullSet=c=>"<0.0.0-0"===c.value,isAny=c=>""===c.value,isSatisfiable=(comparators,options)=>{let result=!0;const remainingComparators=comparators.slice();let testComparator=remainingComparators.pop();for(;result&&remainingComparators.length;)result=remainingComparators.every((otherComparator=>testComparator.intersects(otherComparator,options))),testComparator=remainingComparators.pop();return result},parseComparator=(comp,options)=>(debug_1("comp",comp,options),comp=replaceCarets(comp,options),debug_1("caret",comp),comp=replaceTildes(comp,options),debug_1("tildes",comp),comp=replaceXRanges(comp,options),debug_1("xrange",comp),comp=replaceStars(comp,options),debug_1("stars",comp),comp),isX=id=>!id||"x"===id.toLowerCase()||"*"===id,replaceTildes=(comp,options)=>comp.trim().split(/\s+/).map((comp=>replaceTilde(comp,options))).join(" "),replaceTilde=(comp,options)=>{const r=options.loose?re$1[t$1.TILDELOOSE]:re$1[t$1.TILDE];return comp.replace(r,((_,M,m,p,pr)=>{let ret;return debug_1("tilde",comp,_,M,m,p,pr),isX(M)?ret="":isX(m)?ret=`>=${M}.0.0 <${+M+1}.0.0-0`:isX(p)?ret=`>=${M}.${m}.0 <${M}.${+m+1}.0-0`:pr?(debug_1("replaceTilde pr",pr),ret=`>=${M}.${m}.${p}-${pr} <${M}.${+m+1}.0-0`):ret=`>=${M}.${m}.${p} <${M}.${+m+1}.0-0`,debug_1("tilde return",ret),ret}))},replaceCarets=(comp,options)=>comp.trim().split(/\s+/).map((comp=>replaceCaret(comp,options))).join(" "),replaceCaret=(comp,options)=>{debug_1("caret",comp,options);const r=options.loose?re$1[t$1.CARETLOOSE]:re$1[t$1.CARET],z=options.includePrerelease?"-0":"";return comp.replace(r,((_,M,m,p,pr)=>{let ret;return debug_1("caret",comp,_,M,m,p,pr),isX(M)?ret="":isX(m)?ret=`>=${M}.0.0${z} <${+M+1}.0.0-0`:isX(p)?ret="0"===M?`>=${M}.${m}.0${z} <${M}.${+m+1}.0-0`:`>=${M}.${m}.0${z} <${+M+1}.0.0-0`:pr?(debug_1("replaceCaret pr",pr),ret="0"===M?"0"===m?`>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p+1}-0`:`>=${M}.${m}.${p}-${pr} <${M}.${+m+1}.0-0`:`>=${M}.${m}.${p}-${pr} <${+M+1}.0.0-0`):(debug_1("no pr"),ret="0"===M?"0"===m?`>=${M}.${m}.${p}${z} <${M}.${m}.${+p+1}-0`:`>=${M}.${m}.${p}${z} <${M}.${+m+1}.0-0`:`>=${M}.${m}.${p} <${+M+1}.0.0-0`),debug_1("caret return",ret),ret}))},replaceXRanges=(comp,options)=>(debug_1("replaceXRanges",comp,options),comp.split(/\s+/).map((comp=>replaceXRange(comp,options))).join(" ")),replaceXRange=(comp,options)=>{comp=comp.trim();const r=options.loose?re$1[t$1.XRANGELOOSE]:re$1[t$1.XRANGE];return comp.replace(r,((ret,gtlt,M,m,p,pr)=>{debug_1("xRange",comp,ret,gtlt,M,m,p,pr);const xM=isX(M),xm=xM||isX(m),xp=xm||isX(p),anyX=xp;return "="===gtlt&&anyX&&(gtlt=""),pr=options.includePrerelease?"-0":"",xM?ret=">"===gtlt||"<"===gtlt?"<0.0.0-0":"*":gtlt&&anyX?(xm&&(m=0),p=0,">"===gtlt?(gtlt=">=",xm?(M=+M+1,m=0,p=0):(m=+m+1,p=0)):"<="===gtlt&&(gtlt="<",xm?M=+M+1:m=+m+1),"<"===gtlt&&(pr="-0"),ret=`${gtlt+M}.${m}.${p}${pr}`):xm?ret=`>=${M}.0.0${pr} <${+M+1}.0.0-0`:xp&&(ret=`>=${M}.${m}.0${pr} <${M}.${+m+1}.0-0`),debug_1("xRange return",ret),ret}))},replaceStars=(comp,options)=>(debug_1("replaceStars",comp,options),comp.trim().replace(re$1[t$1.STAR],"")),replaceGTE0=(comp,options)=>(debug_1("replaceGTE0",comp,options),comp.trim().replace(re$1[options.includePrerelease?t$1.GTE0PRE:t$1.GTE0],"")),hyphenReplace=incPr=>($0,from,fM,fm,fp,fpr,fb,to,tM,tm,tp,tpr,tb)=>`${from=isX(fM)?"":isX(fm)?`>=${fM}.0.0${incPr?"-0":""}`:isX(fp)?`>=${fM}.${fm}.0${incPr?"-0":""}`:fpr?`>=${from}`:`>=${from}${incPr?"-0":""}`} ${to=isX(tM)?"":isX(tm)?`<${+tM+1}.0.0-0`:isX(tp)?`<${tM}.${+tm+1}.0-0`:tpr?`<=${tM}.${tm}.${tp}-${tpr}`:incPr?`<${tM}.${tm}.${+tp+1}-0`:`<=${to}`}`.trim(),testSet=(set,version,options)=>{for(let i=0;i<set.length;i++)if(!set[i].test(version))return !1;if(version.prerelease.length&&!options.includePrerelease){for(let i=0;i<set.length;i++)if(debug_1(set[i].semver),set[i].semver!==comparator.ANY&&set[i].semver.prerelease.length>0){const allowed=set[i].semver;if(allowed.major===version.major&&allowed.minor===version.minor&&allowed.patch===version.patch)return !0}return !1}return !0},ANY$2=Symbol("SemVer ANY");class Comparator{static get ANY(){return ANY$2}constructor(comp,options){if(options=parseOptions_1(options),comp instanceof Comparator){if(comp.loose===!!options.loose)return comp;comp=comp.value;}debug_1("comparator",comp,options),this.options=options,this.loose=!!options.loose,this.parse(comp),this.semver===ANY$2?this.value="":this.value=this.operator+this.semver.version,debug_1("comp",this);}parse(comp){const r=this.options.loose?re[t.COMPARATORLOOSE]:re[t.COMPARATOR],m=comp.match(r);if(!m)throw new TypeError(`Invalid comparator: ${comp}`);this.operator=void 0!==m[1]?m[1]:"","="===this.operator&&(this.operator=""),m[2]?this.semver=new semver$1(m[2],this.options.loose):this.semver=ANY$2;}toString(){return this.value}test(version){if(debug_1("Comparator.test",version,this.options.loose),this.semver===ANY$2||version===ANY$2)return !0;if("string"==typeof version)try{version=new semver$1(version,this.options);}catch(er){return !1}return cmp_1(version,this.operator,this.semver,this.options)}intersects(comp,options){if(!(comp instanceof Comparator))throw new TypeError("a Comparator is required");if(options&&"object"==typeof options||(options={loose:!!options,includePrerelease:!1}),""===this.operator)return ""===this.value||new range(comp.value,options).test(this.value);if(""===comp.operator)return ""===comp.value||new range(this.value,options).test(comp.semver);const sameDirectionIncreasing=!(">="!==this.operator&&">"!==this.operator||">="!==comp.operator&&">"!==comp.operator),sameDirectionDecreasing=!("<="!==this.operator&&"<"!==this.operator||"<="!==comp.operator&&"<"!==comp.operator),sameSemVer=this.semver.version===comp.semver.version,differentDirectionsInclusive=!(">="!==this.operator&&"<="!==this.operator||">="!==comp.operator&&"<="!==comp.operator),oppositeDirectionsLessThan=cmp_1(this.semver,"<",comp.semver,options)&&(">="===this.operator||">"===this.operator)&&("<="===comp.operator||"<"===comp.operator),oppositeDirectionsGreaterThan=cmp_1(this.semver,">",comp.semver,options)&&("<="===this.operator||"<"===this.operator)&&(">="===comp.operator||">"===comp.operator);return sameDirectionIncreasing||sameDirectionDecreasing||sameSemVer&&differentDirectionsInclusive||oppositeDirectionsLessThan||oppositeDirectionsGreaterThan}}var comparator=Comparator;const{re,t}=re_1;var satisfies_1=(version,range$1,options)=>{try{range$1=new range(range$1,options);}catch(er){return !1}return range$1.test(version)};var toComparators_1=(range$1,options)=>new range(range$1,options).set.map((comp=>comp.map((c=>c.value)).join(" ").trim().split(" ")));var maxSatisfying_1=(versions,range$1,options)=>{let max=null,maxSV=null,rangeObj=null;try{rangeObj=new range(range$1,options);}catch(er){return null}return versions.forEach((v=>{rangeObj.test(v)&&(max&&-1!==maxSV.compare(v)||(max=v,maxSV=new semver$1(max,options)));})),max};var minSatisfying_1=(versions,range$1,options)=>{let min=null,minSV=null,rangeObj=null;try{rangeObj=new range(range$1,options);}catch(er){return null}return versions.forEach((v=>{rangeObj.test(v)&&(min&&1!==minSV.compare(v)||(min=v,minSV=new semver$1(min,options)));})),min};var minVersion_1=(range$1,loose)=>{range$1=new range(range$1,loose);let minver=new semver$1("0.0.0");if(range$1.test(minver))return minver;if(minver=new semver$1("0.0.0-0"),range$1.test(minver))return minver;minver=null;for(let i=0;i<range$1.set.length;++i){const comparators=range$1.set[i];let setMin=null;comparators.forEach((comparator=>{const compver=new semver$1(comparator.semver.version);switch(comparator.operator){case">":0===compver.prerelease.length?compver.patch++:compver.prerelease.push(0),compver.raw=compver.format();case"":case">=":setMin&&!gt_1(compver,setMin)||(setMin=compver);break;case"<":case"<=":break;default:throw new Error(`Unexpected operation: ${comparator.operator}`)}})),!setMin||minver&&!gt_1(minver,setMin)||(minver=setMin);}return minver&&range$1.test(minver)?minver:null};var valid=(range$1,options)=>{try{return new range(range$1,options).range||"*"}catch(er){return null}};const{ANY:ANY$1}=comparator;var outside_1=(version,range$1,hilo,options)=>{let gtfn,ltefn,ltfn,comp,ecomp;switch(version=new semver$1(version,options),range$1=new range(range$1,options),hilo){case">":gtfn=gt_1,ltefn=lte_1,ltfn=lt_1,comp=">",ecomp=">=";break;case"<":gtfn=lt_1,ltefn=gte_1,ltfn=gt_1,comp="<",ecomp="<=";break;default:throw new TypeError('Must provide a hilo val of "<" or ">"')}if(satisfies_1(version,range$1,options))return !1;for(let i=0;i<range$1.set.length;++i){const comparators=range$1.set[i];let high=null,low=null;if(comparators.forEach((comparator$1=>{comparator$1.semver===ANY$1&&(comparator$1=new comparator(">=0.0.0")),high=high||comparator$1,low=low||comparator$1,gtfn(comparator$1.semver,high.semver,options)?high=comparator$1:ltfn(comparator$1.semver,low.semver,options)&&(low=comparator$1);})),high.operator===comp||high.operator===ecomp)return !1;if((!low.operator||low.operator===comp)&&ltefn(version,low.semver))return !1;if(low.operator===ecomp&&ltfn(version,low.semver))return !1}return !0};var gtr_1=(version,range,options)=>outside_1(version,range,">",options);var ltr_1=(version,range,options)=>outside_1(version,range,"<",options);var intersects_1=(r1,r2,options)=>(r1=new range(r1,options),r2=new range(r2,options),r1.intersects(r2));const{ANY}=comparator,simpleSubset=(sub,dom,options)=>{if(sub===dom)return !0;if(1===sub.length&&sub[0].semver===ANY){if(1===dom.length&&dom[0].semver===ANY)return !0;sub=options.includePrerelease?[new comparator(">=0.0.0-0")]:[new comparator(">=0.0.0")];}if(1===dom.length&&dom[0].semver===ANY){if(options.includePrerelease)return !0;dom=[new comparator(">=0.0.0")];}const eqSet=new Set;let gt,lt,gtltComp,higher,lower,hasDomLT,hasDomGT;for(const c of sub)">"===c.operator||">="===c.operator?gt=higherGT(gt,c,options):"<"===c.operator||"<="===c.operator?lt=lowerLT(lt,c,options):eqSet.add(c.semver);if(eqSet.size>1)return null;if(gt&&lt){if(gtltComp=compare_1(gt.semver,lt.semver,options),gtltComp>0)return null;if(0===gtltComp&&(">="!==gt.operator||"<="!==lt.operator))return null}for(const eq of eqSet){if(gt&&!satisfies_1(eq,String(gt),options))return null;if(lt&&!satisfies_1(eq,String(lt),options))return null;for(const c of dom)if(!satisfies_1(eq,String(c),options))return !1;return !0}let needDomLTPre=!(!lt||options.includePrerelease||!lt.semver.prerelease.length)&&lt.semver,needDomGTPre=!(!gt||options.includePrerelease||!gt.semver.prerelease.length)&&gt.semver;needDomLTPre&&1===needDomLTPre.prerelease.length&&"<"===lt.operator&&0===needDomLTPre.prerelease[0]&&(needDomLTPre=!1);for(const c of dom){if(hasDomGT=hasDomGT||">"===c.operator||">="===c.operator,hasDomLT=hasDomLT||"<"===c.operator||"<="===c.operator,gt)if(needDomGTPre&&c.semver.prerelease&&c.semver.prerelease.length&&c.semver.major===needDomGTPre.major&&c.semver.minor===needDomGTPre.minor&&c.semver.patch===needDomGTPre.patch&&(needDomGTPre=!1),">"===c.operator||">="===c.operator){if(higher=higherGT(gt,c,options),higher===c&&higher!==gt)return !1}else if(">="===gt.operator&&!satisfies_1(gt.semver,String(c),options))return !1;if(lt)if(needDomLTPre&&c.semver.prerelease&&c.semver.prerelease.length&&c.semver.major===needDomLTPre.major&&c.semver.minor===needDomLTPre.minor&&c.semver.patch===needDomLTPre.patch&&(needDomLTPre=!1),"<"===c.operator||"<="===c.operator){if(lower=lowerLT(lt,c,options),lower===c&&lower!==lt)return !1}else if("<="===lt.operator&&!satisfies_1(lt.semver,String(c),options))return !1;if(!c.operator&&(lt||gt)&&0!==gtltComp)return !1}return !(gt&&hasDomLT&&!lt&&0!==gtltComp)&&(!(lt&&hasDomGT&&!gt&&0!==gtltComp)&&(!needDomGTPre&&!needDomLTPre))},higherGT=(a,b,options)=>{if(!a)return b;const comp=compare_1(a.semver,b.semver,options);return comp>0?a:comp<0||">"===b.operator&&">="===a.operator?b:a},lowerLT=(a,b,options)=>{if(!a)return b;const comp=compare_1(a.semver,b.semver,options);return comp<0?a:comp>0||"<"===b.operator&&"<="===a.operator?b:a};var subset_1=(sub,dom,options={})=>{if(sub===dom)return !0;sub=new range(sub,options),dom=new range(dom,options);let sawNonNull=!1;OUTER:for(const simpleSub of sub.set){for(const simpleDom of dom.set){const isSub=simpleSubset(simpleSub,simpleDom,options);if(sawNonNull=sawNonNull||null!==isSub,isSub)continue OUTER}if(sawNonNull)return !1}return !0},semver={re:re_1.re,src:re_1.src,tokens:re_1.t,SEMVER_SPEC_VERSION:constants.SEMVER_SPEC_VERSION,SemVer:semver$1,compareIdentifiers:identifiers.compareIdentifiers,rcompareIdentifiers:identifiers.rcompareIdentifiers,parse:parse_1,valid:valid_1,clean:clean_1,inc:inc_1,diff:diff_1,major:major_1,minor:minor_1,patch:patch_1,prerelease:prerelease_1,compare:compare_1,rcompare:rcompare_1,compareLoose:compareLoose_1,compareBuild:compareBuild_1,sort:sort_1,rsort:rsort_1,gt:gt_1,lt:lt_1,eq:eq_1,neq:neq_1,gte:gte_1,lte:lte_1,cmp:cmp_1,coerce:coerce_1,Comparator:comparator,Range:range,satisfies:satisfies_1,toComparators:toComparators_1,maxSatisfying:maxSatisfying_1,minSatisfying:minSatisfying_1,minVersion:minVersion_1,validRange:valid,outside:outside_1,gtr:gtr_1,ltr:ltr_1,intersects:intersects_1,simplifyRange:(versions,range,options)=>{const set=[];let min=null,prev=null;const v=versions.sort(((a,b)=>compare_1(a,b,options)));for(const version of v){satisfies_1(version,range,options)?(prev=version,min||(min=version)):(prev&&set.push([min,prev]),prev=null,min=null);}min&&set.push([min,null]);const ranges=[];for(const[min,max]of set)min===max?ranges.push(min):max||min!==v[0]?max?min===v[0]?ranges.push(`<=${max}`):ranges.push(`${min} - ${max}`):ranges.push(`>=${min}`):ranges.push("*");const simplified=ranges.join(" || "),original="string"==typeof range.raw?range.raw:String(range);return simplified.length<original.length?simplified:range},subset:subset_1};const reader={read:function(jsonPath){return find(_path().dirname(jsonPath))}};function find(dir){try{return {string:_fs().default.readFileSync(_path().toNamespacedPath(_path().join(dir,"package.json")),"utf8")}}catch(error){if("ENOENT"===error.code){const parent=_path().dirname(dir);return dir!==parent?find(parent):{string:void 0}}throw error}}const isWindows="win32"===process.platform,own$1={}.hasOwnProperty,codes={},messages=new Map;let userStackTraceLimit;function createError(sym,value,def){return messages.set(sym,value),function(Base,key){return NodeError;function NodeError(...args){const limit=Error.stackTraceLimit;isErrorStackTraceLimitWritable()&&(Error.stackTraceLimit=0);const error=new Base;isErrorStackTraceLimitWritable()&&(Error.stackTraceLimit=limit);const message=function(key,args,self){const message=messages.get(key);if("function"==typeof message)return _assert()(message.length<=args.length,`Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${message.length}).`),Reflect.apply(message,self,args);const expectedLength=(message.match(/%[dfijoOs]/g)||[]).length;return _assert()(expectedLength===args.length,`Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`),0===args.length?message:(args.unshift(message),Reflect.apply(_util().format,null,args))}(key,args,error);return Object.defineProperty(error,"message",{value:message,enumerable:!1,writable:!0,configurable:!0}),Object.defineProperty(error,"toString",{value(){return `${this.name} [${key}]: ${this.message}`},enumerable:!1,writable:!0,configurable:!0}),addCodeToName(error,Base.name,key),error.code=key,error}}(def,sym)}codes.ERR_INVALID_MODULE_SPECIFIER=createError("ERR_INVALID_MODULE_SPECIFIER",((request,reason,base)=>`Invalid module "${request}" ${reason}${base?` imported from ${base}`:""}`),TypeError),codes.ERR_INVALID_PACKAGE_CONFIG=createError("ERR_INVALID_PACKAGE_CONFIG",((path,base,message)=>`Invalid package config ${path}${base?` while importing ${base}`:""}${message?`. ${message}`:""}`),Error),codes.ERR_INVALID_PACKAGE_TARGET=createError("ERR_INVALID_PACKAGE_TARGET",((pkgPath,key,target,isImport=!1,base)=>{const relError="string"==typeof target&&!isImport&&target.length>0&&!target.startsWith("./");return "."===key?(_assert()(!1===isImport),`Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${pkgPath}package.json${base?` imported from ${base}`:""}${relError?'; targets must start with "./"':""}`):`Invalid "${isImport?"imports":"exports"}" target ${JSON.stringify(target)} defined for '${key}' in the package config ${pkgPath}package.json${base?` imported from ${base}`:""}${relError?'; targets must start with "./"':""}`}),Error),codes.ERR_MODULE_NOT_FOUND=createError("ERR_MODULE_NOT_FOUND",((path,base,type="package")=>`Cannot find ${type} '${path}' imported from ${base}`),Error),codes.ERR_PACKAGE_IMPORT_NOT_DEFINED=createError("ERR_PACKAGE_IMPORT_NOT_DEFINED",((specifier,packagePath,base)=>`Package import specifier "${specifier}" is not defined${packagePath?` in package ${packagePath}package.json`:""} imported from ${base}`),TypeError),codes.ERR_PACKAGE_PATH_NOT_EXPORTED=createError("ERR_PACKAGE_PATH_NOT_EXPORTED",((pkgPath,subpath,base)=>"."===subpath?`No "exports" main defined in ${pkgPath}package.json${base?` imported from ${base}`:""}`:`Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${base?` imported from ${base}`:""}`),Error),codes.ERR_UNSUPPORTED_DIR_IMPORT=createError("ERR_UNSUPPORTED_DIR_IMPORT","Directory import '%s' is not supported resolving ES modules imported from %s",Error),codes.ERR_UNKNOWN_FILE_EXTENSION=createError("ERR_UNKNOWN_FILE_EXTENSION",'Unknown file extension "%s" for %s',TypeError),codes.ERR_INVALID_ARG_VALUE=createError("ERR_INVALID_ARG_VALUE",((name,value,reason="is invalid")=>{let inspected=(0, _util().inspect)(value);inspected.length>128&&(inspected=`${inspected.slice(0,128)}...`);return `The ${name.includes(".")?"property":"argument"} '${name}' ${reason}. Received ${inspected}`}),TypeError),codes.ERR_UNSUPPORTED_ESM_URL_SCHEME=createError("ERR_UNSUPPORTED_ESM_URL_SCHEME",(url=>{let message="Only file and data URLs are supported by the default ESM loader";return isWindows&&2===url.protocol.length&&(message+=". On Windows, absolute paths must be valid file:// URLs"),message+=`. Received protocol '${url.protocol}'`,message}),Error);const addCodeToName=hideStackFrames((function(error,name,code){(error=captureLargerStackTrace(error)).name=`${name} [${code}]`,error.stack,"SystemError"===name?Object.defineProperty(error,"name",{value:name,enumerable:!1,writable:!0,configurable:!0}):delete error.name;}));function isErrorStackTraceLimitWritable(){const desc=Object.getOwnPropertyDescriptor(Error,"stackTraceLimit");return void 0===desc?Object.isExtensible(Error):own$1.call(desc,"writable")?desc.writable:void 0!==desc.set}function hideStackFrames(fn){const hidden="__node_internal_"+fn.name;return Object.defineProperty(fn,"name",{value:hidden}),fn}const captureLargerStackTrace=hideStackFrames((function(error){const stackTraceLimitIsWritable=isErrorStackTraceLimitWritable();return stackTraceLimitIsWritable&&(userStackTraceLimit=Error.stackTraceLimit,Error.stackTraceLimit=Number.POSITIVE_INFINITY),Error.captureStackTrace(error),stackTraceLimitIsWritable&&(Error.stackTraceLimit=userStackTraceLimit),error}));const{ERR_UNKNOWN_FILE_EXTENSION}=codes,extensionFormatMap={__proto__:null,".cjs":"commonjs",".js":"module",".mjs":"module"};function defaultGetFormat(url){if(url.startsWith("node:"))return {format:"builtin"};const parsed=new(_url().URL)(url);if("data:"===parsed.protocol){const{1:mime}=/^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname)||[null,null];return {format:"text/javascript"===mime?"module":null}}if("file:"===parsed.protocol){const ext=_path().extname(parsed.pathname);let format;if(format=".js"===ext?"module"===function(url){return getPackageScopeConfig(url).type}(parsed.href)?"module":"commonjs":extensionFormatMap[ext],!format)throw new ERR_UNKNOWN_FILE_EXTENSION(ext,(0, _url().fileURLToPath)(url));return {format:format||null}}return {format:null}}const listOfBuiltins=function({version=process.version,experimental=!1}={}){var coreModules=["assert","buffer","child_process","cluster","console","constants","crypto","dgram","dns","domain","events","fs","http","https","module","net","os","path","punycode","querystring","readline","repl","stream","string_decoder","sys","timers","tls","tty","url","util","vm","zlib"];return semver.lt(version,"6.0.0")&&coreModules.push("freelist"),semver.gte(version,"1.0.0")&&coreModules.push("v8"),semver.gte(version,"1.1.0")&&coreModules.push("process"),semver.gte(version,"8.0.0")&&coreModules.push("inspector"),semver.gte(version,"8.1.0")&&coreModules.push("async_hooks"),semver.gte(version,"8.4.0")&&coreModules.push("http2"),semver.gte(version,"8.5.0")&&coreModules.push("perf_hooks"),semver.gte(version,"10.0.0")&&coreModules.push("trace_events"),semver.gte(version,"10.5.0")&&(experimental||semver.gte(version,"12.0.0"))&&coreModules.push("worker_threads"),semver.gte(version,"12.16.0")&&experimental&&coreModules.push("wasi"),coreModules}(),{ERR_INVALID_MODULE_SPECIFIER,ERR_INVALID_PACKAGE_CONFIG,ERR_INVALID_PACKAGE_TARGET,ERR_MODULE_NOT_FOUND,ERR_PACKAGE_IMPORT_NOT_DEFINED,ERR_PACKAGE_PATH_NOT_EXPORTED,ERR_UNSUPPORTED_DIR_IMPORT,ERR_UNSUPPORTED_ESM_URL_SCHEME,ERR_INVALID_ARG_VALUE}=codes,own={}.hasOwnProperty,DEFAULT_CONDITIONS=Object.freeze(["node","import"]),DEFAULT_CONDITIONS_SET=new Set(DEFAULT_CONDITIONS),invalidSegmentRegEx=/(^|\\|\/)(\.\.?|node_modules)(\\|\/|$)/,patternRegEx=/\*/g,encodedSepRegEx=/%2f|%2c/i,emittedPackageWarnings=new Set,packageJsonCache=new Map;function emitFolderMapDeprecation(match,pjsonUrl,isExports,base){const pjsonPath=(0, _url().fileURLToPath)(pjsonUrl);emittedPackageWarnings.has(pjsonPath+"|"+match)||(emittedPackageWarnings.add(pjsonPath+"|"+match),process.emitWarning(`Use of deprecated folder mapping "${match}" in the ${isExports?'"exports"':'"imports"'} field module resolution of the package at ${pjsonPath}${base?` imported from ${(0, _url().fileURLToPath)(base)}`:""}.\nUpdate this package.json to use a subpath pattern like "${match}*".`,"DeprecationWarning","DEP0148"));}function emitLegacyIndexDeprecation(url,packageJsonUrl,base,main){const{format}=defaultGetFormat(url.href);if("module"!==format)return;const path=(0, _url().fileURLToPath)(url.href),pkgPath=(0, _url().fileURLToPath)(new(_url().URL)(".",packageJsonUrl)),basePath=(0, _url().fileURLToPath)(base);main?process.emitWarning(`Package ${pkgPath} has a "main" field set to ${JSON.stringify(main)}, excluding the full filename and extension to the resolved file at "${path.slice(pkgPath.length)}", imported from ${basePath}.\n Automatic extension resolution of the "main" field isdeprecated for ES modules.`,"DeprecationWarning","DEP0151"):process.emitWarning(`No "main" or "exports" field defined in the package.json for ${pkgPath} resolving the main entry point "${path.slice(pkgPath.length)}", imported from ${basePath}.\nDefault "index" lookups for the main are deprecated for ES modules.`,"DeprecationWarning","DEP0151");}function tryStatSync(path){try{return (0,_fs().statSync)(path)}catch(_unused){return new(_fs().Stats)}}function getPackageConfig(path,specifier,base){const existing=packageJsonCache.get(path);if(void 0!==existing)return existing;const source=reader.read(path).string;if(void 0===source){const packageConfig={pjsonPath:path,exists:!1,main:void 0,name:void 0,type:"none",exports:void 0,imports:void 0};return packageJsonCache.set(path,packageConfig),packageConfig}let packageJson;try{packageJson=JSON.parse(source);}catch(error){throw new ERR_INVALID_PACKAGE_CONFIG(path,(base?`"${specifier}" from `:"")+(0, _url().fileURLToPath)(base||specifier),error.message)}const{exports,imports,main,name,type}=packageJson,packageConfig={pjsonPath:path,exists:!0,main:"string"==typeof main?main:void 0,name:"string"==typeof name?name:void 0,type:"module"===type||"commonjs"===type?type:"none",exports,imports:imports&&"object"==typeof imports?imports:void 0};return packageJsonCache.set(path,packageConfig),packageConfig}function getPackageScopeConfig(resolved){let packageJsonUrl=new(_url().URL)("./package.json",resolved);for(;;){if(packageJsonUrl.pathname.endsWith("node_modules/package.json"))break;const packageConfig=getPackageConfig((0, _url().fileURLToPath)(packageJsonUrl),resolved);if(packageConfig.exists)return packageConfig;const lastPackageJsonUrl=packageJsonUrl;if(packageJsonUrl=new(_url().URL)("../package.json",packageJsonUrl),packageJsonUrl.pathname===lastPackageJsonUrl.pathname)break}const packageJsonPath=(0, _url().fileURLToPath)(packageJsonUrl),packageConfig={pjsonPath:packageJsonPath,exists:!1,main:void 0,name:void 0,type:"none",exports:void 0,imports:void 0};return packageJsonCache.set(packageJsonPath,packageConfig),packageConfig}function fileExists(url){return tryStatSync((0, _url().fileURLToPath)(url)).isFile()}function legacyMainResolve(packageJsonUrl,packageConfig,base){let guess;if(void 0!==packageConfig.main){if(guess=new(_url().URL)(`./${packageConfig.main}`,packageJsonUrl),fileExists(guess))return guess;const tries=[`./${packageConfig.main}.js`,`./${packageConfig.main}.json`,`./${packageConfig.main}.node`,`./${packageConfig.main}/index.js`,`./${packageConfig.main}/index.json`,`./${packageConfig.main}/index.node`];let i=-1;for(;++i<tries.length&&(guess=new(_url().URL)(tries[i],packageJsonUrl),!fileExists(guess));)guess=void 0;if(guess)return emitLegacyIndexDeprecation(guess,packageJsonUrl,base,packageConfig.main),guess}const tries=["./index.js","./index.json","./index.node"];let i=-1;for(;++i<tries.length&&(guess=new(_url().URL)(tries[i],packageJsonUrl),!fileExists(guess));)guess=void 0;if(guess)return emitLegacyIndexDeprecation(guess,packageJsonUrl,base,packageConfig.main),guess;throw new ERR_MODULE_NOT_FOUND((0, _url().fileURLToPath)(new(_url().URL)(".",packageJsonUrl)),(0, _url().fileURLToPath)(base))}function throwExportsNotFound(subpath,packageJsonUrl,base){throw new ERR_PACKAGE_PATH_NOT_EXPORTED((0, _url().fileURLToPath)(new(_url().URL)(".",packageJsonUrl)),subpath,base&&(0, _url().fileURLToPath)(base))}function throwInvalidPackageTarget(subpath,target,packageJsonUrl,internal,base){throw target="object"==typeof target&&null!==target?JSON.stringify(target,null,""):`${target}`,new ERR_INVALID_PACKAGE_TARGET((0, _url().fileURLToPath)(new(_url().URL)(".",packageJsonUrl)),subpath,target,internal,base&&(0, _url().fileURLToPath)(base))}function resolvePackageTargetString(target,subpath,match,packageJsonUrl,base,pattern,internal,conditions){if(""===subpath||pattern||"/"===target[target.length-1]||throwInvalidPackageTarget(match,target,packageJsonUrl,internal,base),!target.startsWith("./")){if(internal&&!target.startsWith("../")&&!target.startsWith("/")){let isURL=!1;try{new(_url().URL)(target),isURL=!0;}catch(_unused2){}if(!isURL){return packageResolve(pattern?target.replace(patternRegEx,subpath):target+subpath,packageJsonUrl,conditions)}}throwInvalidPackageTarget(match,target,packageJsonUrl,internal,base);}invalidSegmentRegEx.test(target.slice(2))&&throwInvalidPackageTarget(match,target,packageJsonUrl,internal,base);const resolved=new(_url().URL)(target,packageJsonUrl),resolvedPath=resolved.pathname,packagePath=new(_url().URL)(".",packageJsonUrl).pathname;return resolvedPath.startsWith(packagePath)||throwInvalidPackageTarget(match,target,packageJsonUrl,internal,base),""===subpath?resolved:(invalidSegmentRegEx.test(subpath)&&function(subpath,packageJsonUrl,internal,base){const reason=`request is not a valid subpath for the "${internal?"imports":"exports"}" resolution of ${(0, _url().fileURLToPath)(packageJsonUrl)}`;throw new ERR_INVALID_MODULE_SPECIFIER(subpath,reason,base&&(0, _url().fileURLToPath)(base))}(match+subpath,packageJsonUrl,internal,base),pattern?new(_url().URL)(resolved.href.replace(patternRegEx,subpath)):new(_url().URL)(subpath,resolved))}function isArrayIndex(key){const keyNumber=Number(key);return `${keyNumber}`===key&&(keyNumber>=0&&keyNumber<4294967295)}function resolvePackageTarget(packageJsonUrl,target,subpath,packageSubpath,base,pattern,internal,conditions){if("string"==typeof target)return resolvePackageTargetString(target,subpath,packageSubpath,packageJsonUrl,base,pattern,internal,conditions);if(Array.isArray(target)){const targetList=target;if(0===targetList.length)return null;let lastException,i=-1;for(;++i<targetList.length;){const targetItem=targetList[i];let resolved;try{resolved=resolvePackageTarget(packageJsonUrl,targetItem,subpath,packageSubpath,base,pattern,internal,conditions);}catch(error){if(lastException=error,"ERR_INVALID_PACKAGE_TARGET"===error.code)continue;throw error}if(void 0!==resolved){if(null!==resolved)return resolved;lastException=null;}}if(null==lastException)return lastException;throw lastException}if("object"!=typeof target||null===target){if(null===target)return null;throwInvalidPackageTarget(packageSubpath,target,packageJsonUrl,internal,base);}else {const keys=Object.getOwnPropertyNames(target);let i=-1;for(;++i<keys.length;){if(isArrayIndex(keys[i]))throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl),base,'"exports" cannot contain numeric property keys.')}for(i=-1;++i<keys.length;){const key=keys[i];if("default"===key||conditions&&conditions.has(key)){const resolved=resolvePackageTarget(packageJsonUrl,target[key],subpath,packageSubpath,base,pattern,internal,conditions);if(void 0===resolved)continue;return resolved}}}}function packageExportsResolve(packageJsonUrl,packageSubpath,packageConfig,base,conditions){let exports=packageConfig.exports;if(function(exports,packageJsonUrl,base){if("string"==typeof exports||Array.isArray(exports))return !0;if("object"!=typeof exports||null===exports)return !1;const keys=Object.getOwnPropertyNames(exports);let isConditionalSugar=!1,i=0,j=-1;for(;++j<keys.length;){const key=keys[j],curIsConditionalSugar=""===key||"."!==key[0];if(0==i++)isConditionalSugar=curIsConditionalSugar;else if(isConditionalSugar!==curIsConditionalSugar)throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl),base,"\"exports\" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.")}return isConditionalSugar}(exports,packageJsonUrl,base)&&(exports={".":exports}),own.call(exports,packageSubpath)){const resolved=resolvePackageTarget(packageJsonUrl,exports[packageSubpath],"",packageSubpath,base,!1,!1,conditions);return null==resolved&&throwExportsNotFound(packageSubpath,packageJsonUrl,base),{resolved,exact:!0}}let bestMatch="";const keys=Object.getOwnPropertyNames(exports);let i=-1;for(;++i<keys.length;){const key=keys[i];("*"===key[key.length-1]&&packageSubpath.startsWith(key.slice(0,-1))&&packageSubpath.length>=key.length&&key.length>bestMatch.length||"/"===key[key.length-1]&&packageSubpath.startsWith(key)&&key.length>bestMatch.length)&&(bestMatch=key);}if(bestMatch){const target=exports[bestMatch],pattern="*"===bestMatch[bestMatch.length-1],resolved=resolvePackageTarget(packageJsonUrl,target,packageSubpath.slice(bestMatch.length-(pattern?1:0)),bestMatch,base,pattern,!1,conditions);return null==resolved&&throwExportsNotFound(packageSubpath,packageJsonUrl,base),pattern||emitFolderMapDeprecation(bestMatch,packageJsonUrl,!0,base),{resolved,exact:pattern}}throwExportsNotFound(packageSubpath,packageJsonUrl,base);}function packageImportsResolve(name,base,conditions){if("#"===name||name.startsWith("#/")){throw new ERR_INVALID_MODULE_SPECIFIER(name,"is not a valid internal imports specifier name",(0, _url().fileURLToPath)(base))}let packageJsonUrl;const packageConfig=getPackageScopeConfig(base);if(packageConfig.exists){packageJsonUrl=(0, _url().pathToFileURL)(packageConfig.pjsonPath);const imports=packageConfig.imports;if(imports)if(own.call(imports,name)){const resolved=resolvePackageTarget(packageJsonUrl,imports[name],"",name,base,!1,!0,conditions);if(null!==resolved)return {resolved,exact:!0}}else {let bestMatch="";const keys=Object.getOwnPropertyNames(imports);let i=-1;for(;++i<keys.length;){const key=keys[i];("*"===key[key.length-1]&&name.startsWith(key.slice(0,-1))&&name.length>=key.length&&key.length>bestMatch.length||"/"===key[key.length-1]&&name.startsWith(key)&&key.length>bestMatch.length)&&(bestMatch=key);}if(bestMatch){const target=imports[bestMatch],pattern="*"===bestMatch[bestMatch.length-1],resolved=resolvePackageTarget(packageJsonUrl,target,name.slice(bestMatch.length-(pattern?1:0)),bestMatch,base,pattern,!0,conditions);if(null!==resolved)return pattern||emitFolderMapDeprecation(bestMatch,packageJsonUrl,!1,base),{resolved,exact:pattern}}}}!function(specifier,packageJsonUrl,base){throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier,packageJsonUrl&&(0, _url().fileURLToPath)(new(_url().URL)(".",packageJsonUrl)),(0, _url().fileURLToPath)(base))}(name,packageJsonUrl,base);}function packageResolve(specifier,base,conditions){const{packageName,packageSubpath,isScoped}=function(specifier,base){let separatorIndex=specifier.indexOf("/"),validPackageName=!0,isScoped=!1;"@"===specifier[0]&&(isScoped=!0,-1===separatorIndex||0===specifier.length?validPackageName=!1:separatorIndex=specifier.indexOf("/",separatorIndex+1));const packageName=-1===separatorIndex?specifier:specifier.slice(0,separatorIndex);let i=-1;for(;++i<packageName.length;)if("%"===packageName[i]||"\\"===packageName[i]){validPackageName=!1;break}if(!validPackageName)throw new ERR_INVALID_MODULE_SPECIFIER(specifier,"is not a valid package name",(0, _url().fileURLToPath)(base));return {packageName,packageSubpath:"."+(-1===separatorIndex?"":specifier.slice(separatorIndex)),isScoped}}(specifier,base),packageConfig=getPackageScopeConfig(base);if(packageConfig.exists){const packageJsonUrl=(0, _url().pathToFileURL)(packageConfig.pjsonPath);if(packageConfig.name===packageName&&void 0!==packageConfig.exports&&null!==packageConfig.exports)return packageExportsResolve(packageJsonUrl,packageSubpath,packageConfig,base,conditions).resolved}let lastPath,packageJsonUrl=new(_url().URL)("./node_modules/"+packageName+"/package.json",base),packageJsonPath=(0, _url().fileURLToPath)(packageJsonUrl);do{if(!tryStatSync(packageJsonPath.slice(0,-13)).isDirectory()){lastPath=packageJsonPath,packageJsonUrl=new(_url().URL)((isScoped?"../../../../node_modules/":"../../../node_modules/")+packageName+"/package.json",packageJsonUrl),packageJsonPath=(0, _url().fileURLToPath)(packageJsonUrl);continue}const packageConfig=getPackageConfig(packageJsonPath,specifier,base);return void 0!==packageConfig.exports&&null!==packageConfig.exports?packageExportsResolve(packageJsonUrl,packageSubpath,packageConfig,base,conditions).resolved:"."===packageSubpath?legacyMainResolve(packageJsonUrl,packageConfig,base):new(_url().URL)(packageSubpath,packageJsonUrl)}while(packageJsonPath.length!==lastPath.length);throw new ERR_MODULE_NOT_FOUND(packageName,(0, _url().fileURLToPath)(base))}function moduleResolve(specifier,base,conditions){let resolved;if(function(specifier){return ""!==specifier&&("/"===specifier[0]||function(specifier){if("."===specifier[0]){if(1===specifier.length||"/"===specifier[1])return !0;if("."===specifier[1]&&(2===specifier.length||"/"===specifier[2]))return !0}return !1}(specifier))}(specifier))resolved=new(_url().URL)(specifier,base);else if("#"===specifier[0])({resolved}=packageImportsResolve(specifier,base,conditions));else try{resolved=new(_url().URL)(specifier);}catch(_unused3){resolved=packageResolve(specifier,base,conditions);}return function(resolved,base){if(encodedSepRegEx.test(resolved.pathname))throw new ERR_INVALID_MODULE_SPECIFIER(resolved.pathname,'must not include encoded "/" or "\\" characters',(0, _url().fileURLToPath)(base));const path=(0, _url().fileURLToPath)(resolved),stats=tryStatSync(path.endsWith("/")?path.slice(-1):path);if(stats.isDirectory()){const error=new ERR_UNSUPPORTED_DIR_IMPORT(path,(0, _url().fileURLToPath)(base));throw error.url=String(resolved),error}if(!stats.isFile())throw new ERR_MODULE_NOT_FOUND(path||resolved.pathname,base&&(0, _url().fileURLToPath)(base),"module");return resolved}(resolved,base)}function defaultResolve(specifier,context={}){const{parentURL}=context;let parsed;try{if(parsed=new(_url().URL)(specifier),"data:"===parsed.protocol)return {url:specifier}}catch(_unused4){}if(parsed&&"node:"===parsed.protocol)return {url:specifier};if(parsed&&"file:"!==parsed.protocol&&"data:"!==parsed.protocol)throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed);if(listOfBuiltins.includes(specifier))return {url:"node:"+specifier};parentURL.startsWith("data:")&&new(_url().URL)(specifier,parentURL);const conditions=function(conditions){if(void 0!==conditions&&conditions!==DEFAULT_CONDITIONS){if(!Array.isArray(conditions))throw new ERR_INVALID_ARG_VALUE("conditions",conditions,"expected an array");return new Set(conditions)}return DEFAULT_CONDITIONS_SET}(context.conditions);let url=moduleResolve(specifier,new(_url().URL)(parentURL),conditions);const urlPath=(0, _url().fileURLToPath)(url),real=(0, _fs().realpathSync)(urlPath),old=url;return url=(0, _url().pathToFileURL)(real+(urlPath.endsWith(_path().sep)?"/":"")),url.search=old.search,url.hash=old.hash,{url:`${url}`}}function _resolve(){return (_resolve=_asyncToGenerator((function*(specifier,parent){if(!parent)throw new Error("Please pass `parent`: `import-meta-resolve` cannot ponyfill that");try{return defaultResolve(specifier,{parentURL:parent}).url}catch(error){return "ERR_UNSUPPORTED_DIR_IMPORT"===error.code?error.url:Promise.reject(error)}}))).apply(this,arguments)}},"./node_modules/@babel/core/node_modules/semver/semver.js":(module,exports)=>{var debug;exports=module.exports=SemVer,debug="object"==typeof process&&process.env&&process.env.NODE_DEBUG&&/\bsemver\b/i.test(process.env.NODE_DEBUG)?function(){var args=Array.prototype.slice.call(arguments,0);args.unshift("SEMVER"),console.log.apply(console,args);}:function(){},exports.SEMVER_SPEC_VERSION="2.0.0";var MAX_SAFE_INTEGER=Number.MAX_SAFE_INTEGER||9007199254740991,re=exports.re=[],src=exports.src=[],t=exports.tokens={},R=0;function tok(n){t[n]=R++;}tok("NUMERICIDENTIFIER"),src[t.NUMERICIDENTIFIER]="0|[1-9]\\d*",tok("NUMERICIDENTIFIERLOOSE"),src[t.NUMERICIDENTIFIERLOOSE]="[0-9]+",tok("NONNUMERICIDENTIFIER"),src[t.NONNUMERICIDENTIFIER]="\\d*[a-zA-Z-][a-zA-Z0-9-]*",tok("MAINVERSION"),src[t.MAINVERSION]="("+src[t.NUMERICIDENTIFIER]+")\\.("+src[t.NUMERICIDENTIFIER]+")\\.("+src[t.NUMERICIDENTIFIER]+")",tok("MAINVERSIONLOOSE"),src[t.MAINVERSIONLOOSE]="("+src[t.NUMERICIDENTIFIERLOOSE]+")\\.("+src[t.NUMERICIDENTIFIERLOOSE]+")\\.("+src[t.NUMERICIDENTIFIERLOOSE]+")",tok("PRERELEASEIDENTIFIER"),src[t.PRERELEASEIDENTIFIER]="(?:"+src[t.NUMERICIDENTIFIER]+"|"+src[t.NONNUMERICIDENTIFIER]+")",tok("PRERELEASEIDENTIFIERLOOSE"),src[t.PRERELEASEIDENTIFIERLOOSE]="(?:"+src[t.NUMERICIDENTIFIERLOOSE]+"|"+src[t.NONNUMERICIDENTIFIER]+")",tok("PRERELEASE"),src[t.PRERELEASE]="(?:-("+src[t.PRERELEASEIDENTIFIER]+"(?:\\."+src[t.PRERELEASEIDENTIFIER]+")*))",tok("PRERELEASELOOSE"),src[t.PRERELEASELOOSE]="(?:-?("+src[t.PRERELEASEIDENTIFIERLOOSE]+"(?:\\."+src[t.PRERELEASEIDENTIFIERLOOSE]+")*))",tok("BUILDIDENTIFIER"),src[t.BUILDIDENTIFIER]="[0-9A-Za-z-]+",tok("BUILD"),src[t.BUILD]="(?:\\+("+src[t.BUILDIDENTIFIER]+"(?:\\."+src[t.BUILDIDENTIFIER]+")*))",tok("FULL"),tok("FULLPLAIN"),src[t.FULLPLAIN]="v?"+src[t.MAINVERSION]+src[t.PRERELEASE]+"?"+src[t.BUILD]+"?",src[t.FULL]="^"+src[t.FULLPLAIN]+"$",tok("LOOSEPLAIN"),src[t.LOOSEPLAIN]="[v=\\s]*"+src[t.MAINVERSIONLOOSE]+src[t.PRERELEASELOOSE]+"?"+src[t.BUILD]+"?",tok("LOOSE"),src[t.LOOSE]="^"+src[t.LOOSEPLAIN]+"$",tok("GTLT"),src[t.GTLT]="((?:<|>)?=?)",tok("XRANGEIDENTIFIERLOOSE"),src[t.XRANGEIDENTIFIERLOOSE]=src[t.NUMERICIDENTIFIERLOOSE]+"|x|X|\\*",tok("XRANGEIDENTIFIER"),src[t.XRANGEIDENTIFIER]=src[t.NUMERICIDENTIFIER]+"|x|X|\\*",tok("XRANGEPLAIN"),src[t.XRANGEPLAIN]="[v=\\s]*("+src[t.XRANGEIDENTIFIER]+")(?:\\.("+src[t.XRANGEIDENTIFIER]+")(?:\\.("+src[t.XRANGEIDENTIFIER]+")(?:"+src[t.PRERELEASE]+")?"+src[t.BUILD]+"?)?)?",tok("XRANGEPLAINLOOSE"),src[t.XRANGEPLAINLOOSE]="[v=\\s]*("+src[t.XRANGEIDENTIFIERLOOSE]+")(?:\\.("+src[t.XRANGEIDENTIFIERLOOSE]+")(?:\\.("+src[t.XRANGEIDENTIFIERLOOSE]+")(?:"+src[t.PRERELEASELOOSE]+")?"+src[t.BUILD]+"?)?)?",tok("XRANGE"),src[t.XRANGE]="^"+src[t.GTLT]+"\\s*"+src[t.XRANGEPLAIN]+"$",tok("XRANGELOOSE"),src[t.XRANGELOOSE]="^"+src[t.GTLT]+"\\s*"+src[t.XRANGEPLAINLOOSE]+"$",tok("COERCE"),src[t.COERCE]="(^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])",tok("COERCERTL"),re[t.COERCERTL]=new RegExp(src[t.COERCE],"g"),tok("LONETILDE"),src[t.LONETILDE]="(?:~>?)",tok("TILDETRIM"),src[t.TILDETRIM]="(\\s*)"+src[t.LONETILDE]+"\\s+",re[t.TILDETRIM]=new RegExp(src[t.TILDETRIM],"g");tok("TILDE"),src[t.TILDE]="^"+src[t.LONETILDE]+src[t.XRANGEPLAIN]+"$",tok("TILDELOOSE"),src[t.TILDELOOSE]="^"+src[t.LONETILDE]+src[t.XRANGEPLAINLOOSE]+"$",tok("LONECARET"),src[t.LONECARET]="(?:\\^)",tok("CARETTRIM"),src[t.CARETTRIM]="(\\s*)"+src[t.LONECARET]+"\\s+",re[t.CARETTRIM]=new RegExp(src[t.CARETTRIM],"g");tok("CARET"),src[t.CARET]="^"+src[t.LONECARET]+src[t.XRANGEPLAIN]+"$",tok("CARETLOOSE"),src[t.CARETLOOSE]="^"+src[t.LONECARET]+src[t.XRANGEPLAINLOOSE]+"$",tok("COMPARATORLOOSE"),src[t.COMPARATORLOOSE]="^"+src[t.GTLT]+"\\s*("+src[t.LOOSEPLAIN]+")$|^$",tok("COMPARATOR"),src[t.COMPARATOR]="^"+src[t.GTLT]+"\\s*("+src[t.FULLPLAIN]+")$|^$",tok("COMPARATORTRIM"),src[t.COMPARATORTRIM]="(\\s*)"+src[t.GTLT]+"\\s*("+src[t.LOOSEPLAIN]+"|"+src[t.XRANGEPLAIN]+")",re[t.COMPARATORTRIM]=new RegExp(src[t.COMPARATORTRIM],"g");tok("HYPHENRANGE"),src[t.HYPHENRANGE]="^\\s*("+src[t.XRANGEPLAIN]+")\\s+-\\s+("+src[t.XRANGEPLAIN]+")\\s*$",tok("HYPHENRANGELOOSE"),src[t.HYPHENRANGELOOSE]="^\\s*("+src[t.XRANGEPLAINLOOSE]+")\\s+-\\s+("+src[t.XRANGEPLAINLOOSE]+")\\s*$",tok("STAR"),src[t.STAR]="(<|>)?=?\\s*\\*";for(var i=0;i<R;i++)debug(i,src[i]),re[i]||(re[i]=new RegExp(src[i]));function parse(version,options){if(options&&"object"==typeof options||(options={loose:!!options,includePrerelease:!1}),version instanceof SemVer)return version;if("string"!=typeof version)return null;if(version.length>256)return null;if(!(options.loose?re[t.LOOSE]:re[t.FULL]).test(version))return null;try{return new SemVer(version,options)}catch(er){return null}}function SemVer(version,options){if(options&&"object"==typeof options||(options={loose:!!options,includePrerelease:!1}),version instanceof SemVer){if(version.loose===options.loose)return version;version=version.version;}else if("string"!=typeof version)throw new TypeError("Invalid Version: "+version);if(version.length>256)throw new TypeError("version is longer than 256 characters");if(!(this instanceof SemVer))return new SemVer(version,options);debug("SemVer",version,options),this.options=options,this.loose=!!options.loose;var m=version.trim().match(options.loose?re[t.LOOSE]:re[t.FULL]);if(!m)throw new TypeError("Invalid Version: "+version);if(this.raw=version,this.major=+m[1],this.minor=+m[2],this.patch=+m[3],this.major>MAX_SAFE_INTEGER||this.major<0)throw new TypeError("Invalid major version");if(this.minor>MAX_SAFE_INTEGER||this.minor<0)throw new TypeError("Invalid minor version");if(this.patch>MAX_SAFE_INTEGER||this.patch<0)throw new TypeError("Invalid patch version");m[4]?this.prerelease=m[4].split(".").map((function(id){if(/^[0-9]+$/.test(id)){var num=+id;if(num>=0&&num<MAX_SAFE_INTEGER)return num}return id})):this.prerelease=[],this.build=m[5]?m[5].split("."):[],this.format();}exports.parse=parse,exports.valid=function(version,options){var v=parse(version,options);return v?v.version:null},exports.clean=function(version,options){var s=parse(version.trim().replace(/^[=v]+/,""),options);return s?s.version:null},exports.SemVer=SemVer,SemVer.prototype.format=function(){return this.version=this.major+"."+this.minor+"."+this.patch,this.prerelease.length&&(this.version+="-"+this.prerelease.join(".")),this.version},SemVer.prototype.toString=function(){return this.version},SemVer.prototype.compare=function(other){return debug("SemVer.compare",this.version,this.options,other),other instanceof SemVer||(other=new SemVer(other,this.options)),this.compareMain(other)||this.comparePre(other)},SemVer.prototype.compareMain=function(other){return other instanceof SemVer||(other=new SemVer(other,this.options)),compareIdentifiers(this.major,other.major)||compareIdentifiers(this.minor,other.minor)||compareIdentifiers(this.patch,other.patch)},SemVer.prototype.comparePre=function(other){if(other instanceof SemVer||(other=new SemVer(other,this.options)),this.prerelease.length&&!other.prerelease.length)return -1;if(!this.prerelease.length&&other.prerelease.length)return 1;if(!this.prerelease.length&&!other.prerelease.length)return 0;var i=0;do{var a=this.prerelease[i],b=other.prerelease[i];if(debug("prerelease compare",i,a,b),void 0===a&&void 0===b)return 0;if(void 0===b)return 1;if(void 0===a)return -1;if(a!==b)return compareIdentifiers(a,b)}while(++i)},SemVer.prototype.compareBuild=function(other){other instanceof SemVer||(other=new SemVer(other,this.options));var i=0;do{var a=this.build[i],b=other.build[i];if(debug("prerelease compare",i,a,b),void 0===a&&void 0===b)return 0;if(void 0===b)return 1;if(void 0===a)return -1;if(a!==b)return compareIdentifiers(a,b)}while(++i)},SemVer.prototype.inc=function(release,identifier){switch(release){case"premajor":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc("pre",identifier);break;case"preminor":this.prerelease.length=0,this.patch=0,this.minor++,this.inc("pre",identifier);break;case"prepatch":this.prerelease.length=0,this.inc("patch",identifier),this.inc("pre",identifier);break;case"prerelease":0===this.prerelease.length&&this.inc("patch",identifier),this.inc("pre",identifier);break;case"major":0===this.minor&&0===this.patch&&0!==this.prerelease.length||this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case"minor":0===this.patch&&0!==this.prerelease.length||this.minor++,this.patch=0,this.prerelease=[];break;case"patch":0===this.prerelease.length&&this.patch++,this.prerelease=[];break;case"pre":if(0===this.prerelease.length)this.prerelease=[0];else {for(var i=this.prerelease.length;--i>=0;)"number"==typeof this.prerelease[i]&&(this.prerelease[i]++,i=-2);-1===i&&this.prerelease.push(0);}identifier&&(this.prerelease[0]===identifier?isNaN(this.prerelease[1])&&(this.prerelease=[identifier,0]):this.prerelease=[identifier,0]);break;default:throw new Error("invalid increment argument: "+release)}return this.format(),this.raw=this.version,this},exports.inc=function(version,release,loose,identifier){"string"==typeof loose&&(identifier=loose,loose=void 0);try{return new SemVer(version,loose).inc(release,identifier).version}catch(er){return null}},exports.diff=function(version1,version2){if(eq(version1,version2))return null;var v1=parse(version1),v2=parse(version2),prefix="";if(v1.prerelease.length||v2.prerelease.length){prefix="pre";var defaultResult="prerelease";}for(var key in v1)if(("major"===key||"minor"===key||"patch"===key)&&v1[key]!==v2[key])return prefix+key;return defaultResult},exports.compareIdentifiers=compareIdentifiers;var numeric=/^[0-9]+$/;function compareIdentifiers(a,b){var anum=numeric.test(a),bnum=numeric.test(b);return anum&&bnum&&(a=+a,b=+b),a===b?0:anum&&!bnum?-1:bnum&&!anum?1:a<b?-1:1}function compare(a,b,loose){return new SemVer(a,loose).compare(new SemVer(b,loose))}function gt(a,b,loose){return compare(a,b,loose)>0}function lt(a,b,loose){return compare(a,b,loose)<0}function eq(a,b,loose){return 0===compare(a,b,loose)}function neq(a,b,loose){return 0!==compare(a,b,loose)}function gte(a,b,loose){return compare(a,b,loose)>=0}function lte(a,b,loose){return compare(a,b,loose)<=0}function cmp(a,op,b,loose){switch(op){case"===":return "object"==typeof a&&(a=a.version),"object"==typeof b&&(b=b.version),a===b;case"!==":return "object"==typeof a&&(a=a.version),"object"==typeof b&&(b=b.version),a!==b;case"":case"=":case"==":return eq(a,b,loose);case"!=":return neq(a,b,loose);case">":return gt(a,b,loose);case">=":return gte(a,b,loose);case"<":return lt(a,b,loose);case"<=":return lte(a,b,loose);default:throw new TypeError("Invalid operator: "+op)}}function Comparator(comp,options){if(options&&"object"==typeof options||(options={loose:!!options,includePrerelease:!1}),comp instanceof Comparator){if(comp.loose===!!options.loose)return comp;comp=comp.value;}if(!(this instanceof Comparator))return new Comparator(comp,options);debug("comparator",comp,options),this.options=options,this.loose=!!options.loose,this.parse(comp),this.semver===ANY?this.value="":this.value=this.operator+this.semver.version,debug("comp",this);}exports.rcompareIdentifiers=function(a,b){return compareIdentifiers(b,a)},exports.major=function(a,loose){return new SemVer(a,loose).major},exports.minor=function(a,loose){return new SemVer(a,loose).minor},exports.patch=function(a,loose){return new SemVer(a,loose).patch},exports.compare=compare,exports.compareLoose=function(a,b){return compare(a,b,!0)},exports.compareBuild=function(a,b,loose){var versionA=new SemVer(a,loose),versionB=new SemVer(b,loose);return versionA.compare(versionB)||versionA.compareBuild(versionB)},exports.rcompare=function(a,b,loose){return compare(b,a,loose)},exports.sort=function(list,loose){return list.sort((function(a,b){return exports.compareBuild(a,b,loose)}))},exports.rsort=function(list,loose){return list.sort((function(a,b){return exports.compareBuild(b,a,loose)}))},exports.gt=gt,exports.lt=lt,exports.eq=eq,exports.neq=neq,exports.gte=gte,exports.lte=lte,exports.cmp=cmp,exports.Comparator=Comparator;var ANY={};function Range(range,options){if(options&&"object"==typeof options||(options={loose:!!options,includePrerelease:!1}),range instanceof Range)return range.loose===!!options.loose&&range.includePrerelease===!!options.includePrerelease?range:new Range(range.raw,options);if(range instanceof Comparator)return new Range(range.value,options);if(!(this instanceof Range))return new Range(range,options);if(this.options=options,this.loose=!!options.loose,this.includePrerelease=!!options.includePrerelease,this.raw=range,this.set=range.split(/\s*\|\|\s*/).map((function(range){return this.parseRange(range.trim())}),this).filter((function(c){return c.length})),!this.set.length)throw new TypeError("Invalid SemVer Range: "+range);this.format();}function isSatisfiable(comparators,options){for(var result=!0,remainingComparators=comparators.slice(),testComparator=remainingComparators.pop();result&&remainingComparators.length;)result=remainingComparators.every((function(otherComparator){return testComparator.intersects(otherComparator,options)})),testComparator=remainingComparators.pop();return result}function isX(id){return !id||"x"===id.toLowerCase()||"*"===id}function hyphenReplace($0,from,fM,fm,fp,fpr,fb,to,tM,tm,tp,tpr,tb){return ((from=isX(fM)?"":isX(fm)?">="+fM+".0.0":isX(fp)?">="+fM+"."+fm+".0":">="+from)+" "+(to=isX(tM)?"":isX(tm)?"<"+(+tM+1)+".0.0":isX(tp)?"<"+tM+"."+(+tm+1)+".0":tpr?"<="+tM+"."+tm+"."+tp+"-"+tpr:"<="+to)).trim()}function testSet(set,version,options){for(var i=0;i<set.length;i++)if(!set[i].test(version))return !1;if(version.prerelease.length&&!options.includePrerelease){for(i=0;i<set.length;i++)if(debug(set[i].semver),set[i].semver!==ANY&&set[i].semver.prerelease.length>0){var allowed=set[i].semver;if(allowed.major===version.major&&allowed.minor===version.minor&&allowed.patch===version.patch)return !0}return !1}return !0}function satisfies(version,range,options){try{range=new Range(range,options);}catch(er){return !1}return range.test(version)}function outside(version,range,hilo,options){var gtfn,ltefn,ltfn,comp,ecomp;switch(version=new SemVer(version,options),range=new Range(range,options),hilo){case">":gtfn=gt,ltefn=lte,ltfn=lt,comp=">",ecomp=">=";break;case"<":gtfn=lt,ltefn=gte,ltfn=gt,comp="<",ecomp="<=";break;default:throw new TypeError('Must provide a hilo val of "<" or ">"')}if(satisfies(version,range,options))return !1;for(var i=0;i<range.set.length;++i){var comparators=range.set[i],high=null,low=null;if(comparators.forEach((function(comparator){comparator.semver===ANY&&(comparator=new Comparator(">=0.0.0")),high=high||comparator,low=low||comparator,gtfn(comparator.semver,high.semver,options)?high=comparator:ltfn(comparator.semver,low.semver,options)&&(low=comparator);})),high.operator===comp||high.operator===ecomp)return !1;if((!low.operator||low.operator===comp)&&ltefn(version,low.semver))return !1;if(low.operator===ecomp&&ltfn(version,low.semver))return !1}return !0}Comparator.prototype.parse=function(comp){var r=this.options.loose?re[t.COMPARATORLOOSE]:re[t.COMPARATOR],m=comp.match(r);if(!m)throw new TypeError("Invalid comparator: "+comp);this.operator=void 0!==m[1]?m[1]:"","="===this.operator&&(this.operator=""),m[2]?this.semver=new SemVer(m[2],this.options.loose):this.semver=ANY;},Comparator.prototype.toString=function(){return this.value},Comparator.prototype.test=function(version){if(debug("Comparator.test",version,this.options.loose),this.semver===ANY||version===ANY)return !0;if("string"==typeof version)try{version=new SemVer(version,this.options);}catch(er){return !1}return cmp(version,this.operator,this.semver,this.options)},Comparator.prototype.intersects=function(comp,options){if(!(comp instanceof Comparator))throw new TypeError("a Comparator is required");var rangeTmp;if(options&&"object"==typeof options||(options={loose:!!options,includePrerelease:!1}),""===this.operator)return ""===this.value||(rangeTmp=new Range(comp.value,options),satisfies(this.value,rangeTmp,options));if(""===comp.operator)return ""===comp.value||(rangeTmp=new Range(this.value,options),satisfies(comp.semver,rangeTmp,options));var sameDirectionIncreasing=!(">="!==this.operator&&">"!==this.operator||">="!==comp.operator&&">"!==comp.operator),sameDirectionDecreasing=!("<="!==this.operator&&"<"!==this.operator||"<="!==comp.operator&&"<"!==comp.operator),sameSemVer=this.semver.version===comp.semver.version,differentDirectionsInclusive=!(">="!==this.operator&&"<="!==this.operator||">="!==comp.operator&&"<="!==comp.operator),oppositeDirectionsLessThan=cmp(this.semver,"<",comp.semver,options)&&(">="===this.operator||">"===this.operator)&&("<="===comp.operator||"<"===comp.operator),oppositeDirectionsGreaterThan=cmp(this.semver,">",comp.semver,options)&&("<="===this.operator||"<"===this.operator)&&(">="===comp.operator||">"===comp.operator);return sameDirectionIncreasing||sameDirectionDecreasing||sameSemVer&&differentDirectionsInclusive||oppositeDirectionsLessThan||oppositeDirectionsGreaterThan},exports.Range=Range,Range.prototype.format=function(){return this.range=this.set.map((function(comps){return comps.join(" ").trim()})).join("||").trim(),this.range},Range.prototype.toString=function(){return this.range},Range.prototype.parseRange=function(range){var loose=this.options.loose;range=range.trim();var hr=loose?re[t.HYPHENRANGELOOSE]:re[t.HYPHENRANGE];range=range.replace(hr,hyphenReplace),debug("hyphen replace",range),range=range.replace(re[t.COMPARATORTRIM],"$1$2$3"),debug("comparator trim",range,re[t.COMPARATORTRIM]),range=(range=(range=range.replace(re[t.TILDETRIM],"$1~")).replace(re[t.CARETTRIM],"$1^")).split(/\s+/).join(" ");var compRe=loose?re[t.COMPARATORLOOSE]:re[t.COMPARATOR],set=range.split(" ").map((function(comp){return function(comp,options){return debug("comp",comp,options),comp=function(comp,options){return comp.trim().split(/\s+/).map((function(comp){return function(comp,options){debug("caret",comp,options);var r=options.loose?re[t.CARETLOOSE]:re[t.CARET];return comp.replace(r,(function(_,M,m,p,pr){var ret;return debug("caret",comp,_,M,m,p,pr),isX(M)?ret="":isX(m)?ret=">="+M+".0.0 <"+(+M+1)+".0.0":isX(p)?ret="0"===M?">="+M+"."+m+".0 <"+M+"."+(+m+1)+".0":">="+M+"."+m+".0 <"+(+M+1)+".0.0":pr?(debug("replaceCaret pr",pr),ret="0"===M?"0"===m?">="+M+"."+m+"."+p+"-"+pr+" <"+M+"."+m+"."+(+p+1):">="+M+"."+m+"."+p+"-"+pr+" <"+M+"."+(+m+1)+".0":">="+M+"."+m+"."+p+"-"+pr+" <"+(+M+1)+".0.0"):(debug("no pr"),ret="0"===M?"0"===m?">="+M+"."+m+"."+p+" <"+M+"."+m+"."+(+p+1):">="+M+"."+m+"."+p+" <"+M+"."+(+m+1)+".0":">="+M+"."+m+"."+p+" <"+(+M+1)+".0.0"),debug("caret return",ret),ret}))}(comp,options)})).join(" ")}(comp,options),debug("caret",comp),comp=function(comp,options){return comp.trim().split(/\s+/).map((function(comp){return function(comp,options){var r=options.loose?re[t.TILDELOOSE]:re[t.TILDE];return comp.replace(r,(function(_,M,m,p,pr){var ret;return debug("tilde",comp,_,M,m,p,pr),isX(M)?ret="":isX(m)?ret=">="+M+".0.0 <"+(+M+1)+".0.0":isX(p)?ret=">="+M+"."+m+".0 <"+M+"."+(+m+1)+".0":pr?(debug("replaceTilde pr",pr),ret=">="+M+"."+m+"."+p+"-"+pr+" <"+M+"."+(+m+1)+".0"):ret=">="+M+"."+m+"."+p+" <"+M+"."+(+m+1)+".0",debug("tilde return",ret),ret}))}(comp,options)})).join(" ")}(comp,options),debug("tildes",comp),comp=function(comp,options){return debug("replaceXRanges",comp,options),comp.split(/\s+/).map((function(comp){return function(comp,options){comp=comp.trim();var r=options.loose?re[t.XRANGELOOSE]:re[t.XRANGE];return comp.replace(r,(function(ret,gtlt,M,m,p,pr){debug("xRange",comp,ret,gtlt,M,m,p,pr);var xM=isX(M),xm=xM||isX(m),xp=xm||isX(p),anyX=xp;return "="===gtlt&&anyX&&(gtlt=""),pr=options.includePrerelease?"-0":"",xM?ret=">"===gtlt||"<"===gtlt?"<0.0.0-0":"*":gtlt&&anyX?(xm&&(m=0),p=0,">"===gtlt?(gtlt=">=",xm?(M=+M+1,m=0,p=0):(m=+m+1,p=0)):"<="===gtlt&&(gtlt="<",xm?M=+M+1:m=+m+1),ret=gtlt+M+"."+m+"."+p+pr):xm?ret=">="+M+".0.0"+pr+" <"+(+M+1)+".0.0"+pr:xp&&(ret=">="+M+"."+m+".0"+pr+" <"+M+"."+(+m+1)+".0"+pr),debug("xRange return",ret),ret}))}(comp,options)})).join(" ")}(comp,options),debug("xrange",comp),comp=function(comp,options){return debug("replaceStars",comp,options),comp.trim().replace(re[t.STAR],"")}(comp,options),debug("stars",comp),comp}(comp,this.options)}),this).join(" ").split(/\s+/);return this.options.loose&&(set=set.filter((function(comp){return !!comp.match(compRe)}))),set=set.map((function(comp){return new Comparator(comp,this.options)}),this)},Range.prototype.intersects=function(range,options){if(!(range instanceof Range))throw new TypeError("a Range is required");return this.set.some((function(thisComparators){return isSatisfiable(thisComparators,options)&&range.set.some((function(rangeComparators){return isSatisfiable(rangeComparators,options)&&thisComparators.every((function(thisComparator){return rangeComparators.every((function(rangeComparator){return thisComparator.intersects(rangeComparator,options)}))}))}))}))},exports.toComparators=function(range,options){return new Range(range,options).set.map((function(comp){return comp.map((function(c){return c.value})).join(" ").trim().split(" ")}))},Range.prototype.test=function(version){if(!version)return !1;if("string"==typeof version)try{version=new SemVer(version,this.options);}catch(er){return !1}for(var i=0;i<this.set.length;i++)if(testSet(this.set[i],version,this.options))return !0;return !1},exports.satisfies=satisfies,exports.maxSatisfying=function(versions,range,options){var max=null,maxSV=null;try{var rangeObj=new Range(range,options);}catch(er){return null}return versions.forEach((function(v){rangeObj.test(v)&&(max&&-1!==maxSV.compare(v)||(maxSV=new SemVer(max=v,options)));})),max},exports.minSatisfying=function(versions,range,options){var min=null,minSV=null;try{var rangeObj=new Range(range,options);}catch(er){return null}return versions.forEach((function(v){rangeObj.test(v)&&(min&&1!==minSV.compare(v)||(minSV=new SemVer(min=v,options)));})),min},exports.minVersion=function(range,loose){range=new Range(range,loose);var minver=new SemVer("0.0.0");if(range.test(minver))return minver;if(minver=new SemVer("0.0.0-0"),range.test(minver))return minver;minver=null;for(var i=0;i<range.set.length;++i){range.set[i].forEach((function(comparator){var compver=new SemVer(comparator.semver.version);switch(comparator.operator){case">":0===compver.prerelease.length?compver.patch++:compver.prerelease.push(0),compver.raw=compver.format();case"":case">=":minver&&!gt(minver,compver)||(minver=compver);break;case"<":case"<=":break;default:throw new Error("Unexpected operation: "+comparator.operator)}}));}if(minver&&range.test(minver))return minver;return null},exports.validRange=function(range,options){try{return new Range(range,options).range||"*"}catch(er){return null}},exports.ltr=function(version,range,options){return outside(version,range,"<",options)},exports.gtr=function(version,range,options){return outside(version,range,">",options)},exports.outside=outside,exports.prerelease=function(version,options){var parsed=parse(version,options);return parsed&&parsed.prerelease.length?parsed.prerelease:null},exports.intersects=function(r1,r2,options){return r1=new Range(r1,options),r2=new Range(r2,options),r1.intersects(r2)},exports.coerce=function(version,options){if(version instanceof SemVer)return version;"number"==typeof version&&(version=String(version));if("string"!=typeof version)return null;var match=null;if((options=options||{}).rtl){for(var next;(next=re[t.COERCERTL].exec(version))&&(!match||match.index+match[0].length!==version.length);)match&&next.index+next[0].length===match.index+match[0].length||(match=next),re[t.COERCERTL].lastIndex=next.index+next[1].length+next[2].length;re[t.COERCERTL].lastIndex=-1;}else match=version.match(re[t.COERCE]);if(null===match)return null;return parse(match[2]+"."+(match[3]||"0")+"."+(match[4]||"0"),options)};},"./node_modules/@babel/core/node_modules/source-map/lib/array-set.js":(__unused_webpack_module,exports,__webpack_require__)=>{var util=__webpack_require__("./node_modules/@babel/core/node_modules/source-map/lib/util.js"),has=Object.prototype.hasOwnProperty,hasNativeMap="undefined"!=typeof Map;function ArraySet(){this._array=[],this._set=hasNativeMap?new Map:Object.create(null);}ArraySet.fromArray=function(aArray,aAllowDuplicates){for(var set=new ArraySet,i=0,len=aArray.length;i<len;i++)set.add(aArray[i],aAllowDuplicates);return set},ArraySet.prototype.size=function(){return hasNativeMap?this._set.size:Object.getOwnPropertyNames(this._set).length},ArraySet.prototype.add=function(aStr,aAllowDuplicates){var sStr=hasNativeMap?aStr:util.toSetString(aStr),isDuplicate=hasNativeMap?this.has(aStr):has.call(this._set,sStr),idx=this._array.length;isDuplicate&&!aAllowDuplicates||this._array.push(aStr),isDuplicate||(hasNativeMap?this._set.set(aStr,idx):this._set[sStr]=idx);},ArraySet.prototype.has=function(aStr){if(hasNativeMap)return this._set.has(aStr);var sStr=util.toSetString(aStr);return has.call(this._set,sStr)},ArraySet.prototype.indexOf=function(aStr){if(hasNativeMap){var idx=this._set.get(aStr);if(idx>=0)return idx}else {var sStr=util.toSetString(aStr);if(has.call(this._set,sStr))return this._set[sStr]}throw new Error('"'+aStr+'" is not in the set.')},ArraySet.prototype.at=function(aIdx){if(aIdx>=0&&aIdx<this._array.length)return this._array[aIdx];throw new Error("No element indexed by "+aIdx)},ArraySet.prototype.toArray=function(){return this._array.slice()},exports.I=ArraySet;},"./node_modules/@babel/core/node_modules/source-map/lib/base64-vlq.js":(__unused_webpack_module,exports,__webpack_require__)=>{var base64=__webpack_require__("./node_modules/@babel/core/node_modules/source-map/lib/base64.js");exports.encode=function(aValue){var digit,encoded="",vlq=function(aValue){return aValue<0?1+(-aValue<<1):0+(aValue<<1)}(aValue);do{digit=31&vlq,(vlq>>>=5)>0&&(digit|=32),encoded+=base64.encode(digit);}while(vlq>0);return encoded},exports.decode=function(aStr,aIndex,aOutParam){var continuation,digit,aValue,shifted,strLen=aStr.length,result=0,shift=0;do{if(aIndex>=strLen)throw new Error("Expected more digits in base 64 VLQ value.");if(-1===(digit=base64.decode(aStr.charCodeAt(aIndex++))))throw new Error("Invalid base64 digit: "+aStr.charAt(aIndex-1));continuation=!!(32&digit),result+=(digit&=31)<<shift,shift+=5;}while(continuation);aOutParam.value=(shifted=(aValue=result)>>1,1==(1&aValue)?-shifted:shifted),aOutParam.rest=aIndex;};},"./node_modules/@babel/core/node_modules/source-map/lib/base64.js":(__unused_webpack_module,exports)=>{var intToCharMap="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");exports.encode=function(number){if(0<=number&&number<intToCharMap.length)return intToCharMap[number];throw new TypeError("Must be between 0 and 63: "+number)},exports.decode=function(charCode){return 65<=charCode&&charCode<=90?charCode-65:97<=charCode&&charCode<=122?charCode-97+26:48<=charCode&&charCode<=57?charCode-48+52:43==charCode?62:47==charCode?63:-1};},"./node_modules/@babel/core/node_modules/source-map/lib/binary-search.js":(__unused_webpack_module,exports)=>{function recursiveSearch(aLow,aHigh,aNeedle,aHaystack,aCompare,aBias){var mid=Math.floor((aHigh-aLow)/2)+aLow,cmp=aCompare(aNeedle,aHaystack[mid],!0);return 0===cmp?mid:cmp>0?aHigh-mid>1?recursiveSearch(mid,aHigh,aNeedle,aHaystack,aCompare,aBias):aBias==exports.LEAST_UPPER_BOUND?aHigh<aHaystack.length?aHigh:-1:mid:mid-aLow>1?recursiveSearch(aLow,mid,aNeedle,aHaystack,aCompare,aBias):aBias==exports.LEAST_UPPER_BOUND?mid:aLow<0?-1:aLow}exports.GREATEST_LOWER_BOUND=1,exports.LEAST_UPPER_BOUND=2,exports.search=function(aNeedle,aHaystack,aCompare,aBias){if(0===aHaystack.length)return -1;var index=recursiveSearch(-1,aHaystack.length,aNeedle,aHaystack,aCompare,aBias||exports.GREATEST_LOWER_BOUND);if(index<0)return -1;for(;index-1>=0&&0===aCompare(aHaystack[index],aHaystack[index-1],!0);)--index;return index};},"./node_modules/@babel/core/node_modules/source-map/lib/mapping-list.js":(__unused_webpack_module,exports,__webpack_require__)=>{var util=__webpack_require__("./node_modules/@babel/core/node_modules/source-map/lib/util.js");function MappingList(){this._array=[],this._sorted=!0,this._last={generatedLine:-1,generatedColumn:0};}MappingList.prototype.unsortedForEach=function(aCallback,aThisArg){this._array.forEach(aCallback,aThisArg);},MappingList.prototype.add=function(aMapping){var mappingA,mappingB,lineA,lineB,columnA,columnB;mappingA=this._last,mappingB=aMapping,lineA=mappingA.generatedLine,lineB=mappingB.generatedLine,columnA=mappingA.generatedColumn,columnB=mappingB.generatedColumn,lineB>lineA||lineB==lineA&&columnB>=columnA||util.compareByGeneratedPositionsInflated(mappingA,mappingB)<=0?(this._last=aMapping,this._array.push(aMapping)):(this._sorted=!1,this._array.push(aMapping));},MappingList.prototype.toArray=function(){return this._sorted||(this._array.sort(util.compareByGeneratedPositionsInflated),this._sorted=!0),this._array},exports.H=MappingList;},"./node_modules/@babel/core/node_modules/source-map/lib/quick-sort.js":(__unused_webpack_module,exports)=>{function swap(ary,x,y){var temp=ary[x];ary[x]=ary[y],ary[y]=temp;}function doQuickSort(ary,comparator,p,r){if(p<r){var i=p-1;swap(ary,(low=p,high=r,Math.round(low+Math.random()*(high-low))),r);for(var pivot=ary[r],j=p;j<r;j++)comparator(ary[j],pivot)<=0&&swap(ary,i+=1,j);swap(ary,i+1,j);var q=i+1;doQuickSort(ary,comparator,p,q-1),doQuickSort(ary,comparator,q+1,r);}var low,high;}exports.U=function(ary,comparator){doQuickSort(ary,comparator,0,ary.length-1);};},"./node_modules/@babel/core/node_modules/source-map/lib/source-map-consumer.js":(__unused_webpack_module,exports,__webpack_require__)=>{var util=__webpack_require__("./node_modules/@babel/core/node_modules/source-map/lib/util.js"),binarySearch=__webpack_require__("./node_modules/@babel/core/node_modules/source-map/lib/binary-search.js"),ArraySet=__webpack_require__("./node_modules/@babel/core/node_modules/source-map/lib/array-set.js").I,base64VLQ=__webpack_require__("./node_modules/@babel/core/node_modules/source-map/lib/base64-vlq.js"),quickSort=__webpack_require__("./node_modules/@babel/core/node_modules/source-map/lib/quick-sort.js").U;function SourceMapConsumer(aSourceMap){var sourceMap=aSourceMap;return "string"==typeof aSourceMap&&(sourceMap=JSON.parse(aSourceMap.replace(/^\)\]\}'/,""))),null!=sourceMap.sections?new IndexedSourceMapConsumer(sourceMap):new BasicSourceMapConsumer(sourceMap)}function BasicSourceMapConsumer(aSourceMap){var sourceMap=aSourceMap;"string"==typeof aSourceMap&&(sourceMap=JSON.parse(aSourceMap.replace(/^\)\]\}'/,"")));var version=util.getArg(sourceMap,"version"),sources=util.getArg(sourceMap,"sources"),names=util.getArg(sourceMap,"names",[]),sourceRoot=util.getArg(sourceMap,"sourceRoot",null),sourcesContent=util.getArg(sourceMap,"sourcesContent",null),mappings=util.getArg(sourceMap,"mappings"),file=util.getArg(sourceMap,"file",null);if(version!=this._version)throw new Error("Unsupported version: "+version);sources=sources.map(String).map(util.normalize).map((function(source){return sourceRoot&&util.isAbsolute(sourceRoot)&&util.isAbsolute(source)?util.relative(sourceRoot,source):source})),this._names=ArraySet.fromArray(names.map(String),!0),this._sources=ArraySet.fromArray(sources,!0),this.sourceRoot=sourceRoot,this.sourcesContent=sourcesContent,this._mappings=mappings,this.file=file;}function Mapping(){this.generatedLine=0,this.generatedColumn=0,this.source=null,this.originalLine=null,this.originalColumn=null,this.name=null;}function IndexedSourceMapConsumer(aSourceMap){var sourceMap=aSourceMap;"string"==typeof aSourceMap&&(sourceMap=JSON.parse(aSourceMap.replace(/^\)\]\}'/,"")));var version=util.getArg(sourceMap,"version"),sections=util.getArg(sourceMap,"sections");if(version!=this._version)throw new Error("Unsupported version: "+version);this._sources=new ArraySet,this._names=new ArraySet;var lastOffset={line:-1,column:0};this._sections=sections.map((function(s){if(s.url)throw new Error("Support for url field in sections not implemented.");var offset=util.getArg(s,"offset"),offsetLine=util.getArg(offset,"line"),offsetColumn=util.getArg(offset,"column");if(offsetLine<lastOffset.line||offsetLine===lastOffset.line&&offsetColumn<lastOffset.column)throw new Error("Section offsets must be ordered and non-overlapping.");return lastOffset=offset,{generatedOffset:{generatedLine:offsetLine+1,generatedColumn:offsetColumn+1},consumer:new SourceMapConsumer(util.getArg(s,"map"))}}));}SourceMapConsumer.fromSourceMap=function(aSourceMap){return BasicSourceMapConsumer.fromSourceMap(aSourceMap)},SourceMapConsumer.prototype._version=3,SourceMapConsumer.prototype.__generatedMappings=null,Object.defineProperty(SourceMapConsumer.prototype,"_generatedMappings",{get:function(){return this.__generatedMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__generatedMappings}}),SourceMapConsumer.prototype.__originalMappings=null,Object.defineProperty(SourceMapConsumer.prototype,"_originalMappings",{get:function(){return this.__originalMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__originalMappings}}),SourceMapConsumer.prototype._charIsMappingSeparator=function(aStr,index){var c=aStr.charAt(index);return ";"===c||","===c},SourceMapConsumer.prototype._parseMappings=function(aStr,aSourceRoot){throw new Error("Subclasses must implement _parseMappings")},SourceMapConsumer.GENERATED_ORDER=1,SourceMapConsumer.ORIGINAL_ORDER=2,SourceMapConsumer.GREATEST_LOWER_BOUND=1,SourceMapConsumer.LEAST_UPPER_BOUND=2,SourceMapConsumer.prototype.eachMapping=function(aCallback,aContext,aOrder){var mappings,context=aContext||null;switch(aOrder||SourceMapConsumer.GENERATED_ORDER){case SourceMapConsumer.GENERATED_ORDER:mappings=this._generatedMappings;break;case SourceMapConsumer.ORIGINAL_ORDER:mappings=this._originalMappings;break;default:throw new Error("Unknown order of iteration.")}var sourceRoot=this.sourceRoot;mappings.map((function(mapping){var source=null===mapping.source?null:this._sources.at(mapping.source);return null!=source&&null!=sourceRoot&&(source=util.join(sourceRoot,source)),{source,generatedLine:mapping.generatedLine,generatedColumn:mapping.generatedColumn,originalLine:mapping.originalLine,originalColumn:mapping.originalColumn,name:null===mapping.name?null:this._names.at(mapping.name)}}),this).forEach(aCallback,context);},SourceMapConsumer.prototype.allGeneratedPositionsFor=function(aArgs){var line=util.getArg(aArgs,"line"),needle={source:util.getArg(aArgs,"source"),originalLine:line,originalColumn:util.getArg(aArgs,"column",0)};if(null!=this.sourceRoot&&(needle.source=util.relative(this.sourceRoot,needle.source)),!this._sources.has(needle.source))return [];needle.source=this._sources.indexOf(needle.source);var mappings=[],index=this._findMapping(needle,this._originalMappings,"originalLine","originalColumn",util.compareByOriginalPositions,binarySearch.LEAST_UPPER_BOUND);if(index>=0){var mapping=this._originalMappings[index];if(void 0===aArgs.column)for(var originalLine=mapping.originalLine;mapping&&mapping.originalLine===originalLine;)mappings.push({line:util.getArg(mapping,"generatedLine",null),column:util.getArg(mapping,"generatedColumn",null),lastColumn:util.getArg(mapping,"lastGeneratedColumn",null)}),mapping=this._originalMappings[++index];else for(var originalColumn=mapping.originalColumn;mapping&&mapping.originalLine===line&&mapping.originalColumn==originalColumn;)mappings.push({line:util.getArg(mapping,"generatedLine",null),column:util.getArg(mapping,"generatedColumn",null),lastColumn:util.getArg(mapping,"lastGeneratedColumn",null)}),mapping=this._originalMappings[++index];}return mappings},exports.SourceMapConsumer=SourceMapConsumer,BasicSourceMapConsumer.prototype=Object.create(SourceMapConsumer.prototype),BasicSourceMapConsumer.prototype.consumer=SourceMapConsumer,BasicSourceMapConsumer.fromSourceMap=function(aSourceMap){var smc=Object.create(BasicSourceMapConsumer.prototype),names=smc._names=ArraySet.fromArray(aSourceMap._names.toArray(),!0),sources=smc._sources=ArraySet.fromArray(aSourceMap._sources.toArray(),!0);smc.sourceRoot=aSourceMap._sourceRoot,smc.sourcesContent=aSourceMap._generateSourcesContent(smc._sources.toArray(),smc.sourceRoot),smc.file=aSourceMap._file;for(var generatedMappings=aSourceMap._mappings.toArray().slice(),destGeneratedMappings=smc.__generatedMappings=[],destOriginalMappings=smc.__originalMappings=[],i=0,length=generatedMappings.length;i<length;i++){var srcMapping=generatedMappings[i],destMapping=new Mapping;destMapping.generatedLine=srcMapping.generatedLine,destMapping.generatedColumn=srcMapping.generatedColumn,srcMapping.source&&(destMapping.source=sources.indexOf(srcMapping.source),destMapping.originalLine=srcMapping.originalLine,destMapping.originalColumn=srcMapping.originalColumn,srcMapping.name&&(destMapping.name=names.indexOf(srcMapping.name)),destOriginalMappings.push(destMapping)),destGeneratedMappings.push(destMapping);}return quickSort(smc.__originalMappings,util.compareByOriginalPositions),smc},BasicSourceMapConsumer.prototype._version=3,Object.defineProperty(BasicSourceMapConsumer.prototype,"sources",{get:function(){return this._sources.toArray().map((function(s){return null!=this.sourceRoot?util.join(this.sourceRoot,s):s}),this)}}),BasicSourceMapConsumer.prototype._parseMappings=function(aStr,aSourceRoot){for(var mapping,str,segment,end,value,generatedLine=1,previousGeneratedColumn=0,previousOriginalLine=0,previousOriginalColumn=0,previousSource=0,previousName=0,length=aStr.length,index=0,cachedSegments={},temp={},originalMappings=[],generatedMappings=[];index<length;)if(";"===aStr.charAt(index))generatedLine++,index++,previousGeneratedColumn=0;else if(","===aStr.charAt(index))index++;else {for((mapping=new Mapping).generatedLine=generatedLine,end=index;end<length&&!this._charIsMappingSeparator(aStr,end);end++);if(segment=cachedSegments[str=aStr.slice(index,end)])index+=str.length;else {for(segment=[];index<end;)base64VLQ.decode(aStr,index,temp),value=temp.value,index=temp.rest,segment.push(value);if(2===segment.length)throw new Error("Found a source, but no line and column");if(3===segment.length)throw new Error("Found a source and line, but no column");cachedSegments[str]=segment;}mapping.generatedColumn=previousGeneratedColumn+segment[0],previousGeneratedColumn=mapping.generatedColumn,segment.length>1&&(mapping.source=previousSource+segment[1],previousSource+=segment[1],mapping.originalLine=previousOriginalLine+segment[2],previousOriginalLine=mapping.originalLine,mapping.originalLine+=1,mapping.originalColumn=previousOriginalColumn+segment[3],previousOriginalColumn=mapping.originalColumn,segment.length>4&&(mapping.name=previousName+segment[4],previousName+=segment[4])),generatedMappings.push(mapping),"number"==typeof mapping.originalLine&&originalMappings.push(mapping);}quickSort(generatedMappings,util.compareByGeneratedPositionsDeflated),this.__generatedMappings=generatedMappings,quickSort(originalMappings,util.compareByOriginalPositions),this.__originalMappings=originalMappings;},BasicSourceMapConsumer.prototype._findMapping=function(aNeedle,aMappings,aLineName,aColumnName,aComparator,aBias){if(aNeedle[aLineName]<=0)throw new TypeError("Line must be greater than or equal to 1, got "+aNeedle[aLineName]);if(aNeedle[aColumnName]<0)throw new TypeError("Column must be greater than or equal to 0, got "+aNeedle[aColumnName]);return binarySearch.search(aNeedle,aMappings,aComparator,aBias)},BasicSourceMapConsumer.prototype.computeColumnSpans=function(){for(var index=0;index<this._generatedMappings.length;++index){var mapping=this._generatedMappings[index];if(index+1<this._generatedMappings.length){var nextMapping=this._generatedMappings[index+1];if(mapping.generatedLine===nextMapping.generatedLine){mapping.lastGeneratedColumn=nextMapping.generatedColumn-1;continue}}mapping.lastGeneratedColumn=1/0;}},BasicSourceMapConsumer.prototype.originalPositionFor=function(aArgs){var needle={generatedLine:util.getArg(aArgs,"line"),generatedColumn:util.getArg(aArgs,"column")},index=this._findMapping(needle,this._generatedMappings,"generatedLine","generatedColumn",util.compareByGeneratedPositionsDeflated,util.getArg(aArgs,"bias",SourceMapConsumer.GREATEST_LOWER_BOUND));if(index>=0){var mapping=this._generatedMappings[index];if(mapping.generatedLine===needle.generatedLine){var source=util.getArg(mapping,"source",null);null!==source&&(source=this._sources.at(source),null!=this.sourceRoot&&(source=util.join(this.sourceRoot,source)));var name=util.getArg(mapping,"name",null);return null!==name&&(name=this._names.at(name)),{source,line:util.getArg(mapping,"originalLine",null),column:util.getArg(mapping,"originalColumn",null),name}}}return {source:null,line:null,column:null,name:null}},BasicSourceMapConsumer.prototype.hasContentsOfAllSources=function(){return !!this.sourcesContent&&(this.sourcesContent.length>=this._sources.size()&&!this.sourcesContent.some((function(sc){return null==sc})))},BasicSourceMapConsumer.prototype.sourceContentFor=function(aSource,nullOnMissing){if(!this.sourcesContent)return null;if(null!=this.sourceRoot&&(aSource=util.relative(this.sourceRoot,aSource)),this._sources.has(aSource))return this.sourcesContent[this._sources.indexOf(aSource)];var url;if(null!=this.sourceRoot&&(url=util.urlParse(this.sourceRoot))){var fileUriAbsPath=aSource.replace(/^file:\/\//,"");if("file"==url.scheme&&this._sources.has(fileUriAbsPath))return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];if((!url.path||"/"==url.path)&&this._sources.has("/"+aSource))return this.sourcesContent[this._sources.indexOf("/"+aSource)]}if(nullOnMissing)return null;throw new Error('"'+aSource+'" is not in the SourceMap.')},BasicSourceMapConsumer.prototype.generatedPositionFor=function(aArgs){var source=util.getArg(aArgs,"source");if(null!=this.sourceRoot&&(source=util.relative(this.sourceRoot,source)),!this._sources.has(source))return {line:null,column:null,lastColumn:null};var needle={source:source=this._sources.indexOf(source),originalLine:util.getArg(aArgs,"line"),originalColumn:util.getArg(aArgs,"column")},index=this._findMapping(needle,this._originalMappings,"originalLine","originalColumn",util.compareByOriginalPositions,util.getArg(aArgs,"bias",SourceMapConsumer.GREATEST_LOWER_BOUND));if(index>=0){var mapping=this._originalMappings[index];if(mapping.source===needle.source)return {line:util.getArg(mapping,"generatedLine",null),column:util.getArg(mapping,"generatedColumn",null),lastColumn:util.getArg(mapping,"lastGeneratedColumn",null)}}return {line:null,column:null,lastColumn:null}},IndexedSourceMapConsumer.prototype=Object.create(SourceMapConsumer.prototype),IndexedSourceMapConsumer.prototype.constructor=SourceMapConsumer,IndexedSourceMapConsumer.prototype._version=3,Object.defineProperty(IndexedSourceMapConsumer.prototype,"sources",{get:function(){for(var sources=[],i=0;i<this._sections.length;i++)for(var j=0;j<this._sections[i].consumer.sources.length;j++)sources.push(this._sections[i].consumer.sources[j]);return sources}}),IndexedSourceMapConsumer.prototype.originalPositionFor=function(aArgs){var needle={generatedLine:util.getArg(aArgs,"line"),generatedColumn:util.getArg(aArgs,"column")},sectionIndex=binarySearch.search(needle,this._sections,(function(needle,section){var cmp=needle.generatedLine-section.generatedOffset.generatedLine;return cmp||needle.generatedColumn-section.generatedOffset.generatedColumn})),section=this._sections[sectionIndex];return section?section.consumer.originalPositionFor({line:needle.generatedLine-(section.generatedOffset.generatedLine-1),column:needle.generatedColumn-(section.generatedOffset.generatedLine===needle.generatedLine?section.generatedOffset.generatedColumn-1:0),bias:aArgs.bias}):{source:null,line:null,column:null,name:null}},IndexedSourceMapConsumer.prototype.hasContentsOfAllSources=function(){return this._sections.every((function(s){return s.consumer.hasContentsOfAllSources()}))},IndexedSourceMapConsumer.prototype.sourceContentFor=function(aSource,nullOnMissing){for(var i=0;i<this._sections.length;i++){var content=this._sections[i].consumer.sourceContentFor(aSource,!0);if(content)return content}if(nullOnMissing)return null;throw new Error('"'+aSource+'" is not in the SourceMap.')},IndexedSourceMapConsumer.prototype.generatedPositionFor=function(aArgs){for(var i=0;i<this._sections.length;i++){var section=this._sections[i];if(-1!==section.consumer.sources.indexOf(util.getArg(aArgs,"source"))){var generatedPosition=section.consumer.generatedPositionFor(aArgs);if(generatedPosition)return {line:generatedPosition.line+(section.generatedOffset.generatedLine-1),column:generatedPosition.column+(section.generatedOffset.generatedLine===generatedPosition.line?section.generatedOffset.generatedColumn-1:0)}}}return {line:null,column:null}},IndexedSourceMapConsumer.prototype._parseMappings=function(aStr,aSourceRoot){this.__generatedMappings=[],this.__originalMappings=[];for(var i=0;i<this._sections.length;i++)for(var section=this._sections[i],sectionMappings=section.consumer._generatedMappings,j=0;j<sectionMappings.length;j++){var mapping=sectionMappings[j],source=section.consumer._sources.at(mapping.source);null!==section.consumer.sourceRoot&&(source=util.join(section.consumer.sourceRoot,source)),this._sources.add(source),source=this._sources.indexOf(source);var name=section.consumer._names.at(mapping.name);this._names.add(name),name=this._names.indexOf(name);var adjustedMapping={source,generatedLine:mapping.generatedLine+(section.generatedOffset.generatedLine-1),generatedColumn:mapping.generatedColumn+(section.generatedOffset.generatedLine===mapping.generatedLine?section.generatedOffset.generatedColumn-1:0),originalLine:mapping.originalLine,originalColumn:mapping.originalColumn,name};this.__generatedMappings.push(adjustedMapping),"number"==typeof adjustedMapping.originalLine&&this.__originalMappings.push(adjustedMapping);}quickSort(this.__generatedMappings,util.compareByGeneratedPositionsDeflated),quickSort(this.__originalMappings,util.compareByOriginalPositions);};},"./node_modules/@babel/core/node_modules/source-map/lib/source-map-generator.js":(__unused_webpack_module,exports,__webpack_require__)=>{var base64VLQ=__webpack_require__("./node_modules/@babel/core/node_modules/source-map/lib/base64-vlq.js"),util=__webpack_require__("./node_modules/@babel/core/node_modules/source-map/lib/util.js"),ArraySet=__webpack_require__("./node_modules/@babel/core/node_modules/source-map/lib/array-set.js").I,MappingList=__webpack_require__("./node_modules/@babel/core/node_modules/source-map/lib/mapping-list.js").H;function SourceMapGenerator(aArgs){aArgs||(aArgs={}),this._file=util.getArg(aArgs,"file",null),this._sourceRoot=util.getArg(aArgs,"sourceRoot",null),this._skipValidation=util.getArg(aArgs,"skipValidation",!1),this._sources=new ArraySet,this._names=new ArraySet,this._mappings=new MappingList,this._sourcesContents=null;}SourceMapGenerator.prototype._version=3,SourceMapGenerator.fromSourceMap=function(aSourceMapConsumer){var sourceRoot=aSourceMapConsumer.sourceRoot,generator=new SourceMapGenerator({file:aSourceMapConsumer.file,sourceRoot});return aSourceMapConsumer.eachMapping((function(mapping){var newMapping={generated:{line:mapping.generatedLine,column:mapping.generatedColumn}};null!=mapping.source&&(newMapping.source=mapping.source,null!=sourceRoot&&(newMapping.source=util.relative(sourceRoot,newMapping.source)),newMapping.original={line:mapping.originalLine,column:mapping.originalColumn},null!=mapping.name&&(newMapping.name=mapping.name)),generator.addMapping(newMapping);})),aSourceMapConsumer.sources.forEach((function(sourceFile){var content=aSourceMapConsumer.sourceContentFor(sourceFile);null!=content&&generator.setSourceContent(sourceFile,content);})),generator},SourceMapGenerator.prototype.addMapping=function(aArgs){var generated=util.getArg(aArgs,"generated"),original=util.getArg(aArgs,"original",null),source=util.getArg(aArgs,"source",null),name=util.getArg(aArgs,"name",null);this._skipValidation||this._validateMapping(generated,original,source,name),null!=source&&(source=String(source),this._sources.has(source)||this._sources.add(source)),null!=name&&(name=String(name),this._names.has(name)||this._names.add(name)),this._mappings.add({generatedLine:generated.line,generatedColumn:generated.column,originalLine:null!=original&&original.line,originalColumn:null!=original&&original.column,source,name});},SourceMapGenerator.prototype.setSourceContent=function(aSourceFile,aSourceContent){var source=aSourceFile;null!=this._sourceRoot&&(source=util.relative(this._sourceRoot,source)),null!=aSourceContent?(this._sourcesContents||(this._sourcesContents=Object.create(null)),this._sourcesContents[util.toSetString(source)]=aSourceContent):this._sourcesContents&&(delete this._sourcesContents[util.toSetString(source)],0===Object.keys(this._sourcesContents).length&&(this._sourcesContents=null));},SourceMapGenerator.prototype.applySourceMap=function(aSourceMapConsumer,aSourceFile,aSourceMapPath){var sourceFile=aSourceFile;if(null==aSourceFile){if(null==aSourceMapConsumer.file)throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');sourceFile=aSourceMapConsumer.file;}var sourceRoot=this._sourceRoot;null!=sourceRoot&&(sourceFile=util.relative(sourceRoot,sourceFile));var newSources=new ArraySet,newNames=new ArraySet;this._mappings.unsortedForEach((function(mapping){if(mapping.source===sourceFile&&null!=mapping.originalLine){var original=aSourceMapConsumer.originalPositionFor({line:mapping.originalLine,column:mapping.originalColumn});null!=original.source&&(mapping.source=original.source,null!=aSourceMapPath&&(mapping.source=util.join(aSourceMapPath,mapping.source)),null!=sourceRoot&&(mapping.source=util.relative(sourceRoot,mapping.source)),mapping.originalLine=original.line,mapping.originalColumn=original.column,null!=original.name&&(mapping.name=original.name));}var source=mapping.source;null==source||newSources.has(source)||newSources.add(source);var name=mapping.name;null==name||newNames.has(name)||newNames.add(name);}),this),this._sources=newSources,this._names=newNames,aSourceMapConsumer.sources.forEach((function(sourceFile){var content=aSourceMapConsumer.sourceContentFor(sourceFile);null!=content&&(null!=aSourceMapPath&&(sourceFile=util.join(aSourceMapPath,sourceFile)),null!=sourceRoot&&(sourceFile=util.relative(sourceRoot,sourceFile)),this.setSourceContent(sourceFile,content));}),this);},SourceMapGenerator.prototype._validateMapping=function(aGenerated,aOriginal,aSource,aName){if(aOriginal&&"number"!=typeof aOriginal.line&&"number"!=typeof aOriginal.column)throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");if((!(aGenerated&&"line"in aGenerated&&"column"in aGenerated&&aGenerated.line>0&&aGenerated.column>=0)||aOriginal||aSource||aName)&&!(aGenerated&&"line"in aGenerated&&"column"in aGenerated&&aOriginal&&"line"in aOriginal&&"column"in aOriginal&&aGenerated.line>0&&aGenerated.column>=0&&aOriginal.line>0&&aOriginal.column>=0&&aSource))throw new Error("Invalid mapping: "+JSON.stringify({generated:aGenerated,source:aSource,original:aOriginal,name:aName}))},SourceMapGenerator.prototype._serializeMappings=function(){for(var next,mapping,nameIdx,sourceIdx,previousGeneratedColumn=0,previousGeneratedLine=1,previousOriginalColumn=0,previousOriginalLine=0,previousName=0,previousSource=0,result="",mappings=this._mappings.toArray(),i=0,len=mappings.length;i<len;i++){if(next="",(mapping=mappings[i]).generatedLine!==previousGeneratedLine)for(previousGeneratedColumn=0;mapping.generatedLine!==previousGeneratedLine;)next+=";",previousGeneratedLine++;else if(i>0){if(!util.compareByGeneratedPositionsInflated(mapping,mappings[i-1]))continue;next+=",";}next+=base64VLQ.encode(mapping.generatedColumn-previousGeneratedColumn),previousGeneratedColumn=mapping.generatedColumn,null!=mapping.source&&(sourceIdx=this._sources.indexOf(mapping.source),next+=base64VLQ.encode(sourceIdx-previousSource),previousSource=sourceIdx,next+=base64VLQ.encode(mapping.originalLine-1-previousOriginalLine),previousOriginalLine=mapping.originalLine-1,next+=base64VLQ.encode(mapping.originalColumn-previousOriginalColumn),previousOriginalColumn=mapping.originalColumn,null!=mapping.name&&(nameIdx=this._names.indexOf(mapping.name),next+=base64VLQ.encode(nameIdx-previousName),previousName=nameIdx)),result+=next;}return result},SourceMapGenerator.prototype._generateSourcesContent=function(aSources,aSourceRoot){return aSources.map((function(source){if(!this._sourcesContents)return null;null!=aSourceRoot&&(source=util.relative(aSourceRoot,source));var key=util.toSetString(source);return Object.prototype.hasOwnProperty.call(this._sourcesContents,key)?this._sourcesContents[key]:null}),this)},SourceMapGenerator.prototype.toJSON=function(){var map={version:this._version,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};return null!=this._file&&(map.file=this._file),null!=this._sourceRoot&&(map.sourceRoot=this._sourceRoot),this._sourcesContents&&(map.sourcesContent=this._generateSourcesContent(map.sources,map.sourceRoot)),map},SourceMapGenerator.prototype.toString=function(){return JSON.stringify(this.toJSON())},exports.SourceMapGenerator=SourceMapGenerator;},"./node_modules/@babel/core/node_modules/source-map/lib/source-node.js":(__unused_webpack_module,exports,__webpack_require__)=>{var SourceMapGenerator=__webpack_require__("./node_modules/@babel/core/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator,util=__webpack_require__("./node_modules/@babel/core/node_modules/source-map/lib/util.js"),REGEX_NEWLINE=/(\r?\n)/,isSourceNode="$$$isSourceNode$$$";function SourceNode(aLine,aColumn,aSource,aChunks,aName){this.children=[],this.sourceContents={},this.line=null==aLine?null:aLine,this.column=null==aColumn?null:aColumn,this.source=null==aSource?null:aSource,this.name=null==aName?null:aName,this[isSourceNode]=!0,null!=aChunks&&this.add(aChunks);}SourceNode.fromStringWithSourceMap=function(aGeneratedCode,aSourceMapConsumer,aRelativePath){var node=new SourceNode,remainingLines=aGeneratedCode.split(REGEX_NEWLINE),remainingLinesIndex=0,shiftNextLine=function(){return getNextLine()+(getNextLine()||"");function getNextLine(){return remainingLinesIndex<remainingLines.length?remainingLines[remainingLinesIndex++]:void 0}},lastGeneratedLine=1,lastGeneratedColumn=0,lastMapping=null;return aSourceMapConsumer.eachMapping((function(mapping){if(null!==lastMapping){if(!(lastGeneratedLine<mapping.generatedLine)){var code=(nextLine=remainingLines[remainingLinesIndex]).substr(0,mapping.generatedColumn-lastGeneratedColumn);return remainingLines[remainingLinesIndex]=nextLine.substr(mapping.generatedColumn-lastGeneratedColumn),lastGeneratedColumn=mapping.generatedColumn,addMappingWithCode(lastMapping,code),void(lastMapping=mapping)}addMappingWithCode(lastMapping,shiftNextLine()),lastGeneratedLine++,lastGeneratedColumn=0;}for(;lastGeneratedLine<mapping.generatedLine;)node.add(shiftNextLine()),lastGeneratedLine++;if(lastGeneratedColumn<mapping.generatedColumn){var nextLine=remainingLines[remainingLinesIndex];node.add(nextLine.substr(0,mapping.generatedColumn)),remainingLines[remainingLinesIndex]=nextLine.substr(mapping.generatedColumn),lastGeneratedColumn=mapping.generatedColumn;}lastMapping=mapping;}),this),remainingLinesIndex<remainingLines.length&&(lastMapping&&addMappingWithCode(lastMapping,shiftNextLine()),node.add(remainingLines.splice(remainingLinesIndex).join(""))),aSourceMapConsumer.sources.forEach((function(sourceFile){var content=aSourceMapConsumer.sourceContentFor(sourceFile);null!=content&&(null!=aRelativePath&&(sourceFile=util.join(aRelativePath,sourceFile)),node.setSourceContent(sourceFile,content));})),node;function addMappingWithCode(mapping,code){if(null===mapping||void 0===mapping.source)node.add(code);else {var source=aRelativePath?util.join(aRelativePath,mapping.source):mapping.source;node.add(new SourceNode(mapping.originalLine,mapping.originalColumn,source,code,mapping.name));}}},SourceNode.prototype.add=function(aChunk){if(Array.isArray(aChunk))aChunk.forEach((function(chunk){this.add(chunk);}),this);else {if(!aChunk[isSourceNode]&&"string"!=typeof aChunk)throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+aChunk);aChunk&&this.children.push(aChunk);}return this},SourceNode.prototype.prepend=function(aChunk){if(Array.isArray(aChunk))for(var i=aChunk.length-1;i>=0;i--)this.prepend(aChunk[i]);else {if(!aChunk[isSourceNode]&&"string"!=typeof aChunk)throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+aChunk);this.children.unshift(aChunk);}return this},SourceNode.prototype.walk=function(aFn){for(var chunk,i=0,len=this.children.length;i<len;i++)(chunk=this.children[i])[isSourceNode]?chunk.walk(aFn):""!==chunk&&aFn(chunk,{source:this.source,line:this.line,column:this.column,name:this.name});},SourceNode.prototype.join=function(aSep){var newChildren,i,len=this.children.length;if(len>0){for(newChildren=[],i=0;i<len-1;i++)newChildren.push(this.children[i]),newChildren.push(aSep);newChildren.push(this.children[i]),this.children=newChildren;}return this},SourceNode.prototype.replaceRight=function(aPattern,aReplacement){var lastChild=this.children[this.children.length-1];return lastChild[isSourceNode]?lastChild.replaceRight(aPattern,aReplacement):"string"==typeof lastChild?this.children[this.children.length-1]=lastChild.replace(aPattern,aReplacement):this.children.push("".replace(aPattern,aReplacement)),this},SourceNode.prototype.setSourceContent=function(aSourceFile,aSourceContent){this.sourceContents[util.toSetString(aSourceFile)]=aSourceContent;},SourceNode.prototype.walkSourceContents=function(aFn){for(var i=0,len=this.children.length;i<len;i++)this.children[i][isSourceNode]&&this.children[i].walkSourceContents(aFn);var sources=Object.keys(this.sourceContents);for(i=0,len=sources.length;i<len;i++)aFn(util.fromSetString(sources[i]),this.sourceContents[sources[i]]);},SourceNode.prototype.toString=function(){var str="";return this.walk((function(chunk){str+=chunk;})),str},SourceNode.prototype.toStringWithSourceMap=function(aArgs){var generated={code:"",line:1,column:0},map=new SourceMapGenerator(aArgs),sourceMappingActive=!1,lastOriginalSource=null,lastOriginalLine=null,lastOriginalColumn=null,lastOriginalName=null;return this.walk((function(chunk,original){generated.code+=chunk,null!==original.source&&null!==original.line&&null!==original.column?(lastOriginalSource===original.source&&lastOriginalLine===original.line&&lastOriginalColumn===original.column&&lastOriginalName===original.name||map.addMapping({source:original.source,original:{line:original.line,column:original.column},generated:{line:generated.line,column:generated.column},name:original.name}),lastOriginalSource=original.source,lastOriginalLine=original.line,lastOriginalColumn=original.column,lastOriginalName=original.name,sourceMappingActive=!0):sourceMappingActive&&(map.addMapping({generated:{line:generated.line,column:generated.column}}),lastOriginalSource=null,sourceMappingActive=!1);for(var idx=0,length=chunk.length;idx<length;idx++)10===chunk.charCodeAt(idx)?(generated.line++,generated.column=0,idx+1===length?(lastOriginalSource=null,sourceMappingActive=!1):sourceMappingActive&&map.addMapping({source:original.source,original:{line:original.line,column:original.column},generated:{line:generated.line,column:generated.column},name:original.name})):generated.column++;})),this.walkSourceContents((function(sourceFile,sourceContent){map.setSourceContent(sourceFile,sourceContent);})),{code:generated.code,map}},exports.SourceNode=SourceNode;},"./node_modules/@babel/core/node_modules/source-map/lib/util.js":(__unused_webpack_module,exports)=>{exports.getArg=function(aArgs,aName,aDefaultValue){if(aName in aArgs)return aArgs[aName];if(3===arguments.length)return aDefaultValue;throw new Error('"'+aName+'" is a required argument.')};var urlRegexp=/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/,dataUrlRegexp=/^data:.+\,.+$/;function urlParse(aUrl){var match=aUrl.match(urlRegexp);return match?{scheme:match[1],auth:match[2],host:match[3],port:match[4],path:match[5]}:null}function urlGenerate(aParsedUrl){var url="";return aParsedUrl.scheme&&(url+=aParsedUrl.scheme+":"),url+="//",aParsedUrl.auth&&(url+=aParsedUrl.auth+"@"),aParsedUrl.host&&(url+=aParsedUrl.host),aParsedUrl.port&&(url+=":"+aParsedUrl.port),aParsedUrl.path&&(url+=aParsedUrl.path),url}function normalize(aPath){var path=aPath,url=urlParse(aPath);if(url){if(!url.path)return aPath;path=url.path;}for(var part,isAbsolute=exports.isAbsolute(path),parts=path.split(/\/+/),up=0,i=parts.length-1;i>=0;i--)"."===(part=parts[i])?parts.splice(i,1):".."===part?up++:up>0&&(""===part?(parts.splice(i+1,up),up=0):(parts.splice(i,2),up--));return ""===(path=parts.join("/"))&&(path=isAbsolute?"/":"."),url?(url.path=path,urlGenerate(url)):path}exports.urlParse=urlParse,exports.urlGenerate=urlGenerate,exports.normalize=normalize,exports.join=function(aRoot,aPath){""===aRoot&&(aRoot="."),""===aPath&&(aPath=".");var aPathUrl=urlParse(aPath),aRootUrl=urlParse(aRoot);if(aRootUrl&&(aRoot=aRootUrl.path||"/"),aPathUrl&&!aPathUrl.scheme)return aRootUrl&&(aPathUrl.scheme=aRootUrl.scheme),urlGenerate(aPathUrl);if(aPathUrl||aPath.match(dataUrlRegexp))return aPath;if(aRootUrl&&!aRootUrl.host&&!aRootUrl.path)return aRootUrl.host=aPath,urlGenerate(aRootUrl);var joined="/"===aPath.charAt(0)?aPath:normalize(aRoot.replace(/\/+$/,"")+"/"+aPath);return aRootUrl?(aRootUrl.path=joined,urlGenerate(aRootUrl)):joined},exports.isAbsolute=function(aPath){return "/"===aPath.charAt(0)||!!aPath.match(urlRegexp)},exports.relative=function(aRoot,aPath){""===aRoot&&(aRoot="."),aRoot=aRoot.replace(/\/$/,"");for(var level=0;0!==aPath.indexOf(aRoot+"/");){var index=aRoot.lastIndexOf("/");if(index<0)return aPath;if((aRoot=aRoot.slice(0,index)).match(/^([^\/]+:\/)?\/*$/))return aPath;++level;}return Array(level+1).join("../")+aPath.substr(aRoot.length+1)};var supportsNullProto=!("__proto__"in Object.create(null));function identity(s){return s}function isProtoString(s){if(!s)return !1;var length=s.length;if(length<9)return !1;if(95!==s.charCodeAt(length-1)||95!==s.charCodeAt(length-2)||111!==s.charCodeAt(length-3)||116!==s.charCodeAt(length-4)||111!==s.charCodeAt(length-5)||114!==s.charCodeAt(length-6)||112!==s.charCodeAt(length-7)||95!==s.charCodeAt(length-8)||95!==s.charCodeAt(length-9))return !1;for(var i=length-10;i>=0;i--)if(36!==s.charCodeAt(i))return !1;return !0}function strcmp(aStr1,aStr2){return aStr1===aStr2?0:aStr1>aStr2?1:-1}exports.toSetString=supportsNullProto?identity:function(aStr){return isProtoString(aStr)?"$"+aStr:aStr},exports.fromSetString=supportsNullProto?identity:function(aStr){return isProtoString(aStr)?aStr.slice(1):aStr},exports.compareByOriginalPositions=function(mappingA,mappingB,onlyCompareOriginal){var cmp=mappingA.source-mappingB.source;return 0!==cmp||0!==(cmp=mappingA.originalLine-mappingB.originalLine)||0!==(cmp=mappingA.originalColumn-mappingB.originalColumn)||onlyCompareOriginal||0!==(cmp=mappingA.generatedColumn-mappingB.generatedColumn)||0!==(cmp=mappingA.generatedLine-mappingB.generatedLine)?cmp:mappingA.name-mappingB.name},exports.compareByGeneratedPositionsDeflated=function(mappingA,mappingB,onlyCompareGenerated){var cmp=mappingA.generatedLine-mappingB.generatedLine;return 0!==cmp||0!==(cmp=mappingA.generatedColumn-mappingB.generatedColumn)||onlyCompareGenerated||0!==(cmp=mappingA.source-mappingB.source)||0!==(cmp=mappingA.originalLine-mappingB.originalLine)||0!==(cmp=mappingA.originalColumn-mappingB.originalColumn)?cmp:mappingA.name-mappingB.name},exports.compareByGeneratedPositionsInflated=function(mappingA,mappingB){var cmp=mappingA.generatedLine-mappingB.generatedLine;return 0!==cmp||0!==(cmp=mappingA.generatedColumn-mappingB.generatedColumn)||0!==(cmp=strcmp(mappingA.source,mappingB.source))||0!==(cmp=mappingA.originalLine-mappingB.originalLine)||0!==(cmp=mappingA.originalColumn-mappingB.originalColumn)?cmp:strcmp(mappingA.name,mappingB.name)};},"./node_modules/@babel/core/node_modules/source-map/source-map.js":(__unused_webpack_module,exports,__webpack_require__)=>{exports.SourceMapGenerator=__webpack_require__("./node_modules/@babel/core/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator,exports.SourceMapConsumer=__webpack_require__("./node_modules/@babel/core/node_modules/source-map/lib/source-map-consumer.js").SourceMapConsumer,exports.SourceNode=__webpack_require__("./node_modules/@babel/core/node_modules/source-map/lib/source-node.js").SourceNode;},"./node_modules/@babel/generator/lib/buffer.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;const SPACES_RE=/^[ \t]+$/;exports.default=class{constructor(map){this._map=null,this._buf="",this._last=0,this._queue=[],this._position={line:1,column:0},this._sourcePosition={identifierName:null,line:null,column:null,filename:null},this._disallowedPop=null,this._map=map;}get(){this._flush();const map=this._map,result={code:this._buf.trimRight(),map:null,rawMappings:null==map?void 0:map.getRawMappings()};return map&&Object.defineProperty(result,"map",{configurable:!0,enumerable:!0,get(){return this.map=map.get()},set(value){Object.defineProperty(this,"map",{value,writable:!0});}}),result}append(str){this._flush();const{line,column,filename,identifierName,force}=this._sourcePosition;this._append(str,line,column,identifierName,filename,force);}queue(str){if("\n"===str)for(;this._queue.length>0&&SPACES_RE.test(this._queue[0][0]);)this._queue.shift();const{line,column,filename,identifierName,force}=this._sourcePosition;this._queue.unshift([str,line,column,identifierName,filename,force]);}_flush(){let item;for(;item=this._queue.pop();)this._append(...item);}_append(str,line,column,identifierName,filename,force){this._buf+=str,this._last=str.charCodeAt(str.length-1);let i=str.indexOf("\n"),last=0;for(0!==i&&this._mark(line,column,identifierName,filename,force);-1!==i;)this._position.line++,this._position.column=0,last=i+1,last<str.length&&this._mark(++line,0,identifierName,filename,force),i=str.indexOf("\n",last);this._position.column+=str.length-last;}_mark(line,column,identifierName,filename,force){var _this$_map;null==(_this$_map=this._map)||_this$_map.mark(this._position.line,this._position.column,line,column,identifierName,filename,force);}removeTrailingNewline(){this._queue.length>0&&"\n"===this._queue[0][0]&&this._queue.shift();}removeLastSemicolon(){this._queue.length>0&&";"===this._queue[0][0]&&this._queue.shift();}getLastChar(){let last;if(this._queue.length>0){last=this._queue[0][0].charCodeAt(0);}else last=this._last;return last}endsWithCharAndNewline(){const queue=this._queue;if(queue.length>0){if(10!==queue[0][0].charCodeAt(0))return;if(queue.length>1){return queue[1][0].charCodeAt(0)}return this._last}}hasContent(){return this._queue.length>0||!!this._last}exactSource(loc,cb){this.source("start",loc,!0),cb(),this.source("end",loc),this._disallowPop("start",loc);}source(prop,loc,force){prop&&!loc||this._normalizePosition(prop,loc,this._sourcePosition,force);}withSource(prop,loc,cb){if(!this._map)return cb();const originalLine=this._sourcePosition.line,originalColumn=this._sourcePosition.column,originalFilename=this._sourcePosition.filename,originalIdentifierName=this._sourcePosition.identifierName;this.source(prop,loc),cb(),this._sourcePosition.force&&this._sourcePosition.line===originalLine&&this._sourcePosition.column===originalColumn&&this._sourcePosition.filename===originalFilename||this._disallowedPop&&this._disallowedPop.line===originalLine&&this._disallowedPop.column===originalColumn&&this._disallowedPop.filename===originalFilename||(this._sourcePosition.line=originalLine,this._sourcePosition.column=originalColumn,this._sourcePosition.filename=originalFilename,this._sourcePosition.identifierName=originalIdentifierName,this._sourcePosition.force=!1,this._disallowedPop=null);}_disallowPop(prop,loc){prop&&!loc||(this._disallowedPop=this._normalizePosition(prop,loc));}_normalizePosition(prop,loc,targetObj,force){const pos=loc?loc[prop]:null;void 0===targetObj&&(targetObj={identifierName:null,line:null,column:null,filename:null,force:!1});const origLine=targetObj.line,origColumn=targetObj.column,origFilename=targetObj.filename;return targetObj.identifierName="start"===prop&&(null==loc?void 0:loc.identifierName)||null,targetObj.line=null==pos?void 0:pos.line,targetObj.column=null==pos?void 0:pos.column,targetObj.filename=null==loc?void 0:loc.filename,(force||targetObj.line!==origLine||targetObj.column!==origColumn||targetObj.filename!==origFilename)&&(targetObj.force=force),targetObj}getCurrentColumn(){const extra=this._queue.reduce(((acc,item)=>item[0]+acc),""),lastIndex=extra.lastIndexOf("\n");return -1===lastIndex?this._position.column+extra.length:extra.length-1-lastIndex}getCurrentLine(){const extra=this._queue.reduce(((acc,item)=>item[0]+acc),"");let count=0;for(let i=0;i<extra.length;i++)"\n"===extra[i]&&count++;return this._position.line+count}};},"./node_modules/@babel/generator/lib/generators/base.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.BlockStatement=function(node){var _node$directives;this.token("{"),this.printInnerComments(node);const hasDirectives=null==(_node$directives=node.directives)?void 0:_node$directives.length;node.body.length||hasDirectives?(this.newline(),this.printSequence(node.directives,node,{indent:!0}),hasDirectives&&this.newline(),this.printSequence(node.body,node,{indent:!0}),this.removeTrailingNewline(),this.source("end",node.loc),this.endsWith(10)||this.newline(),this.rightBrace()):(this.source("end",node.loc),this.token("}"));},exports.Directive=function(node){this.print(node.value,node),this.semicolon();},exports.DirectiveLiteral=function(node){const raw=this.getPossibleRaw(node);if(!this.format.minified&&null!=raw)return void this.token(raw);const{value}=node;if(unescapedDoubleQuoteRE.test(value)){if(unescapedSingleQuoteRE.test(value))throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");this.token(`'${value}'`);}else this.token(`"${value}"`);},exports.File=function(node){node.program&&this.print(node.program.interpreter,node);this.print(node.program,node);},exports.InterpreterDirective=function(node){this.token(`#!${node.value}\n`);},exports.Placeholder=function(node){this.token("%%"),this.print(node.name),this.token("%%"),"Statement"===node.expectedNode&&this.semicolon();},exports.Program=function(node){this.printInnerComments(node,!1),this.printSequence(node.directives,node),node.directives&&node.directives.length&&this.newline();this.printSequence(node.body,node);};const unescapedSingleQuoteRE=/(?:^|[^\\])(?:\\\\)*'/,unescapedDoubleQuoteRE=/(?:^|[^\\])(?:\\\\)*"/;},"./node_modules/@babel/generator/lib/generators/classes.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.ClassBody=function(node){this.token("{"),this.printInnerComments(node),0===node.body.length?this.token("}"):(this.newline(),this.indent(),this.printSequence(node.body,node),this.dedent(),this.endsWith(10)||this.newline(),this.rightBrace());},exports.ClassExpression=exports.ClassDeclaration=function(node,parent){this.format.decoratorsBeforeExport&&(isExportDefaultDeclaration(parent)||isExportNamedDeclaration(parent))||this.printJoin(node.decorators,node);node.declare&&(this.word("declare"),this.space());node.abstract&&(this.word("abstract"),this.space());this.word("class"),this.printInnerComments(node),node.id&&(this.space(),this.print(node.id,node));this.print(node.typeParameters,node),node.superClass&&(this.space(),this.word("extends"),this.space(),this.print(node.superClass,node),this.print(node.superTypeParameters,node));node.implements&&(this.space(),this.word("implements"),this.space(),this.printList(node.implements,node));this.space(),this.print(node.body,node);},exports.ClassMethod=function(node){this._classMethodHead(node),this.space(),this.print(node.body,node);},exports.ClassPrivateMethod=function(node){this._classMethodHead(node),this.space(),this.print(node.body,node);},exports.ClassPrivateProperty=function(node){this.printJoin(node.decorators,node),node.static&&(this.word("static"),this.space());this.print(node.key,node),this.print(node.typeAnnotation,node),node.value&&(this.space(),this.token("="),this.space(),this.print(node.value,node));this.semicolon();},exports.ClassProperty=function(node){this.printJoin(node.decorators,node),this.source("end",node.key.loc),this.tsPrintClassMemberModifiers(node,!0),node.computed?(this.token("["),this.print(node.key,node),this.token("]")):(this._variance(node),this.print(node.key,node));node.optional&&this.token("?");node.definite&&this.token("!");this.print(node.typeAnnotation,node),node.value&&(this.space(),this.token("="),this.space(),this.print(node.value,node));this.semicolon();},exports.StaticBlock=function(node){this.word("static"),this.space(),this.token("{"),0===node.body.length?this.token("}"):(this.newline(),this.printSequence(node.body,node,{indent:!0}),this.rightBrace());},exports._classMethodHead=function(node){this.printJoin(node.decorators,node),this.source("end",node.key.loc),this.tsPrintClassMemberModifiers(node,!1),this._methodHead(node);};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{isExportDefaultDeclaration,isExportNamedDeclaration}=_t;},"./node_modules/@babel/generator/lib/generators/expressions.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.LogicalExpression=exports.BinaryExpression=exports.AssignmentExpression=function(node,parent){const parens=this.inForStatementInitCounter&&"in"===node.operator&&!n.needsParens(node,parent);parens&&this.token("(");this.print(node.left,node),this.space(),"in"===node.operator||"instanceof"===node.operator?this.word(node.operator):this.token(node.operator);this.space(),this.print(node.right,node),parens&&this.token(")");},exports.AssignmentPattern=function(node){this.print(node.left,node),node.left.optional&&this.token("?");this.print(node.left.typeAnnotation,node),this.space(),this.token("="),this.space(),this.print(node.right,node);},exports.AwaitExpression=void 0,exports.BindExpression=function(node){this.print(node.object,node),this.token("::"),this.print(node.callee,node);},exports.CallExpression=function(node){this.print(node.callee,node),this.print(node.typeArguments,node),this.print(node.typeParameters,node),this.token("("),this.printList(node.arguments,node),this.token(")");},exports.ConditionalExpression=function(node){this.print(node.test,node),this.space(),this.token("?"),this.space(),this.print(node.consequent,node),this.space(),this.token(":"),this.space(),this.print(node.alternate,node);},exports.Decorator=function(node){this.token("@"),this.print(node.expression,node),this.newline();},exports.DoExpression=function(node){node.async&&(this.word("async"),this.space());this.word("do"),this.space(),this.print(node.body,node);},exports.EmptyStatement=function(){this.semicolon(!0);},exports.ExpressionStatement=function(node){this.print(node.expression,node),this.semicolon();},exports.Import=function(){this.word("import");},exports.MemberExpression=function(node){if(this.print(node.object,node),!node.computed&&isMemberExpression(node.property))throw new TypeError("Got a MemberExpression for MemberExpression property");let computed=node.computed;isLiteral(node.property)&&"number"==typeof node.property.value&&(computed=!0);computed?(this.token("["),this.print(node.property,node),this.token("]")):(this.token("."),this.print(node.property,node));},exports.MetaProperty=function(node){this.print(node.meta,node),this.token("."),this.print(node.property,node);},exports.ModuleExpression=function(node){this.word("module"),this.space(),this.token("{"),0===node.body.body.length?this.token("}"):(this.newline(),this.printSequence(node.body.body,node,{indent:!0}),this.rightBrace());},exports.NewExpression=function(node,parent){if(this.word("new"),this.space(),this.print(node.callee,node),this.format.minified&&0===node.arguments.length&&!node.optional&&!isCallExpression(parent,{callee:node})&&!isMemberExpression(parent)&&!isNewExpression(parent))return;this.print(node.typeArguments,node),this.print(node.typeParameters,node),node.optional&&this.token("?.");this.token("("),this.printList(node.arguments,node),this.token(")");},exports.OptionalCallExpression=function(node){this.print(node.callee,node),this.print(node.typeArguments,node),this.print(node.typeParameters,node),node.optional&&this.token("?.");this.token("("),this.printList(node.arguments,node),this.token(")");},exports.OptionalMemberExpression=function(node){if(this.print(node.object,node),!node.computed&&isMemberExpression(node.property))throw new TypeError("Got a MemberExpression for MemberExpression property");let computed=node.computed;isLiteral(node.property)&&"number"==typeof node.property.value&&(computed=!0);node.optional&&this.token("?.");computed?(this.token("["),this.print(node.property,node),this.token("]")):(node.optional||this.token("."),this.print(node.property,node));},exports.ParenthesizedExpression=function(node){this.token("("),this.print(node.expression,node),this.token(")");},exports.PrivateName=function(node){this.token("#"),this.print(node.id,node);},exports.SequenceExpression=function(node){this.printList(node.expressions,node);},exports.Super=function(){this.word("super");},exports.ThisExpression=function(){this.word("this");},exports.UnaryExpression=function(node){"void"===node.operator||"delete"===node.operator||"typeof"===node.operator||"throw"===node.operator?(this.word(node.operator),this.space()):this.token(node.operator);this.print(node.argument,node);},exports.UpdateExpression=function(node){node.prefix?(this.token(node.operator),this.print(node.argument,node)):(this.startTerminatorless(!0),this.print(node.argument,node),this.endTerminatorless(),this.token(node.operator));},exports.V8IntrinsicIdentifier=function(node){this.token("%"),this.word(node.name);},exports.YieldExpression=void 0;var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js"),n=__webpack_require__("./node_modules/@babel/generator/lib/node/index.js");const{isCallExpression,isLiteral,isMemberExpression,isNewExpression}=_t;function buildYieldAwait(keyword){return function(node){if(this.word(keyword),node.delegate&&this.token("*"),node.argument){this.space();const terminatorState=this.startTerminatorless();this.print(node.argument,node),this.endTerminatorless(terminatorState);}}}const YieldExpression=buildYieldAwait("yield");exports.YieldExpression=YieldExpression;const AwaitExpression=buildYieldAwait("await");exports.AwaitExpression=AwaitExpression;},"./node_modules/@babel/generator/lib/generators/flow.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.AnyTypeAnnotation=function(){this.word("any");},exports.ArrayTypeAnnotation=function(node){this.print(node.elementType,node),this.token("["),this.token("]");},exports.BooleanLiteralTypeAnnotation=function(node){this.word(node.value?"true":"false");},exports.BooleanTypeAnnotation=function(){this.word("boolean");},exports.DeclareClass=function(node,parent){isDeclareExportDeclaration(parent)||(this.word("declare"),this.space());this.word("class"),this.space(),this._interfaceish(node);},exports.DeclareExportAllDeclaration=function(){this.word("declare"),this.space(),_modules.ExportAllDeclaration.apply(this,arguments);},exports.DeclareExportDeclaration=function(node){this.word("declare"),this.space(),this.word("export"),this.space(),node.default&&(this.word("default"),this.space());FlowExportDeclaration.apply(this,arguments);},exports.DeclareFunction=function(node,parent){isDeclareExportDeclaration(parent)||(this.word("declare"),this.space());this.word("function"),this.space(),this.print(node.id,node),this.print(node.id.typeAnnotation.typeAnnotation,node),node.predicate&&(this.space(),this.print(node.predicate,node));this.semicolon();},exports.DeclareInterface=function(node){this.word("declare"),this.space(),this.InterfaceDeclaration(node);},exports.DeclareModule=function(node){this.word("declare"),this.space(),this.word("module"),this.space(),this.print(node.id,node),this.space(),this.print(node.body,node);},exports.DeclareModuleExports=function(node){this.word("declare"),this.space(),this.word("module"),this.token("."),this.word("exports"),this.print(node.typeAnnotation,node);},exports.DeclareOpaqueType=function(node,parent){isDeclareExportDeclaration(parent)||(this.word("declare"),this.space());this.OpaqueType(node);},exports.DeclareTypeAlias=function(node){this.word("declare"),this.space(),this.TypeAlias(node);},exports.DeclareVariable=function(node,parent){isDeclareExportDeclaration(parent)||(this.word("declare"),this.space());this.word("var"),this.space(),this.print(node.id,node),this.print(node.id.typeAnnotation,node),this.semicolon();},exports.DeclaredPredicate=function(node){this.token("%"),this.word("checks"),this.token("("),this.print(node.value,node),this.token(")");},exports.EmptyTypeAnnotation=function(){this.word("empty");},exports.EnumBooleanBody=function(node){const{explicitType}=node;enumExplicitType(this,"boolean",explicitType),enumBody(this,node);},exports.EnumBooleanMember=function(node){enumInitializedMember(this,node);},exports.EnumDeclaration=function(node){const{id,body}=node;this.word("enum"),this.space(),this.print(id,node),this.print(body,node);},exports.EnumDefaultedMember=function(node){const{id}=node;this.print(id,node),this.token(",");},exports.EnumNumberBody=function(node){const{explicitType}=node;enumExplicitType(this,"number",explicitType),enumBody(this,node);},exports.EnumNumberMember=function(node){enumInitializedMember(this,node);},exports.EnumStringBody=function(node){const{explicitType}=node;enumExplicitType(this,"string",explicitType),enumBody(this,node);},exports.EnumStringMember=function(node){enumInitializedMember(this,node);},exports.EnumSymbolBody=function(node){enumExplicitType(this,"symbol",!0),enumBody(this,node);},exports.ExistsTypeAnnotation=function(){this.token("*");},exports.FunctionTypeAnnotation=function(node,parent){this.print(node.typeParameters,node),this.token("("),node.this&&(this.word("this"),this.token(":"),this.space(),this.print(node.this.typeAnnotation,node),(node.params.length||node.rest)&&(this.token(","),this.space()));this.printList(node.params,node),node.rest&&(node.params.length&&(this.token(","),this.space()),this.token("..."),this.print(node.rest,node));this.token(")"),parent&&("ObjectTypeCallProperty"===parent.type||"DeclareFunction"===parent.type||"ObjectTypeProperty"===parent.type&&parent.method)?this.token(":"):(this.space(),this.token("=>"));this.space(),this.print(node.returnType,node);},exports.FunctionTypeParam=function(node){this.print(node.name,node),node.optional&&this.token("?");node.name&&(this.token(":"),this.space());this.print(node.typeAnnotation,node);},exports.IndexedAccessType=function(node){this.print(node.objectType,node),this.token("["),this.print(node.indexType,node),this.token("]");},exports.InferredPredicate=function(){this.token("%"),this.word("checks");},exports.InterfaceDeclaration=function(node){this.word("interface"),this.space(),this._interfaceish(node);},exports.GenericTypeAnnotation=exports.ClassImplements=exports.InterfaceExtends=function(node){this.print(node.id,node),this.print(node.typeParameters,node);},exports.InterfaceTypeAnnotation=function(node){this.word("interface"),node.extends&&node.extends.length&&(this.space(),this.word("extends"),this.space(),this.printList(node.extends,node));this.space(),this.print(node.body,node);},exports.IntersectionTypeAnnotation=function(node){this.printJoin(node.types,node,{separator:andSeparator});},exports.MixedTypeAnnotation=function(){this.word("mixed");},exports.NullLiteralTypeAnnotation=function(){this.word("null");},exports.NullableTypeAnnotation=function(node){this.token("?"),this.print(node.typeAnnotation,node);},Object.defineProperty(exports,"NumberLiteralTypeAnnotation",{enumerable:!0,get:function(){return _types2.NumericLiteral}}),exports.NumberTypeAnnotation=function(){this.word("number");},exports.ObjectTypeAnnotation=function(node){node.exact?this.token("{|"):this.token("{");const props=[...node.properties,...node.callProperties||[],...node.indexers||[],...node.internalSlots||[]];props.length&&(this.space(),this.printJoin(props,node,{addNewlines(leading){if(leading&&!props[0])return 1},indent:!0,statement:!0,iterator:()=>{(1!==props.length||node.inexact)&&(this.token(","),this.space());}}),this.space());node.inexact&&(this.indent(),this.token("..."),props.length&&this.newline(),this.dedent());node.exact?this.token("|}"):this.token("}");},exports.ObjectTypeCallProperty=function(node){node.static&&(this.word("static"),this.space());this.print(node.value,node);},exports.ObjectTypeIndexer=function(node){node.static&&(this.word("static"),this.space());this._variance(node),this.token("["),node.id&&(this.print(node.id,node),this.token(":"),this.space());this.print(node.key,node),this.token("]"),this.token(":"),this.space(),this.print(node.value,node);},exports.ObjectTypeInternalSlot=function(node){node.static&&(this.word("static"),this.space());this.token("["),this.token("["),this.print(node.id,node),this.token("]"),this.token("]"),node.optional&&this.token("?");node.method||(this.token(":"),this.space());this.print(node.value,node);},exports.ObjectTypeProperty=function(node){node.proto&&(this.word("proto"),this.space());node.static&&(this.word("static"),this.space());"get"!==node.kind&&"set"!==node.kind||(this.word(node.kind),this.space());this._variance(node),this.print(node.key,node),node.optional&&this.token("?");node.method||(this.token(":"),this.space());this.print(node.value,node);},exports.ObjectTypeSpreadProperty=function(node){this.token("..."),this.print(node.argument,node);},exports.OpaqueType=function(node){this.word("opaque"),this.space(),this.word("type"),this.space(),this.print(node.id,node),this.print(node.typeParameters,node),node.supertype&&(this.token(":"),this.space(),this.print(node.supertype,node));node.impltype&&(this.space(),this.token("="),this.space(),this.print(node.impltype,node));this.semicolon();},exports.OptionalIndexedAccessType=function(node){this.print(node.objectType,node),node.optional&&this.token("?.");this.token("["),this.print(node.indexType,node),this.token("]");},exports.QualifiedTypeIdentifier=function(node){this.print(node.qualification,node),this.token("."),this.print(node.id,node);},Object.defineProperty(exports,"StringLiteralTypeAnnotation",{enumerable:!0,get:function(){return _types2.StringLiteral}}),exports.StringTypeAnnotation=function(){this.word("string");},exports.SymbolTypeAnnotation=function(){this.word("symbol");},exports.ThisTypeAnnotation=function(){this.word("this");},exports.TupleTypeAnnotation=function(node){this.token("["),this.printList(node.types,node),this.token("]");},exports.TypeAlias=function(node){this.word("type"),this.space(),this.print(node.id,node),this.print(node.typeParameters,node),this.space(),this.token("="),this.space(),this.print(node.right,node),this.semicolon();},exports.TypeAnnotation=function(node){this.token(":"),this.space(),node.optional&&this.token("?");this.print(node.typeAnnotation,node);},exports.TypeCastExpression=function(node){this.token("("),this.print(node.expression,node),this.print(node.typeAnnotation,node),this.token(")");},exports.TypeParameter=function(node){this._variance(node),this.word(node.name),node.bound&&this.print(node.bound,node);node.default&&(this.space(),this.token("="),this.space(),this.print(node.default,node));},exports.TypeParameterDeclaration=exports.TypeParameterInstantiation=function(node){this.token("<"),this.printList(node.params,node,{}),this.token(">");},exports.TypeofTypeAnnotation=function(node){this.word("typeof"),this.space(),this.print(node.argument,node);},exports.UnionTypeAnnotation=function(node){this.printJoin(node.types,node,{separator:orSeparator});},exports.Variance=function(node){"plus"===node.kind?this.token("+"):this.token("-");},exports.VoidTypeAnnotation=function(){this.word("void");},exports._interfaceish=function(node){var _node$extends;this.print(node.id,node),this.print(node.typeParameters,node),null!=(_node$extends=node.extends)&&_node$extends.length&&(this.space(),this.word("extends"),this.space(),this.printList(node.extends,node));node.mixins&&node.mixins.length&&(this.space(),this.word("mixins"),this.space(),this.printList(node.mixins,node));node.implements&&node.implements.length&&(this.space(),this.word("implements"),this.space(),this.printList(node.implements,node));this.space(),this.print(node.body,node);},exports._variance=function(node){node.variance&&("plus"===node.variance.kind?this.token("+"):"minus"===node.variance.kind&&this.token("-"));};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js"),_modules=__webpack_require__("./node_modules/@babel/generator/lib/generators/modules.js"),_types2=__webpack_require__("./node_modules/@babel/generator/lib/generators/types.js");const{isDeclareExportDeclaration,isStatement}=_t;function enumExplicitType(context,name,hasExplicitType){hasExplicitType&&(context.space(),context.word("of"),context.space(),context.word(name)),context.space();}function enumBody(context,node){const{members}=node;context.token("{"),context.indent(),context.newline();for(const member of members)context.print(member,node),context.newline();node.hasUnknownMembers&&(context.token("..."),context.newline()),context.dedent(),context.token("}");}function enumInitializedMember(context,node){const{id,init}=node;context.print(id,node),context.space(),context.token("="),context.space(),context.print(init,node),context.token(",");}function FlowExportDeclaration(node){if(node.declaration){const declar=node.declaration;this.print(declar,node),isStatement(declar)||this.semicolon();}else this.token("{"),node.specifiers.length&&(this.space(),this.printList(node.specifiers,node),this.space()),this.token("}"),node.source&&(this.space(),this.word("from"),this.space(),this.print(node.source,node)),this.semicolon();}function andSeparator(){this.space(),this.token("&"),this.space();}function orSeparator(){this.space(),this.token("|"),this.space();}},"./node_modules/@babel/generator/lib/generators/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0});var _templateLiterals=__webpack_require__("./node_modules/@babel/generator/lib/generators/template-literals.js");Object.keys(_templateLiterals).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_templateLiterals[key]||Object.defineProperty(exports,key,{enumerable:!0,get:function(){return _templateLiterals[key]}}));}));var _expressions=__webpack_require__("./node_modules/@babel/generator/lib/generators/expressions.js");Object.keys(_expressions).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_expressions[key]||Object.defineProperty(exports,key,{enumerable:!0,get:function(){return _expressions[key]}}));}));var _statements=__webpack_require__("./node_modules/@babel/generator/lib/generators/statements.js");Object.keys(_statements).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_statements[key]||Object.defineProperty(exports,key,{enumerable:!0,get:function(){return _statements[key]}}));}));var _classes=__webpack_require__("./node_modules/@babel/generator/lib/generators/classes.js");Object.keys(_classes).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_classes[key]||Object.defineProperty(exports,key,{enumerable:!0,get:function(){return _classes[key]}}));}));var _methods=__webpack_require__("./node_modules/@babel/generator/lib/generators/methods.js");Object.keys(_methods).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_methods[key]||Object.defineProperty(exports,key,{enumerable:!0,get:function(){return _methods[key]}}));}));var _modules=__webpack_require__("./node_modules/@babel/generator/lib/generators/modules.js");Object.keys(_modules).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_modules[key]||Object.defineProperty(exports,key,{enumerable:!0,get:function(){return _modules[key]}}));}));var _types=__webpack_require__("./node_modules/@babel/generator/lib/generators/types.js");Object.keys(_types).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_types[key]||Object.defineProperty(exports,key,{enumerable:!0,get:function(){return _types[key]}}));}));var _flow=__webpack_require__("./node_modules/@babel/generator/lib/generators/flow.js");Object.keys(_flow).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_flow[key]||Object.defineProperty(exports,key,{enumerable:!0,get:function(){return _flow[key]}}));}));var _base=__webpack_require__("./node_modules/@babel/generator/lib/generators/base.js");Object.keys(_base).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_base[key]||Object.defineProperty(exports,key,{enumerable:!0,get:function(){return _base[key]}}));}));var _jsx=__webpack_require__("./node_modules/@babel/generator/lib/generators/jsx.js");Object.keys(_jsx).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_jsx[key]||Object.defineProperty(exports,key,{enumerable:!0,get:function(){return _jsx[key]}}));}));var _typescript=__webpack_require__("./node_modules/@babel/generator/lib/generators/typescript.js");Object.keys(_typescript).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_typescript[key]||Object.defineProperty(exports,key,{enumerable:!0,get:function(){return _typescript[key]}}));}));},"./node_modules/@babel/generator/lib/generators/jsx.js":(__unused_webpack_module,exports)=>{function spaceSeparator(){this.space();}Object.defineProperty(exports,"__esModule",{value:!0}),exports.JSXAttribute=function(node){this.print(node.name,node),node.value&&(this.token("="),this.print(node.value,node));},exports.JSXClosingElement=function(node){this.token("</"),this.print(node.name,node),this.token(">");},exports.JSXClosingFragment=function(){this.token("</"),this.token(">");},exports.JSXElement=function(node){const open=node.openingElement;if(this.print(open,node),open.selfClosing)return;this.indent();for(const child of node.children)this.print(child,node);this.dedent(),this.print(node.closingElement,node);},exports.JSXEmptyExpression=function(node){this.printInnerComments(node);},exports.JSXExpressionContainer=function(node){this.token("{"),this.print(node.expression,node),this.token("}");},exports.JSXFragment=function(node){this.print(node.openingFragment,node),this.indent();for(const child of node.children)this.print(child,node);this.dedent(),this.print(node.closingFragment,node);},exports.JSXIdentifier=function(node){this.word(node.name);},exports.JSXMemberExpression=function(node){this.print(node.object,node),this.token("."),this.print(node.property,node);},exports.JSXNamespacedName=function(node){this.print(node.namespace,node),this.token(":"),this.print(node.name,node);},exports.JSXOpeningElement=function(node){this.token("<"),this.print(node.name,node),this.print(node.typeParameters,node),node.attributes.length>0&&(this.space(),this.printJoin(node.attributes,node,{separator:spaceSeparator}));node.selfClosing?(this.space(),this.token("/>")):this.token(">");},exports.JSXOpeningFragment=function(){this.token("<"),this.token(">");},exports.JSXSpreadAttribute=function(node){this.token("{"),this.token("..."),this.print(node.argument,node),this.token("}");},exports.JSXSpreadChild=function(node){this.token("{"),this.token("..."),this.print(node.expression,node),this.token("}");},exports.JSXText=function(node){const raw=this.getPossibleRaw(node);null!=raw?this.token(raw):this.token(node.value);};},"./node_modules/@babel/generator/lib/generators/methods.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.ArrowFunctionExpression=function(node){node.async&&(this.word("async"),this.space());const firstParam=node.params[0];this.format.retainLines||this.format.auxiliaryCommentBefore||this.format.auxiliaryCommentAfter||1!==node.params.length||!isIdentifier(firstParam)||function(node,param){var _param$leadingComment,_param$trailingCommen;return !!(node.typeParameters||node.returnType||node.predicate||param.typeAnnotation||param.optional||null!=(_param$leadingComment=param.leadingComments)&&_param$leadingComment.length||null!=(_param$trailingCommen=param.trailingComments)&&_param$trailingCommen.length)}(node,firstParam)?this._params(node):this.print(firstParam,node);this._predicate(node),this.space(),this.token("=>"),this.space(),this.print(node.body,node);},exports.FunctionDeclaration=exports.FunctionExpression=function(node){this._functionHead(node),this.space(),this.print(node.body,node);},exports._functionHead=function(node){node.async&&(this.word("async"),this.space());this.word("function"),node.generator&&this.token("*");this.printInnerComments(node),this.space(),node.id&&this.print(node.id,node);this._params(node),this._predicate(node);},exports._methodHead=function(node){const kind=node.kind,key=node.key;"get"!==kind&&"set"!==kind||(this.word(kind),this.space());node.async&&(this._catchUp("start",key.loc),this.word("async"),this.space());"method"!==kind&&"init"!==kind||node.generator&&this.token("*");node.computed?(this.token("["),this.print(key,node),this.token("]")):this.print(key,node);node.optional&&this.token("?");this._params(node);},exports._param=function(parameter,parent){this.printJoin(parameter.decorators,parameter),this.print(parameter,parent),parameter.optional&&this.token("?");this.print(parameter.typeAnnotation,parameter);},exports._parameters=function(parameters,parent){for(let i=0;i<parameters.length;i++)this._param(parameters[i],parent),i<parameters.length-1&&(this.token(","),this.space());},exports._params=function(node){this.print(node.typeParameters,node),this.token("("),this._parameters(node.params,node),this.token(")"),this.print(node.returnType,node);},exports._predicate=function(node){node.predicate&&(node.returnType||this.token(":"),this.space(),this.print(node.predicate,node));};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{isIdentifier}=_t;},"./node_modules/@babel/generator/lib/generators/modules.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.ExportAllDeclaration=function(node){this.word("export"),this.space(),"type"===node.exportKind&&(this.word("type"),this.space());this.token("*"),this.space(),this.word("from"),this.space(),this.print(node.source,node),this.printAssertions(node),this.semicolon();},exports.ExportDefaultDeclaration=function(node){this.format.decoratorsBeforeExport&&isClassDeclaration(node.declaration)&&this.printJoin(node.declaration.decorators,node);this.word("export"),this.space(),this.word("default"),this.space(),ExportDeclaration.apply(this,arguments);},exports.ExportDefaultSpecifier=function(node){this.print(node.exported,node);},exports.ExportNamedDeclaration=function(node){this.format.decoratorsBeforeExport&&isClassDeclaration(node.declaration)&&this.printJoin(node.declaration.decorators,node);this.word("export"),this.space(),ExportDeclaration.apply(this,arguments);},exports.ExportNamespaceSpecifier=function(node){this.token("*"),this.space(),this.word("as"),this.space(),this.print(node.exported,node);},exports.ExportSpecifier=function(node){"type"===node.exportKind&&(this.word("type"),this.space());this.print(node.local,node),node.exported&&node.local.name!==node.exported.name&&(this.space(),this.word("as"),this.space(),this.print(node.exported,node));},exports.ImportAttribute=function(node){this.print(node.key),this.token(":"),this.space(),this.print(node.value);},exports.ImportDeclaration=function(node){this.word("import"),this.space(),("type"===node.importKind||"typeof"===node.importKind)&&(this.word(node.importKind),this.space());const specifiers=node.specifiers.slice(0);if(null!=specifiers&&specifiers.length){for(;;){const first=specifiers[0];if(!isImportDefaultSpecifier(first)&&!isImportNamespaceSpecifier(first))break;this.print(specifiers.shift(),node),specifiers.length&&(this.token(","),this.space());}specifiers.length&&(this.token("{"),this.space(),this.printList(specifiers,node),this.space(),this.token("}")),this.space(),this.word("from"),this.space();}var _node$attributes;this.print(node.source,node),this.printAssertions(node),null!=(_node$attributes=node.attributes)&&_node$attributes.length&&(this.space(),this.word("with"),this.space(),this.printList(node.attributes,node));this.semicolon();},exports.ImportDefaultSpecifier=function(node){this.print(node.local,node);},exports.ImportNamespaceSpecifier=function(node){this.token("*"),this.space(),this.word("as"),this.space(),this.print(node.local,node);},exports.ImportSpecifier=function(node){"type"!==node.importKind&&"typeof"!==node.importKind||(this.word(node.importKind),this.space());this.print(node.imported,node),node.local&&node.local.name!==node.imported.name&&(this.space(),this.word("as"),this.space(),this.print(node.local,node));};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{isClassDeclaration,isExportDefaultSpecifier,isExportNamespaceSpecifier,isImportDefaultSpecifier,isImportNamespaceSpecifier,isStatement}=_t;function ExportDeclaration(node){if(node.declaration){const declar=node.declaration;this.print(declar,node),isStatement(declar)||this.semicolon();}else {"type"===node.exportKind&&(this.word("type"),this.space());const specifiers=node.specifiers.slice(0);let hasSpecial=!1;for(;;){const first=specifiers[0];if(!isExportDefaultSpecifier(first)&&!isExportNamespaceSpecifier(first))break;hasSpecial=!0,this.print(specifiers.shift(),node),specifiers.length&&(this.token(","),this.space());}(specifiers.length||!specifiers.length&&!hasSpecial)&&(this.token("{"),specifiers.length&&(this.space(),this.printList(specifiers,node),this.space()),this.token("}")),node.source&&(this.space(),this.word("from"),this.space(),this.print(node.source,node),this.printAssertions(node)),this.semicolon();}}},"./node_modules/@babel/generator/lib/generators/statements.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.BreakStatement=void 0,exports.CatchClause=function(node){this.word("catch"),this.space(),node.param&&(this.token("("),this.print(node.param,node),this.print(node.param.typeAnnotation,node),this.token(")"),this.space());this.print(node.body,node);},exports.ContinueStatement=void 0,exports.DebuggerStatement=function(){this.word("debugger"),this.semicolon();},exports.DoWhileStatement=function(node){this.word("do"),this.space(),this.print(node.body,node),this.space(),this.word("while"),this.space(),this.token("("),this.print(node.test,node),this.token(")"),this.semicolon();},exports.ForOfStatement=exports.ForInStatement=void 0,exports.ForStatement=function(node){this.word("for"),this.space(),this.token("("),this.inForStatementInitCounter++,this.print(node.init,node),this.inForStatementInitCounter--,this.token(";"),node.test&&(this.space(),this.print(node.test,node));this.token(";"),node.update&&(this.space(),this.print(node.update,node));this.token(")"),this.printBlock(node);},exports.IfStatement=function(node){this.word("if"),this.space(),this.token("("),this.print(node.test,node),this.token(")"),this.space();const needsBlock=node.alternate&&isIfStatement(getLastStatement(node.consequent));needsBlock&&(this.token("{"),this.newline(),this.indent());this.printAndIndentOnComments(node.consequent,node),needsBlock&&(this.dedent(),this.newline(),this.token("}"));node.alternate&&(this.endsWith(125)&&this.space(),this.word("else"),this.space(),this.printAndIndentOnComments(node.alternate,node));},exports.LabeledStatement=function(node){this.print(node.label,node),this.token(":"),this.space(),this.print(node.body,node);},exports.ReturnStatement=void 0,exports.SwitchCase=function(node){node.test?(this.word("case"),this.space(),this.print(node.test,node),this.token(":")):(this.word("default"),this.token(":"));node.consequent.length&&(this.newline(),this.printSequence(node.consequent,node,{indent:!0}));},exports.SwitchStatement=function(node){this.word("switch"),this.space(),this.token("("),this.print(node.discriminant,node),this.token(")"),this.space(),this.token("{"),this.printSequence(node.cases,node,{indent:!0,addNewlines(leading,cas){if(!leading&&node.cases[node.cases.length-1]===cas)return -1}}),this.token("}");},exports.ThrowStatement=void 0,exports.TryStatement=function(node){this.word("try"),this.space(),this.print(node.block,node),this.space(),node.handlers?this.print(node.handlers[0],node):this.print(node.handler,node);node.finalizer&&(this.space(),this.word("finally"),this.space(),this.print(node.finalizer,node));},exports.VariableDeclaration=function(node,parent){node.declare&&(this.word("declare"),this.space());this.word(node.kind),this.space();let separator,hasInits=!1;if(!isFor(parent))for(const declar of node.declarations)declar.init&&(hasInits=!0);hasInits&&(separator="const"===node.kind?constDeclarationIndent:variableDeclarationIndent);if(this.printList(node.declarations,node,{separator}),isFor(parent))if(isForStatement(parent)){if(parent.init===node)return}else if(parent.left===node)return;this.semicolon();},exports.VariableDeclarator=function(node){this.print(node.id,node),node.definite&&this.token("!");this.print(node.id.typeAnnotation,node),node.init&&(this.space(),this.token("="),this.space(),this.print(node.init,node));},exports.WhileStatement=function(node){this.word("while"),this.space(),this.token("("),this.print(node.test,node),this.token(")"),this.printBlock(node);},exports.WithStatement=function(node){this.word("with"),this.space(),this.token("("),this.print(node.object,node),this.token(")"),this.printBlock(node);};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{isFor,isForStatement,isIfStatement,isStatement}=_t;function getLastStatement(statement){return isStatement(statement.body)?getLastStatement(statement.body):statement}const buildForXStatement=function(op){return function(node){this.word("for"),this.space(),"of"===op&&node.await&&(this.word("await"),this.space()),this.token("("),this.print(node.left,node),this.space(),this.word(op),this.space(),this.print(node.right,node),this.token(")"),this.printBlock(node);}},ForInStatement=buildForXStatement("in");exports.ForInStatement=ForInStatement;const ForOfStatement=buildForXStatement("of");function buildLabelStatement(prefix,key="label"){return function(node){this.word(prefix);const label=node[key];if(label){this.space();const isLabel="label"==key,terminatorState=this.startTerminatorless(isLabel);this.print(label,node),this.endTerminatorless(terminatorState);}this.semicolon();}}exports.ForOfStatement=ForOfStatement;const ContinueStatement=buildLabelStatement("continue");exports.ContinueStatement=ContinueStatement;const ReturnStatement=buildLabelStatement("return","argument");exports.ReturnStatement=ReturnStatement;const BreakStatement=buildLabelStatement("break");exports.BreakStatement=BreakStatement;const ThrowStatement=buildLabelStatement("throw","argument");function variableDeclarationIndent(){if(this.token(","),this.newline(),this.endsWith(10))for(let i=0;i<4;i++)this.space(!0);}function constDeclarationIndent(){if(this.token(","),this.newline(),this.endsWith(10))for(let i=0;i<6;i++)this.space(!0);}exports.ThrowStatement=ThrowStatement;},"./node_modules/@babel/generator/lib/generators/template-literals.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.TaggedTemplateExpression=function(node){this.print(node.tag,node),this.print(node.typeParameters,node),this.print(node.quasi,node);},exports.TemplateElement=function(node,parent){const isFirst=parent.quasis[0]===node,isLast=parent.quasis[parent.quasis.length-1]===node,value=(isFirst?"`":"}")+node.value.raw+(isLast?"`":"${");this.token(value);},exports.TemplateLiteral=function(node){const quasis=node.quasis;for(let i=0;i<quasis.length;i++)this.print(quasis[i],node),i+1<quasis.length&&this.print(node.expressions[i],node);};},"./node_modules/@babel/generator/lib/generators/types.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.ArgumentPlaceholder=function(){this.token("?");},exports.ArrayPattern=exports.ArrayExpression=function(node){const elems=node.elements,len=elems.length;this.token("["),this.printInnerComments(node);for(let i=0;i<elems.length;i++){const elem=elems[i];elem?(i>0&&this.space(),this.print(elem,node),i<len-1&&this.token(",")):this.token(",");}this.token("]");},exports.BigIntLiteral=function(node){const raw=this.getPossibleRaw(node);if(!this.format.minified&&null!=raw)return void this.word(raw);this.word(node.value+"n");},exports.BooleanLiteral=function(node){this.word(node.value?"true":"false");},exports.DecimalLiteral=function(node){const raw=this.getPossibleRaw(node);if(!this.format.minified&&null!=raw)return void this.word(raw);this.word(node.value+"m");},exports.Identifier=function(node){this.exactSource(node.loc,(()=>{this.word(node.name);}));},exports.NullLiteral=function(){this.word("null");},exports.NumericLiteral=function(node){const raw=this.getPossibleRaw(node),opts=this.format.jsescOption,value=node.value+"";opts.numbers?this.number(_jsesc(node.value,opts)):null==raw?this.number(value):this.format.minified?this.number(raw.length<value.length?raw:value):this.number(raw);},exports.ObjectPattern=exports.ObjectExpression=function(node){const props=node.properties;this.token("{"),this.printInnerComments(node),props.length&&(this.space(),this.printList(props,node,{indent:!0,statement:!0}),this.space());this.token("}");},exports.ObjectMethod=function(node){this.printJoin(node.decorators,node),this._methodHead(node),this.space(),this.print(node.body,node);},exports.ObjectProperty=function(node){if(this.printJoin(node.decorators,node),node.computed)this.token("["),this.print(node.key,node),this.token("]");else {if(isAssignmentPattern(node.value)&&isIdentifier(node.key)&&node.key.name===node.value.left.name)return void this.print(node.value,node);if(this.print(node.key,node),node.shorthand&&isIdentifier(node.key)&&isIdentifier(node.value)&&node.key.name===node.value.name)return}this.token(":"),this.space(),this.print(node.value,node);},exports.PipelineBareFunction=function(node){this.print(node.callee,node);},exports.PipelinePrimaryTopicReference=function(){this.token("#");},exports.PipelineTopicExpression=function(node){this.print(node.expression,node);},exports.RecordExpression=function(node){const props=node.properties;let startToken,endToken;if("bar"===this.format.recordAndTupleSyntaxType)startToken="{|",endToken="|}";else {if("hash"!==this.format.recordAndTupleSyntaxType)throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);startToken="#{",endToken="}";}this.token(startToken),this.printInnerComments(node),props.length&&(this.space(),this.printList(props,node,{indent:!0,statement:!0}),this.space());this.token(endToken);},exports.RegExpLiteral=function(node){this.word(`/${node.pattern}/${node.flags}`);},exports.SpreadElement=exports.RestElement=function(node){this.token("..."),this.print(node.argument,node);},exports.StringLiteral=function(node){const raw=this.getPossibleRaw(node);if(!this.format.minified&&null!=raw)return void this.token(raw);const val=_jsesc(node.value,Object.assign(this.format.jsescOption,this.format.jsonCompatibleStrings&&{json:!0}));return this.token(val)},exports.TopicReference=function(){const{topicToken}=this.format;if(!validTopicTokenSet.has(topicToken)){const givenTopicTokenJSON=JSON.stringify(topicToken),validTopics=Array.from(validTopicTokenSet,(v=>JSON.stringify(v)));throw new Error(`The "topicToken" generator option must be one of ${validTopics.join(", ")} (${givenTopicTokenJSON} received instead).`)}this.token(topicToken);},exports.TupleExpression=function(node){const elems=node.elements,len=elems.length;let startToken,endToken;if("bar"===this.format.recordAndTupleSyntaxType)startToken="[|",endToken="|]";else {if("hash"!==this.format.recordAndTupleSyntaxType)throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);startToken="#[",endToken="]";}this.token(startToken),this.printInnerComments(node);for(let i=0;i<elems.length;i++){const elem=elems[i];elem&&(i>0&&this.space(),this.print(elem,node),i<len-1&&this.token(","));}this.token(endToken);};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js"),_jsesc=__webpack_require__("./node_modules/jsesc/jsesc.js");const{isAssignmentPattern,isIdentifier}=_t;const validTopicTokenSet=new Set(["^","%","#"]);},"./node_modules/@babel/generator/lib/generators/typescript.js":(__unused_webpack_module,exports)=>{function tokenIfPlusMinus(self,tok){!0!==tok&&self.token(tok);}Object.defineProperty(exports,"__esModule",{value:!0}),exports.TSAnyKeyword=function(){this.word("any");},exports.TSArrayType=function(node){this.print(node.elementType,node),this.token("[]");},exports.TSAsExpression=function(node){const{expression,typeAnnotation}=node;this.print(expression,node),this.space(),this.word("as"),this.space(),this.print(typeAnnotation,node);},exports.TSBigIntKeyword=function(){this.word("bigint");},exports.TSBooleanKeyword=function(){this.word("boolean");},exports.TSCallSignatureDeclaration=function(node){this.tsPrintSignatureDeclarationBase(node),this.token(";");},exports.TSConditionalType=function(node){this.print(node.checkType),this.space(),this.word("extends"),this.space(),this.print(node.extendsType),this.space(),this.token("?"),this.space(),this.print(node.trueType),this.space(),this.token(":"),this.space(),this.print(node.falseType);},exports.TSConstructSignatureDeclaration=function(node){this.word("new"),this.space(),this.tsPrintSignatureDeclarationBase(node),this.token(";");},exports.TSConstructorType=function(node){node.abstract&&(this.word("abstract"),this.space());this.word("new"),this.space(),this.tsPrintFunctionOrConstructorType(node);},exports.TSDeclareFunction=function(node){node.declare&&(this.word("declare"),this.space());this._functionHead(node),this.token(";");},exports.TSDeclareMethod=function(node){this._classMethodHead(node),this.token(";");},exports.TSEnumDeclaration=function(node){const{declare,const:isConst,id,members}=node;declare&&(this.word("declare"),this.space());isConst&&(this.word("const"),this.space());this.word("enum"),this.space(),this.print(id,node),this.space(),this.tsPrintBraced(members,node);},exports.TSEnumMember=function(node){const{id,initializer}=node;this.print(id,node),initializer&&(this.space(),this.token("="),this.space(),this.print(initializer,node));this.token(",");},exports.TSExportAssignment=function(node){this.word("export"),this.space(),this.token("="),this.space(),this.print(node.expression,node),this.token(";");},exports.TSExpressionWithTypeArguments=function(node){this.print(node.expression,node),this.print(node.typeParameters,node);},exports.TSExternalModuleReference=function(node){this.token("require("),this.print(node.expression,node),this.token(")");},exports.TSFunctionType=function(node){this.tsPrintFunctionOrConstructorType(node);},exports.TSImportEqualsDeclaration=function(node){const{isExport,id,moduleReference}=node;isExport&&(this.word("export"),this.space());this.word("import"),this.space(),this.print(id,node),this.space(),this.token("="),this.space(),this.print(moduleReference,node),this.token(";");},exports.TSImportType=function(node){const{argument,qualifier,typeParameters}=node;this.word("import"),this.token("("),this.print(argument,node),this.token(")"),qualifier&&(this.token("."),this.print(qualifier,node));typeParameters&&this.print(typeParameters,node);},exports.TSIndexSignature=function(node){const{readonly,static:isStatic}=node;isStatic&&(this.word("static"),this.space());readonly&&(this.word("readonly"),this.space());this.token("["),this._parameters(node.parameters,node),this.token("]"),this.print(node.typeAnnotation,node),this.token(";");},exports.TSIndexedAccessType=function(node){this.print(node.objectType,node),this.token("["),this.print(node.indexType,node),this.token("]");},exports.TSInferType=function(node){this.token("infer"),this.space(),this.print(node.typeParameter);},exports.TSInterfaceBody=function(node){this.tsPrintTypeLiteralOrInterfaceBody(node.body,node);},exports.TSInterfaceDeclaration=function(node){const{declare,id,typeParameters,extends:extendz,body}=node;declare&&(this.word("declare"),this.space());this.word("interface"),this.space(),this.print(id,node),this.print(typeParameters,node),null!=extendz&&extendz.length&&(this.space(),this.word("extends"),this.space(),this.printList(extendz,node));this.space(),this.print(body,node);},exports.TSIntersectionType=function(node){this.tsPrintUnionOrIntersectionType(node,"&");},exports.TSIntrinsicKeyword=function(){this.word("intrinsic");},exports.TSLiteralType=function(node){this.print(node.literal,node);},exports.TSMappedType=function(node){const{nameType,optional,readonly,typeParameter}=node;this.token("{"),this.space(),readonly&&(tokenIfPlusMinus(this,readonly),this.word("readonly"),this.space());this.token("["),this.word(typeParameter.name),this.space(),this.word("in"),this.space(),this.print(typeParameter.constraint,typeParameter),nameType&&(this.space(),this.word("as"),this.space(),this.print(nameType,node));this.token("]"),optional&&(tokenIfPlusMinus(this,optional),this.token("?"));this.token(":"),this.space(),this.print(node.typeAnnotation,node),this.space(),this.token("}");},exports.TSMethodSignature=function(node){const{kind}=node;"set"!==kind&&"get"!==kind||(this.word(kind),this.space());this.tsPrintPropertyOrMethodName(node),this.tsPrintSignatureDeclarationBase(node),this.token(";");},exports.TSModuleBlock=function(node){this.tsPrintBraced(node.body,node);},exports.TSModuleDeclaration=function(node){const{declare,id}=node;declare&&(this.word("declare"),this.space());node.global||(this.word("Identifier"===id.type?"namespace":"module"),this.space());if(this.print(id,node),!node.body)return void this.token(";");let body=node.body;for(;"TSModuleDeclaration"===body.type;)this.token("."),this.print(body.id,body),body=body.body;this.space(),this.print(body,node);},exports.TSNamedTupleMember=function(node){this.print(node.label,node),node.optional&&this.token("?");this.token(":"),this.space(),this.print(node.elementType,node);},exports.TSNamespaceExportDeclaration=function(node){this.word("export"),this.space(),this.word("as"),this.space(),this.word("namespace"),this.space(),this.print(node.id,node);},exports.TSNeverKeyword=function(){this.word("never");},exports.TSNonNullExpression=function(node){this.print(node.expression,node),this.token("!");},exports.TSNullKeyword=function(){this.word("null");},exports.TSNumberKeyword=function(){this.word("number");},exports.TSObjectKeyword=function(){this.word("object");},exports.TSOptionalType=function(node){this.print(node.typeAnnotation,node),this.token("?");},exports.TSParameterProperty=function(node){node.accessibility&&(this.word(node.accessibility),this.space());node.readonly&&(this.word("readonly"),this.space());this._param(node.parameter);},exports.TSParenthesizedType=function(node){this.token("("),this.print(node.typeAnnotation,node),this.token(")");},exports.TSPropertySignature=function(node){const{readonly,initializer}=node;readonly&&(this.word("readonly"),this.space());this.tsPrintPropertyOrMethodName(node),this.print(node.typeAnnotation,node),initializer&&(this.space(),this.token("="),this.space(),this.print(initializer,node));this.token(";");},exports.TSQualifiedName=function(node){this.print(node.left,node),this.token("."),this.print(node.right,node);},exports.TSRestType=function(node){this.token("..."),this.print(node.typeAnnotation,node);},exports.TSStringKeyword=function(){this.word("string");},exports.TSSymbolKeyword=function(){this.word("symbol");},exports.TSThisType=function(){this.word("this");},exports.TSTupleType=function(node){this.token("["),this.printList(node.elementTypes,node),this.token("]");},exports.TSTypeAliasDeclaration=function(node){const{declare,id,typeParameters,typeAnnotation}=node;declare&&(this.word("declare"),this.space());this.word("type"),this.space(),this.print(id,node),this.print(typeParameters,node),this.space(),this.token("="),this.space(),this.print(typeAnnotation,node),this.token(";");},exports.TSTypeAnnotation=function(node){this.token(":"),this.space(),node.optional&&this.token("?");this.print(node.typeAnnotation,node);},exports.TSTypeAssertion=function(node){const{typeAnnotation,expression}=node;this.token("<"),this.print(typeAnnotation,node),this.token(">"),this.space(),this.print(expression,node);},exports.TSTypeLiteral=function(node){this.tsPrintTypeLiteralOrInterfaceBody(node.members,node);},exports.TSTypeOperator=function(node){this.word(node.operator),this.space(),this.print(node.typeAnnotation,node);},exports.TSTypeParameter=function(node){this.word(node.name),node.constraint&&(this.space(),this.word("extends"),this.space(),this.print(node.constraint,node));node.default&&(this.space(),this.token("="),this.space(),this.print(node.default,node));},exports.TSTypeParameterDeclaration=exports.TSTypeParameterInstantiation=function(node,parent){this.token("<"),this.printList(node.params,node,{}),"ArrowFunctionExpression"===parent.type&&1===node.params.length&&this.token(",");this.token(">");},exports.TSTypePredicate=function(node){node.asserts&&(this.word("asserts"),this.space());this.print(node.parameterName),node.typeAnnotation&&(this.space(),this.word("is"),this.space(),this.print(node.typeAnnotation.typeAnnotation));},exports.TSTypeQuery=function(node){this.word("typeof"),this.space(),this.print(node.exprName);},exports.TSTypeReference=function(node){this.print(node.typeName,node),this.print(node.typeParameters,node);},exports.TSUndefinedKeyword=function(){this.word("undefined");},exports.TSUnionType=function(node){this.tsPrintUnionOrIntersectionType(node,"|");},exports.TSUnknownKeyword=function(){this.word("unknown");},exports.TSVoidKeyword=function(){this.word("void");},exports.tsPrintBraced=function(members,node){if(this.token("{"),members.length){this.indent(),this.newline();for(const member of members)this.print(member,node),this.newline();this.dedent(),this.rightBrace();}else this.token("}");},exports.tsPrintClassMemberModifiers=function(node,isField){isField&&node.declare&&(this.word("declare"),this.space());node.accessibility&&(this.word(node.accessibility),this.space());node.static&&(this.word("static"),this.space());node.override&&(this.word("override"),this.space());node.abstract&&(this.word("abstract"),this.space());isField&&node.readonly&&(this.word("readonly"),this.space());},exports.tsPrintFunctionOrConstructorType=function(node){const{typeParameters}=node,parameters=node.parameters;this.print(typeParameters,node),this.token("("),this._parameters(parameters,node),this.token(")"),this.space(),this.token("=>"),this.space();const returnType=node.typeAnnotation;this.print(returnType.typeAnnotation,node);},exports.tsPrintPropertyOrMethodName=function(node){node.computed&&this.token("[");this.print(node.key,node),node.computed&&this.token("]");node.optional&&this.token("?");},exports.tsPrintSignatureDeclarationBase=function(node){const{typeParameters}=node,parameters=node.parameters;this.print(typeParameters,node),this.token("("),this._parameters(parameters,node),this.token(")");const returnType=node.typeAnnotation;this.print(returnType,node);},exports.tsPrintTypeLiteralOrInterfaceBody=function(members,node){this.tsPrintBraced(members,node);},exports.tsPrintUnionOrIntersectionType=function(node,sep){this.printJoin(node.types,node,{separator(){this.space(),this.token(sep),this.space();}});};},"./node_modules/@babel/generator/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.CodeGenerator=void 0,exports.default=function(ast,opts,code){return new Generator(ast,opts,code).generate()};var _sourceMap=__webpack_require__("./node_modules/@babel/generator/lib/source-map.js"),_printer=__webpack_require__("./node_modules/@babel/generator/lib/printer.js");class Generator extends _printer.default{constructor(ast,opts={},code){const format=function(code,opts){const format={auxiliaryCommentBefore:opts.auxiliaryCommentBefore,auxiliaryCommentAfter:opts.auxiliaryCommentAfter,shouldPrintComment:opts.shouldPrintComment,retainLines:opts.retainLines,retainFunctionParens:opts.retainFunctionParens,comments:null==opts.comments||opts.comments,compact:opts.compact,minified:opts.minified,concise:opts.concise,indent:{adjustMultilineComment:!0,style:"  ",base:0},decoratorsBeforeExport:!!opts.decoratorsBeforeExport,jsescOption:Object.assign({quotes:"double",wrap:!0,minimal:!1},opts.jsescOption),recordAndTupleSyntaxType:opts.recordAndTupleSyntaxType,topicToken:opts.topicToken};format.jsonCompatibleStrings=opts.jsonCompatibleStrings,format.minified?(format.compact=!0,format.shouldPrintComment=format.shouldPrintComment||(()=>format.comments)):format.shouldPrintComment=format.shouldPrintComment||(value=>format.comments||value.indexOf("@license")>=0||value.indexOf("@preserve")>=0);"auto"===format.compact&&(format.compact=code.length>5e5,format.compact&&console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${opts.filename} as it exceeds the max of 500KB.`));format.compact&&(format.indent.adjustMultilineComment=!1);return format}(code,opts);super(format,opts.sourceMaps?new _sourceMap.default(opts,code):null),this.ast=void 0,this.ast=ast;}generate(){return super.generate(this.ast)}}exports.CodeGenerator=class{constructor(ast,opts,code){this._generator=void 0,this._generator=new Generator(ast,opts,code);}generate(){return this._generator.generate()}};},"./node_modules/@babel/generator/lib/node/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.needsParens=function(node,parent,printStack){if(!parent)return !1;if(isNewExpression(parent)&&parent.callee===node&&isOrHasCallExpression(node))return !0;return find(expandedParens,node,parent,printStack)},exports.needsWhitespace=needsWhitespace,exports.needsWhitespaceAfter=function(node,parent){return needsWhitespace(node,parent,"after")},exports.needsWhitespaceBefore=function(node,parent){return needsWhitespace(node,parent,"before")};var whitespace=__webpack_require__("./node_modules/@babel/generator/lib/node/whitespace.js"),parens=__webpack_require__("./node_modules/@babel/generator/lib/node/parentheses.js"),_t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{FLIPPED_ALIAS_KEYS,isCallExpression,isExpressionStatement,isMemberExpression,isNewExpression}=_t;function expandAliases(obj){const newObj={};function add(type,func){const fn=newObj[type];newObj[type]=fn?function(node,parent,stack){const result=fn(node,parent,stack);return null==result?func(node,parent,stack):result}:func;}for(const type of Object.keys(obj)){const aliases=FLIPPED_ALIAS_KEYS[type];if(aliases)for(const alias of aliases)add(alias,obj[type]);else add(type,obj[type]);}return newObj}const expandedParens=expandAliases(parens),expandedWhitespaceNodes=expandAliases(whitespace.nodes),expandedWhitespaceList=expandAliases(whitespace.list);function find(obj,node,parent,printStack){const fn=obj[node.type];return fn?fn(node,parent,printStack):null}function isOrHasCallExpression(node){return !!isCallExpression(node)||isMemberExpression(node)&&isOrHasCallExpression(node.object)}function needsWhitespace(node,parent,type){if(!node)return 0;isExpressionStatement(node)&&(node=node.expression);let linesInfo=find(expandedWhitespaceNodes,node,parent);if(!linesInfo){const items=find(expandedWhitespaceList,node,parent);if(items)for(let i=0;i<items.length&&(linesInfo=needsWhitespace(items[i],node,type),!linesInfo);i++);}return "object"==typeof linesInfo&&null!==linesInfo&&linesInfo[type]||0}},"./node_modules/@babel/generator/lib/node/parentheses.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.ArrowFunctionExpression=function(node,parent){return isExportDeclaration(parent)||ConditionalExpression(node,parent)},exports.AssignmentExpression=function(node,parent){return !!isObjectPattern(node.left)||ConditionalExpression(node,parent)},exports.Binary=function(node,parent){if("**"===node.operator&&isBinaryExpression(parent,{operator:"**"}))return parent.left===node;if(isClassExtendsClause(node,parent))return !0;if(hasPostfixPart(node,parent)||isUnaryLike(parent)||isAwaitExpression(parent))return !0;if(isBinary(parent)){const parentOp=parent.operator,parentPos=PRECEDENCE[parentOp],nodeOp=node.operator,nodePos=PRECEDENCE[nodeOp];if(parentPos===nodePos&&parent.right===node&&!isLogicalExpression(parent)||parentPos>nodePos)return !0}},exports.BinaryExpression=function(node,parent){return "in"===node.operator&&(isVariableDeclarator(parent)||isFor(parent))},exports.ClassExpression=function(node,parent,printStack){return isFirstInContext(printStack,{expressionStatement:!0,exportDefault:!0})},exports.ConditionalExpression=ConditionalExpression,exports.DoExpression=function(node,parent,printStack){return !node.async&&isFirstInContext(printStack,{expressionStatement:!0})},exports.FunctionExpression=function(node,parent,printStack){return isFirstInContext(printStack,{expressionStatement:!0,exportDefault:!0})},exports.FunctionTypeAnnotation=function(node,parent,printStack){return isUnionTypeAnnotation(parent)||isIntersectionTypeAnnotation(parent)||isArrayTypeAnnotation(parent)||isTypeAnnotation(parent)&&isArrowFunctionExpression(printStack[printStack.length-3])},exports.Identifier=function(node,parent,printStack){if("let"===node.name){const isFollowedByBracket=isMemberExpression(parent,{object:node,computed:!0})||isOptionalMemberExpression(parent,{object:node,computed:!0,optional:!1});return isFirstInContext(printStack,{expressionStatement:isFollowedByBracket,forHead:isFollowedByBracket,forInHead:isFollowedByBracket,forOfHead:!0})}return "async"===node.name&&isForOfStatement(parent)&&node===parent.left},exports.LogicalExpression=function(node,parent){switch(node.operator){case"||":return !!isLogicalExpression(parent)&&("??"===parent.operator||"&&"===parent.operator);case"&&":return isLogicalExpression(parent,{operator:"??"});case"??":return isLogicalExpression(parent)&&"??"!==parent.operator}},exports.NullableTypeAnnotation=function(node,parent){return isArrayTypeAnnotation(parent)},exports.ObjectExpression=function(node,parent,printStack){return isFirstInContext(printStack,{expressionStatement:!0,arrowBody:!0})},exports.OptionalIndexedAccessType=function(node,parent){return isIndexedAccessType(parent,{objectType:node})},exports.OptionalCallExpression=exports.OptionalMemberExpression=function(node,parent){return isCallExpression(parent,{callee:node})||isMemberExpression(parent,{object:node})},exports.SequenceExpression=function(node,parent){if(isForStatement(parent)||isThrowStatement(parent)||isReturnStatement(parent)||isIfStatement(parent)&&parent.test===node||isWhileStatement(parent)&&parent.test===node||isForInStatement(parent)&&parent.right===node||isSwitchStatement(parent)&&parent.discriminant===node||isExpressionStatement(parent)&&parent.expression===node)return !1;return !0},exports.TSAsExpression=function(){return !0},exports.TSInferType=function(node,parent){return isTSArrayType(parent)||isTSOptionalType(parent)},exports.TSTypeAssertion=function(){return !0},exports.TSIntersectionType=exports.TSUnionType=function(node,parent){return isTSArrayType(parent)||isTSOptionalType(parent)||isTSIntersectionType(parent)||isTSUnionType(parent)||isTSRestType(parent)},exports.UnaryLike=UnaryLike,exports.IntersectionTypeAnnotation=exports.UnionTypeAnnotation=function(node,parent){return isArrayTypeAnnotation(parent)||isNullableTypeAnnotation(parent)||isIntersectionTypeAnnotation(parent)||isUnionTypeAnnotation(parent)},exports.UpdateExpression=function(node,parent){return hasPostfixPart(node,parent)||isClassExtendsClause(node,parent)},exports.AwaitExpression=exports.YieldExpression=function(node,parent){return isBinary(parent)||isUnaryLike(parent)||hasPostfixPart(node,parent)||isAwaitExpression(parent)&&isYieldExpression(node)||isConditionalExpression(parent)&&node===parent.test||isClassExtendsClause(node,parent)};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{isArrayTypeAnnotation,isArrowFunctionExpression,isAssignmentExpression,isAwaitExpression,isBinary,isBinaryExpression,isCallExpression,isClassDeclaration,isClassExpression,isConditional,isConditionalExpression,isExportDeclaration,isExportDefaultDeclaration,isExpressionStatement,isFor,isForInStatement,isForOfStatement,isForStatement,isIfStatement,isIndexedAccessType,isIntersectionTypeAnnotation,isLogicalExpression,isMemberExpression,isNewExpression,isNullableTypeAnnotation,isObjectPattern,isOptionalCallExpression,isOptionalMemberExpression,isReturnStatement,isSequenceExpression,isSwitchStatement,isTSArrayType,isTSAsExpression,isTSIntersectionType,isTSNonNullExpression,isTSOptionalType,isTSRestType,isTSTypeAssertion,isTSUnionType,isTaggedTemplateExpression,isThrowStatement,isTypeAnnotation,isUnaryLike,isUnionTypeAnnotation,isVariableDeclarator,isWhileStatement,isYieldExpression}=_t,PRECEDENCE={"||":0,"??":0,"&&":1,"|":2,"^":3,"&":4,"==":5,"===":5,"!=":5,"!==":5,"<":6,">":6,"<=":6,">=":6,in:6,instanceof:6,">>":7,"<<":7,">>>":7,"+":8,"-":8,"*":9,"/":9,"%":9,"**":10},isClassExtendsClause=(node,parent)=>(isClassDeclaration(parent)||isClassExpression(parent))&&parent.superClass===node,hasPostfixPart=(node,parent)=>(isMemberExpression(parent)||isOptionalMemberExpression(parent))&&parent.object===node||(isCallExpression(parent)||isOptionalCallExpression(parent)||isNewExpression(parent))&&parent.callee===node||isTaggedTemplateExpression(parent)&&parent.tag===node||isTSNonNullExpression(parent);function UnaryLike(node,parent){return hasPostfixPart(node,parent)||isBinaryExpression(parent,{operator:"**",left:node})||isClassExtendsClause(node,parent)}function ConditionalExpression(node,parent){return !!(isUnaryLike(parent)||isBinary(parent)||isConditionalExpression(parent,{test:node})||isAwaitExpression(parent)||isTSTypeAssertion(parent)||isTSAsExpression(parent))||UnaryLike(node,parent)}function isFirstInContext(printStack,{expressionStatement=!1,arrowBody=!1,exportDefault=!1,forHead=!1,forInHead=!1,forOfHead=!1}){let i=printStack.length-1,node=printStack[i];i--;let parent=printStack[i];for(;i>=0;){if(expressionStatement&&isExpressionStatement(parent,{expression:node})||exportDefault&&isExportDefaultDeclaration(parent,{declaration:node})||arrowBody&&isArrowFunctionExpression(parent,{body:node})||forHead&&isForStatement(parent,{init:node})||forInHead&&isForInStatement(parent,{left:node})||forOfHead&&isForOfStatement(parent,{left:node}))return !0;if(!(hasPostfixPart(node,parent)&&!isNewExpression(parent)||isSequenceExpression(parent)&&parent.expressions[0]===node||isConditional(parent,{test:node})||isBinary(parent,{left:node})||isAssignmentExpression(parent,{left:node})))return !1;node=parent,i--,parent=printStack[i];}return !1}},"./node_modules/@babel/generator/lib/node/whitespace.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.nodes=exports.list=void 0;var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{FLIPPED_ALIAS_KEYS,isArrayExpression,isAssignmentExpression,isBinary,isBlockStatement,isCallExpression,isFunction,isIdentifier,isLiteral,isMemberExpression,isObjectExpression,isOptionalCallExpression,isOptionalMemberExpression,isStringLiteral}=_t;function crawl(node,state={}){return isMemberExpression(node)||isOptionalMemberExpression(node)?(crawl(node.object,state),node.computed&&crawl(node.property,state)):isBinary(node)||isAssignmentExpression(node)?(crawl(node.left,state),crawl(node.right,state)):isCallExpression(node)||isOptionalCallExpression(node)?(state.hasCall=!0,crawl(node.callee,state)):isFunction(node)?state.hasFunction=!0:isIdentifier(node)&&(state.hasHelper=state.hasHelper||isHelper(node.callee)),state}function isHelper(node){return isMemberExpression(node)?isHelper(node.object)||isHelper(node.property):isIdentifier(node)?"require"===node.name||"_"===node.name[0]:isCallExpression(node)?isHelper(node.callee):!(!isBinary(node)&&!isAssignmentExpression(node))&&(isIdentifier(node.left)&&isHelper(node.left)||isHelper(node.right))}function isType(node){return isLiteral(node)||isObjectExpression(node)||isArrayExpression(node)||isIdentifier(node)||isMemberExpression(node)}const nodes={AssignmentExpression(node){const state=crawl(node.right);if(state.hasCall&&state.hasHelper||state.hasFunction)return {before:state.hasFunction,after:!0}},SwitchCase:(node,parent)=>({before:!!node.consequent.length||parent.cases[0]===node,after:!node.consequent.length&&parent.cases[parent.cases.length-1]===node}),LogicalExpression(node){if(isFunction(node.left)||isFunction(node.right))return {after:!0}},Literal(node){if(isStringLiteral(node)&&"use strict"===node.value)return {after:!0}},CallExpression(node){if(isFunction(node.callee)||isHelper(node))return {before:!0,after:!0}},OptionalCallExpression(node){if(isFunction(node.callee))return {before:!0,after:!0}},VariableDeclaration(node){for(let i=0;i<node.declarations.length;i++){const declar=node.declarations[i];let enabled=isHelper(declar.id)&&!isType(declar.init);if(!enabled){const state=crawl(declar.init);enabled=isHelper(declar.init)&&state.hasCall||state.hasFunction;}if(enabled)return {before:!0,after:!0}}},IfStatement(node){if(isBlockStatement(node.consequent))return {before:!0,after:!0}}};exports.nodes=nodes,nodes.ObjectProperty=nodes.ObjectTypeProperty=nodes.ObjectMethod=function(node,parent){if(parent.properties[0]===node)return {before:!0}},nodes.ObjectTypeCallProperty=function(node,parent){var _parent$properties;if(parent.callProperties[0]===node&&(null==(_parent$properties=parent.properties)||!_parent$properties.length))return {before:!0}},nodes.ObjectTypeIndexer=function(node,parent){var _parent$properties2,_parent$callPropertie;if(!(parent.indexers[0]!==node||null!=(_parent$properties2=parent.properties)&&_parent$properties2.length||null!=(_parent$callPropertie=parent.callProperties)&&_parent$callPropertie.length))return {before:!0}},nodes.ObjectTypeInternalSlot=function(node,parent){var _parent$properties3,_parent$callPropertie2,_parent$indexers;if(!(parent.internalSlots[0]!==node||null!=(_parent$properties3=parent.properties)&&_parent$properties3.length||null!=(_parent$callPropertie2=parent.callProperties)&&_parent$callPropertie2.length||null!=(_parent$indexers=parent.indexers)&&_parent$indexers.length))return {before:!0}};const list={VariableDeclaration:node=>node.declarations.map((decl=>decl.init)),ArrayExpression:node=>node.elements,ObjectExpression:node=>node.properties};exports.list=list,[["Function",!0],["Class",!0],["Loop",!0],["LabeledStatement",!0],["SwitchStatement",!0],["TryStatement",!0]].forEach((function([type,amounts]){"boolean"==typeof amounts&&(amounts={after:amounts,before:amounts}),[type].concat(FLIPPED_ALIAS_KEYS[type]||[]).forEach((function(type){nodes[type]=function(){return amounts};}));}));},"./node_modules/@babel/generator/lib/printer.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _buffer=__webpack_require__("./node_modules/@babel/generator/lib/buffer.js"),n=__webpack_require__("./node_modules/@babel/generator/lib/node/index.js"),_t=__webpack_require__("./node_modules/@babel/types/lib/index.js"),generatorFunctions=__webpack_require__("./node_modules/@babel/generator/lib/generators/index.js");const{isProgram,isFile,isEmptyStatement}=_t,SCIENTIFIC_NOTATION=/e/i,ZERO_DECIMAL_INTEGER=/\.0+$/,NON_DECIMAL_LITERAL=/^0[box]/,PURE_ANNOTATION_RE=/^\s*[@#]__PURE__\s*$/,{needsParens,needsWhitespaceAfter,needsWhitespaceBefore}=n;class Printer{constructor(format,map){this.inForStatementInitCounter=0,this._printStack=[],this._indent=0,this._insideAux=!1,this._parenPushNewlineState=null,this._noLineTerminator=!1,this._printAuxAfterOnNextUserNode=!1,this._printedComments=new WeakSet,this._endsWithInteger=!1,this._endsWithWord=!1,this.format=format,this._buf=new _buffer.default(map);}generate(ast){return this.print(ast),this._maybeAddAuxComment(),this._buf.get()}indent(){this.format.compact||this.format.concise||this._indent++;}dedent(){this.format.compact||this.format.concise||this._indent--;}semicolon(force=!1){this._maybeAddAuxComment(),this._append(";",!force);}rightBrace(){this.format.minified&&this._buf.removeLastSemicolon(),this.token("}");}space(force=!1){if(!this.format.compact)if(force)this._space();else if(this._buf.hasContent()){const lastCp=this.getLastChar();32!==lastCp&&10!==lastCp&&this._space();}}word(str){(this._endsWithWord||this.endsWith(47)&&47===str.charCodeAt(0))&&this._space(),this._maybeAddAuxComment(),this._append(str),this._endsWithWord=!0;}number(str){this.word(str),this._endsWithInteger=Number.isInteger(+str)&&!NON_DECIMAL_LITERAL.test(str)&&!SCIENTIFIC_NOTATION.test(str)&&!ZERO_DECIMAL_INTEGER.test(str)&&46!==str.charCodeAt(str.length-1);}token(str){const lastChar=this.getLastChar(),strFirst=str.charCodeAt(0);("--"===str&&33===lastChar||43===strFirst&&43===lastChar||45===strFirst&&45===lastChar||46===strFirst&&this._endsWithInteger)&&this._space(),this._maybeAddAuxComment(),this._append(str);}newline(i=1){if(this.format.retainLines||this.format.compact)return;if(this.format.concise)return void this.space();const charBeforeNewline=this.endsWithCharAndNewline();if(10!==charBeforeNewline&&(123!==charBeforeNewline&&58!==charBeforeNewline||i--,!(i<=0)))for(let j=0;j<i;j++)this._newline();}endsWith(char){return this.getLastChar()===char}getLastChar(){return this._buf.getLastChar()}endsWithCharAndNewline(){return this._buf.endsWithCharAndNewline()}removeTrailingNewline(){this._buf.removeTrailingNewline();}exactSource(loc,cb){this._catchUp("start",loc),this._buf.exactSource(loc,cb);}source(prop,loc){this._catchUp(prop,loc),this._buf.source(prop,loc);}withSource(prop,loc,cb){this._catchUp(prop,loc),this._buf.withSource(prop,loc,cb);}_space(){this._append(" ",!0);}_newline(){this._append("\n",!0);}_append(str,queue=!1){this._maybeAddParen(str),this._maybeIndent(str),queue?this._buf.queue(str):this._buf.append(str),this._endsWithWord=!1,this._endsWithInteger=!1;}_maybeIndent(str){this._indent&&this.endsWith(10)&&10!==str.charCodeAt(0)&&this._buf.queue(this._getIndent());}_maybeAddParen(str){const parenPushNewlineState=this._parenPushNewlineState;if(!parenPushNewlineState)return;let i;for(i=0;i<str.length&&" "===str[i];i++)continue;if(i===str.length)return;const cha=str[i];if("\n"!==cha){if("/"!==cha||i+1===str.length)return void(this._parenPushNewlineState=null);const chaPost=str[i+1];if("*"===chaPost){if(PURE_ANNOTATION_RE.test(str.slice(i+2,str.length-2)))return}else if("/"!==chaPost)return void(this._parenPushNewlineState=null)}this.token("("),this.indent(),parenPushNewlineState.printed=!0;}_catchUp(prop,loc){if(!this.format.retainLines)return;const pos=loc?loc[prop]:null;if(null!=(null==pos?void 0:pos.line)){const count=pos.line-this._buf.getCurrentLine();for(let i=0;i<count;i++)this._newline();}}_getIndent(){return this.format.indent.style.repeat(this._indent)}startTerminatorless(isLabel=!1){return isLabel?(this._noLineTerminator=!0,null):this._parenPushNewlineState={printed:!1}}endTerminatorless(state){this._noLineTerminator=!1,null!=state&&state.printed&&(this.dedent(),this.newline(),this.token(")"));}print(node,parent){if(!node)return;const oldConcise=this.format.concise;node._compact&&(this.format.concise=!0);const printMethod=this[node.type];if(!printMethod)throw new ReferenceError(`unknown node of type ${JSON.stringify(node.type)} with constructor ${JSON.stringify(null==node?void 0:node.constructor.name)}`);this._printStack.push(node);const oldInAux=this._insideAux;this._insideAux=!node.loc,this._maybeAddAuxComment(this._insideAux&&!oldInAux);let shouldPrintParens=needsParens(node,parent,this._printStack);this.format.retainFunctionParens&&"FunctionExpression"===node.type&&node.extra&&node.extra.parenthesized&&(shouldPrintParens=!0),shouldPrintParens&&this.token("("),this._printLeadingComments(node);const loc=isProgram(node)||isFile(node)?null:node.loc;this.withSource("start",loc,(()=>{printMethod.call(this,node,parent);})),this._printTrailingComments(node),shouldPrintParens&&this.token(")"),this._printStack.pop(),this.format.concise=oldConcise,this._insideAux=oldInAux;}_maybeAddAuxComment(enteredPositionlessNode){enteredPositionlessNode&&this._printAuxBeforeComment(),this._insideAux||this._printAuxAfterComment();}_printAuxBeforeComment(){if(this._printAuxAfterOnNextUserNode)return;this._printAuxAfterOnNextUserNode=!0;const comment=this.format.auxiliaryCommentBefore;comment&&this._printComment({type:"CommentBlock",value:comment});}_printAuxAfterComment(){if(!this._printAuxAfterOnNextUserNode)return;this._printAuxAfterOnNextUserNode=!1;const comment=this.format.auxiliaryCommentAfter;comment&&this._printComment({type:"CommentBlock",value:comment});}getPossibleRaw(node){const extra=node.extra;if(extra&&null!=extra.raw&&null!=extra.rawValue&&node.value===extra.rawValue)return extra.raw}printJoin(nodes,parent,opts={}){if(null==nodes||!nodes.length)return;opts.indent&&this.indent();const newlineOpts={addNewlines:opts.addNewlines};for(let i=0;i<nodes.length;i++){const node=nodes[i];node&&(opts.statement&&this._printNewline(!0,node,parent,newlineOpts),this.print(node,parent),opts.iterator&&opts.iterator(node,i),opts.separator&&i<nodes.length-1&&opts.separator.call(this),opts.statement&&this._printNewline(!1,node,parent,newlineOpts));}opts.indent&&this.dedent();}printAndIndentOnComments(node,parent){const indent=node.leadingComments&&node.leadingComments.length>0;indent&&this.indent(),this.print(node,parent),indent&&this.dedent();}printBlock(parent){const node=parent.body;isEmptyStatement(node)||this.space(),this.print(node,parent);}_printTrailingComments(node){this._printComments(this._getComments(!1,node));}_printLeadingComments(node){this._printComments(this._getComments(!0,node),!0);}printInnerComments(node,indent=!0){var _node$innerComments;null!=(_node$innerComments=node.innerComments)&&_node$innerComments.length&&(indent&&this.indent(),this._printComments(node.innerComments),indent&&this.dedent());}printSequence(nodes,parent,opts={}){return opts.statement=!0,this.printJoin(nodes,parent,opts)}printList(items,parent,opts={}){return null==opts.separator&&(opts.separator=commaSeparator),this.printJoin(items,parent,opts)}_printNewline(leading,node,parent,opts){if(this.format.retainLines||this.format.compact)return;if(this.format.concise)return void this.space();let lines=0;if(this._buf.hasContent()){leading||lines++,opts.addNewlines&&(lines+=opts.addNewlines(leading,node)||0);(leading?needsWhitespaceBefore:needsWhitespaceAfter)(node,parent)&&lines++;}this.newline(Math.min(2,lines));}_getComments(leading,node){return node&&(leading?node.leadingComments:node.trailingComments)||[]}_printComment(comment,skipNewLines){if(!this.format.shouldPrintComment(comment.value))return;if(comment.ignore)return;if(this._printedComments.has(comment))return;this._printedComments.add(comment);const isBlockComment="CommentBlock"===comment.type,printNewLines=isBlockComment&&!skipNewLines&&!this._noLineTerminator;printNewLines&&this._buf.hasContent()&&this.newline(1);const lastCharCode=this.getLastChar();91!==lastCharCode&&123!==lastCharCode&&this.space();let val=isBlockComment||this._noLineTerminator?`/*${comment.value}*/`:`//${comment.value}\n`;if(isBlockComment&&this.format.indent.adjustMultilineComment){var _comment$loc;const offset=null==(_comment$loc=comment.loc)?void 0:_comment$loc.start.column;if(offset){const newlineRegex=new RegExp("\\n\\s{1,"+offset+"}","g");val=val.replace(newlineRegex,"\n");}const indentSize=Math.max(this._getIndent().length,this.format.retainLines?0:this._buf.getCurrentColumn());val=val.replace(/\n(?!$)/g,`\n${" ".repeat(indentSize)}`);}this.endsWith(47)&&this._space(),this.withSource("start",comment.loc,(()=>{this._append(val);})),printNewLines&&this.newline(1);}_printComments(comments,inlinePureAnnotation){if(null!=comments&&comments.length)if(inlinePureAnnotation&&1===comments.length&&PURE_ANNOTATION_RE.test(comments[0].value))this._printComment(comments[0],this._buf.hasContent()&&!this.endsWith(10));else for(const comment of comments)this._printComment(comment);}printAssertions(node){var _node$assertions;null!=(_node$assertions=node.assertions)&&_node$assertions.length&&(this.space(),this.word("assert"),this.space(),this.token("{"),this.space(),this.printList(node.assertions,node),this.space(),this.token("}"));}}Object.assign(Printer.prototype,generatorFunctions),Printer.prototype.Noop=function(){};var _default=Printer;function commaSeparator(){this.token(","),this.space();}exports.default=_default;},"./node_modules/@babel/generator/lib/source-map.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _sourceMap=__webpack_require__("./node_modules/@babel/generator/node_modules/source-map/source-map.js");exports.default=class{constructor(opts,code){this._cachedMap=void 0,this._code=void 0,this._opts=void 0,this._rawMappings=void 0,this._lastGenLine=void 0,this._lastSourceLine=void 0,this._lastSourceColumn=void 0,this._cachedMap=null,this._code=code,this._opts=opts,this._rawMappings=[];}get(){if(!this._cachedMap){const map=this._cachedMap=new _sourceMap.SourceMapGenerator({sourceRoot:this._opts.sourceRoot}),code=this._code;"string"==typeof code?map.setSourceContent(this._opts.sourceFileName.replace(/\\/g,"/"),code):"object"==typeof code&&Object.keys(code).forEach((sourceFileName=>{map.setSourceContent(sourceFileName.replace(/\\/g,"/"),code[sourceFileName]);})),this._rawMappings.forEach((mapping=>map.addMapping(mapping)),map);}return this._cachedMap.toJSON()}getRawMappings(){return this._rawMappings.slice()}mark(generatedLine,generatedColumn,line,column,identifierName,filename,force){this._lastGenLine!==generatedLine&&null===line||(force||this._lastGenLine!==generatedLine||this._lastSourceLine!==line||this._lastSourceColumn!==column)&&(this._cachedMap=null,this._lastGenLine=generatedLine,this._lastSourceLine=line,this._lastSourceColumn=column,this._rawMappings.push({name:identifierName||void 0,generated:{line:generatedLine,column:generatedColumn},source:null==line?void 0:(filename||this._opts.sourceFileName).replace(/\\/g,"/"),original:null==line?void 0:{line,column}}));}};},"./node_modules/@babel/generator/node_modules/source-map/lib/array-set.js":(__unused_webpack_module,exports,__webpack_require__)=>{var util=__webpack_require__("./node_modules/@babel/generator/node_modules/source-map/lib/util.js"),has=Object.prototype.hasOwnProperty,hasNativeMap="undefined"!=typeof Map;function ArraySet(){this._array=[],this._set=hasNativeMap?new Map:Object.create(null);}ArraySet.fromArray=function(aArray,aAllowDuplicates){for(var set=new ArraySet,i=0,len=aArray.length;i<len;i++)set.add(aArray[i],aAllowDuplicates);return set},ArraySet.prototype.size=function(){return hasNativeMap?this._set.size:Object.getOwnPropertyNames(this._set).length},ArraySet.prototype.add=function(aStr,aAllowDuplicates){var sStr=hasNativeMap?aStr:util.toSetString(aStr),isDuplicate=hasNativeMap?this.has(aStr):has.call(this._set,sStr),idx=this._array.length;isDuplicate&&!aAllowDuplicates||this._array.push(aStr),isDuplicate||(hasNativeMap?this._set.set(aStr,idx):this._set[sStr]=idx);},ArraySet.prototype.has=function(aStr){if(hasNativeMap)return this._set.has(aStr);var sStr=util.toSetString(aStr);return has.call(this._set,sStr)},ArraySet.prototype.indexOf=function(aStr){if(hasNativeMap){var idx=this._set.get(aStr);if(idx>=0)return idx}else {var sStr=util.toSetString(aStr);if(has.call(this._set,sStr))return this._set[sStr]}throw new Error('"'+aStr+'" is not in the set.')},ArraySet.prototype.at=function(aIdx){if(aIdx>=0&&aIdx<this._array.length)return this._array[aIdx];throw new Error("No element indexed by "+aIdx)},ArraySet.prototype.toArray=function(){return this._array.slice()},exports.I=ArraySet;},"./node_modules/@babel/generator/node_modules/source-map/lib/base64-vlq.js":(__unused_webpack_module,exports,__webpack_require__)=>{var base64=__webpack_require__("./node_modules/@babel/generator/node_modules/source-map/lib/base64.js");exports.encode=function(aValue){var digit,encoded="",vlq=function(aValue){return aValue<0?1+(-aValue<<1):0+(aValue<<1)}(aValue);do{digit=31&vlq,(vlq>>>=5)>0&&(digit|=32),encoded+=base64.encode(digit);}while(vlq>0);return encoded},exports.decode=function(aStr,aIndex,aOutParam){var continuation,digit,aValue,shifted,strLen=aStr.length,result=0,shift=0;do{if(aIndex>=strLen)throw new Error("Expected more digits in base 64 VLQ value.");if(-1===(digit=base64.decode(aStr.charCodeAt(aIndex++))))throw new Error("Invalid base64 digit: "+aStr.charAt(aIndex-1));continuation=!!(32&digit),result+=(digit&=31)<<shift,shift+=5;}while(continuation);aOutParam.value=(shifted=(aValue=result)>>1,1==(1&aValue)?-shifted:shifted),aOutParam.rest=aIndex;};},"./node_modules/@babel/generator/node_modules/source-map/lib/base64.js":(__unused_webpack_module,exports)=>{var intToCharMap="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");exports.encode=function(number){if(0<=number&&number<intToCharMap.length)return intToCharMap[number];throw new TypeError("Must be between 0 and 63: "+number)},exports.decode=function(charCode){return 65<=charCode&&charCode<=90?charCode-65:97<=charCode&&charCode<=122?charCode-97+26:48<=charCode&&charCode<=57?charCode-48+52:43==charCode?62:47==charCode?63:-1};},"./node_modules/@babel/generator/node_modules/source-map/lib/binary-search.js":(__unused_webpack_module,exports)=>{function recursiveSearch(aLow,aHigh,aNeedle,aHaystack,aCompare,aBias){var mid=Math.floor((aHigh-aLow)/2)+aLow,cmp=aCompare(aNeedle,aHaystack[mid],!0);return 0===cmp?mid:cmp>0?aHigh-mid>1?recursiveSearch(mid,aHigh,aNeedle,aHaystack,aCompare,aBias):aBias==exports.LEAST_UPPER_BOUND?aHigh<aHaystack.length?aHigh:-1:mid:mid-aLow>1?recursiveSearch(aLow,mid,aNeedle,aHaystack,aCompare,aBias):aBias==exports.LEAST_UPPER_BOUND?mid:aLow<0?-1:aLow}exports.GREATEST_LOWER_BOUND=1,exports.LEAST_UPPER_BOUND=2,exports.search=function(aNeedle,aHaystack,aCompare,aBias){if(0===aHaystack.length)return -1;var index=recursiveSearch(-1,aHaystack.length,aNeedle,aHaystack,aCompare,aBias||exports.GREATEST_LOWER_BOUND);if(index<0)return -1;for(;index-1>=0&&0===aCompare(aHaystack[index],aHaystack[index-1],!0);)--index;return index};},"./node_modules/@babel/generator/node_modules/source-map/lib/mapping-list.js":(__unused_webpack_module,exports,__webpack_require__)=>{var util=__webpack_require__("./node_modules/@babel/generator/node_modules/source-map/lib/util.js");function MappingList(){this._array=[],this._sorted=!0,this._last={generatedLine:-1,generatedColumn:0};}MappingList.prototype.unsortedForEach=function(aCallback,aThisArg){this._array.forEach(aCallback,aThisArg);},MappingList.prototype.add=function(aMapping){var mappingA,mappingB,lineA,lineB,columnA,columnB;mappingA=this._last,mappingB=aMapping,lineA=mappingA.generatedLine,lineB=mappingB.generatedLine,columnA=mappingA.generatedColumn,columnB=mappingB.generatedColumn,lineB>lineA||lineB==lineA&&columnB>=columnA||util.compareByGeneratedPositionsInflated(mappingA,mappingB)<=0?(this._last=aMapping,this._array.push(aMapping)):(this._sorted=!1,this._array.push(aMapping));},MappingList.prototype.toArray=function(){return this._sorted||(this._array.sort(util.compareByGeneratedPositionsInflated),this._sorted=!0),this._array},exports.H=MappingList;},"./node_modules/@babel/generator/node_modules/source-map/lib/quick-sort.js":(__unused_webpack_module,exports)=>{function swap(ary,x,y){var temp=ary[x];ary[x]=ary[y],ary[y]=temp;}function doQuickSort(ary,comparator,p,r){if(p<r){var i=p-1;swap(ary,(low=p,high=r,Math.round(low+Math.random()*(high-low))),r);for(var pivot=ary[r],j=p;j<r;j++)comparator(ary[j],pivot)<=0&&swap(ary,i+=1,j);swap(ary,i+1,j);var q=i+1;doQuickSort(ary,comparator,p,q-1),doQuickSort(ary,comparator,q+1,r);}var low,high;}exports.U=function(ary,comparator){doQuickSort(ary,comparator,0,ary.length-1);};},"./node_modules/@babel/generator/node_modules/source-map/lib/source-map-consumer.js":(__unused_webpack_module,exports,__webpack_require__)=>{var util=__webpack_require__("./node_modules/@babel/generator/node_modules/source-map/lib/util.js"),binarySearch=__webpack_require__("./node_modules/@babel/generator/node_modules/source-map/lib/binary-search.js"),ArraySet=__webpack_require__("./node_modules/@babel/generator/node_modules/source-map/lib/array-set.js").I,base64VLQ=__webpack_require__("./node_modules/@babel/generator/node_modules/source-map/lib/base64-vlq.js"),quickSort=__webpack_require__("./node_modules/@babel/generator/node_modules/source-map/lib/quick-sort.js").U;function SourceMapConsumer(aSourceMap){var sourceMap=aSourceMap;return "string"==typeof aSourceMap&&(sourceMap=JSON.parse(aSourceMap.replace(/^\)\]\}'/,""))),null!=sourceMap.sections?new IndexedSourceMapConsumer(sourceMap):new BasicSourceMapConsumer(sourceMap)}function BasicSourceMapConsumer(aSourceMap){var sourceMap=aSourceMap;"string"==typeof aSourceMap&&(sourceMap=JSON.parse(aSourceMap.replace(/^\)\]\}'/,"")));var version=util.getArg(sourceMap,"version"),sources=util.getArg(sourceMap,"sources"),names=util.getArg(sourceMap,"names",[]),sourceRoot=util.getArg(sourceMap,"sourceRoot",null),sourcesContent=util.getArg(sourceMap,"sourcesContent",null),mappings=util.getArg(sourceMap,"mappings"),file=util.getArg(sourceMap,"file",null);if(version!=this._version)throw new Error("Unsupported version: "+version);sources=sources.map(String).map(util.normalize).map((function(source){return sourceRoot&&util.isAbsolute(sourceRoot)&&util.isAbsolute(source)?util.relative(sourceRoot,source):source})),this._names=ArraySet.fromArray(names.map(String),!0),this._sources=ArraySet.fromArray(sources,!0),this.sourceRoot=sourceRoot,this.sourcesContent=sourcesContent,this._mappings=mappings,this.file=file;}function Mapping(){this.generatedLine=0,this.generatedColumn=0,this.source=null,this.originalLine=null,this.originalColumn=null,this.name=null;}function IndexedSourceMapConsumer(aSourceMap){var sourceMap=aSourceMap;"string"==typeof aSourceMap&&(sourceMap=JSON.parse(aSourceMap.replace(/^\)\]\}'/,"")));var version=util.getArg(sourceMap,"version"),sections=util.getArg(sourceMap,"sections");if(version!=this._version)throw new Error("Unsupported version: "+version);this._sources=new ArraySet,this._names=new ArraySet;var lastOffset={line:-1,column:0};this._sections=sections.map((function(s){if(s.url)throw new Error("Support for url field in sections not implemented.");var offset=util.getArg(s,"offset"),offsetLine=util.getArg(offset,"line"),offsetColumn=util.getArg(offset,"column");if(offsetLine<lastOffset.line||offsetLine===lastOffset.line&&offsetColumn<lastOffset.column)throw new Error("Section offsets must be ordered and non-overlapping.");return lastOffset=offset,{generatedOffset:{generatedLine:offsetLine+1,generatedColumn:offsetColumn+1},consumer:new SourceMapConsumer(util.getArg(s,"map"))}}));}SourceMapConsumer.fromSourceMap=function(aSourceMap){return BasicSourceMapConsumer.fromSourceMap(aSourceMap)},SourceMapConsumer.prototype._version=3,SourceMapConsumer.prototype.__generatedMappings=null,Object.defineProperty(SourceMapConsumer.prototype,"_generatedMappings",{get:function(){return this.__generatedMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__generatedMappings}}),SourceMapConsumer.prototype.__originalMappings=null,Object.defineProperty(SourceMapConsumer.prototype,"_originalMappings",{get:function(){return this.__originalMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__originalMappings}}),SourceMapConsumer.prototype._charIsMappingSeparator=function(aStr,index){var c=aStr.charAt(index);return ";"===c||","===c},SourceMapConsumer.prototype._parseMappings=function(aStr,aSourceRoot){throw new Error("Subclasses must implement _parseMappings")},SourceMapConsumer.GENERATED_ORDER=1,SourceMapConsumer.ORIGINAL_ORDER=2,SourceMapConsumer.GREATEST_LOWER_BOUND=1,SourceMapConsumer.LEAST_UPPER_BOUND=2,SourceMapConsumer.prototype.eachMapping=function(aCallback,aContext,aOrder){var mappings,context=aContext||null;switch(aOrder||SourceMapConsumer.GENERATED_ORDER){case SourceMapConsumer.GENERATED_ORDER:mappings=this._generatedMappings;break;case SourceMapConsumer.ORIGINAL_ORDER:mappings=this._originalMappings;break;default:throw new Error("Unknown order of iteration.")}var sourceRoot=this.sourceRoot;mappings.map((function(mapping){var source=null===mapping.source?null:this._sources.at(mapping.source);return null!=source&&null!=sourceRoot&&(source=util.join(sourceRoot,source)),{source,generatedLine:mapping.generatedLine,generatedColumn:mapping.generatedColumn,originalLine:mapping.originalLine,originalColumn:mapping.originalColumn,name:null===mapping.name?null:this._names.at(mapping.name)}}),this).forEach(aCallback,context);},SourceMapConsumer.prototype.allGeneratedPositionsFor=function(aArgs){var line=util.getArg(aArgs,"line"),needle={source:util.getArg(aArgs,"source"),originalLine:line,originalColumn:util.getArg(aArgs,"column",0)};if(null!=this.sourceRoot&&(needle.source=util.relative(this.sourceRoot,needle.source)),!this._sources.has(needle.source))return [];needle.source=this._sources.indexOf(needle.source);var mappings=[],index=this._findMapping(needle,this._originalMappings,"originalLine","originalColumn",util.compareByOriginalPositions,binarySearch.LEAST_UPPER_BOUND);if(index>=0){var mapping=this._originalMappings[index];if(void 0===aArgs.column)for(var originalLine=mapping.originalLine;mapping&&mapping.originalLine===originalLine;)mappings.push({line:util.getArg(mapping,"generatedLine",null),column:util.getArg(mapping,"generatedColumn",null),lastColumn:util.getArg(mapping,"lastGeneratedColumn",null)}),mapping=this._originalMappings[++index];else for(var originalColumn=mapping.originalColumn;mapping&&mapping.originalLine===line&&mapping.originalColumn==originalColumn;)mappings.push({line:util.getArg(mapping,"generatedLine",null),column:util.getArg(mapping,"generatedColumn",null),lastColumn:util.getArg(mapping,"lastGeneratedColumn",null)}),mapping=this._originalMappings[++index];}return mappings},exports.SourceMapConsumer=SourceMapConsumer,BasicSourceMapConsumer.prototype=Object.create(SourceMapConsumer.prototype),BasicSourceMapConsumer.prototype.consumer=SourceMapConsumer,BasicSourceMapConsumer.fromSourceMap=function(aSourceMap){var smc=Object.create(BasicSourceMapConsumer.prototype),names=smc._names=ArraySet.fromArray(aSourceMap._names.toArray(),!0),sources=smc._sources=ArraySet.fromArray(aSourceMap._sources.toArray(),!0);smc.sourceRoot=aSourceMap._sourceRoot,smc.sourcesContent=aSourceMap._generateSourcesContent(smc._sources.toArray(),smc.sourceRoot),smc.file=aSourceMap._file;for(var generatedMappings=aSourceMap._mappings.toArray().slice(),destGeneratedMappings=smc.__generatedMappings=[],destOriginalMappings=smc.__originalMappings=[],i=0,length=generatedMappings.length;i<length;i++){var srcMapping=generatedMappings[i],destMapping=new Mapping;destMapping.generatedLine=srcMapping.generatedLine,destMapping.generatedColumn=srcMapping.generatedColumn,srcMapping.source&&(destMapping.source=sources.indexOf(srcMapping.source),destMapping.originalLine=srcMapping.originalLine,destMapping.originalColumn=srcMapping.originalColumn,srcMapping.name&&(destMapping.name=names.indexOf(srcMapping.name)),destOriginalMappings.push(destMapping)),destGeneratedMappings.push(destMapping);}return quickSort(smc.__originalMappings,util.compareByOriginalPositions),smc},BasicSourceMapConsumer.prototype._version=3,Object.defineProperty(BasicSourceMapConsumer.prototype,"sources",{get:function(){return this._sources.toArray().map((function(s){return null!=this.sourceRoot?util.join(this.sourceRoot,s):s}),this)}}),BasicSourceMapConsumer.prototype._parseMappings=function(aStr,aSourceRoot){for(var mapping,str,segment,end,value,generatedLine=1,previousGeneratedColumn=0,previousOriginalLine=0,previousOriginalColumn=0,previousSource=0,previousName=0,length=aStr.length,index=0,cachedSegments={},temp={},originalMappings=[],generatedMappings=[];index<length;)if(";"===aStr.charAt(index))generatedLine++,index++,previousGeneratedColumn=0;else if(","===aStr.charAt(index))index++;else {for((mapping=new Mapping).generatedLine=generatedLine,end=index;end<length&&!this._charIsMappingSeparator(aStr,end);end++);if(segment=cachedSegments[str=aStr.slice(index,end)])index+=str.length;else {for(segment=[];index<end;)base64VLQ.decode(aStr,index,temp),value=temp.value,index=temp.rest,segment.push(value);if(2===segment.length)throw new Error("Found a source, but no line and column");if(3===segment.length)throw new Error("Found a source and line, but no column");cachedSegments[str]=segment;}mapping.generatedColumn=previousGeneratedColumn+segment[0],previousGeneratedColumn=mapping.generatedColumn,segment.length>1&&(mapping.source=previousSource+segment[1],previousSource+=segment[1],mapping.originalLine=previousOriginalLine+segment[2],previousOriginalLine=mapping.originalLine,mapping.originalLine+=1,mapping.originalColumn=previousOriginalColumn+segment[3],previousOriginalColumn=mapping.originalColumn,segment.length>4&&(mapping.name=previousName+segment[4],previousName+=segment[4])),generatedMappings.push(mapping),"number"==typeof mapping.originalLine&&originalMappings.push(mapping);}quickSort(generatedMappings,util.compareByGeneratedPositionsDeflated),this.__generatedMappings=generatedMappings,quickSort(originalMappings,util.compareByOriginalPositions),this.__originalMappings=originalMappings;},BasicSourceMapConsumer.prototype._findMapping=function(aNeedle,aMappings,aLineName,aColumnName,aComparator,aBias){if(aNeedle[aLineName]<=0)throw new TypeError("Line must be greater than or equal to 1, got "+aNeedle[aLineName]);if(aNeedle[aColumnName]<0)throw new TypeError("Column must be greater than or equal to 0, got "+aNeedle[aColumnName]);return binarySearch.search(aNeedle,aMappings,aComparator,aBias)},BasicSourceMapConsumer.prototype.computeColumnSpans=function(){for(var index=0;index<this._generatedMappings.length;++index){var mapping=this._generatedMappings[index];if(index+1<this._generatedMappings.length){var nextMapping=this._generatedMappings[index+1];if(mapping.generatedLine===nextMapping.generatedLine){mapping.lastGeneratedColumn=nextMapping.generatedColumn-1;continue}}mapping.lastGeneratedColumn=1/0;}},BasicSourceMapConsumer.prototype.originalPositionFor=function(aArgs){var needle={generatedLine:util.getArg(aArgs,"line"),generatedColumn:util.getArg(aArgs,"column")},index=this._findMapping(needle,this._generatedMappings,"generatedLine","generatedColumn",util.compareByGeneratedPositionsDeflated,util.getArg(aArgs,"bias",SourceMapConsumer.GREATEST_LOWER_BOUND));if(index>=0){var mapping=this._generatedMappings[index];if(mapping.generatedLine===needle.generatedLine){var source=util.getArg(mapping,"source",null);null!==source&&(source=this._sources.at(source),null!=this.sourceRoot&&(source=util.join(this.sourceRoot,source)));var name=util.getArg(mapping,"name",null);return null!==name&&(name=this._names.at(name)),{source,line:util.getArg(mapping,"originalLine",null),column:util.getArg(mapping,"originalColumn",null),name}}}return {source:null,line:null,column:null,name:null}},BasicSourceMapConsumer.prototype.hasContentsOfAllSources=function(){return !!this.sourcesContent&&(this.sourcesContent.length>=this._sources.size()&&!this.sourcesContent.some((function(sc){return null==sc})))},BasicSourceMapConsumer.prototype.sourceContentFor=function(aSource,nullOnMissing){if(!this.sourcesContent)return null;if(null!=this.sourceRoot&&(aSource=util.relative(this.sourceRoot,aSource)),this._sources.has(aSource))return this.sourcesContent[this._sources.indexOf(aSource)];var url;if(null!=this.sourceRoot&&(url=util.urlParse(this.sourceRoot))){var fileUriAbsPath=aSource.replace(/^file:\/\//,"");if("file"==url.scheme&&this._sources.has(fileUriAbsPath))return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];if((!url.path||"/"==url.path)&&this._sources.has("/"+aSource))return this.sourcesContent[this._sources.indexOf("/"+aSource)]}if(nullOnMissing)return null;throw new Error('"'+aSource+'" is not in the SourceMap.')},BasicSourceMapConsumer.prototype.generatedPositionFor=function(aArgs){var source=util.getArg(aArgs,"source");if(null!=this.sourceRoot&&(source=util.relative(this.sourceRoot,source)),!this._sources.has(source))return {line:null,column:null,lastColumn:null};var needle={source:source=this._sources.indexOf(source),originalLine:util.getArg(aArgs,"line"),originalColumn:util.getArg(aArgs,"column")},index=this._findMapping(needle,this._originalMappings,"originalLine","originalColumn",util.compareByOriginalPositions,util.getArg(aArgs,"bias",SourceMapConsumer.GREATEST_LOWER_BOUND));if(index>=0){var mapping=this._originalMappings[index];if(mapping.source===needle.source)return {line:util.getArg(mapping,"generatedLine",null),column:util.getArg(mapping,"generatedColumn",null),lastColumn:util.getArg(mapping,"lastGeneratedColumn",null)}}return {line:null,column:null,lastColumn:null}},IndexedSourceMapConsumer.prototype=Object.create(SourceMapConsumer.prototype),IndexedSourceMapConsumer.prototype.constructor=SourceMapConsumer,IndexedSourceMapConsumer.prototype._version=3,Object.defineProperty(IndexedSourceMapConsumer.prototype,"sources",{get:function(){for(var sources=[],i=0;i<this._sections.length;i++)for(var j=0;j<this._sections[i].consumer.sources.length;j++)sources.push(this._sections[i].consumer.sources[j]);return sources}}),IndexedSourceMapConsumer.prototype.originalPositionFor=function(aArgs){var needle={generatedLine:util.getArg(aArgs,"line"),generatedColumn:util.getArg(aArgs,"column")},sectionIndex=binarySearch.search(needle,this._sections,(function(needle,section){var cmp=needle.generatedLine-section.generatedOffset.generatedLine;return cmp||needle.generatedColumn-section.generatedOffset.generatedColumn})),section=this._sections[sectionIndex];return section?section.consumer.originalPositionFor({line:needle.generatedLine-(section.generatedOffset.generatedLine-1),column:needle.generatedColumn-(section.generatedOffset.generatedLine===needle.generatedLine?section.generatedOffset.generatedColumn-1:0),bias:aArgs.bias}):{source:null,line:null,column:null,name:null}},IndexedSourceMapConsumer.prototype.hasContentsOfAllSources=function(){return this._sections.every((function(s){return s.consumer.hasContentsOfAllSources()}))},IndexedSourceMapConsumer.prototype.sourceContentFor=function(aSource,nullOnMissing){for(var i=0;i<this._sections.length;i++){var content=this._sections[i].consumer.sourceContentFor(aSource,!0);if(content)return content}if(nullOnMissing)return null;throw new Error('"'+aSource+'" is not in the SourceMap.')},IndexedSourceMapConsumer.prototype.generatedPositionFor=function(aArgs){for(var i=0;i<this._sections.length;i++){var section=this._sections[i];if(-1!==section.consumer.sources.indexOf(util.getArg(aArgs,"source"))){var generatedPosition=section.consumer.generatedPositionFor(aArgs);if(generatedPosition)return {line:generatedPosition.line+(section.generatedOffset.generatedLine-1),column:generatedPosition.column+(section.generatedOffset.generatedLine===generatedPosition.line?section.generatedOffset.generatedColumn-1:0)}}}return {line:null,column:null}},IndexedSourceMapConsumer.prototype._parseMappings=function(aStr,aSourceRoot){this.__generatedMappings=[],this.__originalMappings=[];for(var i=0;i<this._sections.length;i++)for(var section=this._sections[i],sectionMappings=section.consumer._generatedMappings,j=0;j<sectionMappings.length;j++){var mapping=sectionMappings[j],source=section.consumer._sources.at(mapping.source);null!==section.consumer.sourceRoot&&(source=util.join(section.consumer.sourceRoot,source)),this._sources.add(source),source=this._sources.indexOf(source);var name=section.consumer._names.at(mapping.name);this._names.add(name),name=this._names.indexOf(name);var adjustedMapping={source,generatedLine:mapping.generatedLine+(section.generatedOffset.generatedLine-1),generatedColumn:mapping.generatedColumn+(section.generatedOffset.generatedLine===mapping.generatedLine?section.generatedOffset.generatedColumn-1:0),originalLine:mapping.originalLine,originalColumn:mapping.originalColumn,name};this.__generatedMappings.push(adjustedMapping),"number"==typeof adjustedMapping.originalLine&&this.__originalMappings.push(adjustedMapping);}quickSort(this.__generatedMappings,util.compareByGeneratedPositionsDeflated),quickSort(this.__originalMappings,util.compareByOriginalPositions);};},"./node_modules/@babel/generator/node_modules/source-map/lib/source-map-generator.js":(__unused_webpack_module,exports,__webpack_require__)=>{var base64VLQ=__webpack_require__("./node_modules/@babel/generator/node_modules/source-map/lib/base64-vlq.js"),util=__webpack_require__("./node_modules/@babel/generator/node_modules/source-map/lib/util.js"),ArraySet=__webpack_require__("./node_modules/@babel/generator/node_modules/source-map/lib/array-set.js").I,MappingList=__webpack_require__("./node_modules/@babel/generator/node_modules/source-map/lib/mapping-list.js").H;function SourceMapGenerator(aArgs){aArgs||(aArgs={}),this._file=util.getArg(aArgs,"file",null),this._sourceRoot=util.getArg(aArgs,"sourceRoot",null),this._skipValidation=util.getArg(aArgs,"skipValidation",!1),this._sources=new ArraySet,this._names=new ArraySet,this._mappings=new MappingList,this._sourcesContents=null;}SourceMapGenerator.prototype._version=3,SourceMapGenerator.fromSourceMap=function(aSourceMapConsumer){var sourceRoot=aSourceMapConsumer.sourceRoot,generator=new SourceMapGenerator({file:aSourceMapConsumer.file,sourceRoot});return aSourceMapConsumer.eachMapping((function(mapping){var newMapping={generated:{line:mapping.generatedLine,column:mapping.generatedColumn}};null!=mapping.source&&(newMapping.source=mapping.source,null!=sourceRoot&&(newMapping.source=util.relative(sourceRoot,newMapping.source)),newMapping.original={line:mapping.originalLine,column:mapping.originalColumn},null!=mapping.name&&(newMapping.name=mapping.name)),generator.addMapping(newMapping);})),aSourceMapConsumer.sources.forEach((function(sourceFile){var content=aSourceMapConsumer.sourceContentFor(sourceFile);null!=content&&generator.setSourceContent(sourceFile,content);})),generator},SourceMapGenerator.prototype.addMapping=function(aArgs){var generated=util.getArg(aArgs,"generated"),original=util.getArg(aArgs,"original",null),source=util.getArg(aArgs,"source",null),name=util.getArg(aArgs,"name",null);this._skipValidation||this._validateMapping(generated,original,source,name),null!=source&&(source=String(source),this._sources.has(source)||this._sources.add(source)),null!=name&&(name=String(name),this._names.has(name)||this._names.add(name)),this._mappings.add({generatedLine:generated.line,generatedColumn:generated.column,originalLine:null!=original&&original.line,originalColumn:null!=original&&original.column,source,name});},SourceMapGenerator.prototype.setSourceContent=function(aSourceFile,aSourceContent){var source=aSourceFile;null!=this._sourceRoot&&(source=util.relative(this._sourceRoot,source)),null!=aSourceContent?(this._sourcesContents||(this._sourcesContents=Object.create(null)),this._sourcesContents[util.toSetString(source)]=aSourceContent):this._sourcesContents&&(delete this._sourcesContents[util.toSetString(source)],0===Object.keys(this._sourcesContents).length&&(this._sourcesContents=null));},SourceMapGenerator.prototype.applySourceMap=function(aSourceMapConsumer,aSourceFile,aSourceMapPath){var sourceFile=aSourceFile;if(null==aSourceFile){if(null==aSourceMapConsumer.file)throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');sourceFile=aSourceMapConsumer.file;}var sourceRoot=this._sourceRoot;null!=sourceRoot&&(sourceFile=util.relative(sourceRoot,sourceFile));var newSources=new ArraySet,newNames=new ArraySet;this._mappings.unsortedForEach((function(mapping){if(mapping.source===sourceFile&&null!=mapping.originalLine){var original=aSourceMapConsumer.originalPositionFor({line:mapping.originalLine,column:mapping.originalColumn});null!=original.source&&(mapping.source=original.source,null!=aSourceMapPath&&(mapping.source=util.join(aSourceMapPath,mapping.source)),null!=sourceRoot&&(mapping.source=util.relative(sourceRoot,mapping.source)),mapping.originalLine=original.line,mapping.originalColumn=original.column,null!=original.name&&(mapping.name=original.name));}var source=mapping.source;null==source||newSources.has(source)||newSources.add(source);var name=mapping.name;null==name||newNames.has(name)||newNames.add(name);}),this),this._sources=newSources,this._names=newNames,aSourceMapConsumer.sources.forEach((function(sourceFile){var content=aSourceMapConsumer.sourceContentFor(sourceFile);null!=content&&(null!=aSourceMapPath&&(sourceFile=util.join(aSourceMapPath,sourceFile)),null!=sourceRoot&&(sourceFile=util.relative(sourceRoot,sourceFile)),this.setSourceContent(sourceFile,content));}),this);},SourceMapGenerator.prototype._validateMapping=function(aGenerated,aOriginal,aSource,aName){if(aOriginal&&"number"!=typeof aOriginal.line&&"number"!=typeof aOriginal.column)throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");if((!(aGenerated&&"line"in aGenerated&&"column"in aGenerated&&aGenerated.line>0&&aGenerated.column>=0)||aOriginal||aSource||aName)&&!(aGenerated&&"line"in aGenerated&&"column"in aGenerated&&aOriginal&&"line"in aOriginal&&"column"in aOriginal&&aGenerated.line>0&&aGenerated.column>=0&&aOriginal.line>0&&aOriginal.column>=0&&aSource))throw new Error("Invalid mapping: "+JSON.stringify({generated:aGenerated,source:aSource,original:aOriginal,name:aName}))},SourceMapGenerator.prototype._serializeMappings=function(){for(var next,mapping,nameIdx,sourceIdx,previousGeneratedColumn=0,previousGeneratedLine=1,previousOriginalColumn=0,previousOriginalLine=0,previousName=0,previousSource=0,result="",mappings=this._mappings.toArray(),i=0,len=mappings.length;i<len;i++){if(next="",(mapping=mappings[i]).generatedLine!==previousGeneratedLine)for(previousGeneratedColumn=0;mapping.generatedLine!==previousGeneratedLine;)next+=";",previousGeneratedLine++;else if(i>0){if(!util.compareByGeneratedPositionsInflated(mapping,mappings[i-1]))continue;next+=",";}next+=base64VLQ.encode(mapping.generatedColumn-previousGeneratedColumn),previousGeneratedColumn=mapping.generatedColumn,null!=mapping.source&&(sourceIdx=this._sources.indexOf(mapping.source),next+=base64VLQ.encode(sourceIdx-previousSource),previousSource=sourceIdx,next+=base64VLQ.encode(mapping.originalLine-1-previousOriginalLine),previousOriginalLine=mapping.originalLine-1,next+=base64VLQ.encode(mapping.originalColumn-previousOriginalColumn),previousOriginalColumn=mapping.originalColumn,null!=mapping.name&&(nameIdx=this._names.indexOf(mapping.name),next+=base64VLQ.encode(nameIdx-previousName),previousName=nameIdx)),result+=next;}return result},SourceMapGenerator.prototype._generateSourcesContent=function(aSources,aSourceRoot){return aSources.map((function(source){if(!this._sourcesContents)return null;null!=aSourceRoot&&(source=util.relative(aSourceRoot,source));var key=util.toSetString(source);return Object.prototype.hasOwnProperty.call(this._sourcesContents,key)?this._sourcesContents[key]:null}),this)},SourceMapGenerator.prototype.toJSON=function(){var map={version:this._version,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};return null!=this._file&&(map.file=this._file),null!=this._sourceRoot&&(map.sourceRoot=this._sourceRoot),this._sourcesContents&&(map.sourcesContent=this._generateSourcesContent(map.sources,map.sourceRoot)),map},SourceMapGenerator.prototype.toString=function(){return JSON.stringify(this.toJSON())},exports.SourceMapGenerator=SourceMapGenerator;},"./node_modules/@babel/generator/node_modules/source-map/lib/source-node.js":(__unused_webpack_module,exports,__webpack_require__)=>{var SourceMapGenerator=__webpack_require__("./node_modules/@babel/generator/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator,util=__webpack_require__("./node_modules/@babel/generator/node_modules/source-map/lib/util.js"),REGEX_NEWLINE=/(\r?\n)/,isSourceNode="$$$isSourceNode$$$";function SourceNode(aLine,aColumn,aSource,aChunks,aName){this.children=[],this.sourceContents={},this.line=null==aLine?null:aLine,this.column=null==aColumn?null:aColumn,this.source=null==aSource?null:aSource,this.name=null==aName?null:aName,this[isSourceNode]=!0,null!=aChunks&&this.add(aChunks);}SourceNode.fromStringWithSourceMap=function(aGeneratedCode,aSourceMapConsumer,aRelativePath){var node=new SourceNode,remainingLines=aGeneratedCode.split(REGEX_NEWLINE),remainingLinesIndex=0,shiftNextLine=function(){return getNextLine()+(getNextLine()||"");function getNextLine(){return remainingLinesIndex<remainingLines.length?remainingLines[remainingLinesIndex++]:void 0}},lastGeneratedLine=1,lastGeneratedColumn=0,lastMapping=null;return aSourceMapConsumer.eachMapping((function(mapping){if(null!==lastMapping){if(!(lastGeneratedLine<mapping.generatedLine)){var code=(nextLine=remainingLines[remainingLinesIndex]).substr(0,mapping.generatedColumn-lastGeneratedColumn);return remainingLines[remainingLinesIndex]=nextLine.substr(mapping.generatedColumn-lastGeneratedColumn),lastGeneratedColumn=mapping.generatedColumn,addMappingWithCode(lastMapping,code),void(lastMapping=mapping)}addMappingWithCode(lastMapping,shiftNextLine()),lastGeneratedLine++,lastGeneratedColumn=0;}for(;lastGeneratedLine<mapping.generatedLine;)node.add(shiftNextLine()),lastGeneratedLine++;if(lastGeneratedColumn<mapping.generatedColumn){var nextLine=remainingLines[remainingLinesIndex];node.add(nextLine.substr(0,mapping.generatedColumn)),remainingLines[remainingLinesIndex]=nextLine.substr(mapping.generatedColumn),lastGeneratedColumn=mapping.generatedColumn;}lastMapping=mapping;}),this),remainingLinesIndex<remainingLines.length&&(lastMapping&&addMappingWithCode(lastMapping,shiftNextLine()),node.add(remainingLines.splice(remainingLinesIndex).join(""))),aSourceMapConsumer.sources.forEach((function(sourceFile){var content=aSourceMapConsumer.sourceContentFor(sourceFile);null!=content&&(null!=aRelativePath&&(sourceFile=util.join(aRelativePath,sourceFile)),node.setSourceContent(sourceFile,content));})),node;function addMappingWithCode(mapping,code){if(null===mapping||void 0===mapping.source)node.add(code);else {var source=aRelativePath?util.join(aRelativePath,mapping.source):mapping.source;node.add(new SourceNode(mapping.originalLine,mapping.originalColumn,source,code,mapping.name));}}},SourceNode.prototype.add=function(aChunk){if(Array.isArray(aChunk))aChunk.forEach((function(chunk){this.add(chunk);}),this);else {if(!aChunk[isSourceNode]&&"string"!=typeof aChunk)throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+aChunk);aChunk&&this.children.push(aChunk);}return this},SourceNode.prototype.prepend=function(aChunk){if(Array.isArray(aChunk))for(var i=aChunk.length-1;i>=0;i--)this.prepend(aChunk[i]);else {if(!aChunk[isSourceNode]&&"string"!=typeof aChunk)throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+aChunk);this.children.unshift(aChunk);}return this},SourceNode.prototype.walk=function(aFn){for(var chunk,i=0,len=this.children.length;i<len;i++)(chunk=this.children[i])[isSourceNode]?chunk.walk(aFn):""!==chunk&&aFn(chunk,{source:this.source,line:this.line,column:this.column,name:this.name});},SourceNode.prototype.join=function(aSep){var newChildren,i,len=this.children.length;if(len>0){for(newChildren=[],i=0;i<len-1;i++)newChildren.push(this.children[i]),newChildren.push(aSep);newChildren.push(this.children[i]),this.children=newChildren;}return this},SourceNode.prototype.replaceRight=function(aPattern,aReplacement){var lastChild=this.children[this.children.length-1];return lastChild[isSourceNode]?lastChild.replaceRight(aPattern,aReplacement):"string"==typeof lastChild?this.children[this.children.length-1]=lastChild.replace(aPattern,aReplacement):this.children.push("".replace(aPattern,aReplacement)),this},SourceNode.prototype.setSourceContent=function(aSourceFile,aSourceContent){this.sourceContents[util.toSetString(aSourceFile)]=aSourceContent;},SourceNode.prototype.walkSourceContents=function(aFn){for(var i=0,len=this.children.length;i<len;i++)this.children[i][isSourceNode]&&this.children[i].walkSourceContents(aFn);var sources=Object.keys(this.sourceContents);for(i=0,len=sources.length;i<len;i++)aFn(util.fromSetString(sources[i]),this.sourceContents[sources[i]]);},SourceNode.prototype.toString=function(){var str="";return this.walk((function(chunk){str+=chunk;})),str},SourceNode.prototype.toStringWithSourceMap=function(aArgs){var generated={code:"",line:1,column:0},map=new SourceMapGenerator(aArgs),sourceMappingActive=!1,lastOriginalSource=null,lastOriginalLine=null,lastOriginalColumn=null,lastOriginalName=null;return this.walk((function(chunk,original){generated.code+=chunk,null!==original.source&&null!==original.line&&null!==original.column?(lastOriginalSource===original.source&&lastOriginalLine===original.line&&lastOriginalColumn===original.column&&lastOriginalName===original.name||map.addMapping({source:original.source,original:{line:original.line,column:original.column},generated:{line:generated.line,column:generated.column},name:original.name}),lastOriginalSource=original.source,lastOriginalLine=original.line,lastOriginalColumn=original.column,lastOriginalName=original.name,sourceMappingActive=!0):sourceMappingActive&&(map.addMapping({generated:{line:generated.line,column:generated.column}}),lastOriginalSource=null,sourceMappingActive=!1);for(var idx=0,length=chunk.length;idx<length;idx++)10===chunk.charCodeAt(idx)?(generated.line++,generated.column=0,idx+1===length?(lastOriginalSource=null,sourceMappingActive=!1):sourceMappingActive&&map.addMapping({source:original.source,original:{line:original.line,column:original.column},generated:{line:generated.line,column:generated.column},name:original.name})):generated.column++;})),this.walkSourceContents((function(sourceFile,sourceContent){map.setSourceContent(sourceFile,sourceContent);})),{code:generated.code,map}},exports.SourceNode=SourceNode;},"./node_modules/@babel/generator/node_modules/source-map/lib/util.js":(__unused_webpack_module,exports)=>{exports.getArg=function(aArgs,aName,aDefaultValue){if(aName in aArgs)return aArgs[aName];if(3===arguments.length)return aDefaultValue;throw new Error('"'+aName+'" is a required argument.')};var urlRegexp=/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/,dataUrlRegexp=/^data:.+\,.+$/;function urlParse(aUrl){var match=aUrl.match(urlRegexp);return match?{scheme:match[1],auth:match[2],host:match[3],port:match[4],path:match[5]}:null}function urlGenerate(aParsedUrl){var url="";return aParsedUrl.scheme&&(url+=aParsedUrl.scheme+":"),url+="//",aParsedUrl.auth&&(url+=aParsedUrl.auth+"@"),aParsedUrl.host&&(url+=aParsedUrl.host),aParsedUrl.port&&(url+=":"+aParsedUrl.port),aParsedUrl.path&&(url+=aParsedUrl.path),url}function normalize(aPath){var path=aPath,url=urlParse(aPath);if(url){if(!url.path)return aPath;path=url.path;}for(var part,isAbsolute=exports.isAbsolute(path),parts=path.split(/\/+/),up=0,i=parts.length-1;i>=0;i--)"."===(part=parts[i])?parts.splice(i,1):".."===part?up++:up>0&&(""===part?(parts.splice(i+1,up),up=0):(parts.splice(i,2),up--));return ""===(path=parts.join("/"))&&(path=isAbsolute?"/":"."),url?(url.path=path,urlGenerate(url)):path}exports.urlParse=urlParse,exports.urlGenerate=urlGenerate,exports.normalize=normalize,exports.join=function(aRoot,aPath){""===aRoot&&(aRoot="."),""===aPath&&(aPath=".");var aPathUrl=urlParse(aPath),aRootUrl=urlParse(aRoot);if(aRootUrl&&(aRoot=aRootUrl.path||"/"),aPathUrl&&!aPathUrl.scheme)return aRootUrl&&(aPathUrl.scheme=aRootUrl.scheme),urlGenerate(aPathUrl);if(aPathUrl||aPath.match(dataUrlRegexp))return aPath;if(aRootUrl&&!aRootUrl.host&&!aRootUrl.path)return aRootUrl.host=aPath,urlGenerate(aRootUrl);var joined="/"===aPath.charAt(0)?aPath:normalize(aRoot.replace(/\/+$/,"")+"/"+aPath);return aRootUrl?(aRootUrl.path=joined,urlGenerate(aRootUrl)):joined},exports.isAbsolute=function(aPath){return "/"===aPath.charAt(0)||!!aPath.match(urlRegexp)},exports.relative=function(aRoot,aPath){""===aRoot&&(aRoot="."),aRoot=aRoot.replace(/\/$/,"");for(var level=0;0!==aPath.indexOf(aRoot+"/");){var index=aRoot.lastIndexOf("/");if(index<0)return aPath;if((aRoot=aRoot.slice(0,index)).match(/^([^\/]+:\/)?\/*$/))return aPath;++level;}return Array(level+1).join("../")+aPath.substr(aRoot.length+1)};var supportsNullProto=!("__proto__"in Object.create(null));function identity(s){return s}function isProtoString(s){if(!s)return !1;var length=s.length;if(length<9)return !1;if(95!==s.charCodeAt(length-1)||95!==s.charCodeAt(length-2)||111!==s.charCodeAt(length-3)||116!==s.charCodeAt(length-4)||111!==s.charCodeAt(length-5)||114!==s.charCodeAt(length-6)||112!==s.charCodeAt(length-7)||95!==s.charCodeAt(length-8)||95!==s.charCodeAt(length-9))return !1;for(var i=length-10;i>=0;i--)if(36!==s.charCodeAt(i))return !1;return !0}function strcmp(aStr1,aStr2){return aStr1===aStr2?0:aStr1>aStr2?1:-1}exports.toSetString=supportsNullProto?identity:function(aStr){return isProtoString(aStr)?"$"+aStr:aStr},exports.fromSetString=supportsNullProto?identity:function(aStr){return isProtoString(aStr)?aStr.slice(1):aStr},exports.compareByOriginalPositions=function(mappingA,mappingB,onlyCompareOriginal){var cmp=mappingA.source-mappingB.source;return 0!==cmp||0!==(cmp=mappingA.originalLine-mappingB.originalLine)||0!==(cmp=mappingA.originalColumn-mappingB.originalColumn)||onlyCompareOriginal||0!==(cmp=mappingA.generatedColumn-mappingB.generatedColumn)||0!==(cmp=mappingA.generatedLine-mappingB.generatedLine)?cmp:mappingA.name-mappingB.name},exports.compareByGeneratedPositionsDeflated=function(mappingA,mappingB,onlyCompareGenerated){var cmp=mappingA.generatedLine-mappingB.generatedLine;return 0!==cmp||0!==(cmp=mappingA.generatedColumn-mappingB.generatedColumn)||onlyCompareGenerated||0!==(cmp=mappingA.source-mappingB.source)||0!==(cmp=mappingA.originalLine-mappingB.originalLine)||0!==(cmp=mappingA.originalColumn-mappingB.originalColumn)?cmp:mappingA.name-mappingB.name},exports.compareByGeneratedPositionsInflated=function(mappingA,mappingB){var cmp=mappingA.generatedLine-mappingB.generatedLine;return 0!==cmp||0!==(cmp=mappingA.generatedColumn-mappingB.generatedColumn)||0!==(cmp=strcmp(mappingA.source,mappingB.source))||0!==(cmp=mappingA.originalLine-mappingB.originalLine)||0!==(cmp=mappingA.originalColumn-mappingB.originalColumn)?cmp:strcmp(mappingA.name,mappingB.name)};},"./node_modules/@babel/generator/node_modules/source-map/source-map.js":(__unused_webpack_module,exports,__webpack_require__)=>{exports.SourceMapGenerator=__webpack_require__("./node_modules/@babel/generator/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator,exports.SourceMapConsumer=__webpack_require__("./node_modules/@babel/generator/node_modules/source-map/lib/source-map-consumer.js").SourceMapConsumer,exports.SourceNode=__webpack_require__("./node_modules/@babel/generator/node_modules/source-map/lib/source-node.js").SourceNode;},"./node_modules/@babel/helper-annotate-as-pure/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(pathOrNode){const node=pathOrNode.node||pathOrNode;if((({leadingComments})=>!!leadingComments&&leadingComments.some((comment=>/[@#]__PURE__/.test(comment.value))))(node))return;addComment(node,"leading","#__PURE__");};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{addComment}=_t;},"./node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.buildDecoratedClass=function(ref,path,elements,file){const{node,scope}=path,initializeId=scope.generateUidIdentifier("initialize"),isDeclaration=node.id&&path.isDeclaration(),isStrict=path.isInStrictMode(),{superClass}=node;node.type="ClassDeclaration",node.id||(node.id=_core.types.cloneNode(ref));let superId;superClass&&(superId=scope.generateUidIdentifierBasedOnNode(node.superClass,"super"),node.superClass=superId);const classDecorators=takeDecorators(node),definitions=_core.types.arrayExpression(elements.filter((element=>!element.node.abstract)).map(extractElementDescriptor.bind(file,node.id,superId))),wrapperCall=_core.template.expression.ast`
    ${function(file){try{return file.addHelper("decorate")}catch(err){throw "BABEL_HELPER_UNKNOWN"===err.code&&(err.message+="\n  '@babel/plugin-transform-decorators' in non-legacy mode requires '@babel/core' version ^7.0.2 and you appear to be using an older version."),err}}(file)}(
      ${classDecorators||_core.types.nullLiteral()},
      function (${initializeId}, ${superClass?_core.types.cloneNode(superId):null}) {
        ${node}
        return { F: ${_core.types.cloneNode(node.id)}, d: ${definitions} };
      },
      ${superClass}
    )
  `;isStrict||wrapperCall.arguments[1].body.directives.push(_core.types.directive(_core.types.directiveLiteral("use strict")));let replacement=wrapperCall,classPathDesc="arguments.1.body.body.0";isDeclaration&&(replacement=_core.template.statement.ast`let ${ref} = ${wrapperCall}`,classPathDesc="declarations.0.init."+classPathDesc);return {instanceNodes:[_core.template.statement.ast`${_core.types.cloneNode(initializeId)}(this)`],wrapClass:path=>(path.replaceWith(replacement),path.get(classPathDesc))}},exports.hasDecorators=function(node){return hasOwnDecorators(node)||node.body.body.some(hasOwnDecorators)},exports.hasOwnDecorators=hasOwnDecorators;var _core=__webpack_require__("./node_modules/@babel/core/lib/index.js"),_helperReplaceSupers=__webpack_require__("./node_modules/@babel/helper-replace-supers/lib/index.js"),_helperFunctionName=__webpack_require__("./node_modules/@babel/helper-function-name/lib/index.js");function hasOwnDecorators(node){return !(!node.decorators||!node.decorators.length)}function prop(key,value){return value?_core.types.objectProperty(_core.types.identifier(key),value):null}function takeDecorators(node){let result;return node.decorators&&node.decorators.length>0&&(result=_core.types.arrayExpression(node.decorators.map((decorator=>decorator.expression)))),node.decorators=void 0,result}function getKey(node){return node.computed?node.key:_core.types.isIdentifier(node.key)?_core.types.stringLiteral(node.key.name):_core.types.stringLiteral(String(node.key.value))}function extractElementDescriptor(classRef,superRef,path){const{node,scope}=path,isMethod=path.isClassMethod();if(path.isPrivate())throw path.buildCodeFrameError(`Private ${isMethod?"methods":"fields"} in decorated classes are not supported yet.`);new _helperReplaceSupers.default({methodPath:path,objectRef:classRef,superRef,file:this,refToPreserve:classRef}).replace();const properties=[prop("kind",_core.types.stringLiteral(_core.types.isClassMethod(node)?node.kind:"field")),prop("decorators",takeDecorators(node)),prop("static",node.static&&_core.types.booleanLiteral(!0)),prop("key",getKey(node))].filter(Boolean);if(_core.types.isClassMethod(node)){const id=node.computed?null:node.key;_core.types.toExpression(node),properties.push(prop("value",(0, _helperFunctionName.default)({node,id,scope})||node));}else _core.types.isClassProperty(node)&&node.value?properties.push((key="value",body=_core.template.statements.ast`return ${node.value}`,_core.types.objectMethod("method",_core.types.identifier(key),[],_core.types.blockStatement(body)))):properties.push(prop("value",scope.buildUndefinedNode()));var key,body;return path.remove(),_core.types.objectExpression(properties)}},"./node_modules/@babel/helper-create-class-features-plugin/lib/features.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.FEATURES=void 0,exports.enableFeature=function(file,feature,loose){hasFeature(file,feature)&&!canIgnoreLoose(file,feature)||(file.set(featuresKey,file.get(featuresKey)|feature),"#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error"===loose?(setLoose(file,feature,!0),file.set(looseLowPriorityKey,file.get(looseLowPriorityKey)|feature)):"#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error"===loose?(setLoose(file,feature,!1),file.set(looseLowPriorityKey,file.get(looseLowPriorityKey)|feature)):setLoose(file,feature,loose));let resolvedLoose,higherPriorityPluginName;for(const[mask,name]of featuresSameLoose){if(!hasFeature(file,mask))continue;const loose=isLoose(file,mask);if(!canIgnoreLoose(file,mask)){if(resolvedLoose===!loose)throw new Error("'loose' mode configuration must be the same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods and @babel/plugin-proposal-private-property-in-object (when they are enabled).");resolvedLoose=loose,higherPriorityPluginName=name;}}if(void 0!==resolvedLoose)for(const[mask,name]of featuresSameLoose)hasFeature(file,mask)&&isLoose(file,mask)!==resolvedLoose&&(setLoose(file,mask,resolvedLoose),console.warn(`Though the "loose" option was set to "${!resolvedLoose}" in your @babel/preset-env config, it will not be used for ${name} since the "loose" mode option was set to "${resolvedLoose}" for ${higherPriorityPluginName}.\nThe "loose" option must be the same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods and @babel/plugin-proposal-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding\n\t["${name}", { "loose": ${resolvedLoose} }]\nto the "plugins" section of your Babel config.`));},exports.isLoose=isLoose,exports.shouldTransform=function(path,file){let decoratorPath=null,publicFieldPath=null,privateFieldPath=null,privateMethodPath=null,staticBlockPath=null;(0, _decorators.hasOwnDecorators)(path.node)&&(decoratorPath=path.get("decorators.0"));for(const el of path.get("body.body"))!decoratorPath&&(0, _decorators.hasOwnDecorators)(el.node)&&(decoratorPath=el.get("decorators.0")),!publicFieldPath&&el.isClassProperty()&&(publicFieldPath=el),!privateFieldPath&&el.isClassPrivateProperty()&&(privateFieldPath=el),!privateMethodPath&&null!=el.isClassPrivateMethod&&el.isClassPrivateMethod()&&(privateMethodPath=el),!staticBlockPath&&null!=el.isStaticBlock&&el.isStaticBlock()&&(staticBlockPath=el);if(decoratorPath&&privateFieldPath)throw privateFieldPath.buildCodeFrameError("Private fields in decorated classes are not supported yet.");if(decoratorPath&&privateMethodPath)throw privateMethodPath.buildCodeFrameError("Private methods in decorated classes are not supported yet.");if(decoratorPath&&!hasFeature(file,FEATURES.decorators))throw path.buildCodeFrameError('Decorators are not enabled.\nIf you are using ["@babel/plugin-proposal-decorators", { "legacy": true }], make sure it comes *before* "@babel/plugin-proposal-class-properties" and enable loose mode, like so:\n\t["@babel/plugin-proposal-decorators", { "legacy": true }]\n\t["@babel/plugin-proposal-class-properties", { "loose": true }]');if(privateMethodPath&&!hasFeature(file,FEATURES.privateMethods))throw privateMethodPath.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-proposal-private-method` to your configuration.");if((publicFieldPath||privateFieldPath)&&!hasFeature(file,FEATURES.fields)&&!hasFeature(file,FEATURES.privateMethods))throw path.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-proposal-class-properties` to your configuration.");if(staticBlockPath&&!hasFeature(file,FEATURES.staticBlocks))throw path.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-proposal-class-static-block` to your configuration.");if(decoratorPath||privateMethodPath||staticBlockPath)return !0;if((publicFieldPath||privateFieldPath)&&hasFeature(file,FEATURES.fields))return !0;return !1};var _decorators=__webpack_require__("./node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js");const FEATURES=Object.freeze({fields:2,privateMethods:4,decorators:8,privateIn:16,staticBlocks:32});exports.FEATURES=FEATURES;const featuresSameLoose=new Map([[FEATURES.fields,"@babel/plugin-proposal-class-properties"],[FEATURES.privateMethods,"@babel/plugin-proposal-private-methods"],[FEATURES.privateIn,"@babel/plugin-proposal-private-property-in-object"]]),featuresKey="@babel/plugin-class-features/featuresKey",looseKey="@babel/plugin-class-features/looseKey",looseLowPriorityKey="@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";function hasFeature(file,feature){return !!(file.get(featuresKey)&feature)}function isLoose(file,feature){return !!(file.get(looseKey)&feature)}function setLoose(file,feature,loose){loose?file.set(looseKey,file.get(looseKey)|feature):file.set(looseKey,file.get(looseKey)&~feature),file.set(looseLowPriorityKey,file.get(looseLowPriorityKey)&~feature);}function canIgnoreLoose(file,feature){return !!(file.get(looseLowPriorityKey)&feature)}},"./node_modules/@babel/helper-create-class-features-plugin/lib/fields.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.buildFieldsInitNodes=function(ref,superRef,props,privateNamesMap,state,setPublicClassFields,privateFieldsAsProperties,constantSuper,innerBindingRef){let injectSuperRef,needsClassRef=!1;const staticNodes=[],instanceNodes=[],pureStaticNodes=[],getSuperRef=_core.types.isIdentifier(superRef)?()=>superRef:()=>(null!=injectSuperRef||(injectSuperRef=props[0].scope.generateUidIdentifierBasedOnNode(superRef)),injectSuperRef);for(const prop of props){prop.isClassProperty()&&ts.assertFieldTransformed(prop);const isStatic=prop.node.static,isInstance=!isStatic,isPrivate=prop.isPrivate(),isPublic=!isPrivate,isField=prop.isProperty(),isMethod=!isField,isStaticBlock=null==prop.isStaticBlock?void 0:prop.isStaticBlock();if(isStatic||isMethod&&isPrivate||isStaticBlock){const replaced=replaceThisContext(prop,ref,getSuperRef,state,isStaticBlock,constantSuper,innerBindingRef);needsClassRef=needsClassRef||replaced;}switch(!0){case isStaticBlock:staticNodes.push(_core.template.statement.ast`(() => ${_core.types.blockStatement(prop.node.body)})()`);break;case isStatic&&isPrivate&&isField&&privateFieldsAsProperties:needsClassRef=!0,staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref),prop,privateNamesMap));break;case isStatic&&isPrivate&&isField&&!privateFieldsAsProperties:needsClassRef=!0,staticNodes.push(buildPrivateStaticFieldInitSpec(prop,privateNamesMap));break;case isStatic&&isPublic&&isField&&setPublicClassFields:needsClassRef=!0,staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref),prop));break;case isStatic&&isPublic&&isField&&!setPublicClassFields:needsClassRef=!0,staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref),prop,state));break;case isInstance&&isPrivate&&isField&&privateFieldsAsProperties:instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(),prop,privateNamesMap));break;case isInstance&&isPrivate&&isField&&!privateFieldsAsProperties:instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(),prop,privateNamesMap,state));break;case isInstance&&isPrivate&&isMethod&&privateFieldsAsProperties:instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(),prop,privateNamesMap)),pureStaticNodes.push(buildPrivateMethodDeclaration(prop,privateNamesMap,privateFieldsAsProperties));break;case isInstance&&isPrivate&&isMethod&&!privateFieldsAsProperties:instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(),prop,privateNamesMap,state)),pureStaticNodes.push(buildPrivateMethodDeclaration(prop,privateNamesMap,privateFieldsAsProperties));break;case isStatic&&isPrivate&&isMethod&&!privateFieldsAsProperties:needsClassRef=!0,staticNodes.unshift(buildPrivateStaticFieldInitSpec(prop,privateNamesMap)),pureStaticNodes.push(buildPrivateMethodDeclaration(prop,privateNamesMap,privateFieldsAsProperties));break;case isStatic&&isPrivate&&isMethod&&privateFieldsAsProperties:needsClassRef=!0,staticNodes.unshift(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref),prop,state,privateNamesMap)),pureStaticNodes.push(buildPrivateMethodDeclaration(prop,privateNamesMap,privateFieldsAsProperties));break;case isInstance&&isPublic&&isField&&setPublicClassFields:instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(),prop));break;case isInstance&&isPublic&&isField&&!setPublicClassFields:instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(),prop,state));break;default:throw new Error("Unreachable.")}}return {staticNodes:staticNodes.filter(Boolean),instanceNodes:instanceNodes.filter(Boolean),pureStaticNodes:pureStaticNodes.filter(Boolean),wrapClass(path){for(const prop of props)prop.remove();return injectSuperRef&&(path.scope.push({id:_core.types.cloneNode(injectSuperRef)}),path.set("superClass",_core.types.assignmentExpression("=",injectSuperRef,path.node.superClass))),needsClassRef?(path.isClassExpression()?(path.scope.push({id:ref}),path.replaceWith(_core.types.assignmentExpression("=",_core.types.cloneNode(ref),path.node))):path.node.id||(path.node.id=ref),path):path}}},exports.buildPrivateNamesMap=function(props){const privateNamesMap=new Map;for(const prop of props)if(prop.isPrivate()){const{name}=prop.node.key.id,update=privateNamesMap.has(name)?privateNamesMap.get(name):{id:prop.scope.generateUidIdentifier(name),static:prop.node.static,method:!prop.isProperty()};prop.isClassPrivateMethod()&&("get"===prop.node.kind?update.getId=prop.scope.generateUidIdentifier(`get_${name}`):"set"===prop.node.kind?update.setId=prop.scope.generateUidIdentifier(`set_${name}`):"method"===prop.node.kind&&(update.methodId=prop.scope.generateUidIdentifier(name))),privateNamesMap.set(name,update);}return privateNamesMap},exports.buildPrivateNamesNodes=function(privateNamesMap,privateFieldsAsProperties,state){const initNodes=[];for(const[name,value]of privateNamesMap){const{static:isStatic,method:isMethod,getId,setId}=value,isAccessor=getId||setId,id=_core.types.cloneNode(value.id);let init;privateFieldsAsProperties?init=_core.types.callExpression(state.addHelper("classPrivateFieldLooseKey"),[_core.types.stringLiteral(name)]):isStatic||(init=_core.types.newExpression(_core.types.identifier(!isMethod||isAccessor?"WeakMap":"WeakSet"),[])),init&&((0, _helperAnnotateAsPure.default)(init),initNodes.push(_core.template.statement.ast`var ${id} = ${init}`));}return initNodes},exports.transformPrivateNamesUsage=function(ref,path,privateNamesMap,{privateFieldsAsProperties,noDocumentAll,innerBinding},state){if(!privateNamesMap.size)return;const body=path.get("body"),handler=privateFieldsAsProperties?privateNameHandlerLoose:privateNameHandlerSpec;(0, _helperMemberExpressionToFunctions.default)(body,privateNameVisitor,Object.assign({privateNamesMap,classRef:ref,file:state},handler,{noDocumentAll,innerBinding})),body.traverse(privateInVisitor,{privateNamesMap,classRef:ref,file:state,privateFieldsAsProperties,innerBinding});};var _core=__webpack_require__("./node_modules/@babel/core/lib/index.js"),_helperReplaceSupers=__webpack_require__("./node_modules/@babel/helper-replace-supers/lib/index.js"),_helperEnvironmentVisitor=__webpack_require__("./node_modules/@babel/helper-environment-visitor/lib/index.js"),_helperMemberExpressionToFunctions=__webpack_require__("./node_modules/@babel/helper-member-expression-to-functions/lib/index.js"),_helperOptimiseCallExpression=__webpack_require__("./node_modules/@babel/helper-optimise-call-expression/lib/index.js"),_helperAnnotateAsPure=__webpack_require__("./node_modules/@babel/helper-annotate-as-pure/lib/index.js"),ts=__webpack_require__("./node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js");function privateNameVisitorFactory(visitor){const privateNameVisitor=Object.assign({},visitor,{Class(path){const{privateNamesMap}=this,body=path.get("body.body"),visiblePrivateNames=new Map(privateNamesMap),redeclared=[];for(const prop of body){if(!prop.isPrivate())continue;const{name}=prop.node.key.id;visiblePrivateNames.delete(name),redeclared.push(name);}redeclared.length&&(path.get("body").traverse(nestedVisitor,Object.assign({},this,{redeclared})),path.traverse(privateNameVisitor,Object.assign({},this,{privateNamesMap:visiblePrivateNames})),path.skipKey("body"));}}),nestedVisitor=_core.traverse.visitors.merge([Object.assign({},visitor),_helperEnvironmentVisitor.default]);return privateNameVisitor}const privateNameVisitor=privateNameVisitorFactory({PrivateName(path,{noDocumentAll}){const{privateNamesMap,redeclared}=this,{node,parentPath}=path;if(!parentPath.isMemberExpression({property:node})&&!parentPath.isOptionalMemberExpression({property:node}))return;const{name}=node.id;privateNamesMap.has(name)&&(redeclared&&redeclared.includes(name)||this.handle(parentPath,noDocumentAll));}});function unshadow(name,scope,innerBinding){for(;null!=(_scope=scope)&&_scope.hasBinding(name)&&!scope.bindingIdentifierEquals(name,innerBinding);){var _scope;scope.rename(name),scope=scope.parent;}}const privateInVisitor=privateNameVisitorFactory({BinaryExpression(path){const{operator,left,right}=path.node;if("in"!==operator)return;if(!_core.types.isPrivateName(left))return;const{privateFieldsAsProperties,privateNamesMap,redeclared}=this,{name}=left.id;if(!privateNamesMap.has(name))return;if(redeclared&&redeclared.includes(name))return;if(unshadow(this.classRef.name,path.scope,this.innerBinding),privateFieldsAsProperties){const{id}=privateNamesMap.get(name);return void path.replaceWith(_core.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${right}, ${_core.types.cloneNode(id)})
      `)}const{id,static:isStatic}=privateNamesMap.get(name);isStatic?path.replaceWith(_core.template.expression.ast`${right} === ${this.classRef}`):path.replaceWith(_core.template.expression.ast`${_core.types.cloneNode(id)}.has(${right})`);}}),privateNameHandlerSpec={memoise(member,count){const{scope}=member,{object}=member.node,memo=scope.maybeGenerateMemoised(object);memo&&this.memoiser.set(object,memo,count);},receiver(member){const{object}=member.node;return this.memoiser.has(object)?_core.types.cloneNode(this.memoiser.get(object)):_core.types.cloneNode(object)},get(member){const{classRef,privateNamesMap,file,innerBinding}=this,{name}=member.node.property.id,{id,static:isStatic,method:isMethod,methodId,getId,setId}=privateNamesMap.get(name),isAccessor=getId||setId;if(isStatic){const helperName=isMethod&&!isAccessor?"classStaticPrivateMethodGet":"classStaticPrivateFieldSpecGet";return unshadow(classRef.name,member.scope,innerBinding),_core.types.callExpression(file.addHelper(helperName),[this.receiver(member),_core.types.cloneNode(classRef),_core.types.cloneNode(id)])}if(isMethod){if(isAccessor){if(!getId&&setId){if(file.availableHelper("writeOnlyError"))return _core.types.sequenceExpression([this.receiver(member),_core.types.callExpression(file.addHelper("writeOnlyError"),[_core.types.stringLiteral(`#${name}`)])]);console.warn("@babel/helpers is outdated, update it to silence this warning.");}return _core.types.callExpression(file.addHelper("classPrivateFieldGet"),[this.receiver(member),_core.types.cloneNode(id)])}return _core.types.callExpression(file.addHelper("classPrivateMethodGet"),[this.receiver(member),_core.types.cloneNode(id),_core.types.cloneNode(methodId)])}return _core.types.callExpression(file.addHelper("classPrivateFieldGet"),[this.receiver(member),_core.types.cloneNode(id)])},boundGet(member){return this.memoise(member,1),_core.types.callExpression(_core.types.memberExpression(this.get(member),_core.types.identifier("bind")),[this.receiver(member)])},set(member,value){const{classRef,privateNamesMap,file}=this,{name}=member.node.property.id,{id,static:isStatic,method:isMethod,setId,getId}=privateNamesMap.get(name);if(isStatic){const helperName=isMethod&&!(getId||setId)?"classStaticPrivateMethodSet":"classStaticPrivateFieldSpecSet";return _core.types.callExpression(file.addHelper(helperName),[this.receiver(member),_core.types.cloneNode(classRef),_core.types.cloneNode(id),value])}return isMethod?setId?_core.types.callExpression(file.addHelper("classPrivateFieldSet"),[this.receiver(member),_core.types.cloneNode(id),value]):_core.types.sequenceExpression([this.receiver(member),value,_core.types.callExpression(file.addHelper("readOnlyError"),[_core.types.stringLiteral(`#${name}`)])]):_core.types.callExpression(file.addHelper("classPrivateFieldSet"),[this.receiver(member),_core.types.cloneNode(id),value])},destructureSet(member){const{classRef,privateNamesMap,file}=this,{name}=member.node.property.id,{id,static:isStatic}=privateNamesMap.get(name);if(isStatic){try{var helper=file.addHelper("classStaticPrivateFieldDestructureSet");}catch(_unused){throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.")}return _core.types.memberExpression(_core.types.callExpression(helper,[this.receiver(member),_core.types.cloneNode(classRef),_core.types.cloneNode(id)]),_core.types.identifier("value"))}return _core.types.memberExpression(_core.types.callExpression(file.addHelper("classPrivateFieldDestructureSet"),[this.receiver(member),_core.types.cloneNode(id)]),_core.types.identifier("value"))},call(member,args){return this.memoise(member,1),(0, _helperOptimiseCallExpression.default)(this.get(member),this.receiver(member),args,!1)},optionalCall(member,args){return this.memoise(member,1),(0, _helperOptimiseCallExpression.default)(this.get(member),this.receiver(member),args,!0)}},privateNameHandlerLoose={get(member){const{privateNamesMap,file}=this,{object}=member.node,{name}=member.node.property.id;return _core.template.expression`BASE(REF, PROP)[PROP]`({BASE:file.addHelper("classPrivateFieldLooseBase"),REF:_core.types.cloneNode(object),PROP:_core.types.cloneNode(privateNamesMap.get(name).id)})},set(){throw new Error("private name handler with loose = true don't need set()")},boundGet(member){return _core.types.callExpression(_core.types.memberExpression(this.get(member),_core.types.identifier("bind")),[_core.types.cloneNode(member.node.object)])},simpleSet(member){return this.get(member)},destructureSet(member){return this.get(member)},call(member,args){return _core.types.callExpression(this.get(member),args)},optionalCall(member,args){return _core.types.optionalCallExpression(this.get(member),args,!0)}};function buildPrivateFieldInitLoose(ref,prop,privateNamesMap){const{id}=privateNamesMap.get(prop.node.key.id.name),value=prop.node.value||prop.scope.buildUndefinedNode();return _core.template.statement.ast`
    Object.defineProperty(${ref}, ${_core.types.cloneNode(id)}, {
      // configurable is false by default
      // enumerable is false by default
      writable: true,
      value: ${value}
    });
  `}function buildPrivateInstanceFieldInitSpec(ref,prop,privateNamesMap,state){const{id}=privateNamesMap.get(prop.node.key.id.name),value=prop.node.value||prop.scope.buildUndefinedNode();if(!state.availableHelper("classPrivateFieldInitSpec"))return _core.template.statement.ast`${_core.types.cloneNode(id)}.set(${ref}, {
        // configurable is always false for private elements
        // enumerable is always false for private elements
        writable: true,
        value: ${value},
      })`;const helper=state.addHelper("classPrivateFieldInitSpec");return _core.template.statement.ast`${helper}(
    ${_core.types.thisExpression()},
    ${_core.types.cloneNode(id)},
    {
      writable: true,
      value: ${value}
    },
  )`}function buildPrivateStaticFieldInitSpec(prop,privateNamesMap){const privateName=privateNamesMap.get(prop.node.key.id.name),{id,getId,setId,initAdded}=privateName,isAccessor=getId||setId;if(!prop.isProperty()&&(initAdded||!isAccessor))return;if(isAccessor)return privateNamesMap.set(prop.node.key.id.name,Object.assign({},privateName,{initAdded:!0})),_core.template.statement.ast`
      var ${_core.types.cloneNode(id)} = {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${getId?getId.name:prop.scope.buildUndefinedNode()},
        set: ${setId?setId.name:prop.scope.buildUndefinedNode()}
      }
    `;const value=prop.node.value||prop.scope.buildUndefinedNode();return _core.template.statement.ast`
    var ${_core.types.cloneNode(id)} = {
      // configurable is false by default
      // enumerable is false by default
      writable: true,
      value: ${value}
    };
  `}function buildPrivateMethodInitLoose(ref,prop,privateNamesMap){const privateName=privateNamesMap.get(prop.node.key.id.name),{methodId,id,getId,setId,initAdded}=privateName;if(initAdded)return;if(methodId)return _core.template.statement.ast`
        Object.defineProperty(${ref}, ${id}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${methodId.name}
        });
      `;return getId||setId?(privateNamesMap.set(prop.node.key.id.name,Object.assign({},privateName,{initAdded:!0})),_core.template.statement.ast`
      Object.defineProperty(${ref}, ${id}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${getId?getId.name:prop.scope.buildUndefinedNode()},
        set: ${setId?setId.name:prop.scope.buildUndefinedNode()}
      });
    `):void 0}function buildPrivateInstanceMethodInitSpec(ref,prop,privateNamesMap,state){const privateName=privateNamesMap.get(prop.node.key.id.name),{getId,setId,initAdded}=privateName;if(initAdded)return;return getId||setId?function(ref,prop,privateNamesMap,state){const privateName=privateNamesMap.get(prop.node.key.id.name),{id,getId,setId}=privateName;if(privateNamesMap.set(prop.node.key.id.name,Object.assign({},privateName,{initAdded:!0})),!state.availableHelper("classPrivateFieldInitSpec"))return _core.template.statement.ast`
      ${id}.set(${ref}, {
        get: ${getId?getId.name:prop.scope.buildUndefinedNode()},
        set: ${setId?setId.name:prop.scope.buildUndefinedNode()}
      });
    `;const helper=state.addHelper("classPrivateFieldInitSpec");return _core.template.statement.ast`${helper}(
    ${_core.types.thisExpression()},
    ${_core.types.cloneNode(id)},
    {
      get: ${getId?getId.name:prop.scope.buildUndefinedNode()},
      set: ${setId?setId.name:prop.scope.buildUndefinedNode()}
    },
  )`}(ref,prop,privateNamesMap,state):function(ref,prop,privateNamesMap,state){const privateName=privateNamesMap.get(prop.node.key.id.name),{id}=privateName;if(!state.availableHelper("classPrivateMethodInitSpec"))return _core.template.statement.ast`${id}.add(${ref})`;const helper=state.addHelper("classPrivateMethodInitSpec");return _core.template.statement.ast`${helper}(
    ${_core.types.thisExpression()},
    ${_core.types.cloneNode(id)}
  )`}(ref,prop,privateNamesMap,state)}function buildPublicFieldInitLoose(ref,prop){const{key,computed}=prop.node,value=prop.node.value||prop.scope.buildUndefinedNode();return _core.types.expressionStatement(_core.types.assignmentExpression("=",_core.types.memberExpression(ref,key,computed||_core.types.isLiteral(key)),value))}function buildPublicFieldInitSpec(ref,prop,state){const{key,computed}=prop.node,value=prop.node.value||prop.scope.buildUndefinedNode();return _core.types.expressionStatement(_core.types.callExpression(state.addHelper("defineProperty"),[ref,computed||_core.types.isLiteral(key)?key:_core.types.stringLiteral(key.name),value]))}function buildPrivateStaticMethodInitLoose(ref,prop,state,privateNamesMap){const privateName=privateNamesMap.get(prop.node.key.id.name),{id,methodId,getId,setId,initAdded}=privateName;if(initAdded)return;return getId||setId?(privateNamesMap.set(prop.node.key.id.name,Object.assign({},privateName,{initAdded:!0})),_core.template.statement.ast`
      Object.defineProperty(${ref}, ${id}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${getId?getId.name:prop.scope.buildUndefinedNode()},
        set: ${setId?setId.name:prop.scope.buildUndefinedNode()}
      })
    `):_core.template.statement.ast`
    Object.defineProperty(${ref}, ${id}, {
      // configurable is false by default
      // enumerable is false by default
      // writable is false by default
      value: ${methodId.name}
    });
  `}function buildPrivateMethodDeclaration(prop,privateNamesMap,privateFieldsAsProperties=!1){const privateName=privateNamesMap.get(prop.node.key.id.name),{id,methodId,getId,setId,getterDeclared,setterDeclared,static:isStatic}=privateName,{params,body,generator,async}=prop.node,isGetter=getId&&!getterDeclared&&0===params.length,isSetter=setId&&!setterDeclared&&params.length>0;let declId=methodId;return isGetter?(privateNamesMap.set(prop.node.key.id.name,Object.assign({},privateName,{getterDeclared:!0})),declId=getId):isSetter?(privateNamesMap.set(prop.node.key.id.name,Object.assign({},privateName,{setterDeclared:!0})),declId=setId):isStatic&&!privateFieldsAsProperties&&(declId=id),_core.types.functionDeclaration(_core.types.cloneNode(declId),params,body,generator,async)}const thisContextVisitor=_core.traverse.visitors.merge([{ThisExpression(path,state){state.needsClassRef=!0,path.replaceWith(_core.types.cloneNode(state.classRef));},MetaProperty(path){const meta=path.get("meta"),property=path.get("property"),{scope}=path;meta.isIdentifier({name:"new"})&&property.isIdentifier({name:"target"})&&path.replaceWith(scope.buildUndefinedNode());}},_helperEnvironmentVisitor.default]),innerReferencesVisitor={ReferencedIdentifier(path,state){path.scope.bindingIdentifierEquals(path.node.name,state.innerBinding)&&(state.needsClassRef=!0,path.node.name=state.classRef.name);}};function replaceThisContext(path,ref,getSuperRef,file,isStaticBlock,constantSuper,innerBindingRef){var _state$classRef;const state={classRef:ref,needsClassRef:!1,innerBinding:innerBindingRef};return new _helperReplaceSupers.default({methodPath:path,constantSuper,file,refToPreserve:ref,getSuperRef,getObjectRef:()=>(state.needsClassRef=!0,isStaticBlock||path.node.static?ref:_core.types.memberExpression(ref,_core.types.identifier("prototype")))}).replace(),(isStaticBlock||path.isProperty())&&path.traverse(thisContextVisitor,state),null!=(_state$classRef=state.classRef)&&_state$classRef.name&&state.classRef.name!==(null==innerBindingRef?void 0:innerBindingRef.name)&&path.traverse(innerReferencesVisitor,state),state.needsClassRef}},"./node_modules/@babel/helper-create-class-features-plugin/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"FEATURES",{enumerable:!0,get:function(){return _features.FEATURES}}),exports.createClassFeaturePlugin=function({name,feature,loose,manipulateOptions,api={assumption:()=>{}}}){const setPublicClassFields=api.assumption("setPublicClassFields"),privateFieldsAsProperties=api.assumption("privateFieldsAsProperties"),constantSuper=api.assumption("constantSuper"),noDocumentAll=api.assumption("noDocumentAll");if(!0===loose){const explicit=[];void 0!==setPublicClassFields&&explicit.push('"setPublicClassFields"'),void 0!==privateFieldsAsProperties&&explicit.push('"privateFieldsAsProperties"'),0!==explicit.length&&console.warn(`[${name}]: You are using the "loose: true" option and you are explicitly setting a value for the ${explicit.join(" and ")} assumption${explicit.length>1?"s":""}. The "loose" option can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:\n\t"assumptions": {\n\t\t"setPublicClassFields": true,\n\t\t"privateFieldsAsProperties": true\n\t}`);}return {name,manipulateOptions,pre(){(0, _features.enableFeature)(this.file,feature,loose),(!this.file.get(versionKey)||this.file.get(versionKey)<version)&&this.file.set(versionKey,version);},visitor:{Class(path,state){if(this.file.get(versionKey)!==version)return;if(!(0, _features.shouldTransform)(path,this.file))return;path.isClassDeclaration()&&(0, _typescript.assertFieldTransformed)(path);const loose=(0, _features.isLoose)(this.file,feature);let constructor;const isDecorated=(0, _decorators.hasDecorators)(path.node),props=[],elements=[],computedPaths=[],privateNames=new Set,body=path.get("body");for(const path of body.get("body")){if((path.isClassProperty()||path.isClassMethod())&&path.node.computed&&computedPaths.push(path),path.isPrivate()){const{name}=path.node.key.id,getName=`get ${name}`,setName=`set ${name}`;if(path.isClassPrivateMethod()){if("get"===path.node.kind){if(privateNames.has(getName)||privateNames.has(name)&&!privateNames.has(setName))throw path.buildCodeFrameError("Duplicate private field");privateNames.add(getName).add(name);}else if("set"===path.node.kind){if(privateNames.has(setName)||privateNames.has(name)&&!privateNames.has(getName))throw path.buildCodeFrameError("Duplicate private field");privateNames.add(setName).add(name);}}else {if(privateNames.has(name)&&!privateNames.has(getName)&&!privateNames.has(setName)||privateNames.has(name)&&(privateNames.has(getName)||privateNames.has(setName)))throw path.buildCodeFrameError("Duplicate private field");privateNames.add(name);}}path.isClassMethod({kind:"constructor"})?constructor=path:(elements.push(path),(path.isProperty()||path.isPrivate()||null!=path.isStaticBlock&&path.isStaticBlock())&&props.push(path));}if(!props.length&&!isDecorated)return;const innerBinding=path.node.id;let ref;!innerBinding||path.isClassExpression()?((0, _helperFunctionName.default)(path),ref=path.scope.generateUidIdentifier("class")):ref=_core.types.cloneNode(path.node.id);const privateNamesMap=(0, _fields.buildPrivateNamesMap)(props),privateNamesNodes=(0, _fields.buildPrivateNamesNodes)(privateNamesMap,null!=privateFieldsAsProperties?privateFieldsAsProperties:loose,state);let keysNodes,staticNodes,instanceNodes,pureStaticNodes,wrapClass;(0, _fields.transformPrivateNamesUsage)(ref,path,privateNamesMap,{privateFieldsAsProperties:null!=privateFieldsAsProperties?privateFieldsAsProperties:loose,noDocumentAll,innerBinding},state),isDecorated?(staticNodes=pureStaticNodes=keysNodes=[],({instanceNodes,wrapClass}=(0, _decorators.buildDecoratedClass)(ref,path,elements,this.file))):(keysNodes=(0, _misc.extractComputedKeys)(ref,path,computedPaths,this.file),({staticNodes,pureStaticNodes,instanceNodes,wrapClass}=(0, _fields.buildFieldsInitNodes)(ref,path.node.superClass,props,privateNamesMap,state,null!=setPublicClassFields?setPublicClassFields:loose,null!=privateFieldsAsProperties?privateFieldsAsProperties:loose,null!=constantSuper?constantSuper:loose,innerBinding))),instanceNodes.length>0&&(0, _misc.injectInitialization)(path,constructor,instanceNodes,((referenceVisitor,state)=>{if(!isDecorated)for(const prop of props)prop.node.static||prop.traverse(referenceVisitor,state);}));const wrappedPath=wrapClass(path);wrappedPath.insertBefore([...privateNamesNodes,...keysNodes]),staticNodes.length>0&&wrappedPath.insertAfter(staticNodes),pureStaticNodes.length>0&&wrappedPath.find((parent=>parent.isStatement()||parent.isDeclaration())).insertAfter(pureStaticNodes);},ExportDefaultDeclaration(path){if(this.file.get(versionKey)!==version)return;const decl=path.get("declaration");decl.isClassDeclaration()&&(0, _decorators.hasDecorators)(decl.node)&&(decl.node.id?(0, _helperSplitExportDeclaration.default)(path):decl.node.type="ClassExpression");}}}},Object.defineProperty(exports,"enableFeature",{enumerable:!0,get:function(){return _features.enableFeature}}),Object.defineProperty(exports,"injectInitialization",{enumerable:!0,get:function(){return _misc.injectInitialization}});var _core=__webpack_require__("./node_modules/@babel/core/lib/index.js"),_helperFunctionName=__webpack_require__("./node_modules/@babel/helper-function-name/lib/index.js"),_helperSplitExportDeclaration=__webpack_require__("./node_modules/@babel/helper-split-export-declaration/lib/index.js"),_fields=__webpack_require__("./node_modules/@babel/helper-create-class-features-plugin/lib/fields.js"),_decorators=__webpack_require__("./node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js"),_misc=__webpack_require__("./node_modules/@babel/helper-create-class-features-plugin/lib/misc.js"),_features=__webpack_require__("./node_modules/@babel/helper-create-class-features-plugin/lib/features.js"),_typescript=__webpack_require__("./node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js");const version="7.16.10".split(".").reduce(((v,x)=>1e5*v+ +x),0),versionKey="@babel/plugin-class-features/version";},"./node_modules/@babel/helper-create-class-features-plugin/lib/misc.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.extractComputedKeys=function(ref,path,computedPaths,file){const declarations=[],state={classBinding:path.node.id&&path.scope.getBinding(path.node.id.name),file};for(const computedPath of computedPaths){const computedKey=computedPath.get("key");computedKey.isReferencedIdentifier()?handleClassTDZ(computedKey,state):computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor,state);const computedNode=computedPath.node;if(!computedKey.isConstantExpression()){const ident=path.scope.generateUidIdentifierBasedOnNode(computedNode.key);path.scope.push({id:ident,kind:"let"}),declarations.push(_core.types.expressionStatement(_core.types.assignmentExpression("=",_core.types.cloneNode(ident),computedNode.key))),computedNode.key=_core.types.cloneNode(ident);}}return declarations},exports.injectInitialization=function(path,constructor,nodes,renamer){if(!nodes.length)return;const isDerived=!!path.node.superClass;if(!constructor){const newConstructor=_core.types.classMethod("constructor",_core.types.identifier("constructor"),[],_core.types.blockStatement([]));isDerived&&(newConstructor.params=[_core.types.restElement(_core.types.identifier("args"))],newConstructor.body.body.push(_core.template.statement.ast`super(...args)`)),[constructor]=path.get("body").unshiftContainer("body",newConstructor);}renamer&&renamer(referenceVisitor,{scope:constructor.scope});if(isDerived){const bareSupers=[];constructor.traverse(findBareSupers,bareSupers);let isFirst=!0;for(const bareSuper of bareSupers)isFirst?(bareSuper.insertAfter(nodes),isFirst=!1):bareSuper.insertAfter(nodes.map((n=>_core.types.cloneNode(n))));}else constructor.get("body").unshiftContainer("body",nodes);};var _core=__webpack_require__("./node_modules/@babel/core/lib/index.js"),_helperEnvironmentVisitor=__webpack_require__("./node_modules/@babel/helper-environment-visitor/lib/index.js");const findBareSupers=_core.traverse.visitors.merge([{Super(path){const{node,parentPath}=path;parentPath.isCallExpression({callee:node})&&this.push(parentPath);}},_helperEnvironmentVisitor.default]),referenceVisitor={"TSTypeAnnotation|TypeAnnotation"(path){path.skip();},ReferencedIdentifier(path){this.scope.hasOwnBinding(path.node.name)&&(this.scope.rename(path.node.name),path.skip());}};function handleClassTDZ(path,state){if(state.classBinding&&state.classBinding===path.scope.getBinding(path.node.name)){const classNameTDZError=state.file.addHelper("classNameTDZError"),throwNode=_core.types.callExpression(classNameTDZError,[_core.types.stringLiteral(path.node.name)]);path.replaceWith(_core.types.sequenceExpression([throwNode,path.node])),path.skip();}}const classFieldDefinitionEvaluationTDZVisitor={ReferencedIdentifier:handleClassTDZ};},"./node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.assertFieldTransformed=function(path){if(path.node.declare)throw path.buildCodeFrameError("TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.\nIf you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:\n - @babel/plugin-proposal-class-properties\n - @babel/plugin-proposal-private-methods\n - @babel/plugin-proposal-decorators")};},"./node_modules/@babel/helper-environment-visitor/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0,exports.skipAllButComputedKey=skipAllButComputedKey;var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{VISITOR_KEYS,staticBlock}=_t;function skipAllButComputedKey(path){if(!path.node.computed)return void path.skip();const keys=VISITOR_KEYS[path.type];for(const key of keys)"key"!==key&&path.skipKey(key);}var _default={[(staticBlock?"StaticBlock|":"")+"ClassPrivateProperty|TypeAnnotation|FunctionDeclaration|FunctionExpression"]:path=>path.skip(),"Method|ClassProperty"(path){skipAllButComputedKey(path);}};exports.default=_default;},"./node_modules/@babel/helper-function-name/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function({node,parent,scope,id},localBinding=!1,supportUnicodeId=!1){if(node.id)return;if(!isObjectProperty(parent)&&!isObjectMethod(parent,{kind:"method"})||parent.computed&&!isLiteral(parent.key)){if(isVariableDeclarator(parent)){if(id=parent.id,isIdentifier(id)&&!localBinding){const binding=scope.parent.getBinding(id.name);if(binding&&binding.constant&&scope.getBinding(id.name)===binding)return node.id=cloneNode(id),void(node.id[NOT_LOCAL_BINDING]=!0)}}else if(isAssignmentExpression(parent,{operator:"="}))id=parent.left;else if(!id)return}else id=parent.key;let name;id&&isLiteral(id)?name=function(id){if(isNullLiteral(id))return "null";if(isRegExpLiteral(id))return `_${id.pattern}_${id.flags}`;if(isTemplateLiteral(id))return id.quasis.map((quasi=>quasi.value.raw)).join("");if(void 0!==id.value)return id.value+"";return ""}(id):id&&isIdentifier(id)&&(name=id.name);if(void 0===name)return;if(!supportUnicodeId&&isFunction(node)&&/[\uD800-\uDFFF]/.test(name))return;name=toBindingIdentifierName(name),(id=identifier(name))[NOT_LOCAL_BINDING]=!0;return function(state,method,id,scope){if(state.selfReference){if(!scope.hasBinding(id.name)||scope.hasGlobal(id.name)){if(!isFunction(method))return;let build=buildPropertyMethodAssignmentWrapper;method.generator&&(build=buildGeneratorPropertyMethodAssignmentWrapper);const template=build({FUNCTION:method,FUNCTION_ID:id,FUNCTION_KEY:scope.generateUidIdentifier(id.name)}).expression,params=template.callee.body.body[0].params;for(let i=0,len=(0, _helperGetFunctionArity.default)(method);i<len;i++)params.push(scope.generateUidIdentifier("x"));return template}scope.rename(id.name);}method.id=id,scope.getProgramParent().references[id.name]=!0;}(function(node,name,scope){const state={selfAssignment:!1,selfReference:!1,outerDeclar:scope.getBindingIdentifier(name),references:[],name},binding=scope.getOwnBinding(name);binding?"param"===binding.kind&&(state.selfReference=!0):(state.outerDeclar||scope.hasGlobal(name))&&scope.traverse(node,visitor,state);return state}(node,name,scope),node,id,scope)||node};var _helperGetFunctionArity=__webpack_require__("./node_modules/@babel/helper-get-function-arity/lib/index.js"),_template=__webpack_require__("./node_modules/@babel/template/lib/index.js"),_t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{NOT_LOCAL_BINDING,cloneNode,identifier,isAssignmentExpression,isFunction,isIdentifier,isLiteral,isNullLiteral,isObjectMethod,isObjectProperty,isRegExpLiteral,isTemplateLiteral,isVariableDeclarator,toBindingIdentifierName}=_t,buildPropertyMethodAssignmentWrapper=(0, _template.default)("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"),buildGeneratorPropertyMethodAssignmentWrapper=(0, _template.default)("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"),visitor={"ReferencedIdentifier|BindingIdentifier"(path,state){if(path.node.name!==state.name)return;path.scope.getBindingIdentifier(state.name)===state.outerDeclar&&(state.selfReference=!0,path.stop());}};},"./node_modules/@babel/helper-get-function-arity/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node){const params=node.params;for(let i=0;i<params.length;i++){const param=params[i];if(isAssignmentPattern(param)||isRestElement(param))return i}return params.length};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{isAssignmentPattern,isRestElement}=_t;},"./node_modules/@babel/helper-hoist-variables/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(path,emit,kind="var"){path.traverse(visitor,{kind,emit});};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{assignmentExpression,expressionStatement,identifier}=_t,visitor={Scope(path,state){"let"===state.kind&&path.skip();},FunctionParent(path){path.skip();},VariableDeclaration(path,state){if(state.kind&&path.node.kind!==state.kind)return;const nodes=[],declarations=path.get("declarations");let firstId;for(const declar of declarations){firstId=declar.node.id,declar.node.init&&nodes.push(expressionStatement(assignmentExpression("=",declar.node.id,declar.node.init)));for(const name of Object.keys(declar.getBindingIdentifiers()))state.emit(identifier(name),name,null!==declar.node.init);}path.parentPath.isFor({left:path.node})?path.replaceWith(firstId):path.replaceWithMultiple(nodes);}};},"./node_modules/@babel/helper-member-expression-to-functions/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _interopNamespace(e){if(e&&e.__esModule)return e;var n=Object.create(null);return e&&Object.keys(e).forEach((function(k){if("default"!==k){var d=Object.getOwnPropertyDescriptor(e,k);Object.defineProperty(n,k,d.get?d:{enumerable:!0,get:function(){return e[k]}});}})),n.default=e,Object.freeze(n)}Object.defineProperty(exports,"__esModule",{value:!0});var _t__namespace=_interopNamespace(__webpack_require__("./node_modules/@babel/types/lib/index.js"));function willPathCastToBoolean(path){const maybeWrapped=path,{node,parentPath}=maybeWrapped;if(parentPath.isLogicalExpression()){const{operator,right}=parentPath.node;if("&&"===operator||"||"===operator||"??"===operator&&node===right)return willPathCastToBoolean(parentPath)}if(parentPath.isSequenceExpression()){const{expressions}=parentPath.node;return expressions[expressions.length-1]!==node||willPathCastToBoolean(parentPath)}return parentPath.isConditional({test:node})||parentPath.isUnaryExpression({operator:"!"})||parentPath.isLoop({test:node})}const{LOGICAL_OPERATORS,arrowFunctionExpression,assignmentExpression,binaryExpression,booleanLiteral,callExpression,cloneNode,conditionalExpression,identifier,isMemberExpression,isOptionalCallExpression,isOptionalMemberExpression,isUpdateExpression,logicalExpression,memberExpression,nullLiteral,numericLiteral,optionalCallExpression,optionalMemberExpression,sequenceExpression,unaryExpression}=_t__namespace;class AssignmentMemoiser{constructor(){this._map=void 0,this._map=new WeakMap;}has(key){return this._map.has(key)}get(key){if(!this.has(key))return;const record=this._map.get(key),{value}=record;return record.count--,0===record.count?assignmentExpression("=",value,key):value}set(key,value,count){return this._map.set(key,{count,value})}}function toNonOptional(path,base){const{node}=path;if(isOptionalMemberExpression(node))return memberExpression(base,node.property,node.computed);if(path.isOptionalCallExpression()){const callee=path.get("callee");if(path.node.optional&&callee.isOptionalMemberExpression()){const{object}=callee.node,context=path.scope.maybeGenerateMemoised(object)||object;return callee.get("object").replaceWith(assignmentExpression("=",context,object)),callExpression(memberExpression(base,identifier("call")),[context,...path.node.arguments])}return callExpression(base,path.node.arguments)}return path.node}const handle={memoise(){},handle(member,noDocumentAll){const{node,parent,parentPath,scope}=member;if(member.isOptionalMemberExpression()){if(function(path){for(;path&&!path.isProgram();){const{parentPath,container,listKey}=path,parentNode=parentPath.node;if(listKey){if(container!==parentNode[listKey])return !0}else if(container!==parentNode)return !0;path=parentPath;}return !1}(member))return;const endPath=member.find((({node,parent})=>isOptionalMemberExpression(parent)?parent.optional||parent.object!==node:!isOptionalCallExpression(parent)||(node!==member.node&&parent.optional||parent.callee!==node)));if(scope.path.isPattern())return void endPath.replaceWith(callExpression(arrowFunctionExpression([],endPath.node),[]));const willEndPathCastToBoolean=willPathCastToBoolean(endPath),rootParentPath=endPath.parentPath;if(rootParentPath.isUpdateExpression({argument:node})||rootParentPath.isAssignmentExpression({left:node}))throw member.buildCodeFrameError("can't handle assignment");const isDeleteOperation=rootParentPath.isUnaryExpression({operator:"delete"});if(isDeleteOperation&&endPath.isOptionalMemberExpression()&&endPath.get("property").isPrivateName())throw member.buildCodeFrameError("can't delete a private class element");let startingOptional=member;for(;;)if(startingOptional.isOptionalMemberExpression()){if(startingOptional.node.optional)break;startingOptional=startingOptional.get("object");}else {if(!startingOptional.isOptionalCallExpression())throw new Error(`Internal error: unexpected ${startingOptional.node.type}`);if(startingOptional.node.optional)break;startingOptional=startingOptional.get("callee");}const startingProp=startingOptional.isOptionalMemberExpression()?"object":"callee",startingNode=startingOptional.node[startingProp],baseNeedsMemoised=scope.maybeGenerateMemoised(startingNode),baseRef=null!=baseNeedsMemoised?baseNeedsMemoised:startingNode,parentIsOptionalCall=parentPath.isOptionalCallExpression({callee:node}),isOptionalCall=parent=>parentIsOptionalCall,parentIsCall=parentPath.isCallExpression({callee:node});startingOptional.replaceWith(toNonOptional(startingOptional,baseRef)),isOptionalCall()?parent.optional?parentPath.replaceWith(this.optionalCall(member,parent.arguments)):parentPath.replaceWith(this.call(member,parent.arguments)):parentIsCall?member.replaceWith(this.boundGet(member)):member.replaceWith(this.get(member));let context,regular=member.node;for(let current=member;current!==endPath;){const parentPath=current.parentPath;if(parentPath===endPath&&isOptionalCall()&&parent.optional){regular=parentPath.node;break}regular=toNonOptional(parentPath,regular),current=parentPath;}const endParentPath=endPath.parentPath;if(isMemberExpression(regular)&&endParentPath.isOptionalCallExpression({callee:endPath.node,optional:!0})){const{object}=regular;context=member.scope.maybeGenerateMemoised(object),context&&(regular.object=assignmentExpression("=",context,object));}let replacementPath=endPath;isDeleteOperation&&(replacementPath=endParentPath,regular=endParentPath.node);const baseMemoised=baseNeedsMemoised?assignmentExpression("=",cloneNode(baseRef),cloneNode(startingNode)):cloneNode(baseRef);if(willEndPathCastToBoolean){let nonNullishCheck;nonNullishCheck=noDocumentAll?binaryExpression("!=",baseMemoised,nullLiteral()):logicalExpression("&&",binaryExpression("!==",baseMemoised,nullLiteral()),binaryExpression("!==",cloneNode(baseRef),scope.buildUndefinedNode())),replacementPath.replaceWith(logicalExpression("&&",nonNullishCheck,regular));}else {let nullishCheck;nullishCheck=noDocumentAll?binaryExpression("==",baseMemoised,nullLiteral()):logicalExpression("||",binaryExpression("===",baseMemoised,nullLiteral()),binaryExpression("===",cloneNode(baseRef),scope.buildUndefinedNode())),replacementPath.replaceWith(conditionalExpression(nullishCheck,isDeleteOperation?booleanLiteral(!0):scope.buildUndefinedNode(),regular));}if(context){const endParent=endParentPath.node;endParentPath.replaceWith(optionalCallExpression(optionalMemberExpression(endParent.callee,identifier("call"),!1,!0),[cloneNode(context),...endParent.arguments],!1));}}else if(isUpdateExpression(parent,{argument:node})){if(this.simpleSet)return void member.replaceWith(this.simpleSet(member));const{operator,prefix}=parent;this.memoise(member,2);const value=binaryExpression(operator[0],unaryExpression("+",this.get(member)),numericLiteral(1));if(prefix)parentPath.replaceWith(this.set(member,value));else {const{scope}=member,ref=scope.generateUidIdentifierBasedOnNode(node);scope.push({id:ref}),value.left=assignmentExpression("=",cloneNode(ref),value.left),parentPath.replaceWith(sequenceExpression([this.set(member,value),cloneNode(ref)]));}}else if(parentPath.isAssignmentExpression({left:node})){if(this.simpleSet)return void member.replaceWith(this.simpleSet(member));const{operator,right:value}=parentPath.node;if("="===operator)parentPath.replaceWith(this.set(member,value));else {const operatorTrunc=operator.slice(0,-1);LOGICAL_OPERATORS.includes(operatorTrunc)?(this.memoise(member,1),parentPath.replaceWith(logicalExpression(operatorTrunc,this.get(member),this.set(member,value)))):(this.memoise(member,2),parentPath.replaceWith(this.set(member,binaryExpression(operatorTrunc,this.get(member),value))));}}else {if(!parentPath.isCallExpression({callee:node}))return parentPath.isOptionalCallExpression({callee:node})?scope.path.isPattern()?void parentPath.replaceWith(callExpression(arrowFunctionExpression([],parentPath.node),[])):void parentPath.replaceWith(this.optionalCall(member,parentPath.node.arguments)):void(parentPath.isForXStatement({left:node})||parentPath.isObjectProperty({value:node})&&parentPath.parentPath.isObjectPattern()||parentPath.isAssignmentPattern({left:node})&&parentPath.parentPath.isObjectProperty({value:parent})&&parentPath.parentPath.parentPath.isObjectPattern()||parentPath.isArrayPattern()||parentPath.isAssignmentPattern({left:node})&&parentPath.parentPath.isArrayPattern()||parentPath.isRestElement()?member.replaceWith(this.destructureSet(member)):parentPath.isTaggedTemplateExpression()?member.replaceWith(this.boundGet(member)):member.replaceWith(this.get(member)));parentPath.replaceWith(this.call(member,parentPath.node.arguments));}}};exports.default=function(path,visitor,state){path.traverse(visitor,Object.assign({},handle,state,{memoiser:new AssignmentMemoiser}));};},"./node_modules/@babel/helper-module-imports/lib/import-builder.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _assert=__webpack_require__("assert"),_t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{callExpression,cloneNode,expressionStatement,identifier,importDeclaration,importDefaultSpecifier,importNamespaceSpecifier,importSpecifier,memberExpression,stringLiteral,variableDeclaration,variableDeclarator}=_t;exports.default=class{constructor(importedSource,scope,hub){this._statements=[],this._resultName=null,this._scope=null,this._hub=null,this._importedSource=void 0,this._scope=scope,this._hub=hub,this._importedSource=importedSource;}done(){return {statements:this._statements,resultName:this._resultName}}import(){return this._statements.push(importDeclaration([],stringLiteral(this._importedSource))),this}require(){return this._statements.push(expressionStatement(callExpression(identifier("require"),[stringLiteral(this._importedSource)]))),this}namespace(name="namespace"){const local=this._scope.generateUidIdentifier(name),statement=this._statements[this._statements.length-1];return _assert("ImportDeclaration"===statement.type),_assert(0===statement.specifiers.length),statement.specifiers=[importNamespaceSpecifier(local)],this._resultName=cloneNode(local),this}default(name){name=this._scope.generateUidIdentifier(name);const statement=this._statements[this._statements.length-1];return _assert("ImportDeclaration"===statement.type),_assert(0===statement.specifiers.length),statement.specifiers=[importDefaultSpecifier(name)],this._resultName=cloneNode(name),this}named(name,importName){if("default"===importName)return this.default(name);name=this._scope.generateUidIdentifier(name);const statement=this._statements[this._statements.length-1];return _assert("ImportDeclaration"===statement.type),_assert(0===statement.specifiers.length),statement.specifiers=[importSpecifier(name,identifier(importName))],this._resultName=cloneNode(name),this}var(name){name=this._scope.generateUidIdentifier(name);let statement=this._statements[this._statements.length-1];return "ExpressionStatement"!==statement.type&&(_assert(this._resultName),statement=expressionStatement(this._resultName),this._statements.push(statement)),this._statements[this._statements.length-1]=variableDeclaration("var",[variableDeclarator(name,statement.expression)]),this._resultName=cloneNode(name),this}defaultInterop(){return this._interop(this._hub.addHelper("interopRequireDefault"))}wildcardInterop(){return this._interop(this._hub.addHelper("interopRequireWildcard"))}_interop(callee){const statement=this._statements[this._statements.length-1];return "ExpressionStatement"===statement.type?statement.expression=callExpression(callee,[statement.expression]):"VariableDeclaration"===statement.type?(_assert(1===statement.declarations.length),statement.declarations[0].init=callExpression(callee,[statement.declarations[0].init])):_assert.fail("Unexpected type."),this}prop(name){const statement=this._statements[this._statements.length-1];return "ExpressionStatement"===statement.type?statement.expression=memberExpression(statement.expression,identifier(name)):"VariableDeclaration"===statement.type?(_assert(1===statement.declarations.length),statement.declarations[0].init=memberExpression(statement.declarations[0].init,identifier(name))):_assert.fail("Unexpected type:"+statement.type),this}read(name){this._resultName=memberExpression(this._resultName,identifier(name));}};},"./node_modules/@babel/helper-module-imports/lib/import-injector.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _assert=__webpack_require__("assert"),_t=__webpack_require__("./node_modules/@babel/types/lib/index.js"),_importBuilder=__webpack_require__("./node_modules/@babel/helper-module-imports/lib/import-builder.js"),_isModule=__webpack_require__("./node_modules/@babel/helper-module-imports/lib/is-module.js");const{numericLiteral,sequenceExpression}=_t;exports.default=class{constructor(path,importedSource,opts){this._defaultOpts={importedSource:null,importedType:"commonjs",importedInterop:"babel",importingInterop:"babel",ensureLiveReference:!1,ensureNoContext:!1,importPosition:"before"};const programPath=path.find((p=>p.isProgram()));this._programPath=programPath,this._programScope=programPath.scope,this._hub=programPath.hub,this._defaultOpts=this._applyDefaults(importedSource,opts,!0);}addDefault(importedSourceIn,opts){return this.addNamed("default",importedSourceIn,opts)}addNamed(importName,importedSourceIn,opts){return _assert("string"==typeof importName),this._generateImport(this._applyDefaults(importedSourceIn,opts),importName)}addNamespace(importedSourceIn,opts){return this._generateImport(this._applyDefaults(importedSourceIn,opts),null)}addSideEffect(importedSourceIn,opts){return this._generateImport(this._applyDefaults(importedSourceIn,opts),!1)}_applyDefaults(importedSource,opts,isInit=!1){const optsList=[];"string"==typeof importedSource?(optsList.push({importedSource}),optsList.push(opts)):(_assert(!opts,"Unexpected secondary arguments."),optsList.push(importedSource));const newOpts=Object.assign({},this._defaultOpts);for(const opts of optsList)opts&&(Object.keys(newOpts).forEach((key=>{void 0!==opts[key]&&(newOpts[key]=opts[key]);})),isInit||(void 0!==opts.nameHint&&(newOpts.nameHint=opts.nameHint),void 0!==opts.blockHoist&&(newOpts.blockHoist=opts.blockHoist)));return newOpts}_generateImport(opts,importName){const isDefault="default"===importName,isNamed=!!importName&&!isDefault,isNamespace=null===importName,{importedSource,importedType,importedInterop,importingInterop,ensureLiveReference,ensureNoContext,nameHint,importPosition,blockHoist}=opts;let name=nameHint||importName;const isMod=(0, _isModule.default)(this._programPath),isModuleForNode=isMod&&"node"===importingInterop,isModuleForBabel=isMod&&"babel"===importingInterop;if("after"===importPosition&&!isMod)throw new Error('"importPosition": "after" is only supported in modules');const builder=new _importBuilder.default(importedSource,this._programScope,this._hub);if("es6"===importedType){if(!isModuleForNode&&!isModuleForBabel)throw new Error("Cannot import an ES6 module from CommonJS");builder.import(),isNamespace?builder.namespace(nameHint||importedSource):(isDefault||isNamed)&&builder.named(name,importName);}else {if("commonjs"!==importedType)throw new Error(`Unexpected interopType "${importedType}"`);if("babel"===importedInterop)if(isModuleForNode){name="default"!==name?name:importedSource;const es6Default=`${importedSource}$es6Default`;builder.import(),isNamespace?builder.default(es6Default).var(name||importedSource).wildcardInterop():isDefault?ensureLiveReference?builder.default(es6Default).var(name||importedSource).defaultInterop().read("default"):builder.default(es6Default).var(name).defaultInterop().prop(importName):isNamed&&builder.default(es6Default).read(importName);}else isModuleForBabel?(builder.import(),isNamespace?builder.namespace(name||importedSource):(isDefault||isNamed)&&builder.named(name,importName)):(builder.require(),isNamespace?builder.var(name||importedSource).wildcardInterop():(isDefault||isNamed)&&ensureLiveReference?isDefault?(name="default"!==name?name:importedSource,builder.var(name).read(importName),builder.defaultInterop()):builder.var(importedSource).read(importName):isDefault?builder.var(name).defaultInterop().prop(importName):isNamed&&builder.var(name).prop(importName));else if("compiled"===importedInterop)isModuleForNode?(builder.import(),isNamespace?builder.default(name||importedSource):(isDefault||isNamed)&&builder.default(importedSource).read(name)):isModuleForBabel?(builder.import(),isNamespace?builder.namespace(name||importedSource):(isDefault||isNamed)&&builder.named(name,importName)):(builder.require(),isNamespace?builder.var(name||importedSource):(isDefault||isNamed)&&(ensureLiveReference?builder.var(importedSource).read(name):builder.prop(importName).var(name)));else {if("uncompiled"!==importedInterop)throw new Error(`Unknown importedInterop "${importedInterop}".`);if(isDefault&&ensureLiveReference)throw new Error("No live reference for commonjs default");isModuleForNode?(builder.import(),isNamespace?builder.default(name||importedSource):isDefault?builder.default(name):isNamed&&builder.default(importedSource).read(name)):isModuleForBabel?(builder.import(),isNamespace?builder.default(name||importedSource):isDefault?builder.default(name):isNamed&&builder.named(name,importName)):(builder.require(),isNamespace?builder.var(name||importedSource):isDefault?builder.var(name):isNamed&&(ensureLiveReference?builder.var(importedSource).read(name):builder.var(name).prop(importName)));}}const{statements,resultName}=builder.done();return this._insertStatements(statements,importPosition,blockHoist),(isDefault||isNamed)&&ensureNoContext&&"Identifier"!==resultName.type?sequenceExpression([numericLiteral(0),resultName]):resultName}_insertStatements(statements,importPosition="before",blockHoist=3){const body=this._programPath.get("body");if("after"===importPosition){for(let i=body.length-1;i>=0;i--)if(body[i].isImportDeclaration())return void body[i].insertAfter(statements)}else {statements.forEach((node=>{node._blockHoist=blockHoist;}));const targetPath=body.find((p=>{const val=p.node._blockHoist;return Number.isFinite(val)&&val<4}));if(targetPath)return void targetPath.insertBefore(statements)}this._programPath.unshiftContainer("body",statements);}};},"./node_modules/@babel/helper-module-imports/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"ImportInjector",{enumerable:!0,get:function(){return _importInjector.default}}),exports.addDefault=function(path,importedSource,opts){return new _importInjector.default(path).addDefault(importedSource,opts)},exports.addNamed=function(path,name,importedSource,opts){return new _importInjector.default(path).addNamed(name,importedSource,opts)},exports.addNamespace=function(path,importedSource,opts){return new _importInjector.default(path).addNamespace(importedSource,opts)},exports.addSideEffect=function(path,importedSource,opts){return new _importInjector.default(path).addSideEffect(importedSource,opts)},Object.defineProperty(exports,"isModule",{enumerable:!0,get:function(){return _isModule.default}});var _importInjector=__webpack_require__("./node_modules/@babel/helper-module-imports/lib/import-injector.js"),_isModule=__webpack_require__("./node_modules/@babel/helper-module-imports/lib/is-module.js");},"./node_modules/@babel/helper-module-imports/lib/is-module.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(path){const{sourceType}=path.node;if("module"!==sourceType&&"script"!==sourceType)throw path.buildCodeFrameError(`Unknown sourceType "${sourceType}", cannot transform.`);return "module"===path.node.sourceType};},"./node_modules/@babel/helper-module-transforms/lib/get-module-name.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=getModuleName;{const originalGetModuleName=getModuleName;exports.default=getModuleName=function(rootOpts,pluginOpts){var _pluginOpts$moduleId,_pluginOpts$moduleIds,_pluginOpts$getModule,_pluginOpts$moduleRoo;return originalGetModuleName(rootOpts,{moduleId:null!=(_pluginOpts$moduleId=pluginOpts.moduleId)?_pluginOpts$moduleId:rootOpts.moduleId,moduleIds:null!=(_pluginOpts$moduleIds=pluginOpts.moduleIds)?_pluginOpts$moduleIds:rootOpts.moduleIds,getModuleId:null!=(_pluginOpts$getModule=pluginOpts.getModuleId)?_pluginOpts$getModule:rootOpts.getModuleId,moduleRoot:null!=(_pluginOpts$moduleRoo=pluginOpts.moduleRoot)?_pluginOpts$moduleRoo:rootOpts.moduleRoot})};}function getModuleName(rootOpts,pluginOpts){const{filename,filenameRelative=filename,sourceRoot=pluginOpts.moduleRoot}=rootOpts,{moduleId,moduleIds=!!moduleId,getModuleId,moduleRoot=sourceRoot}=pluginOpts;if(!moduleIds)return null;if(null!=moduleId&&!getModuleId)return moduleId;let moduleName=null!=moduleRoot?moduleRoot+"/":"";if(filenameRelative){const sourceRootReplacer=null!=sourceRoot?new RegExp("^"+sourceRoot+"/?"):"";moduleName+=filenameRelative.replace(sourceRootReplacer,"").replace(/\.(\w*?)$/,"");}return moduleName=moduleName.replace(/\\/g,"/"),getModuleId&&getModuleId(moduleName)||moduleName}},"./node_modules/@babel/helper-module-transforms/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.buildNamespaceInitStatements=function(metadata,sourceMetadata,constantReexports=!1){const statements=[];let srcNamespace=identifier(sourceMetadata.name);sourceMetadata.lazy&&(srcNamespace=callExpression(srcNamespace,[]));for(const localName of sourceMetadata.importsNamespace)localName!==sourceMetadata.name&&statements.push(_template.default.statement`var NAME = SOURCE;`({NAME:localName,SOURCE:cloneNode(srcNamespace)}));constantReexports&&statements.push(...buildReexportsFromMeta(metadata,sourceMetadata,!0));for(const exportName of sourceMetadata.reexportNamespace)statements.push((sourceMetadata.lazy?_template.default.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          `:_template.default.statement`EXPORTS.NAME = NAMESPACE;`)({EXPORTS:metadata.exportName,NAME:exportName,NAMESPACE:cloneNode(srcNamespace)}));if(sourceMetadata.reexportAll){const statement=function(metadata,namespace,constantReexports){return (constantReexports?_template.default.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      `:_template.default.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({NAMESPACE:namespace,EXPORTS:metadata.exportName,VERIFY_NAME_LIST:metadata.exportNameListName?_template.default`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({EXPORTS_LIST:metadata.exportNameListName}):null})}(metadata,cloneNode(srcNamespace),constantReexports);statement.loc=sourceMetadata.reexportAll.loc,statements.push(statement);}return statements},exports.ensureStatementsHoisted=function(statements){statements.forEach((header=>{header._blockHoist=3;}));},Object.defineProperty(exports,"getModuleName",{enumerable:!0,get:function(){return _getModuleName.default}}),Object.defineProperty(exports,"hasExports",{enumerable:!0,get:function(){return _normalizeAndLoadMetadata.hasExports}}),Object.defineProperty(exports,"isModule",{enumerable:!0,get:function(){return _helperModuleImports.isModule}}),Object.defineProperty(exports,"isSideEffectImport",{enumerable:!0,get:function(){return _normalizeAndLoadMetadata.isSideEffectImport}}),exports.rewriteModuleStatementsAndPrepareHeader=function(path,{loose,exportName,strict,allowTopLevelThis,strictMode,noInterop,importInterop=noInterop?"none":"babel",lazy,esNamespaceOnly,constantReexports=loose,enumerableModuleMeta=loose,noIncompleteNsImportDetection}){(0, _normalizeAndLoadMetadata.validateImportInteropOption)(importInterop),_assert((0, _helperModuleImports.isModule)(path),"Cannot process module statements in a script"),path.node.sourceType="script";const meta=(0, _normalizeAndLoadMetadata.default)(path,exportName,{importInterop,initializeReexports:constantReexports,lazy,esNamespaceOnly});allowTopLevelThis||(0, _rewriteThis.default)(path);if((0, _rewriteLiveReferences.default)(path,meta),!1!==strictMode){const hasStrict=path.node.directives.some((directive=>"use strict"===directive.value.value));hasStrict||path.unshiftContainer("directives",directive(directiveLiteral("use strict")));}const headers=[];(0, _normalizeAndLoadMetadata.hasExports)(meta)&&!strict&&headers.push(function(metadata,enumerableModuleMeta=!1){return (enumerableModuleMeta?_template.default.statement`
        EXPORTS.__esModule = true;
      `:_template.default.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({EXPORTS:metadata.exportName})}(meta,enumerableModuleMeta));const nameList=function(programPath,metadata){const exportedVars=Object.create(null);for(const data of metadata.local.values())for(const name of data.names)exportedVars[name]=!0;let hasReexport=!1;for(const data of metadata.source.values()){for(const exportName of data.reexports.keys())exportedVars[exportName]=!0;for(const exportName of data.reexportNamespace)exportedVars[exportName]=!0;hasReexport=hasReexport||!!data.reexportAll;}if(!hasReexport||0===Object.keys(exportedVars).length)return null;const name=programPath.scope.generateUidIdentifier("exportNames");return delete exportedVars.default,{name:name.name,statement:variableDeclaration("var",[variableDeclarator(name,valueToNode(exportedVars))])}}(path,meta);nameList&&(meta.exportNameListName=nameList.name,headers.push(nameList.statement));return headers.push(...function(programPath,metadata,constantReexports=!1,noIncompleteNsImportDetection=!1){const initStatements=[];for(const[localName,data]of metadata.local)if("import"===data.kind);else if("hoisted"===data.kind)initStatements.push([data.names[0],buildInitStatement(metadata,data.names,identifier(localName))]);else if(!noIncompleteNsImportDetection)for(const exportName of data.names)initStatements.push([exportName,null]);for(const data of metadata.source.values()){if(!constantReexports){const reexportsStatements=buildReexportsFromMeta(metadata,data,!1),reexports=[...data.reexports.keys()];for(let i=0;i<reexportsStatements.length;i++)initStatements.push([reexports[i],reexportsStatements[i]]);}if(!noIncompleteNsImportDetection)for(const exportName of data.reexportNamespace)initStatements.push([exportName,null]);}initStatements.sort(((a,b)=>a[0]>b[0]?1:-1));const results=[];if(noIncompleteNsImportDetection)for(const[,initStatement]of initStatements)results.push(initStatement);else {const chunkSize=100;for(let i=0,uninitializedExportNames=[];i<initStatements.length;i+=chunkSize){for(let j=0;j<chunkSize&&i+j<initStatements.length;j++){const[exportName,initStatement]=initStatements[i+j];null!==initStatement?(uninitializedExportNames.length>0&&(results.push(buildInitStatement(metadata,uninitializedExportNames,programPath.scope.buildUndefinedNode())),uninitializedExportNames=[]),results.push(initStatement)):uninitializedExportNames.push(exportName);}uninitializedExportNames.length>0&&results.push(buildInitStatement(metadata,uninitializedExportNames,programPath.scope.buildUndefinedNode()));}}return results}(path,meta,constantReexports,noIncompleteNsImportDetection)),{meta,headers}},Object.defineProperty(exports,"rewriteThis",{enumerable:!0,get:function(){return _rewriteThis.default}}),exports.wrapInterop=function(programPath,expr,type){if("none"===type)return null;if("node-namespace"===type)return callExpression(programPath.hub.addHelper("interopRequireWildcard"),[expr,booleanLiteral(!0)]);if("node-default"===type)return null;let helper;if("default"===type)helper="interopRequireDefault";else {if("namespace"!==type)throw new Error(`Unknown interop: ${type}`);helper="interopRequireWildcard";}return callExpression(programPath.hub.addHelper(helper),[expr])};var _assert=__webpack_require__("assert"),_t=__webpack_require__("./node_modules/@babel/types/lib/index.js"),_template=__webpack_require__("./node_modules/@babel/template/lib/index.js"),_helperModuleImports=__webpack_require__("./node_modules/@babel/helper-module-imports/lib/index.js"),_rewriteThis=__webpack_require__("./node_modules/@babel/helper-module-transforms/lib/rewrite-this.js"),_rewriteLiveReferences=__webpack_require__("./node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js"),_normalizeAndLoadMetadata=__webpack_require__("./node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js"),_getModuleName=__webpack_require__("./node_modules/@babel/helper-module-transforms/lib/get-module-name.js");const{booleanLiteral,callExpression,cloneNode,directive,directiveLiteral,expressionStatement,identifier,isIdentifier,memberExpression,stringLiteral,valueToNode,variableDeclaration,variableDeclarator}=_t;const ReexportTemplate={constant:_template.default.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,constantComputed:_template.default.statement`EXPORTS["EXPORT_NAME"] = NAMESPACE_IMPORT;`,spec:_template.default.statement`
    Object.defineProperty(EXPORTS, "EXPORT_NAME", {
      enumerable: true,
      get: function() {
        return NAMESPACE_IMPORT;
      },
    });
    `},buildReexportsFromMeta=(meta,metadata,constantReexports)=>{const namespace=metadata.lazy?callExpression(identifier(metadata.name),[]):identifier(metadata.name),{stringSpecifiers}=meta;return Array.from(metadata.reexports,(([exportName,importName])=>{let NAMESPACE_IMPORT=cloneNode(namespace);"default"===importName&&"node-default"===metadata.interop||(NAMESPACE_IMPORT=stringSpecifiers.has(importName)?memberExpression(NAMESPACE_IMPORT,stringLiteral(importName),!0):memberExpression(NAMESPACE_IMPORT,identifier(importName)));const astNodes={EXPORTS:meta.exportName,EXPORT_NAME:exportName,NAMESPACE_IMPORT};return constantReexports||isIdentifier(NAMESPACE_IMPORT)?stringSpecifiers.has(exportName)?ReexportTemplate.constantComputed(astNodes):ReexportTemplate.constant(astNodes):ReexportTemplate.spec(astNodes)}))};const InitTemplate={computed:_template.default.expression`EXPORTS["NAME"] = VALUE`,default:_template.default.expression`EXPORTS.NAME = VALUE`};function buildInitStatement(metadata,exportNames,initExpr){const{stringSpecifiers,exportName:EXPORTS}=metadata;return expressionStatement(exportNames.reduce(((acc,exportName)=>{const params={EXPORTS,NAME:exportName,VALUE:acc};return stringSpecifiers.has(exportName)?InitTemplate.computed(params):InitTemplate.default(params)}),initExpr))}},"./node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(programPath,exportName,{importInterop,initializeReexports=!1,lazy=!1,esNamespaceOnly=!1}){exportName||(exportName=programPath.scope.generateUidIdentifier("exports").name);const stringSpecifiers=new Set;!function(programPath){programPath.get("body").forEach((child=>{child.isExportDefaultDeclaration()&&(0, _helperSplitExportDeclaration.default)(child);}));}(programPath);const{local,source,hasExports}=function(programPath,{lazy,initializeReexports},stringSpecifiers){const localData=function(programPath,initializeReexports,stringSpecifiers){const bindingKindLookup=new Map;programPath.get("body").forEach((child=>{let kind;if(child.isImportDeclaration())kind="import";else {if(child.isExportDefaultDeclaration()&&(child=child.get("declaration")),child.isExportNamedDeclaration())if(child.node.declaration)child=child.get("declaration");else if(initializeReexports&&child.node.source&&child.get("source").isStringLiteral())return void child.get("specifiers").forEach((spec=>{assertExportSpecifier(spec),bindingKindLookup.set(spec.get("local").node.name,"block");}));if(child.isFunctionDeclaration())kind="hoisted";else if(child.isClassDeclaration())kind="block";else if(child.isVariableDeclaration({kind:"var"}))kind="var";else {if(!child.isVariableDeclaration())return;kind="block";}}Object.keys(child.getOuterBindingIdentifiers()).forEach((name=>{bindingKindLookup.set(name,kind);}));}));const localMetadata=new Map,getLocalMetadata=idPath=>{const localName=idPath.node.name;let metadata=localMetadata.get(localName);if(!metadata){const kind=bindingKindLookup.get(localName);if(void 0===kind)throw idPath.buildCodeFrameError(`Exporting local "${localName}", which is not declared.`);metadata={names:[],kind},localMetadata.set(localName,metadata);}return metadata};return programPath.get("body").forEach((child=>{if(!child.isExportNamedDeclaration()||!initializeReexports&&child.node.source){if(child.isExportDefaultDeclaration()){const declaration=child.get("declaration");if(!declaration.isFunctionDeclaration()&&!declaration.isClassDeclaration())throw declaration.buildCodeFrameError("Unexpected default expression export.");getLocalMetadata(declaration.get("id")).names.push("default");}}else if(child.node.declaration){const declaration=child.get("declaration"),ids=declaration.getOuterBindingIdentifierPaths();Object.keys(ids).forEach((name=>{if("__esModule"===name)throw declaration.buildCodeFrameError('Illegal export "__esModule".');getLocalMetadata(ids[name]).names.push(name);}));}else child.get("specifiers").forEach((spec=>{const local=spec.get("local"),exported=spec.get("exported"),localMetadata=getLocalMetadata(local),exportName=getExportSpecifierName(exported,stringSpecifiers);if("__esModule"===exportName)throw exported.buildCodeFrameError('Illegal export "__esModule".');localMetadata.names.push(exportName);}));})),localMetadata}(programPath,initializeReexports,stringSpecifiers),sourceData=new Map,getData=sourceNode=>{const source=sourceNode.value;let data=sourceData.get(source);return data||(data={name:programPath.scope.generateUidIdentifier((0, _path.basename)(source,(0, _path.extname)(source))).name,interop:"none",loc:null,imports:new Map,importsNamespace:new Set,reexports:new Map,reexportNamespace:new Set,reexportAll:null,lazy:!1,source},sourceData.set(source,data)),data};let hasExports=!1;programPath.get("body").forEach((child=>{if(child.isImportDeclaration()){const data=getData(child.node.source);data.loc||(data.loc=child.node.loc),child.get("specifiers").forEach((spec=>{if(spec.isImportDefaultSpecifier()){const localName=spec.get("local").node.name;data.imports.set(localName,"default");const reexport=localData.get(localName);reexport&&(localData.delete(localName),reexport.names.forEach((name=>{data.reexports.set(name,"default");})));}else if(spec.isImportNamespaceSpecifier()){const localName=spec.get("local").node.name;data.importsNamespace.add(localName);const reexport=localData.get(localName);reexport&&(localData.delete(localName),reexport.names.forEach((name=>{data.reexportNamespace.add(name);})));}else if(spec.isImportSpecifier()){const importName=getExportSpecifierName(spec.get("imported"),stringSpecifiers),localName=spec.get("local").node.name;data.imports.set(localName,importName);const reexport=localData.get(localName);reexport&&(localData.delete(localName),reexport.names.forEach((name=>{data.reexports.set(name,importName);})));}}));}else if(child.isExportAllDeclaration()){hasExports=!0;const data=getData(child.node.source);data.loc||(data.loc=child.node.loc),data.reexportAll={loc:child.node.loc};}else if(child.isExportNamedDeclaration()&&child.node.source){hasExports=!0;const data=getData(child.node.source);data.loc||(data.loc=child.node.loc),child.get("specifiers").forEach((spec=>{assertExportSpecifier(spec);const importName=getExportSpecifierName(spec.get("local"),stringSpecifiers),exportName=getExportSpecifierName(spec.get("exported"),stringSpecifiers);if(data.reexports.set(exportName,importName),"__esModule"===exportName)throw spec.get("exported").buildCodeFrameError('Illegal export "__esModule".')}));}else (child.isExportNamedDeclaration()||child.isExportDefaultDeclaration())&&(hasExports=!0);}));for(const metadata of sourceData.values()){let needsDefault=!1,needsNamed=!1;metadata.importsNamespace.size>0&&(needsDefault=!0,needsNamed=!0),metadata.reexportAll&&(needsNamed=!0);for(const importName of metadata.imports.values())"default"===importName?needsDefault=!0:needsNamed=!0;for(const importName of metadata.reexports.values())"default"===importName?needsDefault=!0:needsNamed=!0;needsDefault&&needsNamed?metadata.interop="namespace":needsDefault&&(metadata.interop="default");}for(const[source,metadata]of sourceData)if(!1!==lazy&&!isSideEffectImport(metadata)&&!metadata.reexportAll)if(!0===lazy)metadata.lazy=!/\./.test(source);else if(Array.isArray(lazy))metadata.lazy=-1!==lazy.indexOf(source);else {if("function"!=typeof lazy)throw new Error(".lazy must be a boolean, string array, or function");metadata.lazy=lazy(source);}return {hasExports,local:localData,source:sourceData}}(programPath,{initializeReexports,lazy},stringSpecifiers);!function(programPath){programPath.get("body").forEach((child=>{if(child.isImportDeclaration())child.remove();else if(child.isExportNamedDeclaration())child.node.declaration?(child.node.declaration._blockHoist=child.node._blockHoist,child.replaceWith(child.node.declaration)):child.remove();else if(child.isExportDefaultDeclaration()){const declaration=child.get("declaration");if(!declaration.isFunctionDeclaration()&&!declaration.isClassDeclaration())throw declaration.buildCodeFrameError("Unexpected default expression export.");declaration._blockHoist=child.node._blockHoist,child.replaceWith(declaration);}else child.isExportAllDeclaration()&&child.remove();}));}(programPath);for(const[,metadata]of source){metadata.importsNamespace.size>0&&(metadata.name=metadata.importsNamespace.values().next().value);const resolvedInterop=resolveImportInterop(importInterop,metadata.source);"none"===resolvedInterop?metadata.interop="none":"node"===resolvedInterop&&"namespace"===metadata.interop?metadata.interop="node-namespace":"node"===resolvedInterop&&"default"===metadata.interop?metadata.interop="node-default":esNamespaceOnly&&"namespace"===metadata.interop&&(metadata.interop="default");}return {exportName,exportNameListName:null,hasExports,local,source,stringSpecifiers}},exports.hasExports=function(metadata){return metadata.hasExports},exports.isSideEffectImport=isSideEffectImport,exports.validateImportInteropOption=validateImportInteropOption;var _path=__webpack_require__("path"),_helperValidatorIdentifier=__webpack_require__("./node_modules/@babel/helper-validator-identifier/lib/index.js"),_helperSplitExportDeclaration=__webpack_require__("./node_modules/@babel/helper-split-export-declaration/lib/index.js");function isSideEffectImport(source){return 0===source.imports.size&&0===source.importsNamespace.size&&0===source.reexports.size&&0===source.reexportNamespace.size&&!source.reexportAll}function validateImportInteropOption(importInterop){if("function"!=typeof importInterop&&"none"!==importInterop&&"babel"!==importInterop&&"node"!==importInterop)throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${importInterop}).`);return importInterop}function resolveImportInterop(importInterop,source){return "function"==typeof importInterop?validateImportInteropOption(importInterop(source)):importInterop}function getExportSpecifierName(path,stringSpecifiers){if(path.isIdentifier())return path.node.name;if(path.isStringLiteral()){const stringValue=path.node.value;return (0, _helperValidatorIdentifier.isIdentifierName)(stringValue)||stringSpecifiers.add(stringValue),stringValue}throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`)}function assertExportSpecifier(path){if(!path.isExportSpecifier())throw path.isExportNamespaceSpecifier()?path.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-proposal-export-namespace-from`."):path.buildCodeFrameError("Unexpected export specifier type")}},"./node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(programPath,metadata){const imported=new Map,exported=new Map,requeueInParent=path=>{programPath.requeue(path);};for(const[source,data]of metadata.source){for(const[localName,importName]of data.imports)imported.set(localName,[source,importName,null]);for(const localName of data.importsNamespace)imported.set(localName,[source,null,localName]);}for(const[local,data]of metadata.local){let exportMeta=exported.get(local);exportMeta||(exportMeta=[],exported.set(local,exportMeta)),exportMeta.push(...data.names);}const rewriteBindingInitVisitorState={metadata,requeueInParent,scope:programPath.scope,exported};programPath.traverse(rewriteBindingInitVisitor,rewriteBindingInitVisitorState),(0, _helperSimpleAccess.default)(programPath,new Set([...Array.from(imported.keys()),...Array.from(exported.keys())]));const rewriteReferencesVisitorState={seen:new WeakSet,metadata,requeueInParent,scope:programPath.scope,imported,exported,buildImportReference:([source,importName,localName],identNode)=>{const meta=metadata.source.get(source);if(localName)return meta.lazy&&(identNode=callExpression(identNode,[])),identNode;let namespace=identifier(meta.name);if(meta.lazy&&(namespace=callExpression(namespace,[])),"default"===importName&&"node-default"===meta.interop)return namespace;const computed=metadata.stringSpecifiers.has(importName);return memberExpression(namespace,computed?stringLiteral(importName):identifier(importName),computed)}};programPath.traverse(rewriteReferencesVisitor,rewriteReferencesVisitorState);};var _assert=__webpack_require__("assert"),_t=__webpack_require__("./node_modules/@babel/types/lib/index.js"),_template=__webpack_require__("./node_modules/@babel/template/lib/index.js"),_helperSimpleAccess=__webpack_require__("./node_modules/@babel/helper-simple-access/lib/index.js");const{assignmentExpression,callExpression,cloneNode,expressionStatement,getOuterBindingIdentifiers,identifier,isMemberExpression,isVariableDeclaration,jsxIdentifier,jsxMemberExpression,memberExpression,numericLiteral,sequenceExpression,stringLiteral,variableDeclaration,variableDeclarator}=_t;const rewriteBindingInitVisitor={Scope(path){path.skip();},ClassDeclaration(path){const{requeueInParent,exported,metadata}=this,{id}=path.node;if(!id)throw new Error("Expected class to have a name");const localName=id.name,exportNames=exported.get(localName)||[];if(exportNames.length>0){const statement=expressionStatement(buildBindingExportAssignmentExpression(metadata,exportNames,identifier(localName)));statement._blockHoist=path.node._blockHoist,requeueInParent(path.insertAfter(statement)[0]);}},VariableDeclaration(path){const{requeueInParent,exported,metadata}=this;Object.keys(path.getOuterBindingIdentifiers()).forEach((localName=>{const exportNames=exported.get(localName)||[];if(exportNames.length>0){const statement=expressionStatement(buildBindingExportAssignmentExpression(metadata,exportNames,identifier(localName)));statement._blockHoist=path.node._blockHoist,requeueInParent(path.insertAfter(statement)[0]);}}));}},buildBindingExportAssignmentExpression=(metadata,exportNames,localExpr)=>(exportNames||[]).reduce(((expr,exportName)=>{const{stringSpecifiers}=metadata,computed=stringSpecifiers.has(exportName);return assignmentExpression("=",memberExpression(identifier(metadata.exportName),computed?stringLiteral(exportName):identifier(exportName),computed),expr)}),localExpr),buildImportThrow=localName=>_template.default.expression.ast`
    (function() {
      throw new Error('"' + '${localName}' + '" is read-only.');
    })()
  `,rewriteReferencesVisitor={ReferencedIdentifier(path){const{seen,buildImportReference,scope,imported,requeueInParent}=this;if(seen.has(path.node))return;seen.add(path.node);const localName=path.node.name,importData=imported.get(localName);if(importData){if(function(path){do{switch(path.parent.type){case"TSTypeAnnotation":case"TSTypeAliasDeclaration":case"TSTypeReference":case"TypeAnnotation":case"TypeAlias":return !0;case"ExportSpecifier":return "type"===path.parentPath.parent.exportKind;default:if(path.parentPath.isStatement()||path.parentPath.isExpression())return !1}}while(path=path.parentPath)}(path))throw path.buildCodeFrameError(`Cannot transform the imported binding "${localName}" since it's also used in a type annotation. Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);const localBinding=path.scope.getBinding(localName);if(scope.getBinding(localName)!==localBinding)return;const ref=buildImportReference(importData,path.node);if(ref.loc=path.node.loc,(path.parentPath.isCallExpression({callee:path.node})||path.parentPath.isOptionalCallExpression({callee:path.node})||path.parentPath.isTaggedTemplateExpression({tag:path.node}))&&isMemberExpression(ref))path.replaceWith(sequenceExpression([numericLiteral(0),ref]));else if(path.isJSXIdentifier()&&isMemberExpression(ref)){const{object,property}=ref;path.replaceWith(jsxMemberExpression(jsxIdentifier(object.name),jsxIdentifier(property.name)));}else path.replaceWith(ref);requeueInParent(path),path.skip();}},AssignmentExpression:{exit(path){const{scope,seen,imported,exported,requeueInParent,buildImportReference}=this;if(seen.has(path.node))return;seen.add(path.node);const left=path.get("left");if(!left.isMemberExpression())if(left.isIdentifier()){const localName=left.node.name;if(scope.getBinding(localName)!==path.scope.getBinding(localName))return;const exportedNames=exported.get(localName),importData=imported.get(localName);if((null==exportedNames?void 0:exportedNames.length)>0||importData){_assert("="===path.node.operator,"Path was not simplified");const assignment=path.node;importData&&(assignment.left=buildImportReference(importData,assignment.left),assignment.right=sequenceExpression([assignment.right,buildImportThrow(localName)])),path.replaceWith(buildBindingExportAssignmentExpression(this.metadata,exportedNames,assignment)),requeueInParent(path);}}else {const ids=left.getOuterBindingIdentifiers(),programScopeIds=Object.keys(ids).filter((localName=>scope.getBinding(localName)===path.scope.getBinding(localName))),id=programScopeIds.find((localName=>imported.has(localName)));id&&(path.node.right=sequenceExpression([path.node.right,buildImportThrow(id)]));const items=[];if(programScopeIds.forEach((localName=>{const exportedNames=exported.get(localName)||[];exportedNames.length>0&&items.push(buildBindingExportAssignmentExpression(this.metadata,exportedNames,identifier(localName)));})),items.length>0){let node=sequenceExpression(items);path.parentPath.isExpressionStatement()&&(node=expressionStatement(node),node._blockHoist=path.parentPath.node._blockHoist);requeueInParent(path.insertAfter(node)[0]);}}}},"ForOfStatement|ForInStatement"(path){const{scope,node}=path,{left}=node,{exported,imported,scope:programScope}=this;if(!isVariableDeclaration(left)){let importConstViolationName,didTransformExport=!1;const loopBodyScope=path.get("body").scope;for(const name of Object.keys(getOuterBindingIdentifiers(left)))programScope.getBinding(name)===scope.getBinding(name)&&(exported.has(name)&&(didTransformExport=!0,loopBodyScope.hasOwnBinding(name)&&loopBodyScope.rename(name)),imported.has(name)&&!importConstViolationName&&(importConstViolationName=name));if(!didTransformExport&&!importConstViolationName)return;path.ensureBlock();const bodyPath=path.get("body"),newLoopId=scope.generateUidIdentifierBasedOnNode(left);path.get("left").replaceWith(variableDeclaration("let",[variableDeclarator(cloneNode(newLoopId))])),scope.registerDeclaration(path.get("left")),didTransformExport&&bodyPath.unshiftContainer("body",expressionStatement(assignmentExpression("=",left,newLoopId))),importConstViolationName&&bodyPath.unshiftContainer("body",expressionStatement(buildImportThrow(importConstViolationName)));}}};},"./node_modules/@babel/helper-module-transforms/lib/rewrite-this.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(programPath){(0, _traverse.default)(programPath.node,Object.assign({},rewriteThisVisitor,{noScope:!0}));};var _helperEnvironmentVisitor=__webpack_require__("./node_modules/@babel/helper-environment-visitor/lib/index.js"),_traverse=__webpack_require__("./node_modules/@babel/traverse/lib/index.js"),_t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{numericLiteral,unaryExpression}=_t;const rewriteThisVisitor=_traverse.default.visitors.merge([_helperEnvironmentVisitor.default,{ThisExpression(path){path.replaceWith(unaryExpression("void",numericLiteral(0),!0));}}]);},"./node_modules/@babel/helper-optimise-call-expression/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(callee,thisNode,args,optional){return 1===args.length&&isSpreadElement(args[0])&&isIdentifier(args[0].argument,{name:"arguments"})?optional?optionalCallExpression(optionalMemberExpression(callee,identifier("apply"),!1,!0),[thisNode,args[0].argument],!1):callExpression(memberExpression(callee,identifier("apply")),[thisNode,args[0].argument]):optional?optionalCallExpression(optionalMemberExpression(callee,identifier("call"),!1,!0),[thisNode,...args],!1):callExpression(memberExpression(callee,identifier("call")),[thisNode,...args])};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{callExpression,identifier,isIdentifier,isSpreadElement,memberExpression,optionalCallExpression,optionalMemberExpression}=_t;},"./node_modules/@babel/helper-plugin-utils/lib/index.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.declare=function(builder){return (api,options,dirname)=>{var _clonedApi2;let clonedApi;for(const name of Object.keys(apiPolyfills)){var _clonedApi;api[name]||(clonedApi=null!=(_clonedApi=clonedApi)?_clonedApi:copyApiObject(api),clonedApi[name]=apiPolyfills[name](clonedApi));}return builder(null!=(_clonedApi2=clonedApi)?_clonedApi2:api,options||{},dirname)}};const apiPolyfills={assertVersion:api=>range=>{!function(range,version){if("number"==typeof range){if(!Number.isInteger(range))throw new Error("Expected string or integer value.");range=`^${range}.0.0-0`;}if("string"!=typeof range)throw new Error("Expected string or integer value.");const limit=Error.stackTraceLimit;"number"==typeof limit&&limit<25&&(Error.stackTraceLimit=25);let err;err="7."===version.slice(0,2)?new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${version}". You'll need to update your @babel/core version.`):new Error(`Requires Babel "${range}", but was loaded with "${version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);"number"==typeof limit&&(Error.stackTraceLimit=limit);throw Object.assign(err,{code:"BABEL_VERSION_UNSUPPORTED",version,range})}(range,api.version);},targets:()=>()=>({}),assumption:()=>()=>{}};function copyApiObject(api){let proto=null;return "string"==typeof api.version&&/^7\./.test(api.version)&&(proto=Object.getPrototypeOf(api),!proto||has(proto,"version")&&has(proto,"transform")&&has(proto,"template")&&has(proto,"types")||(proto=null)),Object.assign({},proto,api)}function has(obj,key){return Object.prototype.hasOwnProperty.call(obj,key)}},"./node_modules/@babel/helper-replace-supers/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0,Object.defineProperty(exports,"environmentVisitor",{enumerable:!0,get:function(){return _helperEnvironmentVisitor.default}}),Object.defineProperty(exports,"skipAllButComputedKey",{enumerable:!0,get:function(){return _helperEnvironmentVisitor.skipAllButComputedKey}});var _traverse=__webpack_require__("./node_modules/@babel/traverse/lib/index.js"),_helperMemberExpressionToFunctions=__webpack_require__("./node_modules/@babel/helper-member-expression-to-functions/lib/index.js"),_helperOptimiseCallExpression=__webpack_require__("./node_modules/@babel/helper-optimise-call-expression/lib/index.js"),_helperEnvironmentVisitor=__webpack_require__("./node_modules/@babel/helper-environment-visitor/lib/index.js"),_t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{assignmentExpression,booleanLiteral,callExpression,cloneNode,identifier,memberExpression,sequenceExpression,stringLiteral,thisExpression}=_t;function getPrototypeOfExpression(objectRef,isStatic,file,isPrivateMethod){objectRef=cloneNode(objectRef);const targetRef=isStatic||isPrivateMethod?objectRef:memberExpression(objectRef,identifier("prototype"));return callExpression(file.addHelper("getPrototypeOf"),[targetRef])}const visitor=_traverse.default.visitors.merge([_helperEnvironmentVisitor.default,{Super(path,state){const{node,parentPath}=path;parentPath.isMemberExpression({object:node})&&state.handle(parentPath);}}]),unshadowSuperBindingVisitor=_traverse.default.visitors.merge([_helperEnvironmentVisitor.default,{Scopable(path,{refName}){const binding=path.scope.getOwnBinding(refName);binding&&binding.identifier.name===refName&&path.scope.rename(refName);}}]),specHandlers={memoise(superMember,count){const{scope,node}=superMember,{computed,property}=node;if(!computed)return;const memo=scope.maybeGenerateMemoised(property);memo&&this.memoiser.set(property,memo,count);},prop(superMember){const{computed,property}=superMember.node;return this.memoiser.has(property)?cloneNode(this.memoiser.get(property)):computed?cloneNode(property):stringLiteral(property.name)},get(superMember){return this._get(superMember,this._getThisRefs())},_get(superMember,thisRefs){const proto=getPrototypeOfExpression(this.getObjectRef(),this.isStatic,this.file,this.isPrivateMethod);return callExpression(this.file.addHelper("get"),[thisRefs.memo?sequenceExpression([thisRefs.memo,proto]):proto,this.prop(superMember),thisRefs.this])},_getThisRefs(){if(!this.isDerivedConstructor)return {this:thisExpression()};const thisRef=this.scope.generateDeclaredUidIdentifier("thisSuper");return {memo:assignmentExpression("=",thisRef,thisExpression()),this:cloneNode(thisRef)}},set(superMember,value){const thisRefs=this._getThisRefs(),proto=getPrototypeOfExpression(this.getObjectRef(),this.isStatic,this.file,this.isPrivateMethod);return callExpression(this.file.addHelper("set"),[thisRefs.memo?sequenceExpression([thisRefs.memo,proto]):proto,this.prop(superMember),value,thisRefs.this,booleanLiteral(superMember.isInStrictMode())])},destructureSet(superMember){throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.")},call(superMember,args){const thisRefs=this._getThisRefs();return (0, _helperOptimiseCallExpression.default)(this._get(superMember,thisRefs),cloneNode(thisRefs.this),args,!1)},optionalCall(superMember,args){const thisRefs=this._getThisRefs();return (0, _helperOptimiseCallExpression.default)(this._get(superMember,thisRefs),cloneNode(thisRefs.this),args,!0)}},looseHandlers=Object.assign({},specHandlers,{prop(superMember){const{property}=superMember.node;return this.memoiser.has(property)?cloneNode(this.memoiser.get(property)):cloneNode(property)},get(superMember){const{isStatic,getSuperRef}=this,{computed}=superMember.node,prop=this.prop(superMember);let object;var _getSuperRef,_getSuperRef2;isStatic?object=null!=(_getSuperRef=getSuperRef())?_getSuperRef:memberExpression(identifier("Function"),identifier("prototype")):object=memberExpression(null!=(_getSuperRef2=getSuperRef())?_getSuperRef2:identifier("Object"),identifier("prototype"));return memberExpression(object,prop,computed)},set(superMember,value){const{computed}=superMember.node,prop=this.prop(superMember);return assignmentExpression("=",memberExpression(thisExpression(),prop,computed),value)},destructureSet(superMember){const{computed}=superMember.node,prop=this.prop(superMember);return memberExpression(thisExpression(),prop,computed)},call(superMember,args){return (0, _helperOptimiseCallExpression.default)(this.get(superMember),thisExpression(),args,!1)},optionalCall(superMember,args){return (0, _helperOptimiseCallExpression.default)(this.get(superMember),thisExpression(),args,!0)}});exports.default=class{constructor(opts){var _opts$constantSuper;const path=opts.methodPath;this.methodPath=path,this.isDerivedConstructor=path.isClassMethod({kind:"constructor"})&&!!opts.superRef,this.isStatic=path.isObjectMethod()||path.node.static||(null==path.isStaticBlock?void 0:path.isStaticBlock()),this.isPrivateMethod=path.isPrivate()&&path.isMethod(),this.file=opts.file,this.constantSuper=null!=(_opts$constantSuper=opts.constantSuper)?_opts$constantSuper:opts.isLoose,this.opts=opts;}getObjectRef(){return cloneNode(this.opts.objectRef||this.opts.getObjectRef())}getSuperRef(){return this.opts.superRef?cloneNode(this.opts.superRef):this.opts.getSuperRef?cloneNode(this.opts.getSuperRef()):void 0}replace(){this.opts.refToPreserve&&this.methodPath.traverse(unshadowSuperBindingVisitor,{refName:this.opts.refToPreserve.name});const handler=this.constantSuper?looseHandlers:specHandlers;(0, _helperMemberExpressionToFunctions.default)(this.methodPath,visitor,Object.assign({file:this.file,scope:this.methodPath.scope,isDerivedConstructor:this.isDerivedConstructor,isStatic:this.isStatic,isPrivateMethod:this.isPrivateMethod,getObjectRef:this.getObjectRef.bind(this),getSuperRef:this.getSuperRef.bind(this),boundGet:handler.get},handler));}};},"./node_modules/@babel/helper-simple-access/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(path,bindingNames){path.traverse(simpleAssignmentVisitor,{scope:path.scope,bindingNames,seen:new WeakSet});};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{LOGICAL_OPERATORS,assignmentExpression,binaryExpression,cloneNode,identifier,logicalExpression,numericLiteral,sequenceExpression,unaryExpression}=_t;const simpleAssignmentVisitor={UpdateExpression:{exit(path){const{scope,bindingNames}=this,arg=path.get("argument");if(!arg.isIdentifier())return;const localName=arg.node.name;if(bindingNames.has(localName)&&scope.getBinding(localName)===path.scope.getBinding(localName))if(path.parentPath.isExpressionStatement()&&!path.isCompletionRecord()){const operator="++"==path.node.operator?"+=":"-=";path.replaceWith(assignmentExpression(operator,arg.node,numericLiteral(1)));}else if(path.node.prefix)path.replaceWith(assignmentExpression("=",identifier(localName),binaryExpression(path.node.operator[0],unaryExpression("+",arg.node),numericLiteral(1))));else {const old=path.scope.generateUidIdentifierBasedOnNode(arg.node,"old"),varName=old.name;path.scope.push({id:old});const binary=binaryExpression(path.node.operator[0],identifier(varName),numericLiteral(1));path.replaceWith(sequenceExpression([assignmentExpression("=",identifier(varName),unaryExpression("+",arg.node)),assignmentExpression("=",cloneNode(arg.node),binary),identifier(varName)]));}}},AssignmentExpression:{exit(path){const{scope,seen,bindingNames}=this;if("="===path.node.operator)return;if(seen.has(path.node))return;seen.add(path.node);const left=path.get("left");if(!left.isIdentifier())return;const localName=left.node.name;if(!bindingNames.has(localName))return;if(scope.getBinding(localName)!==path.scope.getBinding(localName))return;const operator=path.node.operator.slice(0,-1);LOGICAL_OPERATORS.includes(operator)?path.replaceWith(logicalExpression(operator,path.node.left,assignmentExpression("=",cloneNode(path.node.left),path.node.right))):(path.node.right=binaryExpression(operator,cloneNode(path.node.left),path.node.right),path.node.operator="=");}}};},"./node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.isTransparentExprWrapper=isTransparentExprWrapper,exports.skipTransparentExprWrapperNodes=function(node){for(;isTransparentExprWrapper(node);)node=node.expression;return node},exports.skipTransparentExprWrappers=function(path){for(;isTransparentExprWrapper(path.node);)path=path.get("expression");return path};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{isParenthesizedExpression,isTSAsExpression,isTSNonNullExpression,isTSTypeAssertion,isTypeCastExpression}=_t;function isTransparentExprWrapper(node){return isTSAsExpression(node)||isTSTypeAssertion(node)||isTSNonNullExpression(node)||isTypeCastExpression(node)||isParenthesizedExpression(node)}},"./node_modules/@babel/helper-split-export-declaration/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(exportDeclaration){if(!exportDeclaration.isExportDeclaration())throw new Error("Only export declarations can be split.");const isDefault=exportDeclaration.isExportDefaultDeclaration(),declaration=exportDeclaration.get("declaration"),isClassDeclaration=declaration.isClassDeclaration();if(isDefault){const standaloneDeclaration=declaration.isFunctionDeclaration()||isClassDeclaration,scope=declaration.isScope()?declaration.scope.parent:declaration.scope;let id=declaration.node.id,needBindingRegistration=!1;id||(needBindingRegistration=!0,id=scope.generateUidIdentifier("default"),(standaloneDeclaration||declaration.isFunctionExpression()||declaration.isClassExpression())&&(declaration.node.id=cloneNode(id)));const updatedDeclaration=standaloneDeclaration?declaration:variableDeclaration("var",[variableDeclarator(cloneNode(id),declaration.node)]),updatedExportDeclaration=exportNamedDeclaration(null,[exportSpecifier(cloneNode(id),identifier("default"))]);return exportDeclaration.insertAfter(updatedExportDeclaration),exportDeclaration.replaceWith(updatedDeclaration),needBindingRegistration&&scope.registerDeclaration(exportDeclaration),exportDeclaration}if(exportDeclaration.get("specifiers").length>0)throw new Error("It doesn't make sense to split exported specifiers.");const bindingIdentifiers=declaration.getOuterBindingIdentifiers(),specifiers=Object.keys(bindingIdentifiers).map((name=>exportSpecifier(identifier(name),identifier(name)))),aliasDeclar=exportNamedDeclaration(null,specifiers);return exportDeclaration.insertAfter(aliasDeclar),exportDeclaration.replaceWith(declaration.node),exportDeclaration};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{cloneNode,exportNamedDeclaration,exportSpecifier,identifier,variableDeclaration,variableDeclarator}=_t;},"./node_modules/@babel/helper-validator-identifier/lib/identifier.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.isIdentifierChar=isIdentifierChar,exports.isIdentifierName=function(name){let isFirst=!0;for(let i=0;i<name.length;i++){let cp=name.charCodeAt(i);if(55296==(64512&cp)&&i+1<name.length){const trail=name.charCodeAt(++i);56320==(64512&trail)&&(cp=65536+((1023&cp)<<10)+(1023&trail));}if(isFirst){if(isFirst=!1,!isIdentifierStart(cp))return !1}else if(!isIdentifierChar(cp))return !1}return !isFirst},exports.isIdentifierStart=isIdentifierStart;let nonASCIIidentifierStartChars="ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",nonASCIIidentifierChars="‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";const nonASCIIidentifierStart=new RegExp("["+nonASCIIidentifierStartChars+"]"),nonASCIIidentifier=new RegExp("["+nonASCIIidentifierStartChars+nonASCIIidentifierChars+"]");nonASCIIidentifierStartChars=nonASCIIidentifierChars=null;const astralIdentifierStartCodes=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,13,10,2,14,2,6,2,1,2,10,2,14,2,6,2,1,68,310,10,21,11,7,25,5,2,41,2,8,70,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,43,17,47,20,28,22,13,52,58,1,3,0,14,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,38,6,186,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,19,72,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2637,96,16,1070,4050,582,8634,568,8,30,18,78,18,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8936,3,2,6,2,1,2,290,46,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,1845,30,482,44,11,6,17,0,322,29,19,43,1269,6,2,3,2,1,2,14,2,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42719,33,4152,8,221,3,5761,15,7472,3104,541,1507,4938],astralIdentifierCodes=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,50,3,123,2,54,14,32,10,3,1,11,3,46,10,8,0,46,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,87,9,39,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,4706,45,3,22,543,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,357,0,62,13,1495,6,110,6,6,9,4759,9,787719,239];function isInAstralSet(code,set){let pos=65536;for(let i=0,length=set.length;i<length;i+=2){if(pos+=set[i],pos>code)return !1;if(pos+=set[i+1],pos>=code)return !0}return !1}function isIdentifierStart(code){return code<65?36===code:code<=90||(code<97?95===code:code<=122||(code<=65535?code>=170&&nonASCIIidentifierStart.test(String.fromCharCode(code)):isInAstralSet(code,astralIdentifierStartCodes)))}function isIdentifierChar(code){return code<48?36===code:code<58||!(code<65)&&(code<=90||(code<97?95===code:code<=122||(code<=65535?code>=170&&nonASCIIidentifier.test(String.fromCharCode(code)):isInAstralSet(code,astralIdentifierStartCodes)||isInAstralSet(code,astralIdentifierCodes))))}},"./node_modules/@babel/helper-validator-identifier/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"isIdentifierChar",{enumerable:!0,get:function(){return _identifier.isIdentifierChar}}),Object.defineProperty(exports,"isIdentifierName",{enumerable:!0,get:function(){return _identifier.isIdentifierName}}),Object.defineProperty(exports,"isIdentifierStart",{enumerable:!0,get:function(){return _identifier.isIdentifierStart}}),Object.defineProperty(exports,"isKeyword",{enumerable:!0,get:function(){return _keyword.isKeyword}}),Object.defineProperty(exports,"isReservedWord",{enumerable:!0,get:function(){return _keyword.isReservedWord}}),Object.defineProperty(exports,"isStrictBindOnlyReservedWord",{enumerable:!0,get:function(){return _keyword.isStrictBindOnlyReservedWord}}),Object.defineProperty(exports,"isStrictBindReservedWord",{enumerable:!0,get:function(){return _keyword.isStrictBindReservedWord}}),Object.defineProperty(exports,"isStrictReservedWord",{enumerable:!0,get:function(){return _keyword.isStrictReservedWord}});var _identifier=__webpack_require__("./node_modules/@babel/helper-validator-identifier/lib/identifier.js"),_keyword=__webpack_require__("./node_modules/@babel/helper-validator-identifier/lib/keyword.js");},"./node_modules/@babel/helper-validator-identifier/lib/keyword.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.isKeyword=function(word){return keywords.has(word)},exports.isReservedWord=isReservedWord,exports.isStrictBindOnlyReservedWord=isStrictBindOnlyReservedWord,exports.isStrictBindReservedWord=function(word,inModule){return isStrictReservedWord(word,inModule)||isStrictBindOnlyReservedWord(word)},exports.isStrictReservedWord=isStrictReservedWord;const reservedWords_strict=["implements","interface","let","package","private","protected","public","static","yield"],reservedWords_strictBind=["eval","arguments"],keywords=new Set(["break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","const","while","with","new","this","super","class","extends","export","import","null","true","false","in","instanceof","typeof","void","delete"]),reservedWordsStrictSet=new Set(reservedWords_strict),reservedWordsStrictBindSet=new Set(reservedWords_strictBind);function isReservedWord(word,inModule){return inModule&&"await"===word||"enum"===word}function isStrictReservedWord(word,inModule){return isReservedWord(word,inModule)||reservedWordsStrictSet.has(word)}function isStrictBindOnlyReservedWord(word){return reservedWordsStrictBindSet.has(word)}},"./node_modules/@babel/helpers/lib/helpers-generated.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _template=__webpack_require__("./node_modules/@babel/template/lib/index.js");function helper(minVersion,source){return Object.freeze({minVersion,ast:()=>_template.default.program.ast(source)})}var _default=Object.freeze({asyncIterator:helper("7.15.9",'export default function _asyncIterator(iterable){var method,async,sync,retry=2;for("undefined"!=typeof Symbol&&(async=Symbol.asyncIterator,sync=Symbol.iterator);retry--;){if(async&&null!=(method=iterable[async]))return method.call(iterable);if(sync&&null!=(method=iterable[sync]))return new AsyncFromSyncIterator(method.call(iterable));async="@@asyncIterator",sync="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(s){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var done=r.done;return Promise.resolve(r.value).then((function(value){return{value:value,done:done}}))}return AsyncFromSyncIterator=function(s){this.s=s,this.n=s.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(value){var ret=this.s.return;return void 0===ret?Promise.resolve({value:value,done:!0}):AsyncFromSyncIteratorContinuation(ret.apply(this.s,arguments))},throw:function(value){var thr=this.s.return;return void 0===thr?Promise.reject(value):AsyncFromSyncIteratorContinuation(thr.apply(this.s,arguments))}},new AsyncFromSyncIterator(s)}'),jsx:helper("7.0.0-beta.0",'var REACT_ELEMENT_TYPE;export default function _createRawReactElement(type,props,key,children){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var defaultProps=type&&type.defaultProps,childrenLength=arguments.length-3;if(props||0===childrenLength||(props={children:void 0}),1===childrenLength)props.children=children;else if(childrenLength>1){for(var childArray=new Array(childrenLength),i=0;i<childrenLength;i++)childArray[i]=arguments[i+3];props.children=childArray}if(props&&defaultProps)for(var propName in defaultProps)void 0===props[propName]&&(props[propName]=defaultProps[propName]);else props||(props=defaultProps||{});return{$$typeof:REACT_ELEMENT_TYPE,type:type,key:void 0===key?null:""+key,ref:null,props:props,_owner:null}}'),objectSpread2:helper("7.5.0",'import defineProperty from"defineProperty";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}export default function _objectSpread2(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach((function(key){defineProperty(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}'),typeof:helper("7.0.0-beta.0",'export default function _typeof(obj){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof(obj)}'),wrapRegExp:helper("7.2.6",'import setPrototypeOf from"setPrototypeOf";import inherits from"inherits";export default function _wrapRegExp(){_wrapRegExp=function(re,groups){return new BabelRegExp(re,void 0,groups)};var _super=RegExp.prototype,_groups=new WeakMap;function BabelRegExp(re,flags,groups){var _this=new RegExp(re,flags);return _groups.set(_this,groups||_groups.get(re)),setPrototypeOf(_this,BabelRegExp.prototype)}function buildGroups(result,re){var g=_groups.get(re);return Object.keys(g).reduce((function(groups,name){return groups[name]=result[g[name]],groups}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(str){var result=_super.exec.call(this,str);return result&&(result.groups=buildGroups(result,this)),result},BabelRegExp.prototype[Symbol.replace]=function(str,substitution){if("string"==typeof substitution){var groups=_groups.get(this);return _super[Symbol.replace].call(this,str,substitution.replace(/\\$<([^>]+)>/g,(function(_,name){return"$"+groups[name]})))}if("function"==typeof substitution){var _this=this;return _super[Symbol.replace].call(this,str,(function(){var args=arguments;return"object"!=typeof args[args.length-1]&&(args=[].slice.call(args)).push(buildGroups(args,_this)),substitution.apply(this,args)}))}return _super[Symbol.replace].call(this,str,substitution)},_wrapRegExp.apply(this,arguments)}')});exports.default=_default;},"./node_modules/@babel/helpers/lib/helpers.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _template=__webpack_require__("./node_modules/@babel/template/lib/index.js"),_helpersGenerated=__webpack_require__("./node_modules/@babel/helpers/lib/helpers-generated.js");const helpers=Object.assign({__proto__:null},_helpersGenerated.default);var _default=helpers;exports.default=_default;const helper=minVersion=>tpl=>({minVersion,ast:()=>_template.default.program.ast(tpl)});helpers.AwaitValue=helper("7.0.0-beta.0")`
  export default function _AwaitValue(value) {
    this.wrapped = value;
  }
`,helpers.AsyncGenerator=helper("7.0.0-beta.0")`
  import AwaitValue from "AwaitValue";

  export default function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null,
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg)
        var value = result.value;
        var wrappedAwait = value instanceof AwaitValue;

        Promise.resolve(wrappedAwait ? value.wrapped : value).then(
          function (arg) {
            if (wrappedAwait) {
              resume(key === "return" ? "return" : "next", arg);
              return
            }

            settle(result.done ? "return" : "normal", arg);
          },
          function (err) { resume("throw", err); });
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({ value: value, done: true });
          break;
        case "throw":
          front.reject(value);
          break;
        default:
          front.resolve({ value: value, done: false });
          break;
      }

      front = front.next;
      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    // Hide "return" method if generator return is not supported
    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; };

  AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };
  AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };
  AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };
`,helpers.wrapAsyncGenerator=helper("7.0.0-beta.0")`
  import AsyncGenerator from "AsyncGenerator";

  export default function _wrapAsyncGenerator(fn) {
    return function () {
      return new AsyncGenerator(fn.apply(this, arguments));
    };
  }
`,helpers.awaitAsyncGenerator=helper("7.0.0-beta.0")`
  import AwaitValue from "AwaitValue";

  export default function _awaitAsyncGenerator(value) {
    return new AwaitValue(value);
  }
`,helpers.asyncGeneratorDelegate=helper("7.0.0-beta.0")`
  export default function _asyncGeneratorDelegate(inner, awaitWrap) {
    var iter = {}, waiting = false;

    function pump(key, value) {
      waiting = true;
      value = new Promise(function (resolve) { resolve(inner[key](value)); });
      return { done: false, value: awaitWrap(value) };
    };

    iter[typeof Symbol !== "undefined" && Symbol.iterator || "@@iterator"] = function () { return this; };

    iter.next = function (value) {
      if (waiting) {
        waiting = false;
        return value;
      }
      return pump("next", value);
    };

    if (typeof inner.throw === "function") {
      iter.throw = function (value) {
        if (waiting) {
          waiting = false;
          throw value;
        }
        return pump("throw", value);
      };
    }

    if (typeof inner.return === "function") {
      iter.return = function (value) {
        if (waiting) {
          waiting = false;
          return value;
        }
        return pump("return", value);
      };
    }

    return iter;
  }
`,helpers.asyncToGenerator=helper("7.0.0-beta.0")`
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  export default function _asyncToGenerator(fn) {
    return function () {
      var self = this, args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }
`,helpers.classCallCheck=helper("7.0.0-beta.0")`
  export default function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
`,helpers.createClass=helper("7.0.0-beta.0")`
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i ++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  export default function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
`,helpers.defineEnumerableProperties=helper("7.0.0-beta.0")`
  export default function _defineEnumerableProperties(obj, descs) {
    for (var key in descs) {
      var desc = descs[key];
      desc.configurable = desc.enumerable = true;
      if ("value" in desc) desc.writable = true;
      Object.defineProperty(obj, key, desc);
    }

    // Symbols are not enumerated over by for-in loops. If native
    // Symbols are available, fetch all of the descs object's own
    // symbol properties and define them on our target object too.
    if (Object.getOwnPropertySymbols) {
      var objectSymbols = Object.getOwnPropertySymbols(descs);
      for (var i = 0; i < objectSymbols.length; i++) {
        var sym = objectSymbols[i];
        var desc = descs[sym];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, sym, desc);
      }
    }
    return obj;
  }
`,helpers.defaults=helper("7.0.0-beta.0")`
  export default function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);
      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }
    return obj;
  }
`,helpers.defineProperty=helper("7.0.0-beta.0")`
  export default function _defineProperty(obj, key, value) {
    // Shortcircuit the slow defineProperty path when possible.
    // We are trying to avoid issues where setters defined on the
    // prototype cause side effects under the fast path of simple
    // assignment. By checking for existence of the property with
    // the in operator, we can optimize most of this overhead away.
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
`,helpers.extends=helper("7.0.0-beta.0")`
  export default function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };

    return _extends.apply(this, arguments);
  }
`,helpers.objectSpread=helper("7.0.0-beta.0")`
  import defineProperty from "defineProperty";

  export default function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = (arguments[i] != null) ? Object(arguments[i]) : {};
      var ownKeys = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys.forEach(function(key) {
        defineProperty(target, key, source[key]);
      });
    }
    return target;
  }
`,helpers.inherits=helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    // We can't use defineProperty to set the prototype in a single step because it
    // doesn't work in Chrome <= 36. https://github.com/babel/babel/issues/14056
    // V8 bug: https://bugs.chromium.org/p/v8/issues/detail?id=3334
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", { writable: false });
    if (superClass) setPrototypeOf(subClass, superClass);
  }
`,helpers.inheritsLoose=helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    setPrototypeOf(subClass, superClass);
  }
`,helpers.getPrototypeOf=helper("7.0.0-beta.0")`
  export default function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
    return _getPrototypeOf(o);
  }
`,helpers.setPrototypeOf=helper("7.0.0-beta.0")`
  export default function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
`,helpers.isNativeReflectConstruct=helper("7.9.0")`
  export default function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;

    // core-js@3
    if (Reflect.construct.sham) return false;

    // Proxy can't be polyfilled. Every browser implemented
    // proxies before or at the same time as Reflect.construct,
    // so if they support Proxy they also support Reflect.construct.
    if (typeof Proxy === "function") return true;

    // Since Reflect.construct can't be properly polyfilled, some
    // implementations (e.g. core-js@2) don't set the correct internal slots.
    // Those polyfills don't allow us to subclass built-ins, so we need to
    // use our fallback implementation.
    try {
      // If the internal slots aren't set, this throws an error similar to
      //   TypeError: this is not a Boolean object.

      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
      return true;
    } catch (e) {
      return false;
    }
  }
`,helpers.construct=helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";
  import isNativeReflectConstruct from "isNativeReflectConstruct";

  export default function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      // NOTE: If Parent !== Class, the correct __proto__ is set *after*
      //       calling the constructor.
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }
    // Avoid issues with Class being present but undefined when it wasn't
    // present in the original call.
    return _construct.apply(null, arguments);
  }
`,helpers.isNativeFunction=helper("7.0.0-beta.0")`
  export default function _isNativeFunction(fn) {
    // Note: This function returns "true" for core-js functions.
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
`,helpers.wrapNativeSuper=helper("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";
  import setPrototypeOf from "setPrototypeOf";
  import isNativeFunction from "isNativeFunction";
  import construct from "construct";

  export default function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !isNativeFunction(Class)) return Class;
      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return construct(Class, arguments, getPrototypeOf(this).constructor)
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true,
        }
      });

      return setPrototypeOf(Wrapper, Class);
    }

    return _wrapNativeSuper(Class)
  }
`,helpers.instanceof=helper("7.0.0-beta.0")`
  export default function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
`,helpers.interopRequireDefault=helper("7.0.0-beta.0")`
  export default function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
`,helpers.interopRequireWildcard=helper("7.14.0")`
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;

    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function (nodeInterop) {
      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }

  export default function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }

    if (obj === null || (typeof obj !== "object" && typeof obj !== "function")) {
      return { default: obj }
    }

    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
`,helpers.newArrowCheck=helper("7.0.0-beta.0")`
  export default function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  }
`,helpers.objectDestructuringEmpty=helper("7.0.0-beta.0")`
  export default function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure undefined");
  }
`,helpers.objectWithoutPropertiesLoose=helper("7.0.0-beta.0")`
  export default function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};

    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }
`,helpers.objectWithoutProperties=helper("7.0.0-beta.0")`
  import objectWithoutPropertiesLoose from "objectWithoutPropertiesLoose";

  export default function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }
`,helpers.assertThisInitialized=helper("7.0.0-beta.0")`
  export default function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
`,helpers.possibleConstructorReturn=helper("7.0.0-beta.0")`
  import assertThisInitialized from "assertThisInitialized";

  export default function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return assertThisInitialized(self);
  }
`,helpers.createSuper=helper("7.9.0")`
  import getPrototypeOf from "getPrototypeOf";
  import isNativeReflectConstruct from "isNativeReflectConstruct";
  import possibleConstructorReturn from "possibleConstructorReturn";

  export default function _createSuper(Derived) {
    var hasNativeReflectConstruct = isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        // NOTE: This doesn't work if this.__proto__.constructor has been modified.
        var NewTarget = getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return possibleConstructorReturn(this, result);
    }
  }
 `,helpers.superPropBase=helper("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";

  export default function _superPropBase(object, property) {
    // Yes, this throws if object is null to being with, that's on purpose.
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
`,helpers.get=helper("7.0.0-beta.0")`
  import superPropBase from "superPropBase";

  export default function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);

        if (!base) return;

        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          // STEP 3. If receiver is not present, then set receiver to target.
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }
`,helpers.set=helper("7.0.0-beta.0")`
  import superPropBase from "superPropBase";
  import defineProperty from "defineProperty";

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = superPropBase(target, property);
        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            // Both getter and non-writable fall into this.
            return false;
          }
        }

        // Without a super that defines the property, spec boils down to
        // "define on receiver" for some reason.
        desc = Object.getOwnPropertyDescriptor(receiver, property);
        if (desc) {
          if (!desc.writable) {
            // Setter, getter, and non-writable fall into this.
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          // Avoid setters that may be defined on Sub's prototype, but not on
          // the instance.
          defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  export default function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s && isStrict) {
      throw new Error('failed to set property');
    }

    return value;
  }
`,helpers.taggedTemplateLiteral=helper("7.0.0-beta.0")`
  export default function _taggedTemplateLiteral(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    return Object.freeze(Object.defineProperties(strings, {
        raw: { value: Object.freeze(raw) }
    }));
  }
`,helpers.taggedTemplateLiteralLoose=helper("7.0.0-beta.0")`
  export default function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    strings.raw = raw;
    return strings;
  }
`,helpers.readOnlyError=helper("7.0.0-beta.0")`
  export default function _readOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is read-only");
  }
`,helpers.writeOnlyError=helper("7.12.13")`
  export default function _writeOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is write-only");
  }
`,helpers.classNameTDZError=helper("7.0.0-beta.0")`
  export default function _classNameTDZError(name) {
    throw new Error("Class \\"" + name + "\\" cannot be referenced in computed property keys.");
  }
`,helpers.temporalUndefined=helper("7.0.0-beta.0")`
  // This function isn't mean to be called, but to be used as a reference.
  // We can't use a normal object because it isn't hoisted.
  export default function _temporalUndefined() {}
`,helpers.tdz=helper("7.5.5")`
  export default function _tdzError(name) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  }
`,helpers.temporalRef=helper("7.0.0-beta.0")`
  import undef from "temporalUndefined";
  import err from "tdz";

  export default function _temporalRef(val, name) {
    return val === undef ? err(name) : val;
  }
`,helpers.slicedToArray=helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimit from "iterableToArrayLimit";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArray(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimit(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`,helpers.slicedToArrayLoose=helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimitLoose from "iterableToArrayLimitLoose";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArrayLoose(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimitLoose(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`,helpers.toArray=helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _toArray(arr) {
    return (
      arrayWithHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableRest()
    );
  }
`,helpers.toConsumableArray=helper("7.0.0-beta.0")`
  import arrayWithoutHoles from "arrayWithoutHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableSpread from "nonIterableSpread";

  export default function _toConsumableArray(arr) {
    return (
      arrayWithoutHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableSpread()
    );
  }
`,helpers.arrayWithoutHoles=helper("7.0.0-beta.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }
`,helpers.arrayWithHoles=helper("7.0.0-beta.0")`
  export default function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
`,helpers.maybeArrayLike=helper("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _maybeArrayLike(next, arr, i) {
    if (arr && !Array.isArray(arr) && typeof arr.length === "number") {
      var len = arr.length;
      return arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);
    }
    return next(arr, i);
  }
`,helpers.iterableToArray=helper("7.0.0-beta.0")`
  export default function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
`,helpers.iterableToArrayLimit=helper("7.0.0-beta.0")`
  export default function _iterableToArrayLimit(arr, i) {
    // this is an expanded form of \`for...of\` that properly supports abrupt completions of
    // iterators etc. variable names have been minimised to reduce the size of this massive
    // helper. sometimes spec compliance is annoying :(
    //
    // _n = _iteratorNormalCompletion
    // _d = _didIteratorError
    // _e = _iteratorError
    // _i = _iterator
    // _s = _step

    var _i = arr == null ? null : (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
    if (_i == null) return;

    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
`,helpers.iterableToArrayLimitLoose=helper("7.0.0-beta.0")`
  export default function _iterableToArrayLimitLoose(arr, i) {
    var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
    if (_i == null) return;

    var _arr = [];
    for (_i = _i.call(arr), _step; !(_step = _i.next()).done;) {
      _arr.push(_step.value);
      if (i && _arr.length === i) break;
    }
    return _arr;
  }
`,helpers.unsupportedIterableToArray=helper("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return arrayLikeToArray(o, minLen);
  }
`,helpers.arrayLikeToArray=helper("7.9.0")`
  export default function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
`,helpers.nonIterableSpread=helper("7.0.0-beta.0")`
  export default function _nonIterableSpread() {
    throw new TypeError(
      "Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`,helpers.nonIterableRest=helper("7.0.0-beta.0")`
  export default function _nonIterableRest() {
    throw new TypeError(
      "Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`,helpers.createForOfIteratorHelper=helper("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  // s: start (create the iterator)
  // n: next
  // e: error (called whenever something throws)
  // f: finish (always called at the end)

  export default function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      // Fallback for engines without symbol support
      if (
        Array.isArray(o) ||
        (it = unsupportedIterableToArray(o)) ||
        (allowArrayLike && o && typeof o.length === "number")
      ) {
        if (it) o = it;
        var i = 0;
        var F = function(){};
        return {
          s: F,
          n: function() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          },
          e: function(e) { throw e; },
          f: F,
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true, didErr = false, err;

    return {
      s: function() {
        it = it.call(o);
      },
      n: function() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function(e) {
        didErr = true;
        err = e;
      },
      f: function() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
`,helpers.createForOfIteratorHelperLoose=helper("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);

    // Fallback for engines without symbol support
    if (
      Array.isArray(o) ||
      (it = unsupportedIterableToArray(o)) ||
      (allowArrayLike && o && typeof o.length === "number")
    ) {
      if (it) o = it;
      var i = 0;
      return function() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
`,helpers.skipFirstGeneratorNext=helper("7.0.0-beta.0")`
  export default function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    }
  }
`,helpers.toPrimitive=helper("7.1.5")`
  export default function _toPrimitive(
    input,
    hint /*: "default" | "string" | "number" | void */
  ) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
`,helpers.toPropertyKey=helper("7.1.5")`
  import toPrimitive from "toPrimitive";

  export default function _toPropertyKey(arg) {
    var key = toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
`,helpers.initializerWarningHelper=helper("7.0.0-beta.0")`
    export default function _initializerWarningHelper(descriptor, context){
        throw new Error(
          'Decorating class property failed. Please ensure that ' +
          'proposal-class-properties is enabled and runs after the decorators transform.'
        );
    }
`,helpers.initializerDefineProperty=helper("7.0.0-beta.0")`
    export default function _initializerDefineProperty(target, property, descriptor, context){
        if (!descriptor) return;

        Object.defineProperty(target, property, {
            enumerable: descriptor.enumerable,
            configurable: descriptor.configurable,
            writable: descriptor.writable,
            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,
        });
    }
`,helpers.applyDecoratedDescriptor=helper("7.0.0-beta.0")`
    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){
        var desc = {};
        Object.keys(descriptor).forEach(function(key){
            desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;
        if ('value' in desc || desc.initializer){
            desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function(desc, decorator){
            return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0){
            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
            desc.initializer = undefined;
        }

        if (desc.initializer === void 0){
            Object.defineProperty(target, property, desc);
            desc = null;
        }

        return desc;
    }
`,helpers.classPrivateFieldLooseKey=helper("7.0.0-beta.0")`
  var id = 0;
  export default function _classPrivateFieldKey(name) {
    return "__private_" + (id++) + "_" + name;
  }
`,helpers.classPrivateFieldLooseBase=helper("7.0.0-beta.0")`
  export default function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
`,helpers.classPrivateFieldGet=helper("7.0.0-beta.0")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`,helpers.classPrivateFieldSet=helper("7.0.0-beta.0")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`,helpers.classPrivateFieldDestructureSet=helper("7.4.4")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`,helpers.classExtractFieldDescriptor=helper("7.13.10")`
  export default function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
  }
`,helpers.classStaticPrivateFieldSpecGet=helper("7.0.2")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`,helpers.classStaticPrivateFieldSpecSet=helper("7.0.2")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`,helpers.classStaticPrivateMethodGet=helper("7.3.2")`
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    return method;
  }
`,helpers.classStaticPrivateMethodSet=helper("7.3.2")`
  export default function _classStaticPrivateMethodSet() {
    throw new TypeError("attempted to set read only static private field");
  }
`,helpers.classApplyDescriptorGet=helper("7.13.10")`
  export default function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }
    return descriptor.value;
  }
`,helpers.classApplyDescriptorSet=helper("7.13.10")`
  export default function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }
      descriptor.value = value;
    }
  }
`,helpers.classApplyDescriptorDestructureSet=helper("7.13.10")`
  export default function _classApplyDescriptorDestructureSet(receiver, descriptor) {
    if (descriptor.set) {
      if (!("__destrObj" in descriptor)) {
        descriptor.__destrObj = {
          set value(v) {
            descriptor.set.call(receiver, v)
          },
        };
      }
      return descriptor.__destrObj;
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }

      return descriptor;
    }
  }
`,helpers.classStaticPrivateFieldDestructureSet=helper("7.13.10")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`,helpers.classCheckPrivateStaticAccess=helper("7.13.10")`
  export default function _classCheckPrivateStaticAccess(receiver, classConstructor) {
    if (receiver !== classConstructor) {
      throw new TypeError("Private static access of wrong provenance");
    }
  }
`,helpers.classCheckPrivateStaticFieldDescriptor=helper("7.13.10")`
  export default function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
    if (descriptor === undefined) {
      throw new TypeError("attempted to " + action + " private static field before its declaration");
    }
  }
`,helpers.decorate=helper("7.1.5")`
  import toArray from "toArray";
  import toPropertyKey from "toPropertyKey";

  // These comments are stripped by @babel/template
  /*::
  type PropertyDescriptor =
    | {
        value: any,
        writable: boolean,
        configurable: boolean,
        enumerable: boolean,
      }
    | {
        get?: () => any,
        set?: (v: any) => void,
        configurable: boolean,
        enumerable: boolean,
      };

  type FieldDescriptor ={
    writable: boolean,
    configurable: boolean,
    enumerable: boolean,
  };

  type Placement = "static" | "prototype" | "own";
  type Key = string | symbol; // PrivateName is not supported yet.

  type ElementDescriptor =
    | {
        kind: "method",
        key: Key,
        placement: Placement,
        descriptor: PropertyDescriptor
      }
    | {
        kind: "field",
        key: Key,
        placement: Placement,
        descriptor: FieldDescriptor,
        initializer?: () => any,
      };

  // This is exposed to the user code
  type ElementObjectInput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
  };

  // This is exposed to the user code
  type ElementObjectOutput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
    extras?: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  // This is exposed to the user code
  type ClassObject = {
    [@@toStringTag]?: "Descriptor",
    kind: "class",
    elements: ElementDescriptor[],
  };

  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;
  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;
  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;

  // Only used by Babel in the transform output, not part of the spec.
  type ElementDefinition =
    | {
        kind: "method",
        value: any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
      }
    | {
        kind: "field",
        value: () => any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
    };

  declare function ClassFactory<C>(initialize: (instance: C) => void): {
    F: Class<C>,
    d: ElementDefinition[]
  }

  */

  /*::
  // Various combinations with/without extras and with one or many finishers

  type ElementFinisherExtras = {
    element: ElementDescriptor,
    finisher?: ClassFinisher,
    extras?: ElementDescriptor[],
  };

  type ElementFinishersExtras = {
    element: ElementDescriptor,
    finishers: ClassFinisher[],
    extras: ElementDescriptor[],
  };

  type ElementsFinisher = {
    elements: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  type ElementsFinishers = {
    elements: ElementDescriptor[],
    finishers: ClassFinisher[],
  };

  */

  /*::

  type Placements = {
    static: Key[],
    prototype: Key[],
    own: Key[],
  };

  */

  // ClassDefinitionEvaluation (Steps 26-*)
  export default function _decorate(
    decorators /*: ClassDecorator[] */,
    factory /*: ClassFactory */,
    superClass /*: ?Class<*> */,
    mixins /*: ?Array<Function> */,
  ) /*: Class<*> */ {
    var api = _getDecoratorsApi();
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        api = mixins[i](api);
      }
    }

    var r = factory(function initialize(O) {
      api.initializeInstanceElements(O, decorated.elements);
    }, superClass);
    var decorated = api.decorateClass(
      _coalesceClassElements(r.d.map(_createElementDescriptor)),
      decorators,
    );

    api.initializeClassElements(r.F, decorated.elements);

    return api.runClassFinishers(r.F, decorated.finishers);
  }

  function _getDecoratorsApi() {
    _getDecoratorsApi = function() {
      return api;
    };

    var api = {
      elementsDefinitionOrder: [["method"], ["field"]],

      // InitializeInstanceElements
      initializeInstanceElements: function(
        /*::<C>*/ O /*: C */,
        elements /*: ElementDescriptor[] */,
      ) {
        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            if (element.kind === kind && element.placement === "own") {
              this.defineClassElement(O, element);
            }
          }, this);
        }, this);
      },

      // InitializeClassElements
      initializeClassElements: function(
        /*::<C>*/ F /*: Class<C> */,
        elements /*: ElementDescriptor[] */,
      ) {
        var proto = F.prototype;

        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            var placement = element.placement;
            if (
              element.kind === kind &&
              (placement === "static" || placement === "prototype")
            ) {
              var receiver = placement === "static" ? F : proto;
              this.defineClassElement(receiver, element);
            }
          }, this);
        }, this);
      },

      // DefineClassElement
      defineClassElement: function(
        /*::<C>*/ receiver /*: C | Class<C> */,
        element /*: ElementDescriptor */,
      ) {
        var descriptor /*: PropertyDescriptor */ = element.descriptor;
        if (element.kind === "field") {
          var initializer = element.initializer;
          descriptor = {
            enumerable: descriptor.enumerable,
            writable: descriptor.writable,
            configurable: descriptor.configurable,
            value: initializer === void 0 ? void 0 : initializer.call(receiver),
          };
        }
        Object.defineProperty(receiver, element.key, descriptor);
      },

      // DecorateClass
      decorateClass: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var newElements /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];
        var placements /*: Placements */ = {
          static: [],
          prototype: [],
          own: [],
        };

        elements.forEach(function(element /*: ElementDescriptor */) {
          this.addElementPlacement(element, placements);
        }, this);

        elements.forEach(function(element /*: ElementDescriptor */) {
          if (!_hasDecorators(element)) return newElements.push(element);

          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(
            element,
            placements,
          );
          newElements.push(elementFinishersExtras.element);
          newElements.push.apply(newElements, elementFinishersExtras.extras);
          finishers.push.apply(finishers, elementFinishersExtras.finishers);
        }, this);

        if (!decorators) {
          return { elements: newElements, finishers: finishers };
        }

        var result /*: ElementsFinishers */ = this.decorateConstructor(
          newElements,
          decorators,
        );
        finishers.push.apply(finishers, result.finishers);
        result.finishers = finishers;

        return result;
      },

      // AddElementPlacement
      addElementPlacement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
        silent /*: boolean */,
      ) {
        var keys = placements[element.placement];
        if (!silent && keys.indexOf(element.key) !== -1) {
          throw new TypeError("Duplicated element (" + element.key + ")");
        }
        keys.push(element.key);
      },

      // DecorateElement
      decorateElement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
      ) /*: ElementFinishersExtras */ {
        var extras /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];

        for (
          var decorators = element.decorators, i = decorators.length - 1;
          i >= 0;
          i--
        ) {
          // (inlined) RemoveElementPlacement
          var keys = placements[element.placement];
          keys.splice(keys.indexOf(element.key), 1);

          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(
            element,
          );
          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(
            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||
              elementObject,
          );

          element = elementFinisherExtras.element;
          this.addElementPlacement(element, placements);

          if (elementFinisherExtras.finisher) {
            finishers.push(elementFinisherExtras.finisher);
          }

          var newExtras /*: ElementDescriptor[] | void */ =
            elementFinisherExtras.extras;
          if (newExtras) {
            for (var j = 0; j < newExtras.length; j++) {
              this.addElementPlacement(newExtras[j], placements);
            }
            extras.push.apply(extras, newExtras);
          }
        }

        return { element: element, finishers: finishers, extras: extras };
      },

      // DecorateConstructor
      decorateConstructor: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var finishers /*: ClassFinisher[] */ = [];

        for (var i = decorators.length - 1; i >= 0; i--) {
          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);
          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(
            (0, decorators[i])(obj) /*: ClassObject */ || obj,
          );

          if (elementsAndFinisher.finisher !== undefined) {
            finishers.push(elementsAndFinisher.finisher);
          }

          if (elementsAndFinisher.elements !== undefined) {
            elements = elementsAndFinisher.elements;

            for (var j = 0; j < elements.length - 1; j++) {
              for (var k = j + 1; k < elements.length; k++) {
                if (
                  elements[j].key === elements[k].key &&
                  elements[j].placement === elements[k].placement
                ) {
                  throw new TypeError(
                    "Duplicated element (" + elements[j].key + ")",
                  );
                }
              }
            }
          }
        }

        return { elements: elements, finishers: finishers };
      },

      // FromElementDescriptor
      fromElementDescriptor: function(
        element /*: ElementDescriptor */,
      ) /*: ElementObject */ {
        var obj /*: ElementObject */ = {
          kind: element.kind,
          key: element.key,
          placement: element.placement,
          descriptor: element.descriptor,
        };

        var desc = {
          value: "Descriptor",
          configurable: true,
        };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        if (element.kind === "field") obj.initializer = element.initializer;

        return obj;
      },

      // ToElementDescriptors
      toElementDescriptors: function(
        elementObjects /*: ElementObject[] */,
      ) /*: ElementDescriptor[] */ {
        if (elementObjects === undefined) return;
        return toArray(elementObjects).map(function(elementObject) {
          var element = this.toElementDescriptor(elementObject);
          this.disallowProperty(elementObject, "finisher", "An element descriptor");
          this.disallowProperty(elementObject, "extras", "An element descriptor");
          return element;
        }, this);
      },

      // ToElementDescriptor
      toElementDescriptor: function(
        elementObject /*: ElementObject */,
      ) /*: ElementDescriptor */ {
        var kind = String(elementObject.kind);
        if (kind !== "method" && kind !== "field") {
          throw new TypeError(
            'An element descriptor\\'s .kind property must be either "method" or' +
              ' "field", but a decorator created an element descriptor with' +
              ' .kind "' +
              kind +
              '"',
          );
        }

        var key = toPropertyKey(elementObject.key);

        var placement = String(elementObject.placement);
        if (
          placement !== "static" &&
          placement !== "prototype" &&
          placement !== "own"
        ) {
          throw new TypeError(
            'An element descriptor\\'s .placement property must be one of "static",' +
              ' "prototype" or "own", but a decorator created an element descriptor' +
              ' with .placement "' +
              placement +
              '"',
          );
        }

        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;

        this.disallowProperty(elementObject, "elements", "An element descriptor");

        var element /*: ElementDescriptor */ = {
          kind: kind,
          key: key,
          placement: placement,
          descriptor: Object.assign({}, descriptor),
        };

        if (kind !== "field") {
          this.disallowProperty(elementObject, "initializer", "A method descriptor");
        } else {
          this.disallowProperty(
            descriptor,
            "get",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "set",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "value",
            "The property descriptor of a field descriptor",
          );

          element.initializer = elementObject.initializer;
        }

        return element;
      },

      toElementFinisherExtras: function(
        elementObject /*: ElementObject */,
      ) /*: ElementFinisherExtras */ {
        var element /*: ElementDescriptor */ = this.toElementDescriptor(
          elementObject,
        );
        var finisher /*: ClassFinisher */ = _optionalCallableProperty(
          elementObject,
          "finisher",
        );
        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(
          elementObject.extras,
        );

        return { element: element, finisher: finisher, extras: extras };
      },

      // FromClassDescriptor
      fromClassDescriptor: function(
        elements /*: ElementDescriptor[] */,
      ) /*: ClassObject */ {
        var obj = {
          kind: "class",
          elements: elements.map(this.fromElementDescriptor, this),
        };

        var desc = { value: "Descriptor", configurable: true };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        return obj;
      },

      // ToClassDescriptor
      toClassDescriptor: function(
        obj /*: ClassObject */,
      ) /*: ElementsFinisher */ {
        var kind = String(obj.kind);
        if (kind !== "class") {
          throw new TypeError(
            'A class descriptor\\'s .kind property must be "class", but a decorator' +
              ' created a class descriptor with .kind "' +
              kind +
              '"',
          );
        }

        this.disallowProperty(obj, "key", "A class descriptor");
        this.disallowProperty(obj, "placement", "A class descriptor");
        this.disallowProperty(obj, "descriptor", "A class descriptor");
        this.disallowProperty(obj, "initializer", "A class descriptor");
        this.disallowProperty(obj, "extras", "A class descriptor");

        var finisher = _optionalCallableProperty(obj, "finisher");
        var elements = this.toElementDescriptors(obj.elements);

        return { elements: elements, finisher: finisher };
      },

      // RunClassFinishers
      runClassFinishers: function(
        constructor /*: Class<*> */,
        finishers /*: ClassFinisher[] */,
      ) /*: Class<*> */ {
        for (var i = 0; i < finishers.length; i++) {
          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);
          if (newConstructor !== undefined) {
            // NOTE: This should check if IsConstructor(newConstructor) is false.
            if (typeof newConstructor !== "function") {
              throw new TypeError("Finishers must return a constructor.");
            }
            constructor = newConstructor;
          }
        }
        return constructor;
      },

      disallowProperty: function(obj, name, objectType) {
        if (obj[name] !== undefined) {
          throw new TypeError(objectType + " can't have a ." + name + " property.");
        }
      }
    };

    return api;
  }

  // ClassElementEvaluation
  function _createElementDescriptor(
    def /*: ElementDefinition */,
  ) /*: ElementDescriptor */ {
    var key = toPropertyKey(def.key);

    var descriptor /*: PropertyDescriptor */;
    if (def.kind === "method") {
      descriptor = {
        value: def.value,
        writable: true,
        configurable: true,
        enumerable: false,
      };
    } else if (def.kind === "get") {
      descriptor = { get: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "set") {
      descriptor = { set: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "field") {
      descriptor = { configurable: true, writable: true, enumerable: true };
    }

    var element /*: ElementDescriptor */ = {
      kind: def.kind === "field" ? "field" : "method",
      key: key,
      placement: def.static
        ? "static"
        : def.kind === "field"
        ? "own"
        : "prototype",
      descriptor: descriptor,
    };
    if (def.decorators) element.decorators = def.decorators;
    if (def.kind === "field") element.initializer = def.value;

    return element;
  }

  // CoalesceGetterSetter
  function _coalesceGetterSetter(
    element /*: ElementDescriptor */,
    other /*: ElementDescriptor */,
  ) {
    if (element.descriptor.get !== undefined) {
      other.descriptor.get = element.descriptor.get;
    } else {
      other.descriptor.set = element.descriptor.set;
    }
  }

  // CoalesceClassElements
  function _coalesceClassElements(
    elements /*: ElementDescriptor[] */,
  ) /*: ElementDescriptor[] */ {
    var newElements /*: ElementDescriptor[] */ = [];

    var isSameElement = function(
      other /*: ElementDescriptor */,
    ) /*: boolean */ {
      return (
        other.kind === "method" &&
        other.key === element.key &&
        other.placement === element.placement
      );
    };

    for (var i = 0; i < elements.length; i++) {
      var element /*: ElementDescriptor */ = elements[i];
      var other /*: ElementDescriptor */;

      if (
        element.kind === "method" &&
        (other = newElements.find(isSameElement))
      ) {
        if (
          _isDataDescriptor(element.descriptor) ||
          _isDataDescriptor(other.descriptor)
        ) {
          if (_hasDecorators(element) || _hasDecorators(other)) {
            throw new ReferenceError(
              "Duplicated methods (" + element.key + ") can't be decorated.",
            );
          }
          other.descriptor = element.descriptor;
        } else {
          if (_hasDecorators(element)) {
            if (_hasDecorators(other)) {
              throw new ReferenceError(
                "Decorators can't be placed on different accessors with for " +
                  "the same property (" +
                  element.key +
                  ").",
              );
            }
            other.decorators = element.decorators;
          }
          _coalesceGetterSetter(element, other);
        }
      } else {
        newElements.push(element);
      }
    }

    return newElements;
  }

  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {
    return element.decorators && element.decorators.length;
  }

  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {
    return (
      desc !== undefined &&
      !(desc.value === undefined && desc.writable === undefined)
    );
  }

  function _optionalCallableProperty /*::<T>*/(
    obj /*: T */,
    name /*: $Keys<T> */,
  ) /*: ?Function */ {
    var value = obj[name];
    if (value !== undefined && typeof value !== "function") {
      throw new TypeError("Expected '" + name + "' to be a function");
    }
    return value;
  }

`,helpers.classPrivateMethodGet=helper("7.1.6")`
  export default function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
  }
`,helpers.checkPrivateRedeclaration=helper("7.14.1")`
  export default function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
      throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
  }
`,helpers.classPrivateFieldInitSpec=helper("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateFieldInitSpec(obj, privateMap, value) {
    checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
  }
`,helpers.classPrivateMethodInitSpec=helper("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateMethodInitSpec(obj, privateSet) {
    checkPrivateRedeclaration(obj, privateSet);
    privateSet.add(obj);
  }
`,helpers.classPrivateMethodSet=helper("7.1.6")`
    export default function _classPrivateMethodSet() {
      throw new TypeError("attempted to reassign private method");
    }
  `;},"./node_modules/@babel/helpers/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0,exports.ensure=function(name,newFileClass){fileClass||(fileClass=newFileClass);loadHelper(name);},exports.get=get,exports.getDependencies=function(name){return Array.from(loadHelper(name).dependencies.values())},exports.list=void 0,exports.minVersion=function(name){return loadHelper(name).minVersion()};var _traverse=__webpack_require__("./node_modules/@babel/traverse/lib/index.js"),_t=__webpack_require__("./node_modules/@babel/types/lib/index.js"),_helpers=__webpack_require__("./node_modules/@babel/helpers/lib/helpers.js");const{assignmentExpression,cloneNode,expressionStatement,file:t_file,identifier,variableDeclaration,variableDeclarator}=_t;function makePath(path){const parts=[];for(;path.parentPath;path=path.parentPath)parts.push(path.key),path.inList&&parts.push(path.listKey);return parts.reverse().join(".")}let fileClass;const helperData=Object.create(null);function loadHelper(name){if(!helperData[name]){const helper=_helpers.default[name];if(!helper)throw Object.assign(new ReferenceError(`Unknown helper ${name}`),{code:"BABEL_HELPER_UNKNOWN",helper:name});const fn=()=>{const file={ast:t_file(helper.ast())};return fileClass?new fileClass({filename:`babel-helper://${name}`},file):file},metadata=function(file){const globals=new Set,localBindingNames=new Set,dependencies=new Map;let exportName,exportPath;const exportBindingAssignments=[],importPaths=[],importBindingsReferences=[],dependencyVisitor={ImportDeclaration(child){const name=child.node.source.value;if(!_helpers.default[name])throw child.buildCodeFrameError(`Unknown helper ${name}`);if(1!==child.get("specifiers").length||!child.get("specifiers.0").isImportDefaultSpecifier())throw child.buildCodeFrameError("Helpers can only import a default value");const bindingIdentifier=child.node.specifiers[0].local;dependencies.set(bindingIdentifier,name),importPaths.push(makePath(child));},ExportDefaultDeclaration(child){const decl=child.get("declaration");if(decl.isFunctionDeclaration()){if(!decl.node.id)throw decl.buildCodeFrameError("Helpers should give names to their exported func declaration");exportName=decl.node.id.name;}exportPath=makePath(child);},ExportAllDeclaration(child){throw child.buildCodeFrameError("Helpers can only export default")},ExportNamedDeclaration(child){throw child.buildCodeFrameError("Helpers can only export default")},Statement(child){child.isModuleDeclaration()||child.skip();}},referenceVisitor={Program(path){const bindings=path.scope.getAllBindings();Object.keys(bindings).forEach((name=>{name!==exportName&&(dependencies.has(bindings[name].identifier)||localBindingNames.add(name));}));},ReferencedIdentifier(child){const name=child.node.name,binding=child.scope.getBinding(name);binding?dependencies.has(binding.identifier)&&importBindingsReferences.push(makePath(child)):globals.add(name);},AssignmentExpression(child){const left=child.get("left");if(!(exportName in left.getBindingIdentifiers()))return;if(!left.isIdentifier())throw left.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");const binding=child.scope.getBinding(exportName);null!=binding&&binding.scope.path.isProgram()&&exportBindingAssignments.push(makePath(child));}};if((0, _traverse.default)(file.ast,dependencyVisitor,file.scope),(0, _traverse.default)(file.ast,referenceVisitor,file.scope),!exportPath)throw new Error("Helpers must default-export something.");return exportBindingAssignments.reverse(),{globals:Array.from(globals),localBindingNames:Array.from(localBindingNames),dependencies,exportBindingAssignments,exportPath,exportName,importBindingsReferences,importPaths}}(fn());helperData[name]={build(getDependency,id,localBindings){const file=fn();return function(file,metadata,id,localBindings,getDependency){if(localBindings&&!id)throw new Error("Unexpected local bindings for module-based helpers.");if(!id)return;const{localBindingNames,dependencies,exportBindingAssignments,exportPath,exportName,importBindingsReferences,importPaths}=metadata,dependenciesRefs={};dependencies.forEach(((name,id)=>{dependenciesRefs[id.name]="function"==typeof getDependency&&getDependency(name)||id;}));const toRename={},bindings=new Set(localBindings||[]);localBindingNames.forEach((name=>{let newName=name;for(;bindings.has(newName);)newName="_"+newName;newName!==name&&(toRename[name]=newName);})),"Identifier"===id.type&&exportName!==id.name&&(toRename[exportName]=id.name);const visitor={Program(path){const exp=path.get(exportPath),imps=importPaths.map((p=>path.get(p))),impsBindingRefs=importBindingsReferences.map((p=>path.get(p))),decl=exp.get("declaration");if("Identifier"===id.type)decl.isFunctionDeclaration()?exp.replaceWith(decl):exp.replaceWith(variableDeclaration("var",[variableDeclarator(id,decl.node)]));else {if("MemberExpression"!==id.type)throw new Error("Unexpected helper format.");decl.isFunctionDeclaration()?(exportBindingAssignments.forEach((assignPath=>{const assign=path.get(assignPath);assign.replaceWith(assignmentExpression("=",id,assign.node));})),exp.replaceWith(decl),path.pushContainer("body",expressionStatement(assignmentExpression("=",id,identifier(exportName))))):exp.replaceWith(expressionStatement(assignmentExpression("=",id,decl.node)));}Object.keys(toRename).forEach((name=>{path.scope.rename(name,toRename[name]);}));for(const path of imps)path.remove();for(const path of impsBindingRefs){const node=cloneNode(dependenciesRefs[path.node.name]);path.replaceWith(node);}path.stop();}};(0, _traverse.default)(file.ast,visitor,file.scope);}(file,metadata,id,localBindings,getDependency),{nodes:file.ast.program.body,globals:metadata.globals}},minVersion:()=>helper.minVersion,dependencies:metadata.dependencies};}return helperData[name]}function get(name,getDependency,id,localBindings){return loadHelper(name).build(getDependency,id,localBindings)}const list=Object.keys(_helpers.default).map((name=>name.replace(/^_/,"")));exports.list=list;var _default=get;exports.default=_default;},"./node_modules/@babel/parser/lib/index.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0});class Position{constructor(line,col,index){this.line=void 0,this.column=void 0,this.index=void 0,this.line=line,this.column=col,indexes.set(this,index);}}class SourceLocation{constructor(start,end){this.start=void 0,this.end=void 0,this.filename=void 0,this.identifierName=void 0,this.start=start,this.end=end;}}const indexes=new WeakMap;function createPositionWithColumnOffset(position,columnOffset){const{line,column}=position;return new Position(line,column+columnOffset,indexes.get(position)+columnOffset)}function setTrailingComments(node,comments){void 0===node.trailingComments?node.trailingComments=comments:node.trailingComments.unshift(...comments);}function setInnerComments(node,comments){void 0===node.innerComments?node.innerComments=comments:node.innerComments.unshift(...comments);}function adjustInnerComments(node,elements,commentWS){let lastElement=null,i=elements.length;for(;null===lastElement&&i>0;)lastElement=elements[--i];null===lastElement||lastElement.start>commentWS.start?setInnerComments(node,commentWS.comments):setTrailingComments(lastElement,commentWS.comments);}const ErrorCodes=Object.freeze({SyntaxError:"BABEL_PARSER_SYNTAX_ERROR",SourceTypeModuleError:"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"}),ErrorMessages=makeErrorTemplates({AccessorIsGenerator:"A %0ter cannot be a generator.",ArgumentsInClass:"'arguments' is only allowed in functions and class methods.",AsyncFunctionInSingleStatementContext:"Async functions can only be declared at the top level or inside a block.",AwaitBindingIdentifier:"Can not use 'await' as identifier inside an async function.",AwaitBindingIdentifierInStaticBlock:"Can not use 'await' as identifier inside a static block.",AwaitExpressionFormalParameter:"'await' is not allowed in async function parameters.",AwaitNotInAsyncContext:"'await' is only allowed within async functions and at the top levels of modules.",AwaitNotInAsyncFunction:"'await' is only allowed within async functions.",BadGetterArity:"A 'get' accesor must not have any formal parameters.",BadSetterArity:"A 'set' accesor must have exactly one formal parameter.",BadSetterRestParameter:"A 'set' accesor function argument must not be a rest parameter.",ConstructorClassField:"Classes may not have a field named 'constructor'.",ConstructorClassPrivateField:"Classes may not have a private field named '#constructor'.",ConstructorIsAccessor:"Class constructor may not be an accessor.",ConstructorIsAsync:"Constructor can't be an async function.",ConstructorIsGenerator:"Constructor can't be a generator.",DeclarationMissingInitializer:"'%0' require an initialization value.",DecoratorBeforeExport:"Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",DecoratorConstructor:"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",DecoratorExportClass:"Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",DecoratorSemicolon:"Decorators must not be followed by a semicolon.",DecoratorStaticBlock:"Decorators can't be used with a static block.",DeletePrivateField:"Deleting a private field is not allowed.",DestructureNamedImport:"ES2015 named imports do not destructure. Use another statement for destructuring after the import.",DuplicateConstructor:"Duplicate constructor in the same class.",DuplicateDefaultExport:"Only one default export allowed per module.",DuplicateExport:"`%0` has already been exported. Exported identifiers must be unique.",DuplicateProto:"Redefinition of __proto__ property.",DuplicateRegExpFlags:"Duplicate regular expression flag.",ElementAfterRest:"Rest element must be last element.",EscapedCharNotAnIdentifier:"Invalid Unicode escape.",ExportBindingIsString:"A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?",ExportDefaultFromAsIdentifier:"'from' is not allowed as an identifier after 'export default'.",ForInOfLoopInitializer:"'%0' loop variable declaration may not have an initializer.",ForOfAsync:"The left-hand side of a for-of loop may not be 'async'.",ForOfLet:"The left-hand side of a for-of loop may not start with 'let'.",GeneratorInSingleStatementContext:"Generators can only be declared at the top level or inside a block.",IllegalBreakContinue:"Unsyntactic %0.",IllegalLanguageModeDirective:"Illegal 'use strict' directive in function with non-simple parameter list.",IllegalReturn:"'return' outside of function.",ImportBindingIsString:'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?',ImportCallArgumentTrailingComma:"Trailing comma is disallowed inside import(...) arguments.",ImportCallArity:"`import()` requires exactly %0.",ImportCallNotNewExpression:"Cannot use new with import(...).",ImportCallSpreadArgument:"`...` is not allowed in `import()`.",InvalidBigIntLiteral:"Invalid BigIntLiteral.",InvalidCodePoint:"Code point out of bounds.",InvalidCoverInitializedName:"Invalid shorthand property initializer.",InvalidDecimal:"Invalid decimal.",InvalidDigit:"Expected number in radix %0.",InvalidEscapeSequence:"Bad character escape sequence.",InvalidEscapeSequenceTemplate:"Invalid escape sequence in template.",InvalidEscapedReservedWord:"Escape sequence in keyword %0.",InvalidIdentifier:"Invalid identifier %0.",InvalidLhs:"Invalid left-hand side in %0.",InvalidLhsBinding:"Binding invalid left-hand side in %0.",InvalidNumber:"Invalid number.",InvalidOrMissingExponent:"Floating-point numbers require a valid exponent after the 'e'.",InvalidOrUnexpectedToken:"Unexpected character '%0'.",InvalidParenthesizedAssignment:"Invalid parenthesized assignment pattern.",InvalidPrivateFieldResolution:"Private name #%0 is not defined.",InvalidPropertyBindingPattern:"Binding member expression.",InvalidRecordProperty:"Only properties and spread elements are allowed in record definitions.",InvalidRestAssignmentPattern:"Invalid rest operator's argument.",LabelRedeclaration:"Label '%0' is already declared.",LetInLexicalBinding:"'let' is not allowed to be used as a name in 'let' or 'const' declarations.",LineTerminatorBeforeArrow:"No line break is allowed before '=>'.",MalformedRegExpFlags:"Invalid regular expression flag.",MissingClassName:"A class name is required.",MissingEqInAssignment:"Only '=' operator can be used for specifying default value.",MissingSemicolon:"Missing semicolon.",MissingUnicodeEscape:"Expecting Unicode escape sequence \\uXXXX.",MixingCoalesceWithLogical:"Nullish coalescing operator(??) requires parens when mixing with logical operators.",ModuleAttributeDifferentFromType:"The only accepted module attribute is `type`.",ModuleAttributeInvalidValue:"Only string literals are allowed as module attribute values.",ModuleAttributesWithDuplicateKeys:'Duplicate key "%0" is not allowed in module attributes.',ModuleExportNameHasLoneSurrogate:"An export name cannot include a lone surrogate, found '\\u%0'.",ModuleExportUndefined:"Export '%0' is not defined.",MultipleDefaultsInSwitch:"Multiple default clauses.",NewlineAfterThrow:"Illegal newline after throw.",NoCatchOrFinally:"Missing catch or finally clause.",NumberIdentifier:"Identifier directly after number.",NumericSeparatorInEscapeSequence:"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",ObsoleteAwaitStar:"'await*' has been removed from the async functions proposal. Use Promise.all() instead.",OptionalChainingNoNew:"Constructors in/after an Optional Chain are not allowed.",OptionalChainingNoTemplate:"Tagged Template Literals are not allowed in optionalChain.",OverrideOnConstructor:"'override' modifier cannot appear on a constructor declaration.",ParamDupe:"Argument name clash.",PatternHasAccessor:"Object pattern can't contain getter or setter.",PatternHasMethod:"Object pattern can't contain methods.",PipeBodyIsTighter:"Unexpected %0 after pipeline body; any %0 expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",PipeTopicRequiresHackPipes:'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',PipeTopicUnbound:"Topic reference is unbound; it must be inside a pipe body.",PipeTopicUnconfiguredToken:'Invalid topic token %0. In order to use %0 as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "%0" }.',PipeTopicUnused:"Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",PipeUnparenthesizedBody:"Hack-style pipe body cannot be an unparenthesized %0 expression; please wrap it in parentheses.",PipelineBodyNoArrow:'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',PipelineBodySequenceExpression:"Pipeline body may not be a comma-separated sequence expression.",PipelineHeadSequenceExpression:"Pipeline head should not be a comma-separated sequence expression.",PipelineTopicUnused:"Pipeline is in topic style but does not use topic reference.",PrimaryTopicNotAllowed:"Topic reference was used in a lexical context without topic binding.",PrimaryTopicRequiresSmartPipeline:'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',PrivateInExpectedIn:"Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).",PrivateNameRedeclaration:"Duplicate private name #%0.",RecordExpressionBarIncorrectEndSyntaxType:"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",RecordExpressionBarIncorrectStartSyntaxType:"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",RecordExpressionHashIncorrectStartSyntaxType:"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",RecordNoProto:"'__proto__' is not allowed in Record expressions.",RestTrailingComma:"Unexpected trailing comma after rest element.",SloppyFunction:"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",StaticPrototype:"Classes may not have static property named prototype.",StrictDelete:"Deleting local variable in strict mode.",StrictEvalArguments:"Assigning to '%0' in strict mode.",StrictEvalArgumentsBinding:"Binding '%0' in strict mode.",StrictFunction:"In strict mode code, functions can only be declared at top level or inside a block.",StrictNumericEscape:"The only valid numeric escape in strict mode is '\\0'.",StrictOctalLiteral:"Legacy octal literals are not allowed in strict mode.",StrictWith:"'with' in strict mode.",SuperNotAllowed:"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",SuperPrivateField:"Private fields can't be accessed on super.",TrailingDecorator:"Decorators must be attached to a class element.",TupleExpressionBarIncorrectEndSyntaxType:"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",TupleExpressionBarIncorrectStartSyntaxType:"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",TupleExpressionHashIncorrectStartSyntaxType:"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",UnexpectedArgumentPlaceholder:"Unexpected argument placeholder.",UnexpectedAwaitAfterPipelineBody:'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',UnexpectedDigitAfterHash:"Unexpected digit after hash token.",UnexpectedImportExport:"'import' and 'export' may only appear at the top level.",UnexpectedKeyword:"Unexpected keyword '%0'.",UnexpectedLeadingDecorator:"Leading decorators must be attached to a class declaration.",UnexpectedLexicalDeclaration:"Lexical declaration cannot appear in a single-statement context.",UnexpectedNewTarget:"`new.target` can only be used in functions or class properties.",UnexpectedNumericSeparator:"A numeric separator is only allowed between two digits.",UnexpectedPrivateField:"Unexpected private name.",UnexpectedReservedWord:"Unexpected reserved word '%0'.",UnexpectedSuper:"'super' is only allowed in object methods and classes.",UnexpectedToken:"Unexpected token '%0'.",UnexpectedTokenUnaryExponentiation:"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",UnsupportedBind:"Binding should be performed on object property.",UnsupportedDecoratorExport:"A decorated export must export a class declaration.",UnsupportedDefaultExport:"Only expressions, functions or classes are allowed as the `default` export.",UnsupportedImport:"`import` can only be used in `import()` or `import.meta`.",UnsupportedMetaProperty:"The only valid meta property for %0 is %0.%1.",UnsupportedParameterDecorator:"Decorators cannot be used to decorate parameters.",UnsupportedPropertyDecorator:"Decorators cannot be used to decorate object literal properties.",UnsupportedSuper:"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",UnterminatedComment:"Unterminated comment.",UnterminatedRegExp:"Unterminated regular expression.",UnterminatedString:"Unterminated string constant.",UnterminatedTemplate:"Unterminated template.",VarRedeclaration:"Identifier '%0' has already been declared.",YieldBindingIdentifier:"Can not use 'yield' as identifier inside a generator.",YieldInParameter:"Yield expression is not allowed in formal parameters.",ZeroDigitNumericSeparator:"Numeric separator can not be used after leading 0."},ErrorCodes.SyntaxError),SourceTypeModuleErrorMessages=makeErrorTemplates({ImportMetaOutsideModule:"import.meta may appear only with 'sourceType: \"module\"'",ImportOutsideModule:"'import' and 'export' may appear only with 'sourceType: \"module\"'"},ErrorCodes.SourceTypeModuleError);function keepReasonCodeCompat(reasonCode,syntaxPlugin){return "flow"===syntaxPlugin&&"PatternIsOptional"===reasonCode?"OptionalBindingPattern":reasonCode}function makeErrorTemplates(messages,code,syntaxPlugin){const templates={};return Object.keys(messages).forEach((reasonCode=>{templates[reasonCode]=Object.freeze({code,reasonCode:keepReasonCodeCompat(reasonCode,syntaxPlugin),template:messages[reasonCode]});})),Object.freeze(templates)}class TokContext{constructor(token,preserveSpace){this.token=void 0,this.preserveSpace=void 0,this.token=token,this.preserveSpace=!!preserveSpace;}}const types={brace:new TokContext("{"),j_oTag:new TokContext("<tag"),j_cTag:new TokContext("</tag"),j_expr:new TokContext("<tag>...</tag>",!0)};types.template=new TokContext("`",!0);class ExportedTokenType{constructor(label,conf={}){this.label=void 0,this.keyword=void 0,this.beforeExpr=void 0,this.startsExpr=void 0,this.rightAssociative=void 0,this.isLoop=void 0,this.isAssign=void 0,this.prefix=void 0,this.postfix=void 0,this.binop=void 0,this.label=label,this.keyword=conf.keyword,this.beforeExpr=!!conf.beforeExpr,this.startsExpr=!!conf.startsExpr,this.rightAssociative=!!conf.rightAssociative,this.isLoop=!!conf.isLoop,this.isAssign=!!conf.isAssign,this.prefix=!!conf.prefix,this.postfix=!!conf.postfix,this.binop=null!=conf.binop?conf.binop:null,this.updateContext=null;}}const keywords$1=new Map;function createKeyword(name,options={}){options.keyword=name;const token=createToken(name,options);return keywords$1.set(name,token),token}function createBinop(name,binop){return createToken(name,{beforeExpr:true,binop})}let tokenTypeCounter=-1;const tokenTypes=[],tokenLabels=[],tokenBinops=[],tokenBeforeExprs=[],tokenStartsExprs=[],tokenPrefixes=[];function createToken(name,options={}){var _options$binop,_options$beforeExpr,_options$startsExpr,_options$prefix;return ++tokenTypeCounter,tokenLabels.push(name),tokenBinops.push(null!=(_options$binop=options.binop)?_options$binop:-1),tokenBeforeExprs.push(null!=(_options$beforeExpr=options.beforeExpr)&&_options$beforeExpr),tokenStartsExprs.push(null!=(_options$startsExpr=options.startsExpr)&&_options$startsExpr),tokenPrefixes.push(null!=(_options$prefix=options.prefix)&&_options$prefix),tokenTypes.push(new ExportedTokenType(name,options)),tokenTypeCounter}function createKeywordLike(name,options={}){var _options$binop2,_options$beforeExpr2,_options$startsExpr2,_options$prefix2;return ++tokenTypeCounter,keywords$1.set(name,tokenTypeCounter),tokenLabels.push(name),tokenBinops.push(null!=(_options$binop2=options.binop)?_options$binop2:-1),tokenBeforeExprs.push(null!=(_options$beforeExpr2=options.beforeExpr)&&_options$beforeExpr2),tokenStartsExprs.push(null!=(_options$startsExpr2=options.startsExpr)&&_options$startsExpr2),tokenPrefixes.push(null!=(_options$prefix2=options.prefix)&&_options$prefix2),tokenTypes.push(new ExportedTokenType("name",options)),tokenTypeCounter}const tt={bracketL:createToken("[",{beforeExpr:true,startsExpr:true}),bracketHashL:createToken("#[",{beforeExpr:true,startsExpr:true}),bracketBarL:createToken("[|",{beforeExpr:true,startsExpr:true}),bracketR:createToken("]"),bracketBarR:createToken("|]"),braceL:createToken("{",{beforeExpr:true,startsExpr:true}),braceBarL:createToken("{|",{beforeExpr:true,startsExpr:true}),braceHashL:createToken("#{",{beforeExpr:true,startsExpr:true}),braceR:createToken("}",{beforeExpr:true}),braceBarR:createToken("|}"),parenL:createToken("(",{beforeExpr:true,startsExpr:true}),parenR:createToken(")"),comma:createToken(",",{beforeExpr:true}),semi:createToken(";",{beforeExpr:true}),colon:createToken(":",{beforeExpr:true}),doubleColon:createToken("::",{beforeExpr:true}),dot:createToken("."),question:createToken("?",{beforeExpr:true}),questionDot:createToken("?."),arrow:createToken("=>",{beforeExpr:true}),template:createToken("template"),ellipsis:createToken("...",{beforeExpr:true}),backQuote:createToken("`",{startsExpr:true}),dollarBraceL:createToken("${",{beforeExpr:true,startsExpr:true}),templateTail:createToken("...`",{startsExpr:true}),templateNonTail:createToken("...${",{beforeExpr:true,startsExpr:true}),at:createToken("@"),hash:createToken("#",{startsExpr:true}),interpreterDirective:createToken("#!..."),eq:createToken("=",{beforeExpr:true,isAssign:true}),assign:createToken("_=",{beforeExpr:true,isAssign:true}),slashAssign:createToken("_=",{beforeExpr:true,isAssign:true}),xorAssign:createToken("_=",{beforeExpr:true,isAssign:true}),moduloAssign:createToken("_=",{beforeExpr:true,isAssign:true}),incDec:createToken("++/--",{prefix:true,postfix:!0,startsExpr:true}),bang:createToken("!",{beforeExpr:true,prefix:true,startsExpr:true}),tilde:createToken("~",{beforeExpr:true,prefix:true,startsExpr:true}),pipeline:createBinop("|>",0),nullishCoalescing:createBinop("??",1),logicalOR:createBinop("||",1),logicalAND:createBinop("&&",2),bitwiseOR:createBinop("|",3),bitwiseXOR:createBinop("^",4),bitwiseAND:createBinop("&",5),equality:createBinop("==/!=/===/!==",6),lt:createBinop("</>/<=/>=",7),gt:createBinop("</>/<=/>=",7),relational:createBinop("</>/<=/>=",7),bitShift:createBinop("<</>>/>>>",8),plusMin:createToken("+/-",{beforeExpr:true,binop:9,prefix:true,startsExpr:true}),modulo:createToken("%",{binop:10,startsExpr:true}),star:createToken("*",{binop:10}),slash:createBinop("/",10),exponent:createToken("**",{beforeExpr:true,binop:11,rightAssociative:!0}),_in:createKeyword("in",{beforeExpr:true,binop:7}),_instanceof:createKeyword("instanceof",{beforeExpr:true,binop:7}),_break:createKeyword("break"),_case:createKeyword("case",{beforeExpr:true}),_catch:createKeyword("catch"),_continue:createKeyword("continue"),_debugger:createKeyword("debugger"),_default:createKeyword("default",{beforeExpr:true}),_else:createKeyword("else",{beforeExpr:true}),_finally:createKeyword("finally"),_function:createKeyword("function",{startsExpr:true}),_if:createKeyword("if"),_return:createKeyword("return",{beforeExpr:true}),_switch:createKeyword("switch"),_throw:createKeyword("throw",{beforeExpr:true,prefix:true,startsExpr:true}),_try:createKeyword("try"),_var:createKeyword("var"),_const:createKeyword("const"),_with:createKeyword("with"),_new:createKeyword("new",{beforeExpr:true,startsExpr:true}),_this:createKeyword("this",{startsExpr:true}),_super:createKeyword("super",{startsExpr:true}),_class:createKeyword("class",{startsExpr:true}),_extends:createKeyword("extends",{beforeExpr:true}),_export:createKeyword("export"),_import:createKeyword("import",{startsExpr:true}),_null:createKeyword("null",{startsExpr:true}),_true:createKeyword("true",{startsExpr:true}),_false:createKeyword("false",{startsExpr:true}),_typeof:createKeyword("typeof",{beforeExpr:true,prefix:true,startsExpr:true}),_void:createKeyword("void",{beforeExpr:true,prefix:true,startsExpr:true}),_delete:createKeyword("delete",{beforeExpr:true,prefix:true,startsExpr:true}),_do:createKeyword("do",{isLoop:true,beforeExpr:true}),_for:createKeyword("for",{isLoop:true}),_while:createKeyword("while",{isLoop:true}),_as:createKeywordLike("as",{startsExpr:true}),_assert:createKeywordLike("assert",{startsExpr:true}),_async:createKeywordLike("async",{startsExpr:true}),_await:createKeywordLike("await",{startsExpr:true}),_from:createKeywordLike("from",{startsExpr:true}),_get:createKeywordLike("get",{startsExpr:true}),_let:createKeywordLike("let",{startsExpr:true}),_meta:createKeywordLike("meta",{startsExpr:true}),_of:createKeywordLike("of",{startsExpr:true}),_sent:createKeywordLike("sent",{startsExpr:true}),_set:createKeywordLike("set",{startsExpr:true}),_static:createKeywordLike("static",{startsExpr:true}),_yield:createKeywordLike("yield",{startsExpr:true}),_asserts:createKeywordLike("asserts",{startsExpr:true}),_checks:createKeywordLike("checks",{startsExpr:true}),_exports:createKeywordLike("exports",{startsExpr:true}),_global:createKeywordLike("global",{startsExpr:true}),_implements:createKeywordLike("implements",{startsExpr:true}),_intrinsic:createKeywordLike("intrinsic",{startsExpr:true}),_infer:createKeywordLike("infer",{startsExpr:true}),_is:createKeywordLike("is",{startsExpr:true}),_mixins:createKeywordLike("mixins",{startsExpr:true}),_proto:createKeywordLike("proto",{startsExpr:true}),_require:createKeywordLike("require",{startsExpr:true}),_keyof:createKeywordLike("keyof",{startsExpr:true}),_readonly:createKeywordLike("readonly",{startsExpr:true}),_unique:createKeywordLike("unique",{startsExpr:true}),_abstract:createKeywordLike("abstract",{startsExpr:true}),_declare:createKeywordLike("declare",{startsExpr:true}),_enum:createKeywordLike("enum",{startsExpr:true}),_module:createKeywordLike("module",{startsExpr:true}),_namespace:createKeywordLike("namespace",{startsExpr:true}),_interface:createKeywordLike("interface",{startsExpr:true}),_type:createKeywordLike("type",{startsExpr:true}),_opaque:createKeywordLike("opaque",{startsExpr:true}),name:createToken("name",{startsExpr:true}),string:createToken("string",{startsExpr:true}),num:createToken("num",{startsExpr:true}),bigint:createToken("bigint",{startsExpr:true}),decimal:createToken("decimal",{startsExpr:true}),regexp:createToken("regexp",{startsExpr:true}),privateName:createToken("#name",{startsExpr:true}),eof:createToken("eof"),jsxName:createToken("jsxName"),jsxText:createToken("jsxText",{beforeExpr:!0}),jsxTagStart:createToken("jsxTagStart",{startsExpr:!0}),jsxTagEnd:createToken("jsxTagEnd"),placeholder:createToken("%%",{startsExpr:!0})};function tokenIsIdentifier(token){return token>=89&&token<=124}function tokenIsKeywordOrIdentifier(token){return token>=54&&token<=124}function tokenIsLiteralPropertyName(token){return token>=54&&token<=128}function tokenCanStartExpression(token){return tokenStartsExprs[token]}function tokenIsFlowInterfaceOrTypeOrOpaque(token){return token>=121&&token<=123}function tokenIsKeyword(token){return token>=54&&token<=88}function tokenLabelName(token){return tokenLabels[token]}function tokenOperatorPrecedence(token){return tokenBinops[token]}function tokenIsTemplate(token){return token>=24&&token<=25}function getExportedToken(token){return tokenTypes[token]}tokenTypes[8].updateContext=context=>{context.pop();},tokenTypes[5].updateContext=tokenTypes[7].updateContext=tokenTypes[23].updateContext=context=>{context.push(types.brace);},tokenTypes[22].updateContext=context=>{context[context.length-1]===types.template?context.pop():context.push(types.template);},tokenTypes[134].updateContext=context=>{context.push(types.j_expr,types.j_oTag);};let nonASCIIidentifierStartChars="ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",nonASCIIidentifierChars="‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";const nonASCIIidentifierStart=new RegExp("["+nonASCIIidentifierStartChars+"]"),nonASCIIidentifier=new RegExp("["+nonASCIIidentifierStartChars+nonASCIIidentifierChars+"]");nonASCIIidentifierStartChars=nonASCIIidentifierChars=null;const astralIdentifierStartCodes=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,13,10,2,14,2,6,2,1,2,10,2,14,2,6,2,1,68,310,10,21,11,7,25,5,2,41,2,8,70,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,43,17,47,20,28,22,13,52,58,1,3,0,14,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,38,6,186,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,19,72,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2637,96,16,1070,4050,582,8634,568,8,30,18,78,18,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8936,3,2,6,2,1,2,290,46,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,1845,30,482,44,11,6,17,0,322,29,19,43,1269,6,2,3,2,1,2,14,2,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42719,33,4152,8,221,3,5761,15,7472,3104,541,1507,4938],astralIdentifierCodes=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,50,3,123,2,54,14,32,10,3,1,11,3,46,10,8,0,46,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,87,9,39,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,4706,45,3,22,543,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,357,0,62,13,1495,6,110,6,6,9,4759,9,787719,239];function isInAstralSet(code,set){let pos=65536;for(let i=0,length=set.length;i<length;i+=2){if(pos+=set[i],pos>code)return !1;if(pos+=set[i+1],pos>=code)return !0}return !1}function isIdentifierStart(code){return code<65?36===code:code<=90||(code<97?95===code:code<=122||(code<=65535?code>=170&&nonASCIIidentifierStart.test(String.fromCharCode(code)):isInAstralSet(code,astralIdentifierStartCodes)))}function isIdentifierChar(code){return code<48?36===code:code<58||!(code<65)&&(code<=90||(code<97?95===code:code<=122||(code<=65535?code>=170&&nonASCIIidentifier.test(String.fromCharCode(code)):isInAstralSet(code,astralIdentifierStartCodes)||isInAstralSet(code,astralIdentifierCodes))))}const reservedWords_strict=["implements","interface","let","package","private","protected","public","static","yield"],reservedWords_strictBind=["eval","arguments"],keywords=new Set(["break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","const","while","with","new","this","super","class","extends","export","import","null","true","false","in","instanceof","typeof","void","delete"]),reservedWordsStrictSet=new Set(reservedWords_strict),reservedWordsStrictBindSet=new Set(reservedWords_strictBind);function isReservedWord(word,inModule){return inModule&&"await"===word||"enum"===word}function isStrictReservedWord(word,inModule){return isReservedWord(word,inModule)||reservedWordsStrictSet.has(word)}function isStrictBindOnlyReservedWord(word){return reservedWordsStrictBindSet.has(word)}function isStrictBindReservedWord(word,inModule){return isStrictReservedWord(word,inModule)||isStrictBindOnlyReservedWord(word)}const reservedWordLikeSet=new Set(["break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","const","while","with","new","this","super","class","extends","export","import","null","true","false","in","instanceof","typeof","void","delete","implements","interface","let","package","private","protected","public","static","yield","eval","arguments","enum","await"]);class Scope{constructor(flags){this.var=new Set,this.lexical=new Set,this.functions=new Set,this.flags=flags;}}class ScopeHandler{constructor(raise,inModule){this.scopeStack=[],this.undefinedExports=new Map,this.raise=raise,this.inModule=inModule;}get inFunction(){return (2&this.currentVarScopeFlags())>0}get allowSuper(){return (16&this.currentThisScopeFlags())>0}get allowDirectSuper(){return (32&this.currentThisScopeFlags())>0}get inClass(){return (64&this.currentThisScopeFlags())>0}get inClassAndNotInNonArrowFunction(){const flags=this.currentThisScopeFlags();return (64&flags)>0&&0==(2&flags)}get inStaticBlock(){for(let i=this.scopeStack.length-1;;i--){const{flags}=this.scopeStack[i];if(128&flags)return !0;if(323&flags)return !1}}get inNonArrowFunction(){return (2&this.currentThisScopeFlags())>0}get treatFunctionsAsVar(){return this.treatFunctionsAsVarInScope(this.currentScope())}createScope(flags){return new Scope(flags)}enter(flags){this.scopeStack.push(this.createScope(flags));}exit(){this.scopeStack.pop();}treatFunctionsAsVarInScope(scope){return !!(2&scope.flags||!this.inModule&&1&scope.flags)}declareName(name,bindingType,loc){let scope=this.currentScope();if(8&bindingType||16&bindingType)this.checkRedeclarationInScope(scope,name,bindingType,loc),16&bindingType?scope.functions.add(name):scope.lexical.add(name),8&bindingType&&this.maybeExportDefined(scope,name);else if(4&bindingType)for(let i=this.scopeStack.length-1;i>=0&&(scope=this.scopeStack[i],this.checkRedeclarationInScope(scope,name,bindingType,loc),scope.var.add(name),this.maybeExportDefined(scope,name),!(259&scope.flags));--i);this.inModule&&1&scope.flags&&this.undefinedExports.delete(name);}maybeExportDefined(scope,name){this.inModule&&1&scope.flags&&this.undefinedExports.delete(name);}checkRedeclarationInScope(scope,name,bindingType,loc){this.isRedeclaredInScope(scope,name,bindingType)&&this.raise(ErrorMessages.VarRedeclaration,{at:loc},name);}isRedeclaredInScope(scope,name,bindingType){return !!(1&bindingType)&&(8&bindingType?scope.lexical.has(name)||scope.functions.has(name)||scope.var.has(name):16&bindingType?scope.lexical.has(name)||!this.treatFunctionsAsVarInScope(scope)&&scope.var.has(name):scope.lexical.has(name)&&!(8&scope.flags&&scope.lexical.values().next().value===name)||!this.treatFunctionsAsVarInScope(scope)&&scope.functions.has(name))}checkLocalExport(id){const{name}=id,topLevelScope=this.scopeStack[0];topLevelScope.lexical.has(name)||topLevelScope.var.has(name)||topLevelScope.functions.has(name)||this.undefinedExports.set(name,id.loc.start);}currentScope(){return this.scopeStack[this.scopeStack.length-1]}currentVarScopeFlags(){for(let i=this.scopeStack.length-1;;i--){const{flags}=this.scopeStack[i];if(259&flags)return flags}}currentThisScopeFlags(){for(let i=this.scopeStack.length-1;;i--){const{flags}=this.scopeStack[i];if(323&flags&&!(4&flags))return flags}}}class FlowScope extends Scope{constructor(...args){super(...args),this.declareFunctions=new Set;}}class FlowScopeHandler extends ScopeHandler{createScope(flags){return new FlowScope(flags)}declareName(name,bindingType,loc){const scope=this.currentScope();if(2048&bindingType)return this.checkRedeclarationInScope(scope,name,bindingType,loc),this.maybeExportDefined(scope,name),void scope.declareFunctions.add(name);super.declareName(...arguments);}isRedeclaredInScope(scope,name,bindingType){return !!super.isRedeclaredInScope(...arguments)||!!(2048&bindingType)&&(!scope.declareFunctions.has(name)&&(scope.lexical.has(name)||scope.functions.has(name)))}checkLocalExport(id){this.scopeStack[0].declareFunctions.has(id.name)||super.checkLocalExport(id);}}const lineBreak=/\r\n?|[\n\u2028\u2029]/,lineBreakG=new RegExp(lineBreak.source,"g");function isNewLine(code){switch(code){case 10:case 13:case 8232:case 8233:return !0;default:return !1}}const skipWhiteSpace=/(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,skipWhiteSpaceToLineBreak=new RegExp("(?=("+/(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y.source+"))\\1"+/(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source,"y");function isWhitespace(code){switch(code){case 9:case 11:case 12:case 32:case 160:case 5760:case 8192:case 8193:case 8194:case 8195:case 8196:case 8197:case 8198:case 8199:case 8200:case 8201:case 8202:case 8239:case 8287:case 12288:case 65279:return !0;default:return !1}}class State{constructor(){this.strict=void 0,this.curLine=void 0,this.lineStart=void 0,this.startLoc=void 0,this.endLoc=void 0,this.errors=[],this.potentialArrowAt=-1,this.noArrowAt=[],this.noArrowParamsConversionAt=[],this.maybeInArrowParameters=!1,this.inType=!1,this.noAnonFunctionType=!1,this.hasFlowComment=!1,this.isAmbientContext=!1,this.inAbstractClass=!1,this.topicContext={maxNumOfResolvableTopics:0,maxTopicIndex:null},this.soloAwait=!1,this.inFSharpPipelineDirectBody=!1,this.labels=[],this.decoratorStack=[[]],this.comments=[],this.commentStack=[],this.pos=0,this.type=131,this.value=null,this.start=0,this.end=0,this.lastTokEndLoc=null,this.lastTokStartLoc=null,this.lastTokStart=0,this.context=[types.brace],this.canStartJSXElement=!0,this.containsEsc=!1,this.strictErrors=new Map,this.tokensLength=0;}init({strictMode,sourceType,startLine,startColumn}){this.strict=!1!==strictMode&&(!0===strictMode||"module"===sourceType),this.curLine=startLine,this.lineStart=-startColumn,this.startLoc=this.endLoc=new Position(startLine,startColumn,0);}curPosition(){return new Position(this.curLine,this.pos-this.lineStart,this.pos)}clone(skipArrays){const state=new State,keys=Object.keys(this);for(let i=0,length=keys.length;i<length;i++){const key=keys[i];let val=this[key];!skipArrays&&Array.isArray(val)&&(val=val.slice()),state[key]=val;}return state}}var _isDigit=function(code){return code>=48&&code<=57};const VALID_REGEX_FLAGS=new Set([103,109,115,105,121,117,100]),forbiddenNumericSeparatorSiblings={decBinOct:[46,66,69,79,95,98,101,111],hex:[46,88,95,120]},allowedNumericSeparatorSiblings={bin:[48,49]};allowedNumericSeparatorSiblings.oct=[...allowedNumericSeparatorSiblings.bin,50,51,52,53,54,55],allowedNumericSeparatorSiblings.dec=[...allowedNumericSeparatorSiblings.oct,56,57],allowedNumericSeparatorSiblings.hex=[...allowedNumericSeparatorSiblings.dec,65,66,67,68,69,70,97,98,99,100,101,102];class Token{constructor(state){this.type=state.type,this.value=state.value,this.start=state.start,this.end=state.end,this.loc=new SourceLocation(state.startLoc,state.endLoc);}}class ClassScope{constructor(){this.privateNames=new Set,this.loneAccessors=new Map,this.undefinedPrivateNames=new Map;}}class ClassScopeHandler{constructor(raise){this.stack=[],this.undefinedPrivateNames=new Map,this.raise=raise;}current(){return this.stack[this.stack.length-1]}enter(){this.stack.push(new ClassScope);}exit(){const oldClassScope=this.stack.pop(),current=this.current();for(const[name,loc]of Array.from(oldClassScope.undefinedPrivateNames))current?current.undefinedPrivateNames.has(name)||current.undefinedPrivateNames.set(name,loc):this.raise(ErrorMessages.InvalidPrivateFieldResolution,{at:loc},name);}declarePrivateName(name,elementType,loc){const{privateNames,loneAccessors,undefinedPrivateNames}=this.current();let redefined=privateNames.has(name);if(3&elementType){const accessor=redefined&&loneAccessors.get(name);if(accessor){const oldStatic=4&accessor,newStatic=4&elementType;redefined=(3&accessor)===(3&elementType)||oldStatic!==newStatic,redefined||loneAccessors.delete(name);}else redefined||loneAccessors.set(name,elementType);}redefined&&this.raise(ErrorMessages.PrivateNameRedeclaration,{at:loc},name),privateNames.add(name),undefinedPrivateNames.delete(name);}usePrivateName(name,loc){let classScope;for(classScope of this.stack)if(classScope.privateNames.has(name))return;classScope?classScope.undefinedPrivateNames.set(name,loc):this.raise(ErrorMessages.InvalidPrivateFieldResolution,{at:loc},name);}}class ExpressionScope{constructor(type=0){this.type=void 0,this.type=type;}canBeArrowParameterDeclaration(){return 2===this.type||1===this.type}isCertainlyParameterDeclaration(){return 3===this.type}}class ArrowHeadParsingScope extends ExpressionScope{constructor(type){super(type),this.errors=new Map;}recordDeclarationError(message,loc){this.errors.set(indexes.get(loc),{message,loc});}clearDeclarationError(loc){this.errors.delete(indexes.get(loc));}iterateErrors(iterator){this.errors.forEach(iterator);}}class ExpressionScopeHandler{constructor(raise){this.stack=[new ExpressionScope],this.raise=raise;}enter(scope){this.stack.push(scope);}exit(){this.stack.pop();}recordParameterInitializerError(loc,template){const{stack}=this;let i=stack.length-1,scope=stack[i];for(;!scope.isCertainlyParameterDeclaration();){if(!scope.canBeArrowParameterDeclaration())return;scope.recordDeclarationError(template,loc),scope=stack[--i];}this.raise(template,{at:loc});}recordParenthesizedIdentifierError(template,loc){const{stack}=this,scope=stack[stack.length-1];if(scope.isCertainlyParameterDeclaration())this.raise(template,{at:loc});else {if(!scope.canBeArrowParameterDeclaration())return;scope.recordDeclarationError(template,loc);}}recordAsyncArrowParametersError(template,loc){const{stack}=this;let i=stack.length-1,scope=stack[i];for(;scope.canBeArrowParameterDeclaration();)2===scope.type&&scope.recordDeclarationError(template,loc),scope=stack[--i];}validateAsPattern(){const{stack}=this,currentScope=stack[stack.length-1];currentScope.canBeArrowParameterDeclaration()&&currentScope.iterateErrors((({message,loc})=>{this.raise(message,{at:loc});let i=stack.length-2,scope=stack[i];for(;scope.canBeArrowParameterDeclaration();)scope.clearDeclarationError(loc),scope=stack[--i];}));}}function newExpressionScope(){return new ExpressionScope}class ProductionParameterHandler{constructor(){this.stacks=[];}enter(flags){this.stacks.push(flags);}exit(){this.stacks.pop();}currentFlags(){return this.stacks[this.stacks.length-1]}get hasAwait(){return (2&this.currentFlags())>0}get hasYield(){return (1&this.currentFlags())>0}get hasReturn(){return (4&this.currentFlags())>0}get hasIn(){return (8&this.currentFlags())>0}}function functionFlags(isAsync,isGenerator){return (isAsync?2:0)|(isGenerator?1:0)}class ExpressionErrors{constructor(){this.shorthandAssignLoc=null,this.doubleProtoLoc=null,this.optionalParametersLoc=null;}}class Node{constructor(parser,pos,loc){this.type="",this.start=pos,this.end=0,this.loc=new SourceLocation(loc),null!=parser&&parser.options.ranges&&(this.range=[pos,0]),null!=parser&&parser.filename&&(this.loc.filename=parser.filename);}}const NodePrototype=Node.prototype;function cloneIdentifier(node){const{type,start,end,loc,range,extra,name}=node,cloned=Object.create(NodePrototype);return cloned.type=type,cloned.start=start,cloned.end=end,cloned.loc=loc,cloned.range=range,cloned.extra=extra,cloned.name=name,"Placeholder"===type&&(cloned.expectedNode=node.expectedNode),cloned}function cloneStringLiteral(node){const{type,start,end,loc,range,extra}=node;if("Placeholder"===type)return function(node){return cloneIdentifier(node)}(node);const cloned=Object.create(NodePrototype);return cloned.type=type,cloned.start=start,cloned.end=end,cloned.loc=loc,cloned.range=range,void 0!==node.raw?cloned.raw=node.raw:cloned.extra=extra,cloned.value=node.value,cloned}NodePrototype.__clone=function(){const newNode=new Node,keys=Object.keys(this);for(let i=0,length=keys.length;i<length;i++){const key=keys[i];"leadingComments"!==key&&"trailingComments"!==key&&"innerComments"!==key&&(newNode[key]=this[key]);}return newNode};const reservedTypes=new Set(["_","any","bool","boolean","empty","extends","false","interface","mixed","null","number","static","string","true","typeof","void"]),FlowErrors=makeErrorTemplates({AmbiguousConditionalArrow:"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",AmbiguousDeclareModuleKind:"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",AssignReservedType:"Cannot overwrite reserved type %0.",DeclareClassElement:"The `declare` modifier can only appear on class fields.",DeclareClassFieldInitializer:"Initializers are not allowed in fields with the `declare` modifier.",DuplicateDeclareModuleExports:"Duplicate `declare module.exports` statement.",EnumBooleanMemberNotInitialized:"Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",EnumDuplicateMemberName:"Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",EnumInconsistentMemberValues:"Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",EnumInvalidExplicitType:"Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",EnumInvalidExplicitTypeUnknownSupplied:"Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",EnumInvalidMemberInitializerPrimaryType:"Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",EnumInvalidMemberInitializerSymbolType:"Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",EnumInvalidMemberInitializerUnknownType:"The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",EnumInvalidMemberName:"Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",EnumNumberMemberNotInitialized:"Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",EnumStringMemberInconsistentlyInitailized:"String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",GetterMayNotHaveThisParam:"A getter cannot have a `this` parameter.",ImportTypeShorthandOnlyInPureImport:"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",InexactInsideExact:"Explicit inexact syntax cannot appear inside an explicit exact object type.",InexactInsideNonObject:"Explicit inexact syntax cannot appear in class or interface definitions.",InexactVariance:"Explicit inexact syntax cannot have variance.",InvalidNonTypeImportInDeclareModule:"Imports within a `declare module` body must always be `import type` or `import typeof`.",MissingTypeParamDefault:"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",NestedDeclareModule:"`declare module` cannot be used inside another `declare module`.",NestedFlowComment:"Cannot have a flow comment inside another flow comment.",PatternIsOptional:"A binding pattern parameter cannot be optional in an implementation signature.",SetterMayNotHaveThisParam:"A setter cannot have a `this` parameter.",SpreadVariance:"Spread properties cannot have variance.",ThisParamAnnotationRequired:"A type annotation is required for the `this` parameter.",ThisParamBannedInConstructor:"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",ThisParamMayNotBeOptional:"The `this` parameter cannot be optional.",ThisParamMustBeFirst:"The `this` parameter must be the first function parameter.",ThisParamNoDefault:"The `this` parameter may not have a default value.",TypeBeforeInitializer:"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",TypeCastInPattern:"The type cast expression is expected to be wrapped with parenthesis.",UnexpectedExplicitInexactInObject:"Explicit inexact syntax must appear at the end of an inexact object.",UnexpectedReservedType:"Unexpected reserved type %0.",UnexpectedReservedUnderscore:"`_` is only allowed as a type argument to call or new.",UnexpectedSpaceBetweenModuloChecks:"Spaces between `%` and `checks` are not allowed here.",UnexpectedSpreadType:"Spread operator cannot appear in class or interface definitions.",UnexpectedSubtractionOperand:'Unexpected token, expected "number" or "bigint".',UnexpectedTokenAfterTypeParameter:"Expected an arrow function after this type parameter declaration.",UnexpectedTypeParameterBeforeAsyncArrowFunction:"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",UnsupportedDeclareExportKind:"`declare export %0` is not supported. Use `%1` instead.",UnsupportedStatementInDeclareModule:"Only declares and type imports are allowed inside declare module.",UnterminatedFlowComment:"Unterminated flow-comment."},ErrorCodes.SyntaxError,"flow");function hasTypeImportKind(node){return "type"===node.importKind||"typeof"===node.importKind}function isMaybeDefaultImport(type){return tokenIsKeywordOrIdentifier(type)&&93!==type}const exportSuggestions={const:"declare export var",let:"declare export var",type:"export type",interface:"export interface"};const FLOW_PRAGMA_REGEX=/\*?\s*@((?:no)?flow)\b/;const entities={quot:'"',amp:"&",apos:"'",lt:"<",gt:">",nbsp:" ",iexcl:"¡",cent:"¢",pound:"£",curren:"¤",yen:"¥",brvbar:"¦",sect:"§",uml:"¨",copy:"©",ordf:"ª",laquo:"«",not:"¬",shy:"­",reg:"®",macr:"¯",deg:"°",plusmn:"±",sup2:"²",sup3:"³",acute:"´",micro:"µ",para:"¶",middot:"·",cedil:"¸",sup1:"¹",ordm:"º",raquo:"»",frac14:"¼",frac12:"½",frac34:"¾",iquest:"¿",Agrave:"À",Aacute:"Á",Acirc:"Â",Atilde:"Ã",Auml:"Ä",Aring:"Å",AElig:"Æ",Ccedil:"Ç",Egrave:"È",Eacute:"É",Ecirc:"Ê",Euml:"Ë",Igrave:"Ì",Iacute:"Í",Icirc:"Î",Iuml:"Ï",ETH:"Ð",Ntilde:"Ñ",Ograve:"Ò",Oacute:"Ó",Ocirc:"Ô",Otilde:"Õ",Ouml:"Ö",times:"×",Oslash:"Ø",Ugrave:"Ù",Uacute:"Ú",Ucirc:"Û",Uuml:"Ü",Yacute:"Ý",THORN:"Þ",szlig:"ß",agrave:"à",aacute:"á",acirc:"â",atilde:"ã",auml:"ä",aring:"å",aelig:"æ",ccedil:"ç",egrave:"è",eacute:"é",ecirc:"ê",euml:"ë",igrave:"ì",iacute:"í",icirc:"î",iuml:"ï",eth:"ð",ntilde:"ñ",ograve:"ò",oacute:"ó",ocirc:"ô",otilde:"õ",ouml:"ö",divide:"÷",oslash:"ø",ugrave:"ù",uacute:"ú",ucirc:"û",uuml:"ü",yacute:"ý",thorn:"þ",yuml:"ÿ",OElig:"Œ",oelig:"œ",Scaron:"Š",scaron:"š",Yuml:"Ÿ",fnof:"ƒ",circ:"ˆ",tilde:"˜",Alpha:"Α",Beta:"Β",Gamma:"Γ",Delta:"Δ",Epsilon:"Ε",Zeta:"Ζ",Eta:"Η",Theta:"Θ",Iota:"Ι",Kappa:"Κ",Lambda:"Λ",Mu:"Μ",Nu:"Ν",Xi:"Ξ",Omicron:"Ο",Pi:"Π",Rho:"Ρ",Sigma:"Σ",Tau:"Τ",Upsilon:"Υ",Phi:"Φ",Chi:"Χ",Psi:"Ψ",Omega:"Ω",alpha:"α",beta:"β",gamma:"γ",delta:"δ",epsilon:"ε",zeta:"ζ",eta:"η",theta:"θ",iota:"ι",kappa:"κ",lambda:"λ",mu:"μ",nu:"ν",xi:"ξ",omicron:"ο",pi:"π",rho:"ρ",sigmaf:"ς",sigma:"σ",tau:"τ",upsilon:"υ",phi:"φ",chi:"χ",psi:"ψ",omega:"ω",thetasym:"ϑ",upsih:"ϒ",piv:"ϖ",ensp:" ",emsp:" ",thinsp:" ",zwnj:"‌",zwj:"‍",lrm:"‎",rlm:"‏",ndash:"–",mdash:"—",lsquo:"‘",rsquo:"’",sbquo:"‚",ldquo:"“",rdquo:"”",bdquo:"„",dagger:"†",Dagger:"‡",bull:"•",hellip:"…",permil:"‰",prime:"′",Prime:"″",lsaquo:"‹",rsaquo:"›",oline:"‾",frasl:"⁄",euro:"€",image:"ℑ",weierp:"℘",real:"ℜ",trade:"™",alefsym:"ℵ",larr:"←",uarr:"↑",rarr:"→",darr:"↓",harr:"↔",crarr:"↵",lArr:"⇐",uArr:"⇑",rArr:"⇒",dArr:"⇓",hArr:"⇔",forall:"∀",part:"∂",exist:"∃",empty:"∅",nabla:"∇",isin:"∈",notin:"∉",ni:"∋",prod:"∏",sum:"∑",minus:"−",lowast:"∗",radic:"√",prop:"∝",infin:"∞",ang:"∠",and:"∧",or:"∨",cap:"∩",cup:"∪",int:"∫",there4:"∴",sim:"∼",cong:"≅",asymp:"≈",ne:"≠",equiv:"≡",le:"≤",ge:"≥",sub:"⊂",sup:"⊃",nsub:"⊄",sube:"⊆",supe:"⊇",oplus:"⊕",otimes:"⊗",perp:"⊥",sdot:"⋅",lceil:"⌈",rceil:"⌉",lfloor:"⌊",rfloor:"⌋",lang:"〈",rang:"〉",loz:"◊",spades:"♠",clubs:"♣",hearts:"♥",diams:"♦"},HEX_NUMBER=/^[\da-fA-F]+$/,DECIMAL_NUMBER=/^\d+$/,JsxErrors=makeErrorTemplates({AttributeIsEmpty:"JSX attributes must only be assigned a non-empty expression.",MissingClosingTagElement:"Expected corresponding JSX closing tag for <%0>.",MissingClosingTagFragment:"Expected corresponding JSX closing tag for <>.",UnexpectedSequenceExpression:"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",UnsupportedJsxValue:"JSX value should be either an expression or a quoted JSX text.",UnterminatedJsxContent:"Unterminated JSX contents.",UnwrappedAdjacentJSXElements:"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"},ErrorCodes.SyntaxError,"jsx");function isFragment(object){return !!object&&("JSXOpeningFragment"===object.type||"JSXClosingFragment"===object.type)}function getQualifiedJSXName(object){if("JSXIdentifier"===object.type)return object.name;if("JSXNamespacedName"===object.type)return object.namespace.name+":"+object.name.name;if("JSXMemberExpression"===object.type)return getQualifiedJSXName(object.object)+"."+getQualifiedJSXName(object.property);throw new Error("Node had unexpected type: "+object.type)}class TypeScriptScope extends Scope{constructor(...args){super(...args),this.types=new Set,this.enums=new Set,this.constEnums=new Set,this.classes=new Set,this.exportOnlyBindings=new Set;}}class TypeScriptScopeHandler extends ScopeHandler{createScope(flags){return new TypeScriptScope(flags)}declareName(name,bindingType,loc){const scope=this.currentScope();if(1024&bindingType)return this.maybeExportDefined(scope,name),void scope.exportOnlyBindings.add(name);super.declareName(...arguments),2&bindingType&&(1&bindingType||(this.checkRedeclarationInScope(scope,name,bindingType,loc),this.maybeExportDefined(scope,name)),scope.types.add(name)),256&bindingType&&scope.enums.add(name),512&bindingType&&scope.constEnums.add(name),128&bindingType&&scope.classes.add(name);}isRedeclaredInScope(scope,name,bindingType){if(scope.enums.has(name)){if(256&bindingType){return !!(512&bindingType)!==scope.constEnums.has(name)}return !0}return 128&bindingType&&scope.classes.has(name)?!!scope.lexical.has(name)&&!!(1&bindingType):!!(2&bindingType&&scope.types.has(name))||super.isRedeclaredInScope(...arguments)}checkLocalExport(id){const topLevelScope=this.scopeStack[0],{name}=id;topLevelScope.types.has(name)||topLevelScope.exportOnlyBindings.has(name)||super.checkLocalExport(id);}}function assert(x){if(!x)throw new Error("Assert fail")}const TSErrors=makeErrorTemplates({AbstractMethodHasImplementation:"Method '%0' cannot have an implementation because it is marked abstract.",AbstractPropertyHasInitializer:"Property '%0' cannot have an initializer because it is marked abstract.",AccesorCannotDeclareThisParameter:"'get' and 'set' accessors cannot declare 'this' parameters.",AccesorCannotHaveTypeParameters:"An accessor cannot have type parameters.",ClassMethodHasDeclare:"Class methods cannot have the 'declare' modifier.",ClassMethodHasReadonly:"Class methods cannot have the 'readonly' modifier.",ConstructorHasTypeParameters:"Type parameters cannot appear on a constructor declaration.",DeclareAccessor:"'declare' is not allowed in %0ters.",DeclareClassFieldHasInitializer:"Initializers are not allowed in ambient contexts.",DeclareFunctionHasImplementation:"An implementation cannot be declared in ambient contexts.",DuplicateAccessibilityModifier:"Accessibility modifier already seen.",DuplicateModifier:"Duplicate modifier: '%0'.",EmptyHeritageClauseType:"'%0' list cannot be empty.",EmptyTypeArguments:"Type argument list cannot be empty.",EmptyTypeParameters:"Type parameter list cannot be empty.",ExpectedAmbientAfterExportDeclare:"'export declare' must be followed by an ambient declaration.",ImportAliasHasImportType:"An import alias can not use 'import type'.",IncompatibleModifiers:"'%0' modifier cannot be used with '%1' modifier.",IndexSignatureHasAbstract:"Index signatures cannot have the 'abstract' modifier.",IndexSignatureHasAccessibility:"Index signatures cannot have an accessibility modifier ('%0').",IndexSignatureHasDeclare:"Index signatures cannot have the 'declare' modifier.",IndexSignatureHasOverride:"'override' modifier cannot appear on an index signature.",IndexSignatureHasStatic:"Index signatures cannot have the 'static' modifier.",InvalidModifierOnTypeMember:"'%0' modifier cannot appear on a type member.",InvalidModifiersOrder:"'%0' modifier must precede '%1' modifier.",InvalidTupleMemberLabel:"Tuple members must be labeled with a simple identifier.",MissingInterfaceName:"'interface' declarations must be followed by an identifier.",MixedLabeledAndUnlabeledElements:"Tuple members must all have names or all not have names.",NonAbstractClassHasAbstractMethod:"Abstract methods can only appear within an abstract class.",NonClassMethodPropertyHasAbstractModifer:"'abstract' modifier can only appear on a class, method, or property declaration.",OptionalTypeBeforeRequired:"A required element cannot follow an optional element.",OverrideNotInSubClass:"This member cannot have an 'override' modifier because its containing class does not extend another class.",PatternIsOptional:"A binding pattern parameter cannot be optional in an implementation signature.",PrivateElementHasAbstract:"Private elements cannot have the 'abstract' modifier.",PrivateElementHasAccessibility:"Private elements cannot have an accessibility modifier ('%0').",ReadonlyForMethodSignature:"'readonly' modifier can only appear on a property declaration or index signature.",ReservedArrowTypeParam:"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",ReservedTypeAssertion:"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",SetAccesorCannotHaveOptionalParameter:"A 'set' accessor cannot have an optional parameter.",SetAccesorCannotHaveRestParameter:"A 'set' accessor cannot have rest parameter.",SetAccesorCannotHaveReturnType:"A 'set' accessor cannot have a return type annotation.",StaticBlockCannotHaveModifier:"Static class blocks cannot have any modifier.",TypeAnnotationAfterAssign:"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",TypeImportCannotSpecifyDefaultAndNamed:"A type-only import can specify a default import or named bindings, but not both.",TypeModifierIsUsedInTypeExports:"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",TypeModifierIsUsedInTypeImports:"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",UnexpectedParameterModifier:"A parameter property is only allowed in a constructor implementation.",UnexpectedReadonly:"'readonly' type modifier is only permitted on array and tuple literal types.",UnexpectedTypeAnnotation:"Did not expect a type annotation here.",UnexpectedTypeCastInParameter:"Unexpected type cast in parameter position.",UnsupportedImportTypeArgument:"Argument in a type import must be a string literal.",UnsupportedParameterPropertyKind:"A parameter property may not be declared using a binding pattern.",UnsupportedSignatureParameterKind:"Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0."},ErrorCodes.SyntaxError,"typescript");function tsIsAccessModifier(modifier){return "private"===modifier||"public"===modifier||"protected"===modifier}const PlaceholderErrors=makeErrorTemplates({ClassNameIsRequired:"A class name is required."},ErrorCodes.SyntaxError,"placeholders");function hasPlugin(plugins,expectedConfig){const[expectedName,expectedOptions]="string"==typeof expectedConfig?[expectedConfig,{}]:expectedConfig,expectedKeys=Object.keys(expectedOptions),expectedOptionsIsEmpty=0===expectedKeys.length;return plugins.some((p=>{if("string"==typeof p)return expectedOptionsIsEmpty&&p===expectedName;{const[pluginName,pluginOptions]=p;if(pluginName!==expectedName)return !1;for(const key of expectedKeys)if(pluginOptions[key]!==expectedOptions[key])return !1;return !0}}))}function getPluginOption(plugins,name,option){const plugin=plugins.find((plugin=>Array.isArray(plugin)?plugin[0]===name:plugin===name));return plugin&&Array.isArray(plugin)?plugin[1][option]:null}const PIPELINE_PROPOSALS=["minimal","fsharp","hack","smart"],TOPIC_TOKENS=["^","%","#"],RECORD_AND_TUPLE_SYNTAX_TYPES=["hash","bar"];const mixinPlugins={estree:superClass=>class extends superClass{parseRegExpLiteral({pattern,flags}){let regex=null;try{regex=new RegExp(pattern,flags);}catch(e){}const node=this.estreeParseLiteral(regex);return node.regex={pattern,flags},node}parseBigIntLiteral(value){let bigInt;try{bigInt=BigInt(value);}catch(_unused){bigInt=null;}const node=this.estreeParseLiteral(bigInt);return node.bigint=String(node.value||value),node}parseDecimalLiteral(value){const node=this.estreeParseLiteral(null);return node.decimal=String(node.value||value),node}estreeParseLiteral(value){return this.parseLiteral(value,"Literal")}parseStringLiteral(value){return this.estreeParseLiteral(value)}parseNumericLiteral(value){return this.estreeParseLiteral(value)}parseNullLiteral(){return this.estreeParseLiteral(null)}parseBooleanLiteral(value){return this.estreeParseLiteral(value)}directiveToStmt(directive){const directiveLiteral=directive.value,stmt=this.startNodeAt(directive.start,directive.loc.start),expression=this.startNodeAt(directiveLiteral.start,directiveLiteral.loc.start);return expression.value=directiveLiteral.extra.expressionValue,expression.raw=directiveLiteral.extra.raw,stmt.expression=this.finishNodeAt(expression,"Literal",directiveLiteral.loc.end),stmt.directive=directiveLiteral.extra.raw.slice(1,-1),this.finishNodeAt(stmt,"ExpressionStatement",directive.loc.end)}initFunction(node,isAsync){super.initFunction(node,isAsync),node.expression=!1;}checkDeclaration(node){null!=node&&this.isObjectProperty(node)?this.checkDeclaration(node.value):super.checkDeclaration(node);}getObjectOrClassMethodParams(method){return method.value.params}isValidDirective(stmt){var _stmt$expression$extr;return "ExpressionStatement"===stmt.type&&"Literal"===stmt.expression.type&&"string"==typeof stmt.expression.value&&!(null!=(_stmt$expression$extr=stmt.expression.extra)&&_stmt$expression$extr.parenthesized)}parseBlockBody(node,...args){super.parseBlockBody(node,...args);const directiveStatements=node.directives.map((d=>this.directiveToStmt(d)));node.body=directiveStatements.concat(node.body),delete node.directives;}pushClassMethod(classBody,method,isGenerator,isAsync,isConstructor,allowsDirectSuper){this.parseMethod(method,isGenerator,isAsync,isConstructor,allowsDirectSuper,"ClassMethod",!0),method.typeParameters&&(method.value.typeParameters=method.typeParameters,delete method.typeParameters),classBody.body.push(method);}parsePrivateName(){const node=super.parsePrivateName();return this.getPluginOption("estree","classFeatures")?this.convertPrivateNameToPrivateIdentifier(node):node}convertPrivateNameToPrivateIdentifier(node){const name=super.getPrivateNameSV(node);return delete(node=node).id,node.name=name,node.type="PrivateIdentifier",node}isPrivateName(node){return this.getPluginOption("estree","classFeatures")?"PrivateIdentifier"===node.type:super.isPrivateName(node)}getPrivateNameSV(node){return this.getPluginOption("estree","classFeatures")?node.name:super.getPrivateNameSV(node)}parseLiteral(value,type){const node=super.parseLiteral(value,type);return node.raw=node.extra.raw,delete node.extra,node}parseFunctionBody(node,allowExpression,isMethod=!1){super.parseFunctionBody(node,allowExpression,isMethod),node.expression="BlockStatement"!==node.body.type;}parseMethod(node,isGenerator,isAsync,isConstructor,allowDirectSuper,type,inClassScope=!1){let funcNode=this.startNode();return funcNode.kind=node.kind,funcNode=super.parseMethod(funcNode,isGenerator,isAsync,isConstructor,allowDirectSuper,type,inClassScope),funcNode.type="FunctionExpression",delete funcNode.kind,node.value=funcNode,"ClassPrivateMethod"===type&&(node.computed=!1),type="MethodDefinition",this.finishNode(node,type)}parseClassProperty(...args){const propertyNode=super.parseClassProperty(...args);return this.getPluginOption("estree","classFeatures")?(propertyNode.type="PropertyDefinition",propertyNode):propertyNode}parseClassPrivateProperty(...args){const propertyNode=super.parseClassPrivateProperty(...args);return this.getPluginOption("estree","classFeatures")?(propertyNode.type="PropertyDefinition",propertyNode.computed=!1,propertyNode):propertyNode}parseObjectMethod(prop,isGenerator,isAsync,isPattern,isAccessor){const node=super.parseObjectMethod(prop,isGenerator,isAsync,isPattern,isAccessor);return node&&(node.type="Property","method"===node.kind&&(node.kind="init"),node.shorthand=!1),node}parseObjectProperty(prop,startPos,startLoc,isPattern,refExpressionErrors){const node=super.parseObjectProperty(prop,startPos,startLoc,isPattern,refExpressionErrors);return node&&(node.kind="init",node.type="Property"),node}isAssignable(node,isBinding){return null!=node&&this.isObjectProperty(node)?this.isAssignable(node.value,isBinding):super.isAssignable(node,isBinding)}toAssignable(node,isLHS=!1){return null!=node&&this.isObjectProperty(node)?(this.toAssignable(node.value,isLHS),node):super.toAssignable(node,isLHS)}toAssignableObjectExpressionProp(prop,...args){"get"===prop.kind||"set"===prop.kind?this.raise(ErrorMessages.PatternHasAccessor,{node:prop.key}):prop.method?this.raise(ErrorMessages.PatternHasMethod,{node:prop.key}):super.toAssignableObjectExpressionProp(prop,...args);}finishCallExpression(node,optional){if(super.finishCallExpression(node,optional),"Import"===node.callee.type){var _node$arguments$;if(node.type="ImportExpression",node.source=node.arguments[0],this.hasPlugin("importAssertions"))node.attributes=null!=(_node$arguments$=node.arguments[1])?_node$arguments$:null;delete node.arguments,delete node.callee;}return node}toReferencedArguments(node){"ImportExpression"!==node.type&&super.toReferencedArguments(node);}parseExport(node){switch(super.parseExport(node),node.type){case"ExportAllDeclaration":node.exported=null;break;case"ExportNamedDeclaration":1===node.specifiers.length&&"ExportNamespaceSpecifier"===node.specifiers[0].type&&(node.type="ExportAllDeclaration",node.exported=node.specifiers[0].exported,delete node.specifiers);}return node}parseSubscript(base,startPos,startLoc,noCalls,state){const node=super.parseSubscript(base,startPos,startLoc,noCalls,state);if(state.optionalChainMember){if("OptionalMemberExpression"!==node.type&&"OptionalCallExpression"!==node.type||(node.type=node.type.substring(8)),state.stop){const chain=this.startNodeAtNode(node);return chain.expression=node,this.finishNode(chain,"ChainExpression")}}else "MemberExpression"!==node.type&&"CallExpression"!==node.type||(node.optional=!1);return node}hasPropertyAsPrivateName(node){return "ChainExpression"===node.type&&(node=node.expression),super.hasPropertyAsPrivateName(node)}isOptionalChain(node){return "ChainExpression"===node.type}isObjectProperty(node){return "Property"===node.type&&"init"===node.kind&&!node.method}isObjectMethod(node){return node.method||"get"===node.kind||"set"===node.kind}},jsx:superClass=>class extends superClass{jsxReadToken(){let out="",chunkStart=this.state.pos;for(;;){if(this.state.pos>=this.length)throw this.raise(JsxErrors.UnterminatedJsxContent,{at:this.state.startLoc});const ch=this.input.charCodeAt(this.state.pos);switch(ch){case 60:case 123:return this.state.pos===this.state.start?60===ch&&this.state.canStartJSXElement?(++this.state.pos,this.finishToken(134)):super.getTokenFromCode(ch):(out+=this.input.slice(chunkStart,this.state.pos),this.finishToken(133,out));case 38:out+=this.input.slice(chunkStart,this.state.pos),out+=this.jsxReadEntity(),chunkStart=this.state.pos;break;default:isNewLine(ch)?(out+=this.input.slice(chunkStart,this.state.pos),out+=this.jsxReadNewLine(!0),chunkStart=this.state.pos):++this.state.pos;}}}jsxReadNewLine(normalizeCRLF){const ch=this.input.charCodeAt(this.state.pos);let out;return ++this.state.pos,13===ch&&10===this.input.charCodeAt(this.state.pos)?(++this.state.pos,out=normalizeCRLF?"\n":"\r\n"):out=String.fromCharCode(ch),++this.state.curLine,this.state.lineStart=this.state.pos,out}jsxReadString(quote){let out="",chunkStart=++this.state.pos;for(;;){if(this.state.pos>=this.length)throw this.raise(ErrorMessages.UnterminatedString,{at:this.state.startLoc});const ch=this.input.charCodeAt(this.state.pos);if(ch===quote)break;38===ch?(out+=this.input.slice(chunkStart,this.state.pos),out+=this.jsxReadEntity(),chunkStart=this.state.pos):isNewLine(ch)?(out+=this.input.slice(chunkStart,this.state.pos),out+=this.jsxReadNewLine(!1),chunkStart=this.state.pos):++this.state.pos;}return out+=this.input.slice(chunkStart,this.state.pos++),this.finishToken(125,out)}jsxReadEntity(){let entity,str="",count=0,ch=this.input[this.state.pos];const startPos=++this.state.pos;for(;this.state.pos<this.length&&count++<10;){if(ch=this.input[this.state.pos++],";"===ch){"#"===str[0]?"x"===str[1]?(str=str.substr(2),HEX_NUMBER.test(str)&&(entity=String.fromCodePoint(parseInt(str,16)))):(str=str.substr(1),DECIMAL_NUMBER.test(str)&&(entity=String.fromCodePoint(parseInt(str,10)))):entity=entities[str];break}str+=ch;}return entity||(this.state.pos=startPos,"&")}jsxReadWord(){let ch;const start=this.state.pos;do{ch=this.input.charCodeAt(++this.state.pos);}while(isIdentifierChar(ch)||45===ch);return this.finishToken(132,this.input.slice(start,this.state.pos))}jsxParseIdentifier(){const node=this.startNode();return this.match(132)?node.name=this.state.value:tokenIsKeyword(this.state.type)?node.name=tokenLabelName(this.state.type):this.unexpected(),this.next(),this.finishNode(node,"JSXIdentifier")}jsxParseNamespacedName(){const startPos=this.state.start,startLoc=this.state.startLoc,name=this.jsxParseIdentifier();if(!this.eat(14))return name;const node=this.startNodeAt(startPos,startLoc);return node.namespace=name,node.name=this.jsxParseIdentifier(),this.finishNode(node,"JSXNamespacedName")}jsxParseElementName(){const startPos=this.state.start,startLoc=this.state.startLoc;let node=this.jsxParseNamespacedName();if("JSXNamespacedName"===node.type)return node;for(;this.eat(16);){const newNode=this.startNodeAt(startPos,startLoc);newNode.object=node,newNode.property=this.jsxParseIdentifier(),node=this.finishNode(newNode,"JSXMemberExpression");}return node}jsxParseAttributeValue(){let node;switch(this.state.type){case 5:return node=this.startNode(),this.setContext(types.brace),this.next(),node=this.jsxParseExpressionContainer(node,types.j_oTag),"JSXEmptyExpression"===node.expression.type&&this.raise(JsxErrors.AttributeIsEmpty,{node}),node;case 134:case 125:return this.parseExprAtom();default:throw this.raise(JsxErrors.UnsupportedJsxValue,{at:this.state.startLoc})}}jsxParseEmptyExpression(){const node=this.startNodeAt(indexes.get(this.state.lastTokEndLoc),this.state.lastTokEndLoc);return this.finishNodeAt(node,"JSXEmptyExpression",this.state.startLoc)}jsxParseSpreadChild(node){return this.next(),node.expression=this.parseExpression(),this.setContext(types.j_oTag),this.expect(8),this.finishNode(node,"JSXSpreadChild")}jsxParseExpressionContainer(node,previousContext){if(this.match(8))node.expression=this.jsxParseEmptyExpression();else {const expression=this.parseExpression();node.expression=expression;}return this.setContext(previousContext),this.expect(8),this.finishNode(node,"JSXExpressionContainer")}jsxParseAttribute(){const node=this.startNode();return this.match(5)?(this.setContext(types.brace),this.next(),this.expect(21),node.argument=this.parseMaybeAssignAllowIn(),this.setContext(types.j_oTag),this.expect(8),this.finishNode(node,"JSXSpreadAttribute")):(node.name=this.jsxParseNamespacedName(),node.value=this.eat(29)?this.jsxParseAttributeValue():null,this.finishNode(node,"JSXAttribute"))}jsxParseOpeningElementAt(startPos,startLoc){const node=this.startNodeAt(startPos,startLoc);return this.match(135)?(this.expect(135),this.finishNode(node,"JSXOpeningFragment")):(node.name=this.jsxParseElementName(),this.jsxParseOpeningElementAfterName(node))}jsxParseOpeningElementAfterName(node){const attributes=[];for(;!this.match(52)&&!this.match(135);)attributes.push(this.jsxParseAttribute());return node.attributes=attributes,node.selfClosing=this.eat(52),this.expect(135),this.finishNode(node,"JSXOpeningElement")}jsxParseClosingElementAt(startPos,startLoc){const node=this.startNodeAt(startPos,startLoc);return this.match(135)?(this.expect(135),this.finishNode(node,"JSXClosingFragment")):(node.name=this.jsxParseElementName(),this.expect(135),this.finishNode(node,"JSXClosingElement"))}jsxParseElementAt(startPos,startLoc){const node=this.startNodeAt(startPos,startLoc),children=[],openingElement=this.jsxParseOpeningElementAt(startPos,startLoc);let closingElement=null;if(!openingElement.selfClosing){contents:for(;;)switch(this.state.type){case 134:if(startPos=this.state.start,startLoc=this.state.startLoc,this.next(),this.eat(52)){closingElement=this.jsxParseClosingElementAt(startPos,startLoc);break contents}children.push(this.jsxParseElementAt(startPos,startLoc));break;case 133:children.push(this.parseExprAtom());break;case 5:{const node=this.startNode();this.setContext(types.brace),this.next(),this.match(21)?children.push(this.jsxParseSpreadChild(node)):children.push(this.jsxParseExpressionContainer(node,types.j_expr));break}default:throw this.unexpected()}isFragment(openingElement)&&!isFragment(closingElement)&&null!==closingElement?this.raise(JsxErrors.MissingClosingTagFragment,{node:closingElement}):!isFragment(openingElement)&&isFragment(closingElement)?this.raise(JsxErrors.MissingClosingTagElement,{node:closingElement},getQualifiedJSXName(openingElement.name)):isFragment(openingElement)||isFragment(closingElement)||getQualifiedJSXName(closingElement.name)!==getQualifiedJSXName(openingElement.name)&&this.raise(JsxErrors.MissingClosingTagElement,{node:closingElement},getQualifiedJSXName(openingElement.name));}if(isFragment(openingElement)?(node.openingFragment=openingElement,node.closingFragment=closingElement):(node.openingElement=openingElement,node.closingElement=closingElement),node.children=children,this.match(45))throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements,{at:this.state.startLoc});return isFragment(openingElement)?this.finishNode(node,"JSXFragment"):this.finishNode(node,"JSXElement")}jsxParseElement(){const startPos=this.state.start,startLoc=this.state.startLoc;return this.next(),this.jsxParseElementAt(startPos,startLoc)}setContext(newContext){const{context}=this.state;context[context.length-1]=newContext;}parseExprAtom(refExpressionErrors){return this.match(133)?this.parseLiteral(this.state.value,"JSXText"):this.match(134)?this.jsxParseElement():this.match(45)&&33!==this.input.charCodeAt(this.state.pos)?(this.replaceToken(134),this.jsxParseElement()):super.parseExprAtom(refExpressionErrors)}skipSpace(){this.curContext().preserveSpace||super.skipSpace();}getTokenFromCode(code){const context=this.curContext();if(context===types.j_expr)return this.jsxReadToken();if(context===types.j_oTag||context===types.j_cTag){if(isIdentifierStart(code))return this.jsxReadWord();if(62===code)return ++this.state.pos,this.finishToken(135);if((34===code||39===code)&&context===types.j_oTag)return this.jsxReadString(code)}return 60===code&&this.state.canStartJSXElement&&33!==this.input.charCodeAt(this.state.pos+1)?(++this.state.pos,this.finishToken(134)):super.getTokenFromCode(code)}updateContext(prevType){const{context,type}=this.state;if(52===type&&134===prevType)context.splice(-2,2,types.j_cTag),this.state.canStartJSXElement=!1;else if(134===type)context.push(types.j_oTag);else if(135===type){const out=context[context.length-1];out===types.j_oTag&&52===prevType||out===types.j_cTag?(context.pop(),this.state.canStartJSXElement=context[context.length-1]===types.j_expr):(this.setContext(types.j_expr),this.state.canStartJSXElement=!0);}else this.state.canStartJSXElement=tokenBeforeExprs[type];}},flow:superClass=>class extends superClass{constructor(...args){super(...args),this.flowPragma=void 0;}getScopeHandler(){return FlowScopeHandler}shouldParseTypes(){return this.getPluginOption("flow","all")||"flow"===this.flowPragma}shouldParseEnums(){return !!this.getPluginOption("flow","enums")}finishToken(type,val){return 125!==type&&13!==type&&28!==type&&void 0===this.flowPragma&&(this.flowPragma=null),super.finishToken(type,val)}addComment(comment){if(void 0===this.flowPragma){const matches=FLOW_PRAGMA_REGEX.exec(comment.value);if(matches)if("flow"===matches[1])this.flowPragma="flow";else {if("noflow"!==matches[1])throw new Error("Unexpected flow pragma");this.flowPragma="noflow";}}return super.addComment(comment)}flowParseTypeInitialiser(tok){const oldInType=this.state.inType;this.state.inType=!0,this.expect(tok||14);const type=this.flowParseType();return this.state.inType=oldInType,type}flowParsePredicate(){const node=this.startNode(),moduloLoc=this.state.startLoc;return this.next(),this.expectContextual(103),this.state.lastTokStart>indexes.get(moduloLoc)+1&&this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks,{at:moduloLoc}),this.eat(10)?(node.value=this.parseExpression(),this.expect(11),this.finishNode(node,"DeclaredPredicate")):this.finishNode(node,"InferredPredicate")}flowParseTypeAndPredicateInitialiser(){const oldInType=this.state.inType;this.state.inType=!0,this.expect(14);let type=null,predicate=null;return this.match(50)?(this.state.inType=oldInType,predicate=this.flowParsePredicate()):(type=this.flowParseType(),this.state.inType=oldInType,this.match(50)&&(predicate=this.flowParsePredicate())),[type,predicate]}flowParseDeclareClass(node){return this.next(),this.flowParseInterfaceish(node,!0),this.finishNode(node,"DeclareClass")}flowParseDeclareFunction(node){this.next();const id=node.id=this.parseIdentifier(),typeNode=this.startNode(),typeContainer=this.startNode();this.match(45)?typeNode.typeParameters=this.flowParseTypeParameterDeclaration():typeNode.typeParameters=null,this.expect(10);const tmp=this.flowParseFunctionTypeParams();return typeNode.params=tmp.params,typeNode.rest=tmp.rest,typeNode.this=tmp._this,this.expect(11),[typeNode.returnType,node.predicate]=this.flowParseTypeAndPredicateInitialiser(),typeContainer.typeAnnotation=this.finishNode(typeNode,"FunctionTypeAnnotation"),id.typeAnnotation=this.finishNode(typeContainer,"TypeAnnotation"),this.resetEndLocation(id),this.semicolon(),this.scope.declareName(node.id.name,2048,node.id.loc.start),this.finishNode(node,"DeclareFunction")}flowParseDeclare(node,insideModule){if(this.match(76))return this.flowParseDeclareClass(node);if(this.match(64))return this.flowParseDeclareFunction(node);if(this.match(70))return this.flowParseDeclareVariable(node);if(this.eatContextual(119))return this.match(16)?this.flowParseDeclareModuleExports(node):(insideModule&&this.raise(FlowErrors.NestedDeclareModule,{at:this.state.lastTokStartLoc}),this.flowParseDeclareModule(node));if(this.isContextual(122))return this.flowParseDeclareTypeAlias(node);if(this.isContextual(123))return this.flowParseDeclareOpaqueType(node);if(this.isContextual(121))return this.flowParseDeclareInterface(node);if(this.match(78))return this.flowParseDeclareExportDeclaration(node,insideModule);throw this.unexpected()}flowParseDeclareVariable(node){return this.next(),node.id=this.flowParseTypeAnnotatableIdentifier(!0),this.scope.declareName(node.id.name,5,node.id.loc.start),this.semicolon(),this.finishNode(node,"DeclareVariable")}flowParseDeclareModule(node){this.scope.enter(0),this.match(125)?node.id=this.parseExprAtom():node.id=this.parseIdentifier();const bodyNode=node.body=this.startNode(),body=bodyNode.body=[];for(this.expect(5);!this.match(8);){let bodyNode=this.startNode();this.match(79)?(this.next(),this.isContextual(122)||this.match(83)||this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule,{at:this.state.lastTokStartLoc}),this.parseImport(bodyNode)):(this.expectContextual(117,FlowErrors.UnsupportedStatementInDeclareModule),bodyNode=this.flowParseDeclare(bodyNode,!0)),body.push(bodyNode);}this.scope.exit(),this.expect(8),this.finishNode(bodyNode,"BlockStatement");let kind=null,hasModuleExport=!1;return body.forEach((bodyElement=>{!function(bodyElement){return "DeclareExportAllDeclaration"===bodyElement.type||"DeclareExportDeclaration"===bodyElement.type&&(!bodyElement.declaration||"TypeAlias"!==bodyElement.declaration.type&&"InterfaceDeclaration"!==bodyElement.declaration.type)}(bodyElement)?"DeclareModuleExports"===bodyElement.type&&(hasModuleExport&&this.raise(FlowErrors.DuplicateDeclareModuleExports,{node:bodyElement}),"ES"===kind&&this.raise(FlowErrors.AmbiguousDeclareModuleKind,{node:bodyElement}),kind="CommonJS",hasModuleExport=!0):("CommonJS"===kind&&this.raise(FlowErrors.AmbiguousDeclareModuleKind,{node:bodyElement}),kind="ES");})),node.kind=kind||"CommonJS",this.finishNode(node,"DeclareModule")}flowParseDeclareExportDeclaration(node,insideModule){if(this.expect(78),this.eat(61))return this.match(64)||this.match(76)?node.declaration=this.flowParseDeclare(this.startNode()):(node.declaration=this.flowParseType(),this.semicolon()),node.default=!0,this.finishNode(node,"DeclareExportDeclaration");if(this.match(71)||this.isLet()||(this.isContextual(122)||this.isContextual(121))&&!insideModule){const label=this.state.value,suggestion=exportSuggestions[label];throw this.raise(FlowErrors.UnsupportedDeclareExportKind,{at:this.state.startLoc},label,suggestion)}if(this.match(70)||this.match(64)||this.match(76)||this.isContextual(123))return node.declaration=this.flowParseDeclare(this.startNode()),node.default=!1,this.finishNode(node,"DeclareExportDeclaration");if(this.match(51)||this.match(5)||this.isContextual(121)||this.isContextual(122)||this.isContextual(123))return "ExportNamedDeclaration"===(node=this.parseExport(node)).type&&(node.type="ExportDeclaration",node.default=!1,delete node.exportKind),node.type="Declare"+node.type,node;throw this.unexpected()}flowParseDeclareModuleExports(node){return this.next(),this.expectContextual(104),node.typeAnnotation=this.flowParseTypeAnnotation(),this.semicolon(),this.finishNode(node,"DeclareModuleExports")}flowParseDeclareTypeAlias(node){return this.next(),this.flowParseTypeAlias(node),node.type="DeclareTypeAlias",node}flowParseDeclareOpaqueType(node){return this.next(),this.flowParseOpaqueType(node,!0),node.type="DeclareOpaqueType",node}flowParseDeclareInterface(node){return this.next(),this.flowParseInterfaceish(node),this.finishNode(node,"DeclareInterface")}flowParseInterfaceish(node,isClass=!1){if(node.id=this.flowParseRestrictedIdentifier(!isClass,!0),this.scope.declareName(node.id.name,isClass?17:9,node.id.loc.start),this.match(45)?node.typeParameters=this.flowParseTypeParameterDeclaration():node.typeParameters=null,node.extends=[],node.implements=[],node.mixins=[],this.eat(77))do{node.extends.push(this.flowParseInterfaceExtends());}while(!isClass&&this.eat(12));if(this.isContextual(110)){this.next();do{node.mixins.push(this.flowParseInterfaceExtends());}while(this.eat(12))}if(this.isContextual(106)){this.next();do{node.implements.push(this.flowParseInterfaceExtends());}while(this.eat(12))}node.body=this.flowParseObjectType({allowStatic:isClass,allowExact:!1,allowSpread:!1,allowProto:isClass,allowInexact:!1});}flowParseInterfaceExtends(){const node=this.startNode();return node.id=this.flowParseQualifiedTypeIdentifier(),this.match(45)?node.typeParameters=this.flowParseTypeParameterInstantiation():node.typeParameters=null,this.finishNode(node,"InterfaceExtends")}flowParseInterface(node){return this.flowParseInterfaceish(node),this.finishNode(node,"InterfaceDeclaration")}checkNotUnderscore(word){"_"===word&&this.raise(FlowErrors.UnexpectedReservedUnderscore,{at:this.state.startLoc});}checkReservedType(word,startLoc,declaration){reservedTypes.has(word)&&this.raise(declaration?FlowErrors.AssignReservedType:FlowErrors.UnexpectedReservedType,{at:startLoc},word);}flowParseRestrictedIdentifier(liberal,declaration){return this.checkReservedType(this.state.value,this.state.startLoc,declaration),this.parseIdentifier(liberal)}flowParseTypeAlias(node){return node.id=this.flowParseRestrictedIdentifier(!1,!0),this.scope.declareName(node.id.name,9,node.id.loc.start),this.match(45)?node.typeParameters=this.flowParseTypeParameterDeclaration():node.typeParameters=null,node.right=this.flowParseTypeInitialiser(29),this.semicolon(),this.finishNode(node,"TypeAlias")}flowParseOpaqueType(node,declare){return this.expectContextual(122),node.id=this.flowParseRestrictedIdentifier(!0,!0),this.scope.declareName(node.id.name,9,node.id.loc.start),this.match(45)?node.typeParameters=this.flowParseTypeParameterDeclaration():node.typeParameters=null,node.supertype=null,this.match(14)&&(node.supertype=this.flowParseTypeInitialiser(14)),node.impltype=null,declare||(node.impltype=this.flowParseTypeInitialiser(29)),this.semicolon(),this.finishNode(node,"OpaqueType")}flowParseTypeParameter(requireDefault=!1){const nodeStartLoc=this.state.startLoc,node=this.startNode(),variance=this.flowParseVariance(),ident=this.flowParseTypeAnnotatableIdentifier();return node.name=ident.name,node.variance=variance,node.bound=ident.typeAnnotation,this.match(29)?(this.eat(29),node.default=this.flowParseType()):requireDefault&&this.raise(FlowErrors.MissingTypeParamDefault,{at:nodeStartLoc}),this.finishNode(node,"TypeParameter")}flowParseTypeParameterDeclaration(){const oldInType=this.state.inType,node=this.startNode();node.params=[],this.state.inType=!0,this.match(45)||this.match(134)?this.next():this.unexpected();let defaultRequired=!1;do{const typeParameter=this.flowParseTypeParameter(defaultRequired);node.params.push(typeParameter),typeParameter.default&&(defaultRequired=!0),this.match(46)||this.expect(12);}while(!this.match(46));return this.expect(46),this.state.inType=oldInType,this.finishNode(node,"TypeParameterDeclaration")}flowParseTypeParameterInstantiation(){const node=this.startNode(),oldInType=this.state.inType;node.params=[],this.state.inType=!0,this.expect(45);const oldNoAnonFunctionType=this.state.noAnonFunctionType;for(this.state.noAnonFunctionType=!1;!this.match(46);)node.params.push(this.flowParseType()),this.match(46)||this.expect(12);return this.state.noAnonFunctionType=oldNoAnonFunctionType,this.expect(46),this.state.inType=oldInType,this.finishNode(node,"TypeParameterInstantiation")}flowParseTypeParameterInstantiationCallOrNew(){const node=this.startNode(),oldInType=this.state.inType;for(node.params=[],this.state.inType=!0,this.expect(45);!this.match(46);)node.params.push(this.flowParseTypeOrImplicitInstantiation()),this.match(46)||this.expect(12);return this.expect(46),this.state.inType=oldInType,this.finishNode(node,"TypeParameterInstantiation")}flowParseInterfaceType(){const node=this.startNode();if(this.expectContextual(121),node.extends=[],this.eat(77))do{node.extends.push(this.flowParseInterfaceExtends());}while(this.eat(12));return node.body=this.flowParseObjectType({allowStatic:!1,allowExact:!1,allowSpread:!1,allowProto:!1,allowInexact:!1}),this.finishNode(node,"InterfaceTypeAnnotation")}flowParseObjectPropertyKey(){return this.match(126)||this.match(125)?this.parseExprAtom():this.parseIdentifier(!0)}flowParseObjectTypeIndexer(node,isStatic,variance){return node.static=isStatic,14===this.lookahead().type?(node.id=this.flowParseObjectPropertyKey(),node.key=this.flowParseTypeInitialiser()):(node.id=null,node.key=this.flowParseType()),this.expect(3),node.value=this.flowParseTypeInitialiser(),node.variance=variance,this.finishNode(node,"ObjectTypeIndexer")}flowParseObjectTypeInternalSlot(node,isStatic){return node.static=isStatic,node.id=this.flowParseObjectPropertyKey(),this.expect(3),this.expect(3),this.match(45)||this.match(10)?(node.method=!0,node.optional=!1,node.value=this.flowParseObjectTypeMethodish(this.startNodeAt(node.start,node.loc.start))):(node.method=!1,this.eat(17)&&(node.optional=!0),node.value=this.flowParseTypeInitialiser()),this.finishNode(node,"ObjectTypeInternalSlot")}flowParseObjectTypeMethodish(node){for(node.params=[],node.rest=null,node.typeParameters=null,node.this=null,this.match(45)&&(node.typeParameters=this.flowParseTypeParameterDeclaration()),this.expect(10),this.match(74)&&(node.this=this.flowParseFunctionTypeParam(!0),node.this.name=null,this.match(11)||this.expect(12));!this.match(11)&&!this.match(21);)node.params.push(this.flowParseFunctionTypeParam(!1)),this.match(11)||this.expect(12);return this.eat(21)&&(node.rest=this.flowParseFunctionTypeParam(!1)),this.expect(11),node.returnType=this.flowParseTypeInitialiser(),this.finishNode(node,"FunctionTypeAnnotation")}flowParseObjectTypeCallProperty(node,isStatic){const valueNode=this.startNode();return node.static=isStatic,node.value=this.flowParseObjectTypeMethodish(valueNode),this.finishNode(node,"ObjectTypeCallProperty")}flowParseObjectType({allowStatic,allowExact,allowSpread,allowProto,allowInexact}){const oldInType=this.state.inType;this.state.inType=!0;const nodeStart=this.startNode();let endDelim,exact;nodeStart.callProperties=[],nodeStart.properties=[],nodeStart.indexers=[],nodeStart.internalSlots=[];let inexact=!1;for(allowExact&&this.match(6)?(this.expect(6),endDelim=9,exact=!0):(this.expect(5),endDelim=8,exact=!1),nodeStart.exact=exact;!this.match(endDelim);){let isStatic=!1,protoStartLoc=null,inexactStartLoc=null;const node=this.startNode();if(allowProto&&this.isContextual(111)){const lookahead=this.lookahead();14!==lookahead.type&&17!==lookahead.type&&(this.next(),protoStartLoc=this.state.startLoc,allowStatic=!1);}if(allowStatic&&this.isContextual(100)){const lookahead=this.lookahead();14!==lookahead.type&&17!==lookahead.type&&(this.next(),isStatic=!0);}const variance=this.flowParseVariance();if(this.eat(0))null!=protoStartLoc&&this.unexpected(protoStartLoc),this.eat(0)?(variance&&this.unexpected(variance.loc.start),nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node,isStatic))):nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node,isStatic,variance));else if(this.match(10)||this.match(45))null!=protoStartLoc&&this.unexpected(protoStartLoc),variance&&this.unexpected(variance.loc.start),nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node,isStatic));else {let kind="init";if(this.isContextual(94)||this.isContextual(99)){tokenIsLiteralPropertyName(this.lookahead().type)&&(kind=this.state.value,this.next());}const propOrInexact=this.flowParseObjectTypeProperty(node,isStatic,protoStartLoc,variance,kind,allowSpread,null!=allowInexact?allowInexact:!exact);null===propOrInexact?(inexact=!0,inexactStartLoc=this.state.lastTokStartLoc):nodeStart.properties.push(propOrInexact);}this.flowObjectTypeSemicolon(),!inexactStartLoc||this.match(8)||this.match(9)||this.raise(FlowErrors.UnexpectedExplicitInexactInObject,{at:inexactStartLoc});}this.expect(endDelim),allowSpread&&(nodeStart.inexact=inexact);const out=this.finishNode(nodeStart,"ObjectTypeAnnotation");return this.state.inType=oldInType,out}flowParseObjectTypeProperty(node,isStatic,protoStartLoc,variance,kind,allowSpread,allowInexact){if(this.eat(21)){return this.match(12)||this.match(13)||this.match(8)||this.match(9)?(allowSpread?allowInexact||this.raise(FlowErrors.InexactInsideExact,{at:this.state.lastTokStartLoc}):this.raise(FlowErrors.InexactInsideNonObject,{at:this.state.lastTokStartLoc}),variance&&this.raise(FlowErrors.InexactVariance,{node:variance}),null):(allowSpread||this.raise(FlowErrors.UnexpectedSpreadType,{at:this.state.lastTokStartLoc}),null!=protoStartLoc&&this.unexpected(protoStartLoc),variance&&this.raise(FlowErrors.SpreadVariance,{node:variance}),node.argument=this.flowParseType(),this.finishNode(node,"ObjectTypeSpreadProperty"))}{node.key=this.flowParseObjectPropertyKey(),node.static=isStatic,node.proto=null!=protoStartLoc,node.kind=kind;let optional=!1;return this.match(45)||this.match(10)?(node.method=!0,null!=protoStartLoc&&this.unexpected(protoStartLoc),variance&&this.unexpected(variance.loc.start),node.value=this.flowParseObjectTypeMethodish(this.startNodeAt(node.start,node.loc.start)),"get"!==kind&&"set"!==kind||this.flowCheckGetterSetterParams(node),!allowSpread&&"constructor"===node.key.name&&node.value.this&&this.raise(FlowErrors.ThisParamBannedInConstructor,{node:node.value.this})):("init"!==kind&&this.unexpected(),node.method=!1,this.eat(17)&&(optional=!0),node.value=this.flowParseTypeInitialiser(),node.variance=variance),node.optional=optional,this.finishNode(node,"ObjectTypeProperty")}}flowCheckGetterSetterParams(property){const paramCount="get"===property.kind?0:1,length=property.value.params.length+(property.value.rest?1:0);property.value.this&&this.raise("get"===property.kind?FlowErrors.GetterMayNotHaveThisParam:FlowErrors.SetterMayNotHaveThisParam,{node:property.value.this}),length!==paramCount&&this.raise("get"===property.kind?ErrorMessages.BadGetterArity:ErrorMessages.BadSetterArity,{node:property}),"set"===property.kind&&property.value.rest&&this.raise(ErrorMessages.BadSetterRestParameter,{node:property});}flowObjectTypeSemicolon(){this.eat(13)||this.eat(12)||this.match(8)||this.match(9)||this.unexpected();}flowParseQualifiedTypeIdentifier(startPos,startLoc,id){startPos=startPos||this.state.start,startLoc=startLoc||this.state.startLoc;let node=id||this.flowParseRestrictedIdentifier(!0);for(;this.eat(16);){const node2=this.startNodeAt(startPos,startLoc);node2.qualification=node,node2.id=this.flowParseRestrictedIdentifier(!0),node=this.finishNode(node2,"QualifiedTypeIdentifier");}return node}flowParseGenericType(startPos,startLoc,id){const node=this.startNodeAt(startPos,startLoc);return node.typeParameters=null,node.id=this.flowParseQualifiedTypeIdentifier(startPos,startLoc,id),this.match(45)&&(node.typeParameters=this.flowParseTypeParameterInstantiation()),this.finishNode(node,"GenericTypeAnnotation")}flowParseTypeofType(){const node=this.startNode();return this.expect(83),node.argument=this.flowParsePrimaryType(),this.finishNode(node,"TypeofTypeAnnotation")}flowParseTupleType(){const node=this.startNode();for(node.types=[],this.expect(0);this.state.pos<this.length&&!this.match(3)&&(node.types.push(this.flowParseType()),!this.match(3));)this.expect(12);return this.expect(3),this.finishNode(node,"TupleTypeAnnotation")}flowParseFunctionTypeParam(first){let name=null,optional=!1,typeAnnotation=null;const node=this.startNode(),lh=this.lookahead(),isThis=74===this.state.type;return 14===lh.type||17===lh.type?(isThis&&!first&&this.raise(FlowErrors.ThisParamMustBeFirst,{node}),name=this.parseIdentifier(isThis),this.eat(17)&&(optional=!0,isThis&&this.raise(FlowErrors.ThisParamMayNotBeOptional,{node})),typeAnnotation=this.flowParseTypeInitialiser()):typeAnnotation=this.flowParseType(),node.name=name,node.optional=optional,node.typeAnnotation=typeAnnotation,this.finishNode(node,"FunctionTypeParam")}reinterpretTypeAsFunctionTypeParam(type){const node=this.startNodeAt(type.start,type.loc.start);return node.name=null,node.optional=!1,node.typeAnnotation=type,this.finishNode(node,"FunctionTypeParam")}flowParseFunctionTypeParams(params=[]){let rest=null,_this=null;for(this.match(74)&&(_this=this.flowParseFunctionTypeParam(!0),_this.name=null,this.match(11)||this.expect(12));!this.match(11)&&!this.match(21);)params.push(this.flowParseFunctionTypeParam(!1)),this.match(11)||this.expect(12);return this.eat(21)&&(rest=this.flowParseFunctionTypeParam(!1)),{params,rest,_this}}flowIdentToTypeAnnotation(startPos,startLoc,node,id){switch(id.name){case"any":return this.finishNode(node,"AnyTypeAnnotation");case"bool":case"boolean":return this.finishNode(node,"BooleanTypeAnnotation");case"mixed":return this.finishNode(node,"MixedTypeAnnotation");case"empty":return this.finishNode(node,"EmptyTypeAnnotation");case"number":return this.finishNode(node,"NumberTypeAnnotation");case"string":return this.finishNode(node,"StringTypeAnnotation");case"symbol":return this.finishNode(node,"SymbolTypeAnnotation");default:return this.checkNotUnderscore(id.name),this.flowParseGenericType(startPos,startLoc,id)}}flowParsePrimaryType(){const startPos=this.state.start,startLoc=this.state.startLoc,node=this.startNode();let tmp,type,isGroupedType=!1;const oldNoAnonFunctionType=this.state.noAnonFunctionType;switch(this.state.type){case 5:return this.flowParseObjectType({allowStatic:!1,allowExact:!1,allowSpread:!0,allowProto:!1,allowInexact:!0});case 6:return this.flowParseObjectType({allowStatic:!1,allowExact:!0,allowSpread:!0,allowProto:!1,allowInexact:!1});case 0:return this.state.noAnonFunctionType=!1,type=this.flowParseTupleType(),this.state.noAnonFunctionType=oldNoAnonFunctionType,type;case 45:return node.typeParameters=this.flowParseTypeParameterDeclaration(),this.expect(10),tmp=this.flowParseFunctionTypeParams(),node.params=tmp.params,node.rest=tmp.rest,node.this=tmp._this,this.expect(11),this.expect(19),node.returnType=this.flowParseType(),this.finishNode(node,"FunctionTypeAnnotation");case 10:if(this.next(),!this.match(11)&&!this.match(21))if(tokenIsIdentifier(this.state.type)||this.match(74)){const token=this.lookahead().type;isGroupedType=17!==token&&14!==token;}else isGroupedType=!0;if(isGroupedType){if(this.state.noAnonFunctionType=!1,type=this.flowParseType(),this.state.noAnonFunctionType=oldNoAnonFunctionType,this.state.noAnonFunctionType||!(this.match(12)||this.match(11)&&19===this.lookahead().type))return this.expect(11),type;this.eat(12);}return tmp=type?this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]):this.flowParseFunctionTypeParams(),node.params=tmp.params,node.rest=tmp.rest,node.this=tmp._this,this.expect(11),this.expect(19),node.returnType=this.flowParseType(),node.typeParameters=null,this.finishNode(node,"FunctionTypeAnnotation");case 125:return this.parseLiteral(this.state.value,"StringLiteralTypeAnnotation");case 81:case 82:return node.value=this.match(81),this.next(),this.finishNode(node,"BooleanLiteralTypeAnnotation");case 49:if("-"===this.state.value){if(this.next(),this.match(126))return this.parseLiteralAtNode(-this.state.value,"NumberLiteralTypeAnnotation",node);if(this.match(127))return this.parseLiteralAtNode(-this.state.value,"BigIntLiteralTypeAnnotation",node);throw this.raise(FlowErrors.UnexpectedSubtractionOperand,{at:this.state.startLoc})}throw this.unexpected();case 126:return this.parseLiteral(this.state.value,"NumberLiteralTypeAnnotation");case 127:return this.parseLiteral(this.state.value,"BigIntLiteralTypeAnnotation");case 84:return this.next(),this.finishNode(node,"VoidTypeAnnotation");case 80:return this.next(),this.finishNode(node,"NullLiteralTypeAnnotation");case 74:return this.next(),this.finishNode(node,"ThisTypeAnnotation");case 51:return this.next(),this.finishNode(node,"ExistsTypeAnnotation");case 83:return this.flowParseTypeofType();default:if(tokenIsKeyword(this.state.type)){const label=tokenLabelName(this.state.type);return this.next(),super.createIdentifier(node,label)}if(tokenIsIdentifier(this.state.type))return this.isContextual(121)?this.flowParseInterfaceType():this.flowIdentToTypeAnnotation(startPos,startLoc,node,this.parseIdentifier())}throw this.unexpected()}flowParsePostfixType(){const startPos=this.state.start,startLoc=this.state.startLoc;let type=this.flowParsePrimaryType(),seenOptionalIndexedAccess=!1;for(;(this.match(0)||this.match(18))&&!this.canInsertSemicolon();){const node=this.startNodeAt(startPos,startLoc),optional=this.eat(18);seenOptionalIndexedAccess=seenOptionalIndexedAccess||optional,this.expect(0),!optional&&this.match(3)?(node.elementType=type,this.next(),type=this.finishNode(node,"ArrayTypeAnnotation")):(node.objectType=type,node.indexType=this.flowParseType(),this.expect(3),seenOptionalIndexedAccess?(node.optional=optional,type=this.finishNode(node,"OptionalIndexedAccessType")):type=this.finishNode(node,"IndexedAccessType"));}return type}flowParsePrefixType(){const node=this.startNode();return this.eat(17)?(node.typeAnnotation=this.flowParsePrefixType(),this.finishNode(node,"NullableTypeAnnotation")):this.flowParsePostfixType()}flowParseAnonFunctionWithoutParens(){const param=this.flowParsePrefixType();if(!this.state.noAnonFunctionType&&this.eat(19)){const node=this.startNodeAt(param.start,param.loc.start);return node.params=[this.reinterpretTypeAsFunctionTypeParam(param)],node.rest=null,node.this=null,node.returnType=this.flowParseType(),node.typeParameters=null,this.finishNode(node,"FunctionTypeAnnotation")}return param}flowParseIntersectionType(){const node=this.startNode();this.eat(43);const type=this.flowParseAnonFunctionWithoutParens();for(node.types=[type];this.eat(43);)node.types.push(this.flowParseAnonFunctionWithoutParens());return 1===node.types.length?type:this.finishNode(node,"IntersectionTypeAnnotation")}flowParseUnionType(){const node=this.startNode();this.eat(41);const type=this.flowParseIntersectionType();for(node.types=[type];this.eat(41);)node.types.push(this.flowParseIntersectionType());return 1===node.types.length?type:this.finishNode(node,"UnionTypeAnnotation")}flowParseType(){const oldInType=this.state.inType;this.state.inType=!0;const type=this.flowParseUnionType();return this.state.inType=oldInType,type}flowParseTypeOrImplicitInstantiation(){if(124===this.state.type&&"_"===this.state.value){const startPos=this.state.start,startLoc=this.state.startLoc,node=this.parseIdentifier();return this.flowParseGenericType(startPos,startLoc,node)}return this.flowParseType()}flowParseTypeAnnotation(){const node=this.startNode();return node.typeAnnotation=this.flowParseTypeInitialiser(),this.finishNode(node,"TypeAnnotation")}flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride){const ident=allowPrimitiveOverride?this.parseIdentifier():this.flowParseRestrictedIdentifier();return this.match(14)&&(ident.typeAnnotation=this.flowParseTypeAnnotation(),this.resetEndLocation(ident)),ident}typeCastToParameter(node){return node.expression.typeAnnotation=node.typeAnnotation,this.resetEndLocation(node.expression,node.typeAnnotation.loc.end),node.expression}flowParseVariance(){let variance=null;return this.match(49)&&(variance=this.startNode(),"+"===this.state.value?variance.kind="plus":variance.kind="minus",this.next(),this.finishNode(variance,"Variance")),variance}parseFunctionBody(node,allowExpressionBody,isMethod=!1){return allowExpressionBody?this.forwardNoArrowParamsConversionAt(node,(()=>super.parseFunctionBody(node,!0,isMethod))):super.parseFunctionBody(node,!1,isMethod)}parseFunctionBodyAndFinish(node,type,isMethod=!1){if(this.match(14)){const typeNode=this.startNode();[typeNode.typeAnnotation,node.predicate]=this.flowParseTypeAndPredicateInitialiser(),node.returnType=typeNode.typeAnnotation?this.finishNode(typeNode,"TypeAnnotation"):null;}super.parseFunctionBodyAndFinish(node,type,isMethod);}parseStatement(context,topLevel){if(this.state.strict&&this.isContextual(121)){if(tokenIsKeywordOrIdentifier(this.lookahead().type)){const node=this.startNode();return this.next(),this.flowParseInterface(node)}}else if(this.shouldParseEnums()&&this.isContextual(118)){const node=this.startNode();return this.next(),this.flowParseEnumDeclaration(node)}const stmt=super.parseStatement(context,topLevel);return void 0!==this.flowPragma||this.isValidDirective(stmt)||(this.flowPragma=null),stmt}parseExpressionStatement(node,expr){if("Identifier"===expr.type)if("declare"===expr.name){if(this.match(76)||tokenIsIdentifier(this.state.type)||this.match(64)||this.match(70)||this.match(78))return this.flowParseDeclare(node)}else if(tokenIsIdentifier(this.state.type)){if("interface"===expr.name)return this.flowParseInterface(node);if("type"===expr.name)return this.flowParseTypeAlias(node);if("opaque"===expr.name)return this.flowParseOpaqueType(node,!1)}return super.parseExpressionStatement(node,expr)}shouldParseExportDeclaration(){const{type}=this.state;return tokenIsFlowInterfaceOrTypeOrOpaque(type)||this.shouldParseEnums()&&118===type?!this.state.containsEsc:super.shouldParseExportDeclaration()}isExportDefaultSpecifier(){const{type}=this.state;return tokenIsFlowInterfaceOrTypeOrOpaque(type)||this.shouldParseEnums()&&118===type?this.state.containsEsc:super.isExportDefaultSpecifier()}parseExportDefaultExpression(){if(this.shouldParseEnums()&&this.isContextual(118)){const node=this.startNode();return this.next(),this.flowParseEnumDeclaration(node)}return super.parseExportDefaultExpression()}parseConditional(expr,startPos,startLoc,refExpressionErrors){if(!this.match(17))return expr;if(this.state.maybeInArrowParameters){const nextCh=this.lookaheadCharCode();if(44===nextCh||61===nextCh||58===nextCh||41===nextCh)return this.setOptionalParametersError(refExpressionErrors),expr}this.expect(17);const state=this.state.clone(),originalNoArrowAt=this.state.noArrowAt,node=this.startNodeAt(startPos,startLoc);let{consequent,failed}=this.tryParseConditionalConsequent(),[valid,invalid]=this.getArrowLikeExpressions(consequent);if(failed||invalid.length>0){const noArrowAt=[...originalNoArrowAt];if(invalid.length>0){this.state=state,this.state.noArrowAt=noArrowAt;for(let i=0;i<invalid.length;i++)noArrowAt.push(invalid[i].start);(({consequent,failed}=this.tryParseConditionalConsequent())),[valid,invalid]=this.getArrowLikeExpressions(consequent);}failed&&valid.length>1&&this.raise(FlowErrors.AmbiguousConditionalArrow,{at:state.startLoc}),failed&&1===valid.length&&(this.state=state,noArrowAt.push(valid[0].start),this.state.noArrowAt=noArrowAt,({consequent,failed}=this.tryParseConditionalConsequent()));}return this.getArrowLikeExpressions(consequent,!0),this.state.noArrowAt=originalNoArrowAt,this.expect(14),node.test=expr,node.consequent=consequent,node.alternate=this.forwardNoArrowParamsConversionAt(node,(()=>this.parseMaybeAssign(void 0,void 0))),this.finishNode(node,"ConditionalExpression")}tryParseConditionalConsequent(){this.state.noArrowParamsConversionAt.push(this.state.start);const consequent=this.parseMaybeAssignAllowIn(),failed=!this.match(14);return this.state.noArrowParamsConversionAt.pop(),{consequent,failed}}getArrowLikeExpressions(node,disallowInvalid){const stack=[node],arrows=[];for(;0!==stack.length;){const node=stack.pop();"ArrowFunctionExpression"===node.type?(node.typeParameters||!node.returnType?this.finishArrowValidation(node):arrows.push(node),stack.push(node.body)):"ConditionalExpression"===node.type&&(stack.push(node.consequent),stack.push(node.alternate));}return disallowInvalid?(arrows.forEach((node=>this.finishArrowValidation(node))),[arrows,[]]):function(list,test){const list1=[],list2=[];for(let i=0;i<list.length;i++)(test(list[i],i,list)?list1:list2).push(list[i]);return [list1,list2]}(arrows,(node=>node.params.every((param=>this.isAssignable(param,!0)))))}finishArrowValidation(node){var _node$extra;this.toAssignableList(node.params,null==(_node$extra=node.extra)?void 0:_node$extra.trailingCommaLoc,!1),this.scope.enter(6),super.checkParams(node,!1,!0),this.scope.exit();}forwardNoArrowParamsConversionAt(node,parse){let result;return -1!==this.state.noArrowParamsConversionAt.indexOf(node.start)?(this.state.noArrowParamsConversionAt.push(this.state.start),result=parse(),this.state.noArrowParamsConversionAt.pop()):result=parse(),result}parseParenItem(node,startPos,startLoc){if(node=super.parseParenItem(node,startPos,startLoc),this.eat(17)&&(node.optional=!0,this.resetEndLocation(node)),this.match(14)){const typeCastNode=this.startNodeAt(startPos,startLoc);return typeCastNode.expression=node,typeCastNode.typeAnnotation=this.flowParseTypeAnnotation(),this.finishNode(typeCastNode,"TypeCastExpression")}return node}assertModuleNodeAllowed(node){"ImportDeclaration"===node.type&&("type"===node.importKind||"typeof"===node.importKind)||"ExportNamedDeclaration"===node.type&&"type"===node.exportKind||"ExportAllDeclaration"===node.type&&"type"===node.exportKind||super.assertModuleNodeAllowed(node);}parseExport(node){const decl=super.parseExport(node);return "ExportNamedDeclaration"!==decl.type&&"ExportAllDeclaration"!==decl.type||(decl.exportKind=decl.exportKind||"value"),decl}parseExportDeclaration(node){if(this.isContextual(122)){node.exportKind="type";const declarationNode=this.startNode();return this.next(),this.match(5)?(node.specifiers=this.parseExportSpecifiers(!0),this.parseExportFrom(node),null):this.flowParseTypeAlias(declarationNode)}if(this.isContextual(123)){node.exportKind="type";const declarationNode=this.startNode();return this.next(),this.flowParseOpaqueType(declarationNode,!1)}if(this.isContextual(121)){node.exportKind="type";const declarationNode=this.startNode();return this.next(),this.flowParseInterface(declarationNode)}if(this.shouldParseEnums()&&this.isContextual(118)){node.exportKind="value";const declarationNode=this.startNode();return this.next(),this.flowParseEnumDeclaration(declarationNode)}return super.parseExportDeclaration(node)}eatExportStar(node){return !!super.eatExportStar(...arguments)||!(!this.isContextual(122)||51!==this.lookahead().type)&&(node.exportKind="type",this.next(),this.next(),!0)}maybeParseExportNamespaceSpecifier(node){const{startLoc}=this.state,hasNamespace=super.maybeParseExportNamespaceSpecifier(node);return hasNamespace&&"type"===node.exportKind&&this.unexpected(startLoc),hasNamespace}parseClassId(node,isStatement,optionalId){super.parseClassId(node,isStatement,optionalId),this.match(45)&&(node.typeParameters=this.flowParseTypeParameterDeclaration());}parseClassMember(classBody,member,state){const{startLoc}=this.state;if(this.isContextual(117)){if(this.parseClassMemberFromModifier(classBody,member))return;member.declare=!0;}super.parseClassMember(classBody,member,state),member.declare&&("ClassProperty"!==member.type&&"ClassPrivateProperty"!==member.type&&"PropertyDefinition"!==member.type?this.raise(FlowErrors.DeclareClassElement,{at:startLoc}):member.value&&this.raise(FlowErrors.DeclareClassFieldInitializer,{node:member.value}));}isIterator(word){return "iterator"===word||"asyncIterator"===word}readIterator(){const word=super.readWord1(),fullWord="@@"+word;this.isIterator(word)&&this.state.inType||this.raise(ErrorMessages.InvalidIdentifier,{at:this.state.curPosition()},fullWord),this.finishToken(124,fullWord);}getTokenFromCode(code){const next=this.input.charCodeAt(this.state.pos+1);return 123===code&&124===next?this.finishOp(6,2):!this.state.inType||62!==code&&60!==code?this.state.inType&&63===code?46===next?this.finishOp(18,2):this.finishOp(17,1):function(current,next){return 64===current&&64===next}(code,next)?(this.state.pos+=2,this.readIterator()):super.getTokenFromCode(code):this.finishOp(62===code?46:45,1)}isAssignable(node,isBinding){return "TypeCastExpression"===node.type?this.isAssignable(node.expression,isBinding):super.isAssignable(node,isBinding)}toAssignable(node,isLHS=!1){return "TypeCastExpression"===node.type?super.toAssignable(this.typeCastToParameter(node),isLHS):super.toAssignable(node,isLHS)}toAssignableList(exprList,trailingCommaLoc,isLHS){for(let i=0;i<exprList.length;i++){const expr=exprList[i];"TypeCastExpression"===(null==expr?void 0:expr.type)&&(exprList[i]=this.typeCastToParameter(expr));}return super.toAssignableList(exprList,trailingCommaLoc,isLHS)}toReferencedList(exprList,isParenthesizedExpr){for(let i=0;i<exprList.length;i++){var _expr$extra;const expr=exprList[i];!expr||"TypeCastExpression"!==expr.type||null!=(_expr$extra=expr.extra)&&_expr$extra.parenthesized||!(exprList.length>1)&&isParenthesizedExpr||this.raise(FlowErrors.TypeCastInPattern,{node:expr.typeAnnotation});}return exprList}parseArrayLike(close,canBePattern,isTuple,refExpressionErrors){const node=super.parseArrayLike(close,canBePattern,isTuple,refExpressionErrors);return canBePattern&&!this.state.maybeInArrowParameters&&this.toReferencedList(node.elements),node}checkLVal(expr,...args){if("TypeCastExpression"!==expr.type)return super.checkLVal(expr,...args)}parseClassProperty(node){return this.match(14)&&(node.typeAnnotation=this.flowParseTypeAnnotation()),super.parseClassProperty(node)}parseClassPrivateProperty(node){return this.match(14)&&(node.typeAnnotation=this.flowParseTypeAnnotation()),super.parseClassPrivateProperty(node)}isClassMethod(){return this.match(45)||super.isClassMethod()}isClassProperty(){return this.match(14)||super.isClassProperty()}isNonstaticConstructor(method){return !this.match(14)&&super.isNonstaticConstructor(method)}pushClassMethod(classBody,method,isGenerator,isAsync,isConstructor,allowsDirectSuper){if(method.variance&&this.unexpected(method.variance.loc.start),delete method.variance,this.match(45)&&(method.typeParameters=this.flowParseTypeParameterDeclaration()),super.pushClassMethod(classBody,method,isGenerator,isAsync,isConstructor,allowsDirectSuper),method.params&&isConstructor){const params=method.params;params.length>0&&this.isThisParam(params[0])&&this.raise(FlowErrors.ThisParamBannedInConstructor,{node:method});}else if("MethodDefinition"===method.type&&isConstructor&&method.value.params){const params=method.value.params;params.length>0&&this.isThisParam(params[0])&&this.raise(FlowErrors.ThisParamBannedInConstructor,{node:method});}}pushClassPrivateMethod(classBody,method,isGenerator,isAsync){method.variance&&this.unexpected(method.variance.loc.start),delete method.variance,this.match(45)&&(method.typeParameters=this.flowParseTypeParameterDeclaration()),super.pushClassPrivateMethod(classBody,method,isGenerator,isAsync);}parseClassSuper(node){if(super.parseClassSuper(node),node.superClass&&this.match(45)&&(node.superTypeParameters=this.flowParseTypeParameterInstantiation()),this.isContextual(106)){this.next();const implemented=node.implements=[];do{const node=this.startNode();node.id=this.flowParseRestrictedIdentifier(!0),this.match(45)?node.typeParameters=this.flowParseTypeParameterInstantiation():node.typeParameters=null,implemented.push(this.finishNode(node,"ClassImplements"));}while(this.eat(12))}}checkGetterSetterParams(method){super.checkGetterSetterParams(method);const params=this.getObjectOrClassMethodParams(method);if(params.length>0){const param=params[0];this.isThisParam(param)&&"get"===method.kind?this.raise(FlowErrors.GetterMayNotHaveThisParam,{node:param}):this.isThisParam(param)&&this.raise(FlowErrors.SetterMayNotHaveThisParam,{node:param});}}parsePropertyNamePrefixOperator(node){node.variance=this.flowParseVariance();}parseObjPropValue(prop,startPos,startLoc,isGenerator,isAsync,isPattern,isAccessor,refExpressionErrors){let typeParameters;prop.variance&&this.unexpected(prop.variance.loc.start),delete prop.variance,this.match(45)&&!isAccessor&&(typeParameters=this.flowParseTypeParameterDeclaration(),this.match(10)||this.unexpected()),super.parseObjPropValue(prop,startPos,startLoc,isGenerator,isAsync,isPattern,isAccessor,refExpressionErrors),typeParameters&&((prop.value||prop).typeParameters=typeParameters);}parseAssignableListItemTypes(param){return this.eat(17)&&("Identifier"!==param.type&&this.raise(FlowErrors.PatternIsOptional,{node:param}),this.isThisParam(param)&&this.raise(FlowErrors.ThisParamMayNotBeOptional,{node:param}),param.optional=!0),this.match(14)?param.typeAnnotation=this.flowParseTypeAnnotation():this.isThisParam(param)&&this.raise(FlowErrors.ThisParamAnnotationRequired,{node:param}),this.match(29)&&this.isThisParam(param)&&this.raise(FlowErrors.ThisParamNoDefault,{node:param}),this.resetEndLocation(param),param}parseMaybeDefault(startPos,startLoc,left){const node=super.parseMaybeDefault(startPos,startLoc,left);return "AssignmentPattern"===node.type&&node.typeAnnotation&&node.right.start<node.typeAnnotation.start&&this.raise(FlowErrors.TypeBeforeInitializer,{node:node.typeAnnotation}),node}shouldParseDefaultImport(node){return hasTypeImportKind(node)?isMaybeDefaultImport(this.state.type):super.shouldParseDefaultImport(node)}parseImportSpecifierLocal(node,specifier,type,contextDescription){specifier.local=hasTypeImportKind(node)?this.flowParseRestrictedIdentifier(!0,!0):this.parseIdentifier(),this.checkLVal(specifier.local,contextDescription,9),node.specifiers.push(this.finishNode(specifier,type));}maybeParseDefaultImportSpecifier(node){node.importKind="value";let kind=null;if(this.match(83)?kind="typeof":this.isContextual(122)&&(kind="type"),kind){const lh=this.lookahead(),{type}=lh;"type"===kind&&51===type&&this.unexpected(null,lh.type),(isMaybeDefaultImport(type)||5===type||51===type)&&(this.next(),node.importKind=kind);}return super.maybeParseDefaultImportSpecifier(node)}parseImportSpecifier(specifier,importedIsString,isInTypeOnlyImport,isMaybeTypeOnly){const firstIdent=specifier.imported;let specifierTypeKind=null;"Identifier"===firstIdent.type&&("type"===firstIdent.name?specifierTypeKind="type":"typeof"===firstIdent.name&&(specifierTypeKind="typeof"));let isBinding=!1;if(this.isContextual(89)&&!this.isLookaheadContextual("as")){const as_ident=this.parseIdentifier(!0);null===specifierTypeKind||tokenIsKeywordOrIdentifier(this.state.type)?(specifier.imported=firstIdent,specifier.importKind=null,specifier.local=this.parseIdentifier()):(specifier.imported=as_ident,specifier.importKind=specifierTypeKind,specifier.local=cloneIdentifier(as_ident));}else {if(null!==specifierTypeKind&&tokenIsKeywordOrIdentifier(this.state.type))specifier.imported=this.parseIdentifier(!0),specifier.importKind=specifierTypeKind;else {if(importedIsString)throw this.raise(ErrorMessages.ImportBindingIsString,{node:specifier},firstIdent.value);specifier.imported=firstIdent,specifier.importKind=null;}this.eatContextual(89)?specifier.local=this.parseIdentifier():(isBinding=!0,specifier.local=cloneIdentifier(specifier.imported));}const specifierIsTypeImport=hasTypeImportKind(specifier);return isInTypeOnlyImport&&specifierIsTypeImport&&this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport,{node:specifier}),(isInTypeOnlyImport||specifierIsTypeImport)&&this.checkReservedType(specifier.local.name,specifier.local.loc.start,!0),!isBinding||isInTypeOnlyImport||specifierIsTypeImport||this.checkReservedWord(specifier.local.name,specifier.loc.start,!0,!0),this.checkLVal(specifier.local,"import specifier",9),this.finishNode(specifier,"ImportSpecifier")}parseBindingAtom(){return 74===this.state.type?this.parseIdentifier(!0):super.parseBindingAtom()}parseFunctionParams(node,allowModifiers){const kind=node.kind;"get"!==kind&&"set"!==kind&&this.match(45)&&(node.typeParameters=this.flowParseTypeParameterDeclaration()),super.parseFunctionParams(node,allowModifiers);}parseVarId(decl,kind){super.parseVarId(decl,kind),this.match(14)&&(decl.id.typeAnnotation=this.flowParseTypeAnnotation(),this.resetEndLocation(decl.id));}parseAsyncArrowFromCallExpression(node,call){if(this.match(14)){const oldNoAnonFunctionType=this.state.noAnonFunctionType;this.state.noAnonFunctionType=!0,node.returnType=this.flowParseTypeAnnotation(),this.state.noAnonFunctionType=oldNoAnonFunctionType;}return super.parseAsyncArrowFromCallExpression(node,call)}shouldParseAsyncArrow(){return this.match(14)||super.shouldParseAsyncArrow()}parseMaybeAssign(refExpressionErrors,afterLeftParse){var _jsx;let jsx,state=null;if(this.hasPlugin("jsx")&&(this.match(134)||this.match(45))){if(state=this.state.clone(),jsx=this.tryParse((()=>super.parseMaybeAssign(refExpressionErrors,afterLeftParse)),state),!jsx.error)return jsx.node;const{context}=this.state,currentContext=context[context.length-1];currentContext!==types.j_oTag&&currentContext!==types.j_expr||context.pop();}if(null!=(_jsx=jsx)&&_jsx.error||this.match(45)){var _jsx2,_jsx3;let typeParameters;state=state||this.state.clone();const arrow=this.tryParse((abort=>{var _arrowExpression$extr;typeParameters=this.flowParseTypeParameterDeclaration();const arrowExpression=this.forwardNoArrowParamsConversionAt(typeParameters,(()=>{const result=super.parseMaybeAssign(refExpressionErrors,afterLeftParse);return this.resetStartLocationFromNode(result,typeParameters),result}));null!=(_arrowExpression$extr=arrowExpression.extra)&&_arrowExpression$extr.parenthesized&&abort();const expr=this.maybeUnwrapTypeCastExpression(arrowExpression);return "ArrowFunctionExpression"!==expr.type&&abort(),expr.typeParameters=typeParameters,this.resetStartLocationFromNode(expr,typeParameters),arrowExpression}),state);let arrowExpression=null;if(arrow.node&&"ArrowFunctionExpression"===this.maybeUnwrapTypeCastExpression(arrow.node).type){if(!arrow.error&&!arrow.aborted)return arrow.node.async&&this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction,{node:typeParameters}),arrow.node;arrowExpression=arrow.node;}if(null!=(_jsx2=jsx)&&_jsx2.node)return this.state=jsx.failState,jsx.node;if(arrowExpression)return this.state=arrow.failState,arrowExpression;if(null!=(_jsx3=jsx)&&_jsx3.thrown)throw jsx.error;if(arrow.thrown)throw arrow.error;throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter,{node:typeParameters})}return super.parseMaybeAssign(refExpressionErrors,afterLeftParse)}parseArrow(node){if(this.match(14)){const result=this.tryParse((()=>{const oldNoAnonFunctionType=this.state.noAnonFunctionType;this.state.noAnonFunctionType=!0;const typeNode=this.startNode();return [typeNode.typeAnnotation,node.predicate]=this.flowParseTypeAndPredicateInitialiser(),this.state.noAnonFunctionType=oldNoAnonFunctionType,this.canInsertSemicolon()&&this.unexpected(),this.match(19)||this.unexpected(),typeNode}));if(result.thrown)return null;result.error&&(this.state=result.failState),node.returnType=result.node.typeAnnotation?this.finishNode(result.node,"TypeAnnotation"):null;}return super.parseArrow(node)}shouldParseArrow(params){return this.match(14)||super.shouldParseArrow(params)}setArrowFunctionParameters(node,params){-1!==this.state.noArrowParamsConversionAt.indexOf(node.start)?node.params=params:super.setArrowFunctionParameters(node,params);}checkParams(node,allowDuplicates,isArrowFunction){if(!isArrowFunction||-1===this.state.noArrowParamsConversionAt.indexOf(node.start)){for(let i=0;i<node.params.length;i++)this.isThisParam(node.params[i])&&i>0&&this.raise(FlowErrors.ThisParamMustBeFirst,{node:node.params[i]});return super.checkParams(...arguments)}}parseParenAndDistinguishExpression(canBeArrow){return super.parseParenAndDistinguishExpression(canBeArrow&&-1===this.state.noArrowAt.indexOf(this.state.start))}parseSubscripts(base,startPos,startLoc,noCalls){if("Identifier"===base.type&&"async"===base.name&&-1!==this.state.noArrowAt.indexOf(startPos)){this.next();const node=this.startNodeAt(startPos,startLoc);node.callee=base,node.arguments=this.parseCallExpressionArguments(11,!1),base=this.finishNode(node,"CallExpression");}else if("Identifier"===base.type&&"async"===base.name&&this.match(45)){const state=this.state.clone(),arrow=this.tryParse((abort=>this.parseAsyncArrowWithTypeParameters(startPos,startLoc)||abort()),state);if(!arrow.error&&!arrow.aborted)return arrow.node;const result=this.tryParse((()=>super.parseSubscripts(base,startPos,startLoc,noCalls)),state);if(result.node&&!result.error)return result.node;if(arrow.node)return this.state=arrow.failState,arrow.node;if(result.node)return this.state=result.failState,result.node;throw arrow.error||result.error}return super.parseSubscripts(base,startPos,startLoc,noCalls)}parseSubscript(base,startPos,startLoc,noCalls,subscriptState){if(this.match(18)&&this.isLookaheadToken_lt()){if(subscriptState.optionalChainMember=!0,noCalls)return subscriptState.stop=!0,base;this.next();const node=this.startNodeAt(startPos,startLoc);return node.callee=base,node.typeArguments=this.flowParseTypeParameterInstantiation(),this.expect(10),node.arguments=this.parseCallExpressionArguments(11,!1),node.optional=!0,this.finishCallExpression(node,!0)}if(!noCalls&&this.shouldParseTypes()&&this.match(45)){const node=this.startNodeAt(startPos,startLoc);node.callee=base;const result=this.tryParse((()=>(node.typeArguments=this.flowParseTypeParameterInstantiationCallOrNew(),this.expect(10),node.arguments=this.parseCallExpressionArguments(11,!1),subscriptState.optionalChainMember&&(node.optional=!1),this.finishCallExpression(node,subscriptState.optionalChainMember))));if(result.node)return result.error&&(this.state=result.failState),result.node}return super.parseSubscript(base,startPos,startLoc,noCalls,subscriptState)}parseNewArguments(node){let targs=null;this.shouldParseTypes()&&this.match(45)&&(targs=this.tryParse((()=>this.flowParseTypeParameterInstantiationCallOrNew())).node),node.typeArguments=targs,super.parseNewArguments(node);}parseAsyncArrowWithTypeParameters(startPos,startLoc){const node=this.startNodeAt(startPos,startLoc);if(this.parseFunctionParams(node),this.parseArrow(node))return this.parseArrowExpression(node,void 0,!0)}readToken_mult_modulo(code){const next=this.input.charCodeAt(this.state.pos+1);if(42===code&&47===next&&this.state.hasFlowComment)return this.state.hasFlowComment=!1,this.state.pos+=2,void this.nextToken();super.readToken_mult_modulo(code);}readToken_pipe_amp(code){const next=this.input.charCodeAt(this.state.pos+1);124!==code||125!==next?super.readToken_pipe_amp(code):this.finishOp(9,2);}parseTopLevel(file,program){const fileNode=super.parseTopLevel(file,program);return this.state.hasFlowComment&&this.raise(FlowErrors.UnterminatedFlowComment,{at:this.state.curPosition()}),fileNode}skipBlockComment(){if(this.hasPlugin("flowComments")&&this.skipFlowComment()){if(this.state.hasFlowComment)throw this.raise(FlowErrors.NestedFlowComment,{at:this.state.startLoc});return this.hasFlowCommentCompletion(),this.state.pos+=this.skipFlowComment(),void(this.state.hasFlowComment=!0)}if(!this.state.hasFlowComment)return super.skipBlockComment();{const end=this.input.indexOf("*-/",this.state.pos+2);if(-1===end)throw this.raise(ErrorMessages.UnterminatedComment,{at:this.state.curPosition()});this.state.pos=end+2+3;}}skipFlowComment(){const{pos}=this.state;let shiftToFirstNonWhiteSpace=2;for(;[32,9].includes(this.input.charCodeAt(pos+shiftToFirstNonWhiteSpace));)shiftToFirstNonWhiteSpace++;const ch2=this.input.charCodeAt(shiftToFirstNonWhiteSpace+pos),ch3=this.input.charCodeAt(shiftToFirstNonWhiteSpace+pos+1);return 58===ch2&&58===ch3?shiftToFirstNonWhiteSpace+2:"flow-include"===this.input.slice(shiftToFirstNonWhiteSpace+pos,shiftToFirstNonWhiteSpace+pos+12)?shiftToFirstNonWhiteSpace+12:58===ch2&&58!==ch3&&shiftToFirstNonWhiteSpace}hasFlowCommentCompletion(){if(-1===this.input.indexOf("*/",this.state.pos))throw this.raise(ErrorMessages.UnterminatedComment,{at:this.state.curPosition()})}flowEnumErrorBooleanMemberNotInitialized(loc,{enumName,memberName}){this.raise(FlowErrors.EnumBooleanMemberNotInitialized,{at:loc},memberName,enumName);}flowEnumErrorInvalidExplicitType(loc,{enumName,suppliedType}){return this.raise(null===suppliedType?FlowErrors.EnumInvalidExplicitTypeUnknownSupplied:FlowErrors.EnumInvalidExplicitType,{at:loc},enumName,suppliedType)}flowEnumErrorInvalidMemberInitializer(loc,{enumName,explicitType,memberName}){return this.raise("boolean"===explicitType||"number"===explicitType||"string"===explicitType?FlowErrors.EnumInvalidMemberInitializerPrimaryType:"symbol"===explicitType?FlowErrors.EnumInvalidMemberInitializerSymbolType:FlowErrors.EnumInvalidMemberInitializerUnknownType,{at:loc},enumName,memberName,explicitType)}flowEnumErrorNumberMemberNotInitialized(loc,{enumName,memberName}){this.raise(FlowErrors.EnumNumberMemberNotInitialized,{at:loc},enumName,memberName);}flowEnumErrorStringMemberInconsistentlyInitailized(node,{enumName}){this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized,{node},enumName);}flowEnumMemberInit(){const startLoc=this.state.startLoc,endOfInit=()=>this.match(12)||this.match(8);switch(this.state.type){case 126:{const literal=this.parseNumericLiteral(this.state.value);return endOfInit()?{type:"number",loc:literal.loc.start,value:literal}:{type:"invalid",loc:startLoc}}case 125:{const literal=this.parseStringLiteral(this.state.value);return endOfInit()?{type:"string",loc:literal.loc.start,value:literal}:{type:"invalid",loc:startLoc}}case 81:case 82:{const literal=this.parseBooleanLiteral(this.match(81));return endOfInit()?{type:"boolean",loc:literal.loc.start,value:literal}:{type:"invalid",loc:startLoc}}default:return {type:"invalid",loc:startLoc}}}flowEnumMemberRaw(){const loc=this.state.startLoc;return {id:this.parseIdentifier(!0),init:this.eat(29)?this.flowEnumMemberInit():{type:"none",loc}}}flowEnumCheckExplicitTypeMismatch(loc,context,expectedType){const{explicitType}=context;null!==explicitType&&explicitType!==expectedType&&this.flowEnumErrorInvalidMemberInitializer(loc,context);}flowEnumMembers({enumName,explicitType}){const seenNames=new Set,members={booleanMembers:[],numberMembers:[],stringMembers:[],defaultedMembers:[]};let hasUnknownMembers=!1;for(;!this.match(8);){if(this.eat(21)){hasUnknownMembers=!0;break}const memberNode=this.startNode(),{id,init}=this.flowEnumMemberRaw(),memberName=id.name;if(""===memberName)continue;/^[a-z]/.test(memberName)&&this.raise(FlowErrors.EnumInvalidMemberName,{node:id},memberName,memberName[0].toUpperCase()+memberName.slice(1),enumName),seenNames.has(memberName)&&this.raise(FlowErrors.EnumDuplicateMemberName,{node:id},memberName,enumName),seenNames.add(memberName);const context={enumName,explicitType,memberName};switch(memberNode.id=id,init.type){case"boolean":this.flowEnumCheckExplicitTypeMismatch(init.loc,context,"boolean"),memberNode.init=init.value,members.booleanMembers.push(this.finishNode(memberNode,"EnumBooleanMember"));break;case"number":this.flowEnumCheckExplicitTypeMismatch(init.loc,context,"number"),memberNode.init=init.value,members.numberMembers.push(this.finishNode(memberNode,"EnumNumberMember"));break;case"string":this.flowEnumCheckExplicitTypeMismatch(init.loc,context,"string"),memberNode.init=init.value,members.stringMembers.push(this.finishNode(memberNode,"EnumStringMember"));break;case"invalid":throw this.flowEnumErrorInvalidMemberInitializer(init.loc,context);case"none":switch(explicitType){case"boolean":this.flowEnumErrorBooleanMemberNotInitialized(init.loc,context);break;case"number":this.flowEnumErrorNumberMemberNotInitialized(init.loc,context);break;default:members.defaultedMembers.push(this.finishNode(memberNode,"EnumDefaultedMember"));}}this.match(8)||this.expect(12);}return {members,hasUnknownMembers}}flowEnumStringMembers(initializedMembers,defaultedMembers,{enumName}){if(0===initializedMembers.length)return defaultedMembers;if(0===defaultedMembers.length)return initializedMembers;if(defaultedMembers.length>initializedMembers.length){for(const member of initializedMembers)this.flowEnumErrorStringMemberInconsistentlyInitailized(member,{enumName});return defaultedMembers}for(const member of defaultedMembers)this.flowEnumErrorStringMemberInconsistentlyInitailized(member,{enumName});return initializedMembers}flowEnumParseExplicitType({enumName}){if(this.eatContextual(97)){if(!tokenIsIdentifier(this.state.type))throw this.flowEnumErrorInvalidExplicitType(this.state.startLoc,{enumName,suppliedType:null});const{value}=this.state;return this.next(),"boolean"!==value&&"number"!==value&&"string"!==value&&"symbol"!==value&&this.flowEnumErrorInvalidExplicitType(this.state.startLoc,{enumName,suppliedType:value}),value}return null}flowEnumBody(node,id){const enumName=id.name,nameLoc=id.loc.start,explicitType=this.flowEnumParseExplicitType({enumName});this.expect(5);const{members,hasUnknownMembers}=this.flowEnumMembers({enumName,explicitType});switch(node.hasUnknownMembers=hasUnknownMembers,explicitType){case"boolean":return node.explicitType=!0,node.members=members.booleanMembers,this.expect(8),this.finishNode(node,"EnumBooleanBody");case"number":return node.explicitType=!0,node.members=members.numberMembers,this.expect(8),this.finishNode(node,"EnumNumberBody");case"string":return node.explicitType=!0,node.members=this.flowEnumStringMembers(members.stringMembers,members.defaultedMembers,{enumName}),this.expect(8),this.finishNode(node,"EnumStringBody");case"symbol":return node.members=members.defaultedMembers,this.expect(8),this.finishNode(node,"EnumSymbolBody");default:{const empty=()=>(node.members=[],this.expect(8),this.finishNode(node,"EnumStringBody"));node.explicitType=!1;const boolsLen=members.booleanMembers.length,numsLen=members.numberMembers.length,strsLen=members.stringMembers.length,defaultedLen=members.defaultedMembers.length;if(boolsLen||numsLen||strsLen||defaultedLen){if(boolsLen||numsLen){if(!numsLen&&!strsLen&&boolsLen>=defaultedLen){for(const member of members.defaultedMembers)this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start,{enumName,memberName:member.id.name});return node.members=members.booleanMembers,this.expect(8),this.finishNode(node,"EnumBooleanBody")}if(!boolsLen&&!strsLen&&numsLen>=defaultedLen){for(const member of members.defaultedMembers)this.flowEnumErrorNumberMemberNotInitialized(member.loc.start,{enumName,memberName:member.id.name});return node.members=members.numberMembers,this.expect(8),this.finishNode(node,"EnumNumberBody")}return this.raise(FlowErrors.EnumInconsistentMemberValues,{at:nameLoc},enumName),empty()}return node.members=this.flowEnumStringMembers(members.stringMembers,members.defaultedMembers,{enumName}),this.expect(8),this.finishNode(node,"EnumStringBody")}return empty()}}}flowParseEnumDeclaration(node){const id=this.parseIdentifier();return node.id=id,node.body=this.flowEnumBody(this.startNode(),id),this.finishNode(node,"EnumDeclaration")}isLookaheadToken_lt(){const next=this.nextTokenStart();if(60===this.input.charCodeAt(next)){const afterNext=this.input.charCodeAt(next+1);return 60!==afterNext&&61!==afterNext}return !1}maybeUnwrapTypeCastExpression(node){return "TypeCastExpression"===node.type?node.expression:node}},typescript:superClass=>class extends superClass{getScopeHandler(){return TypeScriptScopeHandler}tsIsIdentifier(){return tokenIsIdentifier(this.state.type)}tsTokenCanFollowModifier(){return (this.match(0)||this.match(5)||this.match(51)||this.match(21)||this.match(130)||this.isLiteralPropertyName())&&!this.hasPrecedingLineBreak()}tsNextTokenCanFollowModifier(){return this.next(),this.tsTokenCanFollowModifier()}tsParseModifier(allowedModifiers,stopOnStartOfClassStaticBlock){if(!tokenIsIdentifier(this.state.type))return;const modifier=this.state.value;if(-1!==allowedModifiers.indexOf(modifier)){if(stopOnStartOfClassStaticBlock&&this.tsIsStartOfStaticBlocks())return;if(this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))return modifier}}tsParseModifiers(modified,allowedModifiers,disallowedModifiers,errorTemplate,stopOnStartOfClassStaticBlock){const enforceOrder=(loc,modifier,before,after)=>{modifier===before&&modified[after]&&this.raise(TSErrors.InvalidModifiersOrder,{at:loc},before,after);},incompatible=(loc,modifier,mod1,mod2)=>{(modified[mod1]&&modifier===mod2||modified[mod2]&&modifier===mod1)&&this.raise(TSErrors.IncompatibleModifiers,{at:loc},mod1,mod2);};for(;;){const{startLoc}=this.state,modifier=this.tsParseModifier(allowedModifiers.concat(null!=disallowedModifiers?disallowedModifiers:[]),stopOnStartOfClassStaticBlock);if(!modifier)break;tsIsAccessModifier(modifier)?modified.accessibility?this.raise(TSErrors.DuplicateAccessibilityModifier,{at:startLoc}):(enforceOrder(startLoc,modifier,modifier,"override"),enforceOrder(startLoc,modifier,modifier,"static"),enforceOrder(startLoc,modifier,modifier,"readonly"),modified.accessibility=modifier):(Object.hasOwnProperty.call(modified,modifier)?this.raise(TSErrors.DuplicateModifier,{at:startLoc},modifier):(enforceOrder(startLoc,modifier,"static","readonly"),enforceOrder(startLoc,modifier,"static","override"),enforceOrder(startLoc,modifier,"override","readonly"),enforceOrder(startLoc,modifier,"abstract","override"),incompatible(startLoc,modifier,"declare","override"),incompatible(startLoc,modifier,"static","abstract")),modified[modifier]=!0),null!=disallowedModifiers&&disallowedModifiers.includes(modifier)&&this.raise(errorTemplate,{at:startLoc},modifier);}}tsIsListTerminator(kind){switch(kind){case"EnumMembers":case"TypeMembers":return this.match(8);case"HeritageClauseElement":return this.match(5);case"TupleElementTypes":return this.match(3);case"TypeParametersOrArguments":return this.match(46)}throw new Error("Unreachable")}tsParseList(kind,parseElement){const result=[];for(;!this.tsIsListTerminator(kind);)result.push(parseElement());return result}tsParseDelimitedList(kind,parseElement,refTrailingCommaPos){return function(x){if(null==x)throw new Error(`Unexpected ${x} value.`);return x}(this.tsParseDelimitedListWorker(kind,parseElement,!0,refTrailingCommaPos))}tsParseDelimitedListWorker(kind,parseElement,expectSuccess,refTrailingCommaPos){const result=[];let trailingCommaPos=-1;for(;!this.tsIsListTerminator(kind);){trailingCommaPos=-1;const element=parseElement();if(null==element)return;if(result.push(element),!this.eat(12)){if(this.tsIsListTerminator(kind))break;return void(expectSuccess&&this.expect(12))}trailingCommaPos=this.state.lastTokStart;}return refTrailingCommaPos&&(refTrailingCommaPos.value=trailingCommaPos),result}tsParseBracketedList(kind,parseElement,bracket,skipFirstToken,refTrailingCommaPos){skipFirstToken||(bracket?this.expect(0):this.expect(45));const result=this.tsParseDelimitedList(kind,parseElement,refTrailingCommaPos);return bracket?this.expect(3):this.expect(46),result}tsParseImportType(){const node=this.startNode();return this.expect(79),this.expect(10),this.match(125)||this.raise(TSErrors.UnsupportedImportTypeArgument,{at:this.state.startLoc}),node.argument=this.parseExprAtom(),this.expect(11),this.eat(16)&&(node.qualifier=this.tsParseEntityName(!0)),this.match(45)&&(node.typeParameters=this.tsParseTypeArguments()),this.finishNode(node,"TSImportType")}tsParseEntityName(allowReservedWords){let entity=this.parseIdentifier();for(;this.eat(16);){const node=this.startNodeAtNode(entity);node.left=entity,node.right=this.parseIdentifier(allowReservedWords),entity=this.finishNode(node,"TSQualifiedName");}return entity}tsParseTypeReference(){const node=this.startNode();return node.typeName=this.tsParseEntityName(!1),!this.hasPrecedingLineBreak()&&this.match(45)&&(node.typeParameters=this.tsParseTypeArguments()),this.finishNode(node,"TSTypeReference")}tsParseThisTypePredicate(lhs){this.next();const node=this.startNodeAtNode(lhs);return node.parameterName=lhs,node.typeAnnotation=this.tsParseTypeAnnotation(!1),node.asserts=!1,this.finishNode(node,"TSTypePredicate")}tsParseThisTypeNode(){const node=this.startNode();return this.next(),this.finishNode(node,"TSThisType")}tsParseTypeQuery(){const node=this.startNode();return this.expect(83),this.match(79)?node.exprName=this.tsParseImportType():node.exprName=this.tsParseEntityName(!0),this.finishNode(node,"TSTypeQuery")}tsParseTypeParameter(){const node=this.startNode();return node.name=this.tsParseTypeParameterName(),node.constraint=this.tsEatThenParseType(77),node.default=this.tsEatThenParseType(29),this.finishNode(node,"TSTypeParameter")}tsTryParseTypeParameters(){if(this.match(45))return this.tsParseTypeParameters()}tsParseTypeParameters(){const node=this.startNode();this.match(45)||this.match(134)?this.next():this.unexpected();const refTrailingCommaPos={value:-1};return node.params=this.tsParseBracketedList("TypeParametersOrArguments",this.tsParseTypeParameter.bind(this),!1,!0,refTrailingCommaPos),0===node.params.length&&this.raise(TSErrors.EmptyTypeParameters,{node}),-1!==refTrailingCommaPos.value&&this.addExtra(node,"trailingComma",refTrailingCommaPos.value),this.finishNode(node,"TSTypeParameterDeclaration")}tsTryNextParseConstantContext(){return 71===this.lookahead().type?(this.next(),this.tsParseTypeReference()):null}tsFillSignature(returnToken,signature){const returnTokenRequired=19===returnToken;signature.typeParameters=this.tsTryParseTypeParameters(),this.expect(10),signature.parameters=this.tsParseBindingListForSignature(),(returnTokenRequired||this.match(returnToken))&&(signature.typeAnnotation=this.tsParseTypeOrTypePredicateAnnotation(returnToken));}tsParseBindingListForSignature(){return this.parseBindingList(11,41).map((pattern=>("Identifier"!==pattern.type&&"RestElement"!==pattern.type&&"ObjectPattern"!==pattern.type&&"ArrayPattern"!==pattern.type&&this.raise(TSErrors.UnsupportedSignatureParameterKind,{node:pattern},pattern.type),pattern)))}tsParseTypeMemberSemicolon(){this.eat(12)||this.isLineTerminator()||this.expect(13);}tsParseSignatureMember(kind,node){return this.tsFillSignature(14,node),this.tsParseTypeMemberSemicolon(),this.finishNode(node,kind)}tsIsUnambiguouslyIndexSignature(){return this.next(),!!tokenIsIdentifier(this.state.type)&&(this.next(),this.match(14))}tsTryParseIndexSignature(node){if(!this.match(0)||!this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))return;this.expect(0);const id=this.parseIdentifier();id.typeAnnotation=this.tsParseTypeAnnotation(),this.resetEndLocation(id),this.expect(3),node.parameters=[id];const type=this.tsTryParseTypeAnnotation();return type&&(node.typeAnnotation=type),this.tsParseTypeMemberSemicolon(),this.finishNode(node,"TSIndexSignature")}tsParsePropertyOrMethodSignature(node,readonly){this.eat(17)&&(node.optional=!0);const nodeAny=node;if(this.match(10)||this.match(45)){readonly&&this.raise(TSErrors.ReadonlyForMethodSignature,{node});const method=nodeAny;method.kind&&this.match(45)&&this.raise(TSErrors.AccesorCannotHaveTypeParameters,{at:this.state.curPosition()}),this.tsFillSignature(14,method),this.tsParseTypeMemberSemicolon();const paramsKey="parameters",returnTypeKey="typeAnnotation";if("get"===method.kind)method[paramsKey].length>0&&(this.raise(ErrorMessages.BadGetterArity,{at:this.state.curPosition()}),this.isThisParam(method[paramsKey][0])&&this.raise(TSErrors.AccesorCannotDeclareThisParameter,{at:this.state.curPosition()}));else if("set"===method.kind){if(1!==method[paramsKey].length)this.raise(ErrorMessages.BadSetterArity,{at:this.state.curPosition()});else {const firstParameter=method[paramsKey][0];this.isThisParam(firstParameter)&&this.raise(TSErrors.AccesorCannotDeclareThisParameter,{at:this.state.curPosition()}),"Identifier"===firstParameter.type&&firstParameter.optional&&this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter,{at:this.state.curPosition()}),"RestElement"===firstParameter.type&&this.raise(TSErrors.SetAccesorCannotHaveRestParameter,{at:this.state.curPosition()});}method[returnTypeKey]&&this.raise(TSErrors.SetAccesorCannotHaveReturnType,{node:method[returnTypeKey]});}else method.kind="method";return this.finishNode(method,"TSMethodSignature")}{const property=nodeAny;readonly&&(property.readonly=!0);const type=this.tsTryParseTypeAnnotation();return type&&(property.typeAnnotation=type),this.tsParseTypeMemberSemicolon(),this.finishNode(property,"TSPropertySignature")}}tsParseTypeMember(){const node=this.startNode();if(this.match(10)||this.match(45))return this.tsParseSignatureMember("TSCallSignatureDeclaration",node);if(this.match(73)){const id=this.startNode();return this.next(),this.match(10)||this.match(45)?this.tsParseSignatureMember("TSConstructSignatureDeclaration",node):(node.key=this.createIdentifier(id,"new"),this.tsParsePropertyOrMethodSignature(node,!1))}this.tsParseModifiers(node,["readonly"],["declare","abstract","private","protected","public","static","override"],TSErrors.InvalidModifierOnTypeMember);const idx=this.tsTryParseIndexSignature(node);return idx||(this.parsePropertyName(node),node.computed||"Identifier"!==node.key.type||"get"!==node.key.name&&"set"!==node.key.name||!this.tsTokenCanFollowModifier()||(node.kind=node.key.name,this.parsePropertyName(node)),this.tsParsePropertyOrMethodSignature(node,!!node.readonly))}tsParseTypeLiteral(){const node=this.startNode();return node.members=this.tsParseObjectTypeMembers(),this.finishNode(node,"TSTypeLiteral")}tsParseObjectTypeMembers(){this.expect(5);const members=this.tsParseList("TypeMembers",this.tsParseTypeMember.bind(this));return this.expect(8),members}tsIsStartOfMappedType(){return this.next(),this.eat(49)?this.isContextual(114):(this.isContextual(114)&&this.next(),!!this.match(0)&&(this.next(),!!this.tsIsIdentifier()&&(this.next(),this.match(54))))}tsParseMappedTypeParameter(){const node=this.startNode();return node.name=this.tsParseTypeParameterName(),node.constraint=this.tsExpectThenParseType(54),this.finishNode(node,"TSTypeParameter")}tsParseMappedType(){const node=this.startNode();return this.expect(5),this.match(49)?(node.readonly=this.state.value,this.next(),this.expectContextual(114)):this.eatContextual(114)&&(node.readonly=!0),this.expect(0),node.typeParameter=this.tsParseMappedTypeParameter(),node.nameType=this.eatContextual(89)?this.tsParseType():null,this.expect(3),this.match(49)?(node.optional=this.state.value,this.next(),this.expect(17)):this.eat(17)&&(node.optional=!0),node.typeAnnotation=this.tsTryParseType(),this.semicolon(),this.expect(8),this.finishNode(node,"TSMappedType")}tsParseTupleType(){const node=this.startNode();node.elementTypes=this.tsParseBracketedList("TupleElementTypes",this.tsParseTupleElementType.bind(this),!0,!1);let seenOptionalElement=!1,labeledElements=null;return node.elementTypes.forEach((elementNode=>{var _labeledElements;let{type}=elementNode;!seenOptionalElement||"TSRestType"===type||"TSOptionalType"===type||"TSNamedTupleMember"===type&&elementNode.optional||this.raise(TSErrors.OptionalTypeBeforeRequired,{node:elementNode}),seenOptionalElement=seenOptionalElement||"TSNamedTupleMember"===type&&elementNode.optional||"TSOptionalType"===type,"TSRestType"===type&&(type=(elementNode=elementNode.typeAnnotation).type);const isLabeled="TSNamedTupleMember"===type;labeledElements=null!=(_labeledElements=labeledElements)?_labeledElements:isLabeled,labeledElements!==isLabeled&&this.raise(TSErrors.MixedLabeledAndUnlabeledElements,{node:elementNode});})),this.finishNode(node,"TSTupleType")}tsParseTupleElementType(){const{start:startPos,startLoc}=this.state,rest=this.eat(21);let type=this.tsParseType();const optional=this.eat(17);if(this.eat(14)){const labeledNode=this.startNodeAtNode(type);labeledNode.optional=optional,"TSTypeReference"!==type.type||type.typeParameters||"Identifier"!==type.typeName.type?(this.raise(TSErrors.InvalidTupleMemberLabel,{node:type}),labeledNode.label=type):labeledNode.label=type.typeName,labeledNode.elementType=this.tsParseType(),type=this.finishNode(labeledNode,"TSNamedTupleMember");}else if(optional){const optionalTypeNode=this.startNodeAtNode(type);optionalTypeNode.typeAnnotation=type,type=this.finishNode(optionalTypeNode,"TSOptionalType");}if(rest){const restNode=this.startNodeAt(startPos,startLoc);restNode.typeAnnotation=type,type=this.finishNode(restNode,"TSRestType");}return type}tsParseParenthesizedType(){const node=this.startNode();return this.expect(10),node.typeAnnotation=this.tsParseType(),this.expect(11),this.finishNode(node,"TSParenthesizedType")}tsParseFunctionOrConstructorType(type,abstract){const node=this.startNode();return "TSConstructorType"===type&&(node.abstract=!!abstract,abstract&&this.next(),this.next()),this.tsFillSignature(19,node),this.finishNode(node,type)}tsParseLiteralTypeNode(){const node=this.startNode();return node.literal=(()=>{switch(this.state.type){case 126:case 127:case 125:case 81:case 82:return this.parseExprAtom();default:throw this.unexpected()}})(),this.finishNode(node,"TSLiteralType")}tsParseTemplateLiteralType(){const node=this.startNode();return node.literal=this.parseTemplate(!1),this.finishNode(node,"TSLiteralType")}parseTemplateSubstitution(){return this.state.inType?this.tsParseType():super.parseTemplateSubstitution()}tsParseThisTypeOrThisTypePredicate(){const thisKeyword=this.tsParseThisTypeNode();return this.isContextual(109)&&!this.hasPrecedingLineBreak()?this.tsParseThisTypePredicate(thisKeyword):thisKeyword}tsParseNonArrayType(){switch(this.state.type){case 125:case 126:case 127:case 81:case 82:return this.tsParseLiteralTypeNode();case 49:if("-"===this.state.value){const node=this.startNode(),nextToken=this.lookahead();if(126!==nextToken.type&&127!==nextToken.type)throw this.unexpected();return node.literal=this.parseMaybeUnary(),this.finishNode(node,"TSLiteralType")}break;case 74:return this.tsParseThisTypeOrThisTypePredicate();case 83:return this.tsParseTypeQuery();case 79:return this.tsParseImportType();case 5:return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))?this.tsParseMappedType():this.tsParseTypeLiteral();case 0:return this.tsParseTupleType();case 10:return this.tsParseParenthesizedType();case 25:case 24:return this.tsParseTemplateLiteralType();default:{const{type}=this.state;if(tokenIsIdentifier(type)||84===type||80===type){const nodeType=84===type?"TSVoidKeyword":80===type?"TSNullKeyword":function(value){switch(value){case"any":return "TSAnyKeyword";case"boolean":return "TSBooleanKeyword";case"bigint":return "TSBigIntKeyword";case"never":return "TSNeverKeyword";case"number":return "TSNumberKeyword";case"object":return "TSObjectKeyword";case"string":return "TSStringKeyword";case"symbol":return "TSSymbolKeyword";case"undefined":return "TSUndefinedKeyword";case"unknown":return "TSUnknownKeyword";default:return}}(this.state.value);if(void 0!==nodeType&&46!==this.lookaheadCharCode()){const node=this.startNode();return this.next(),this.finishNode(node,nodeType)}return this.tsParseTypeReference()}}}throw this.unexpected()}tsParseArrayTypeOrHigher(){let type=this.tsParseNonArrayType();for(;!this.hasPrecedingLineBreak()&&this.eat(0);)if(this.match(3)){const node=this.startNodeAtNode(type);node.elementType=type,this.expect(3),type=this.finishNode(node,"TSArrayType");}else {const node=this.startNodeAtNode(type);node.objectType=type,node.indexType=this.tsParseType(),this.expect(3),type=this.finishNode(node,"TSIndexedAccessType");}return type}tsParseTypeOperator(){const node=this.startNode(),operator=this.state.value;return this.next(),node.operator=operator,node.typeAnnotation=this.tsParseTypeOperatorOrHigher(),"readonly"===operator&&this.tsCheckTypeAnnotationForReadOnly(node),this.finishNode(node,"TSTypeOperator")}tsCheckTypeAnnotationForReadOnly(node){switch(node.typeAnnotation.type){case"TSTupleType":case"TSArrayType":return;default:this.raise(TSErrors.UnexpectedReadonly,{node});}}tsParseInferType(){const node=this.startNode();this.expectContextual(108);const typeParameter=this.startNode();return typeParameter.name=this.tsParseTypeParameterName(),node.typeParameter=this.finishNode(typeParameter,"TSTypeParameter"),this.finishNode(node,"TSInferType")}tsParseTypeOperatorOrHigher(){var token;return (token=this.state.type)>=113&&token<=115&&!this.state.containsEsc?this.tsParseTypeOperator():this.isContextual(108)?this.tsParseInferType():this.tsParseArrayTypeOrHigher()}tsParseUnionOrIntersectionType(kind,parseConstituentType,operator){const node=this.startNode(),hasLeadingOperator=this.eat(operator),types=[];do{types.push(parseConstituentType());}while(this.eat(operator));return 1!==types.length||hasLeadingOperator?(node.types=types,this.finishNode(node,kind)):types[0]}tsParseIntersectionTypeOrHigher(){return this.tsParseUnionOrIntersectionType("TSIntersectionType",this.tsParseTypeOperatorOrHigher.bind(this),43)}tsParseUnionTypeOrHigher(){return this.tsParseUnionOrIntersectionType("TSUnionType",this.tsParseIntersectionTypeOrHigher.bind(this),41)}tsIsStartOfFunctionType(){return !!this.match(45)||this.match(10)&&this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this))}tsSkipParameterStart(){if(tokenIsIdentifier(this.state.type)||this.match(74))return this.next(),!0;if(this.match(5)){let braceStackCounter=1;for(this.next();braceStackCounter>0;)this.match(5)?++braceStackCounter:this.match(8)&&--braceStackCounter,this.next();return !0}if(this.match(0)){let braceStackCounter=1;for(this.next();braceStackCounter>0;)this.match(0)?++braceStackCounter:this.match(3)&&--braceStackCounter,this.next();return !0}return !1}tsIsUnambiguouslyStartOfFunctionType(){if(this.next(),this.match(11)||this.match(21))return !0;if(this.tsSkipParameterStart()){if(this.match(14)||this.match(12)||this.match(17)||this.match(29))return !0;if(this.match(11)&&(this.next(),this.match(19)))return !0}return !1}tsParseTypeOrTypePredicateAnnotation(returnToken){return this.tsInType((()=>{const t=this.startNode();this.expect(returnToken);const node=this.startNode(),asserts=!!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));if(asserts&&this.match(74)){let thisTypePredicate=this.tsParseThisTypeOrThisTypePredicate();return "TSThisType"===thisTypePredicate.type?(node.parameterName=thisTypePredicate,node.asserts=!0,node.typeAnnotation=null,thisTypePredicate=this.finishNode(node,"TSTypePredicate")):(this.resetStartLocationFromNode(thisTypePredicate,node),thisTypePredicate.asserts=!0),t.typeAnnotation=thisTypePredicate,this.finishNode(t,"TSTypeAnnotation")}const typePredicateVariable=this.tsIsIdentifier()&&this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));if(!typePredicateVariable)return asserts?(node.parameterName=this.parseIdentifier(),node.asserts=asserts,node.typeAnnotation=null,t.typeAnnotation=this.finishNode(node,"TSTypePredicate"),this.finishNode(t,"TSTypeAnnotation")):this.tsParseTypeAnnotation(!1,t);const type=this.tsParseTypeAnnotation(!1);return node.parameterName=typePredicateVariable,node.typeAnnotation=type,node.asserts=asserts,t.typeAnnotation=this.finishNode(node,"TSTypePredicate"),this.finishNode(t,"TSTypeAnnotation")}))}tsTryParseTypeOrTypePredicateAnnotation(){return this.match(14)?this.tsParseTypeOrTypePredicateAnnotation(14):void 0}tsTryParseTypeAnnotation(){return this.match(14)?this.tsParseTypeAnnotation():void 0}tsTryParseType(){return this.tsEatThenParseType(14)}tsParseTypePredicatePrefix(){const id=this.parseIdentifier();if(this.isContextual(109)&&!this.hasPrecedingLineBreak())return this.next(),id}tsParseTypePredicateAsserts(){if(102!==this.state.type)return !1;const containsEsc=this.state.containsEsc;return this.next(),!(!tokenIsIdentifier(this.state.type)&&!this.match(74))&&(containsEsc&&this.raise(ErrorMessages.InvalidEscapedReservedWord,{at:this.state.lastTokStartLoc},"asserts"),!0)}tsParseTypeAnnotation(eatColon=!0,t=this.startNode()){return this.tsInType((()=>{eatColon&&this.expect(14),t.typeAnnotation=this.tsParseType();})),this.finishNode(t,"TSTypeAnnotation")}tsParseType(){assert(this.state.inType);const type=this.tsParseNonConditionalType();if(this.hasPrecedingLineBreak()||!this.eat(77))return type;const node=this.startNodeAtNode(type);return node.checkType=type,node.extendsType=this.tsParseNonConditionalType(),this.expect(17),node.trueType=this.tsParseType(),this.expect(14),node.falseType=this.tsParseType(),this.finishNode(node,"TSConditionalType")}isAbstractConstructorSignature(){return this.isContextual(116)&&73===this.lookahead().type}tsParseNonConditionalType(){return this.tsIsStartOfFunctionType()?this.tsParseFunctionOrConstructorType("TSFunctionType"):this.match(73)?this.tsParseFunctionOrConstructorType("TSConstructorType"):this.isAbstractConstructorSignature()?this.tsParseFunctionOrConstructorType("TSConstructorType",!0):this.tsParseUnionTypeOrHigher()}tsParseTypeAssertion(){this.getPluginOption("typescript","disallowAmbiguousJSXLike")&&this.raise(TSErrors.ReservedTypeAssertion,{at:this.state.startLoc});const node=this.startNode(),_const=this.tsTryNextParseConstantContext();return node.typeAnnotation=_const||this.tsNextThenParseType(),this.expect(46),node.expression=this.parseMaybeUnary(),this.finishNode(node,"TSTypeAssertion")}tsParseHeritageClause(descriptor){const originalStartLoc=this.state.startLoc,delimitedList=this.tsParseDelimitedList("HeritageClauseElement",this.tsParseExpressionWithTypeArguments.bind(this));return delimitedList.length||this.raise(TSErrors.EmptyHeritageClauseType,{at:originalStartLoc},descriptor),delimitedList}tsParseExpressionWithTypeArguments(){const node=this.startNode();return node.expression=this.tsParseEntityName(!1),this.match(45)&&(node.typeParameters=this.tsParseTypeArguments()),this.finishNode(node,"TSExpressionWithTypeArguments")}tsParseInterfaceDeclaration(node){tokenIsIdentifier(this.state.type)?(node.id=this.parseIdentifier(),this.checkLVal(node.id,"typescript interface declaration",130)):(node.id=null,this.raise(TSErrors.MissingInterfaceName,{at:this.state.startLoc})),node.typeParameters=this.tsTryParseTypeParameters(),this.eat(77)&&(node.extends=this.tsParseHeritageClause("extends"));const body=this.startNode();return body.body=this.tsInType(this.tsParseObjectTypeMembers.bind(this)),node.body=this.finishNode(body,"TSInterfaceBody"),this.finishNode(node,"TSInterfaceDeclaration")}tsParseTypeAliasDeclaration(node){return node.id=this.parseIdentifier(),this.checkLVal(node.id,"typescript type alias",2),node.typeParameters=this.tsTryParseTypeParameters(),node.typeAnnotation=this.tsInType((()=>{if(this.expect(29),this.isContextual(107)&&16!==this.lookahead().type){const node=this.startNode();return this.next(),this.finishNode(node,"TSIntrinsicKeyword")}return this.tsParseType()})),this.semicolon(),this.finishNode(node,"TSTypeAliasDeclaration")}tsInNoContext(cb){const oldContext=this.state.context;this.state.context=[oldContext[0]];try{return cb()}finally{this.state.context=oldContext;}}tsInType(cb){const oldInType=this.state.inType;this.state.inType=!0;try{return cb()}finally{this.state.inType=oldInType;}}tsEatThenParseType(token){return this.match(token)?this.tsNextThenParseType():void 0}tsExpectThenParseType(token){return this.tsDoThenParseType((()=>this.expect(token)))}tsNextThenParseType(){return this.tsDoThenParseType((()=>this.next()))}tsDoThenParseType(cb){return this.tsInType((()=>(cb(),this.tsParseType())))}tsParseEnumMember(){const node=this.startNode();return node.id=this.match(125)?this.parseExprAtom():this.parseIdentifier(!0),this.eat(29)&&(node.initializer=this.parseMaybeAssignAllowIn()),this.finishNode(node,"TSEnumMember")}tsParseEnumDeclaration(node,isConst){return isConst&&(node.const=!0),node.id=this.parseIdentifier(),this.checkLVal(node.id,"typescript enum declaration",isConst?779:267),this.expect(5),node.members=this.tsParseDelimitedList("EnumMembers",this.tsParseEnumMember.bind(this)),this.expect(8),this.finishNode(node,"TSEnumDeclaration")}tsParseModuleBlock(){const node=this.startNode();return this.scope.enter(0),this.expect(5),this.parseBlockOrModuleBlockBody(node.body=[],void 0,!0,8),this.scope.exit(),this.finishNode(node,"TSModuleBlock")}tsParseModuleOrNamespaceDeclaration(node,nested=!1){if(node.id=this.parseIdentifier(),nested||this.checkLVal(node.id,"module or namespace declaration",1024),this.eat(16)){const inner=this.startNode();this.tsParseModuleOrNamespaceDeclaration(inner,!0),node.body=inner;}else this.scope.enter(256),this.prodParam.enter(0),node.body=this.tsParseModuleBlock(),this.prodParam.exit(),this.scope.exit();return this.finishNode(node,"TSModuleDeclaration")}tsParseAmbientExternalModuleDeclaration(node){return this.isContextual(105)?(node.global=!0,node.id=this.parseIdentifier()):this.match(125)?node.id=this.parseExprAtom():this.unexpected(),this.match(5)?(this.scope.enter(256),this.prodParam.enter(0),node.body=this.tsParseModuleBlock(),this.prodParam.exit(),this.scope.exit()):this.semicolon(),this.finishNode(node,"TSModuleDeclaration")}tsParseImportEqualsDeclaration(node,isExport){node.isExport=isExport||!1,node.id=this.parseIdentifier(),this.checkLVal(node.id,"import equals declaration",9),this.expect(29);const moduleReference=this.tsParseModuleReference();return "type"===node.importKind&&"TSExternalModuleReference"!==moduleReference.type&&this.raise(TSErrors.ImportAliasHasImportType,{node:moduleReference}),node.moduleReference=moduleReference,this.semicolon(),this.finishNode(node,"TSImportEqualsDeclaration")}tsIsExternalModuleReference(){return this.isContextual(112)&&40===this.lookaheadCharCode()}tsParseModuleReference(){return this.tsIsExternalModuleReference()?this.tsParseExternalModuleReference():this.tsParseEntityName(!1)}tsParseExternalModuleReference(){const node=this.startNode();if(this.expectContextual(112),this.expect(10),!this.match(125))throw this.unexpected();return node.expression=this.parseExprAtom(),this.expect(11),this.finishNode(node,"TSExternalModuleReference")}tsLookAhead(f){const state=this.state.clone(),res=f();return this.state=state,res}tsTryParseAndCatch(f){const result=this.tryParse((abort=>f()||abort()));if(!result.aborted&&result.node)return result.error&&(this.state=result.failState),result.node}tsTryParse(f){const state=this.state.clone(),result=f();return void 0!==result&&!1!==result?result:void(this.state=state)}tsTryParseDeclare(nany){if(this.isLineTerminator())return;let kind,starttype=this.state.type;return this.isContextual(95)&&(starttype=70,kind="let"),this.tsInAmbientContext((()=>{switch(starttype){case 64:return nany.declare=!0,this.parseFunctionStatement(nany,!1,!0);case 76:return nany.declare=!0,this.parseClass(nany,!0,!1);case 71:if(this.match(71)&&this.isLookaheadContextual("enum"))return this.expect(71),this.expectContextual(118),this.tsParseEnumDeclaration(nany,!0);case 70:return kind=kind||this.state.value,this.parseVarStatement(nany,kind);case 105:return this.tsParseAmbientExternalModuleDeclaration(nany);default:if(tokenIsIdentifier(starttype))return this.tsParseDeclaration(nany,this.state.value,!0)}}))}tsTryParseExportDeclaration(){return this.tsParseDeclaration(this.startNode(),this.state.value,!0)}tsParseExpressionStatement(node,expr){switch(expr.name){case"declare":{const declaration=this.tsTryParseDeclare(node);if(declaration)return declaration.declare=!0,declaration;break}case"global":if(this.match(5)){this.scope.enter(256),this.prodParam.enter(0);const mod=node;return mod.global=!0,mod.id=expr,mod.body=this.tsParseModuleBlock(),this.scope.exit(),this.prodParam.exit(),this.finishNode(mod,"TSModuleDeclaration")}break;default:return this.tsParseDeclaration(node,expr.name,!1)}}tsParseDeclaration(node,value,next){switch(value){case"abstract":if(this.tsCheckLineTerminator(next)&&(this.match(76)||tokenIsIdentifier(this.state.type)))return this.tsParseAbstractDeclaration(node);break;case"enum":if(next||tokenIsIdentifier(this.state.type))return next&&this.next(),this.tsParseEnumDeclaration(node,!1);break;case"interface":if(this.tsCheckLineTerminator(next)&&tokenIsIdentifier(this.state.type))return this.tsParseInterfaceDeclaration(node);break;case"module":if(this.tsCheckLineTerminator(next)){if(this.match(125))return this.tsParseAmbientExternalModuleDeclaration(node);if(tokenIsIdentifier(this.state.type))return this.tsParseModuleOrNamespaceDeclaration(node)}break;case"namespace":if(this.tsCheckLineTerminator(next)&&tokenIsIdentifier(this.state.type))return this.tsParseModuleOrNamespaceDeclaration(node);break;case"type":if(this.tsCheckLineTerminator(next)&&tokenIsIdentifier(this.state.type))return this.tsParseTypeAliasDeclaration(node)}}tsCheckLineTerminator(next){return next?!this.hasFollowingLineBreak()&&(this.next(),!0):!this.isLineTerminator()}tsTryParseGenericAsyncArrowFunction(startPos,startLoc){if(!this.match(45))return;const oldMaybeInArrowParameters=this.state.maybeInArrowParameters;this.state.maybeInArrowParameters=!0;const res=this.tsTryParseAndCatch((()=>{const node=this.startNodeAt(startPos,startLoc);return node.typeParameters=this.tsParseTypeParameters(),super.parseFunctionParams(node),node.returnType=this.tsTryParseTypeOrTypePredicateAnnotation(),this.expect(19),node}));return this.state.maybeInArrowParameters=oldMaybeInArrowParameters,res?this.parseArrowExpression(res,null,!0):void 0}tsParseTypeArguments(){const node=this.startNode();return node.params=this.tsInType((()=>this.tsInNoContext((()=>(this.expect(45),this.tsParseDelimitedList("TypeParametersOrArguments",this.tsParseType.bind(this))))))),0===node.params.length&&this.raise(TSErrors.EmptyTypeArguments,{node}),this.expect(46),this.finishNode(node,"TSTypeParameterInstantiation")}tsIsDeclarationStart(){return (token=this.state.type)>=116&&token<=122;var token;}isExportDefaultSpecifier(){return !this.tsIsDeclarationStart()&&super.isExportDefaultSpecifier()}parseAssignableListItem(allowModifiers,decorators){const startPos=this.state.start,startLoc=this.state.startLoc;let accessibility,readonly=!1,override=!1;if(void 0!==allowModifiers){const modified={};this.tsParseModifiers(modified,["public","private","protected","override","readonly"]),accessibility=modified.accessibility,override=modified.override,readonly=modified.readonly,!1===allowModifiers&&(accessibility||readonly||override)&&this.raise(TSErrors.UnexpectedParameterModifier,{at:startLoc});}const left=this.parseMaybeDefault();this.parseAssignableListItemTypes(left);const elt=this.parseMaybeDefault(left.start,left.loc.start,left);if(accessibility||readonly||override){const pp=this.startNodeAt(startPos,startLoc);return decorators.length&&(pp.decorators=decorators),accessibility&&(pp.accessibility=accessibility),readonly&&(pp.readonly=readonly),override&&(pp.override=override),"Identifier"!==elt.type&&"AssignmentPattern"!==elt.type&&this.raise(TSErrors.UnsupportedParameterPropertyKind,{node:pp}),pp.parameter=elt,this.finishNode(pp,"TSParameterProperty")}return decorators.length&&(left.decorators=decorators),elt}parseFunctionBodyAndFinish(node,type,isMethod=!1){this.match(14)&&(node.returnType=this.tsParseTypeOrTypePredicateAnnotation(14));const bodilessType="FunctionDeclaration"===type?"TSDeclareFunction":"ClassMethod"===type||"ClassPrivateMethod"===type?"TSDeclareMethod":void 0;bodilessType&&!this.match(5)&&this.isLineTerminator()?this.finishNode(node,bodilessType):"TSDeclareFunction"===bodilessType&&this.state.isAmbientContext&&(this.raise(TSErrors.DeclareFunctionHasImplementation,{node}),node.declare)?super.parseFunctionBodyAndFinish(node,bodilessType,isMethod):super.parseFunctionBodyAndFinish(node,type,isMethod);}registerFunctionStatementId(node){!node.body&&node.id?this.checkLVal(node.id,"function name",1024):super.registerFunctionStatementId(...arguments);}tsCheckForInvalidTypeCasts(items){items.forEach((node=>{"TSTypeCastExpression"===(null==node?void 0:node.type)&&this.raise(TSErrors.UnexpectedTypeAnnotation,{node:node.typeAnnotation});}));}toReferencedList(exprList,isInParens){return this.tsCheckForInvalidTypeCasts(exprList),exprList}parseArrayLike(...args){const node=super.parseArrayLike(...args);return "ArrayExpression"===node.type&&this.tsCheckForInvalidTypeCasts(node.elements),node}parseSubscript(base,startPos,startLoc,noCalls,state){if(!this.hasPrecedingLineBreak()&&this.match(35)){this.state.canStartJSXElement=!1,this.next();const nonNullExpression=this.startNodeAt(startPos,startLoc);return nonNullExpression.expression=base,this.finishNode(nonNullExpression,"TSNonNullExpression")}let isOptionalCall=!1;if(this.match(18)&&60===this.lookaheadCharCode()){if(noCalls)return state.stop=!0,base;state.optionalChainMember=isOptionalCall=!0,this.next();}if(this.match(45)){let missingParenErrorLoc;const result=this.tsTryParseAndCatch((()=>{if(!noCalls&&this.atPossibleAsyncArrow(base)){const asyncArrowFn=this.tsTryParseGenericAsyncArrowFunction(startPos,startLoc);if(asyncArrowFn)return asyncArrowFn}const node=this.startNodeAt(startPos,startLoc);node.callee=base;const typeArguments=this.tsParseTypeArguments();if(typeArguments){if(isOptionalCall&&!this.match(10)&&(missingParenErrorLoc=this.state.curPosition(),this.unexpected()),!noCalls&&this.eat(10))return node.arguments=this.parseCallExpressionArguments(11,!1),this.tsCheckForInvalidTypeCasts(node.arguments),node.typeParameters=typeArguments,state.optionalChainMember&&(node.optional=isOptionalCall),this.finishCallExpression(node,state.optionalChainMember);if(tokenIsTemplate(this.state.type)){const result=this.parseTaggedTemplateExpression(base,startPos,startLoc,state);return result.typeParameters=typeArguments,result}}this.unexpected();}));if(missingParenErrorLoc&&this.unexpected(missingParenErrorLoc,10),result)return result}return super.parseSubscript(base,startPos,startLoc,noCalls,state)}parseNewArguments(node){if(this.match(45)){const typeParameters=this.tsTryParseAndCatch((()=>{const args=this.tsParseTypeArguments();return this.match(10)||this.unexpected(),args}));typeParameters&&(node.typeParameters=typeParameters);}super.parseNewArguments(node);}parseExprOp(left,leftStartPos,leftStartLoc,minPrec){if(tokenOperatorPrecedence(54)>minPrec&&!this.hasPrecedingLineBreak()&&this.isContextual(89)){const node=this.startNodeAt(leftStartPos,leftStartLoc);node.expression=left;const _const=this.tsTryNextParseConstantContext();return node.typeAnnotation=_const||this.tsNextThenParseType(),this.finishNode(node,"TSAsExpression"),this.reScan_lt_gt(),this.parseExprOp(node,leftStartPos,leftStartLoc,minPrec)}return super.parseExprOp(left,leftStartPos,leftStartLoc,minPrec)}checkReservedWord(word,startLoc,checkKeywords,isBinding){}checkDuplicateExports(){}parseImport(node){if(node.importKind="value",tokenIsIdentifier(this.state.type)||this.match(51)||this.match(5)){let ahead=this.lookahead();if(this.isContextual(122)&&12!==ahead.type&&93!==ahead.type&&29!==ahead.type&&(node.importKind="type",this.next(),ahead=this.lookahead()),tokenIsIdentifier(this.state.type)&&29===ahead.type)return this.tsParseImportEqualsDeclaration(node)}const importNode=super.parseImport(node);return "type"===importNode.importKind&&importNode.specifiers.length>1&&"ImportDefaultSpecifier"===importNode.specifiers[0].type&&this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed,{node:importNode}),importNode}parseExport(node){if(this.match(79))return this.next(),this.isContextual(122)&&61!==this.lookaheadCharCode()?(node.importKind="type",this.next()):node.importKind="value",this.tsParseImportEqualsDeclaration(node,!0);if(this.eat(29)){const assign=node;return assign.expression=this.parseExpression(),this.semicolon(),this.finishNode(assign,"TSExportAssignment")}if(this.eatContextual(89)){const decl=node;return this.expectContextual(120),decl.id=this.parseIdentifier(),this.semicolon(),this.finishNode(decl,"TSNamespaceExportDeclaration")}return this.isContextual(122)&&5===this.lookahead().type?(this.next(),node.exportKind="type"):node.exportKind="value",super.parseExport(node)}isAbstractClass(){return this.isContextual(116)&&76===this.lookahead().type}parseExportDefaultExpression(){if(this.isAbstractClass()){const cls=this.startNode();return this.next(),cls.abstract=!0,this.parseClass(cls,!0,!0),cls}if(this.match(121)){const interfaceNode=this.startNode();this.next();const result=this.tsParseInterfaceDeclaration(interfaceNode);if(result)return result}return super.parseExportDefaultExpression()}parseStatementContent(context,topLevel){if(71===this.state.type){if(118===this.lookahead().type){const node=this.startNode();return this.next(),this.expectContextual(118),this.tsParseEnumDeclaration(node,!0)}}return super.parseStatementContent(context,topLevel)}parseAccessModifier(){return this.tsParseModifier(["public","protected","private"])}tsHasSomeModifiers(member,modifiers){return modifiers.some((modifier=>tsIsAccessModifier(modifier)?member.accessibility===modifier:!!member[modifier]))}tsIsStartOfStaticBlocks(){return this.isContextual(100)&&123===this.lookaheadCharCode()}parseClassMember(classBody,member,state){const modifiers=["declare","private","public","protected","override","abstract","readonly","static"];this.tsParseModifiers(member,modifiers,void 0,void 0,!0);const callParseClassMemberWithIsStatic=()=>{this.tsIsStartOfStaticBlocks()?(this.next(),this.next(),this.tsHasSomeModifiers(member,modifiers)&&this.raise(TSErrors.StaticBlockCannotHaveModifier,{at:this.state.curPosition()}),this.parseClassStaticBlock(classBody,member)):this.parseClassMemberWithIsStatic(classBody,member,state,!!member.static);};member.declare?this.tsInAmbientContext(callParseClassMemberWithIsStatic):callParseClassMemberWithIsStatic();}parseClassMemberWithIsStatic(classBody,member,state,isStatic){const idx=this.tsTryParseIndexSignature(member);if(idx)return classBody.body.push(idx),member.abstract&&this.raise(TSErrors.IndexSignatureHasAbstract,{node:member}),member.accessibility&&this.raise(TSErrors.IndexSignatureHasAccessibility,{node:member},member.accessibility),member.declare&&this.raise(TSErrors.IndexSignatureHasDeclare,{node:member}),void(member.override&&this.raise(TSErrors.IndexSignatureHasOverride,{node:member}));!this.state.inAbstractClass&&member.abstract&&this.raise(TSErrors.NonAbstractClassHasAbstractMethod,{node:member}),member.override&&(state.hadSuperClass||this.raise(TSErrors.OverrideNotInSubClass,{node:member})),super.parseClassMemberWithIsStatic(classBody,member,state,isStatic);}parsePostMemberNameModifiers(methodOrProp){this.eat(17)&&(methodOrProp.optional=!0),methodOrProp.readonly&&this.match(10)&&this.raise(TSErrors.ClassMethodHasReadonly,{node:methodOrProp}),methodOrProp.declare&&this.match(10)&&this.raise(TSErrors.ClassMethodHasDeclare,{node:methodOrProp});}parseExpressionStatement(node,expr){return ("Identifier"===expr.type?this.tsParseExpressionStatement(node,expr):void 0)||super.parseExpressionStatement(node,expr)}shouldParseExportDeclaration(){return !!this.tsIsDeclarationStart()||super.shouldParseExportDeclaration()}parseConditional(expr,startPos,startLoc,refExpressionErrors){if(!this.state.maybeInArrowParameters||!this.match(17))return super.parseConditional(expr,startPos,startLoc,refExpressionErrors);const result=this.tryParse((()=>super.parseConditional(expr,startPos,startLoc)));return result.node?(result.error&&(this.state=result.failState),result.node):(result.error&&super.setOptionalParametersError(refExpressionErrors,result.error),expr)}parseParenItem(node,startPos,startLoc){if(node=super.parseParenItem(node,startPos,startLoc),this.eat(17)&&(node.optional=!0,this.resetEndLocation(node)),this.match(14)){const typeCastNode=this.startNodeAt(startPos,startLoc);return typeCastNode.expression=node,typeCastNode.typeAnnotation=this.tsParseTypeAnnotation(),this.finishNode(typeCastNode,"TSTypeCastExpression")}return node}parseExportDeclaration(node){const startPos=this.state.start,startLoc=this.state.startLoc,isDeclare=this.eatContextual(117);if(isDeclare&&(this.isContextual(117)||!this.shouldParseExportDeclaration()))throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare,{at:this.state.startLoc});let declaration;return tokenIsIdentifier(this.state.type)&&(declaration=this.tsTryParseExportDeclaration()),declaration||(declaration=super.parseExportDeclaration(node)),declaration&&("TSInterfaceDeclaration"===declaration.type||"TSTypeAliasDeclaration"===declaration.type||isDeclare)&&(node.exportKind="type"),declaration&&isDeclare&&(this.resetStartLocation(declaration,startPos,startLoc),declaration.declare=!0),declaration}parseClassId(node,isStatement,optionalId){if((!isStatement||optionalId)&&this.isContextual(106))return;super.parseClassId(node,isStatement,optionalId,node.declare?1024:139);const typeParameters=this.tsTryParseTypeParameters();typeParameters&&(node.typeParameters=typeParameters);}parseClassPropertyAnnotation(node){!node.optional&&this.eat(35)&&(node.definite=!0);const type=this.tsTryParseTypeAnnotation();type&&(node.typeAnnotation=type);}parseClassProperty(node){if(this.parseClassPropertyAnnotation(node),this.state.isAmbientContext&&this.match(29)&&this.raise(TSErrors.DeclareClassFieldHasInitializer,{at:this.state.startLoc}),node.abstract&&this.match(29)){const{key}=node;this.raise(TSErrors.AbstractPropertyHasInitializer,{at:this.state.startLoc},"Identifier"!==key.type||node.computed?`[${this.input.slice(key.start,key.end)}]`:key.name);}return super.parseClassProperty(node)}parseClassPrivateProperty(node){return node.abstract&&this.raise(TSErrors.PrivateElementHasAbstract,{node}),node.accessibility&&this.raise(TSErrors.PrivateElementHasAccessibility,{node},node.accessibility),this.parseClassPropertyAnnotation(node),super.parseClassPrivateProperty(node)}pushClassMethod(classBody,method,isGenerator,isAsync,isConstructor,allowsDirectSuper){const typeParameters=this.tsTryParseTypeParameters();typeParameters&&isConstructor&&this.raise(TSErrors.ConstructorHasTypeParameters,{node:typeParameters}),!method.declare||"get"!==method.kind&&"set"!==method.kind||this.raise(TSErrors.DeclareAccessor,{node:method},method.kind),typeParameters&&(method.typeParameters=typeParameters),super.pushClassMethod(classBody,method,isGenerator,isAsync,isConstructor,allowsDirectSuper);}pushClassPrivateMethod(classBody,method,isGenerator,isAsync){const typeParameters=this.tsTryParseTypeParameters();typeParameters&&(method.typeParameters=typeParameters),super.pushClassPrivateMethod(classBody,method,isGenerator,isAsync);}declareClassPrivateMethodInScope(node,kind){"TSDeclareMethod"!==node.type&&("MethodDefinition"!==node.type||node.value.body)&&super.declareClassPrivateMethodInScope(node,kind);}parseClassSuper(node){super.parseClassSuper(node),node.superClass&&this.match(45)&&(node.superTypeParameters=this.tsParseTypeArguments()),this.eatContextual(106)&&(node.implements=this.tsParseHeritageClause("implements"));}parseObjPropValue(prop,...args){const typeParameters=this.tsTryParseTypeParameters();typeParameters&&(prop.typeParameters=typeParameters),super.parseObjPropValue(prop,...args);}parseFunctionParams(node,allowModifiers){const typeParameters=this.tsTryParseTypeParameters();typeParameters&&(node.typeParameters=typeParameters),super.parseFunctionParams(node,allowModifiers);}parseVarId(decl,kind){super.parseVarId(decl,kind),"Identifier"===decl.id.type&&!this.hasPrecedingLineBreak()&&this.eat(35)&&(decl.definite=!0);const type=this.tsTryParseTypeAnnotation();type&&(decl.id.typeAnnotation=type,this.resetEndLocation(decl.id));}parseAsyncArrowFromCallExpression(node,call){return this.match(14)&&(node.returnType=this.tsParseTypeAnnotation()),super.parseAsyncArrowFromCallExpression(node,call)}parseMaybeAssign(...args){var _jsx,_jsx2,_typeCast,_jsx3,_typeCast2,_jsx4,_typeCast3;let state,jsx,typeCast,typeParameters;if(this.hasPlugin("jsx")&&(this.match(134)||this.match(45))){if(state=this.state.clone(),jsx=this.tryParse((()=>super.parseMaybeAssign(...args)),state),!jsx.error)return jsx.node;const{context}=this.state,currentContext=context[context.length-1];currentContext!==types.j_oTag&&currentContext!==types.j_expr||context.pop();}if(!(null!=(_jsx=jsx)&&_jsx.error||this.match(45)))return super.parseMaybeAssign(...args);state=state||this.state.clone();const arrow=this.tryParse((abort=>{var _expr$extra,_typeParameters;typeParameters=this.tsParseTypeParameters();const expr=super.parseMaybeAssign(...args);return ("ArrowFunctionExpression"!==expr.type||null!=(_expr$extra=expr.extra)&&_expr$extra.parenthesized)&&abort(),0!==(null==(_typeParameters=typeParameters)?void 0:_typeParameters.params.length)&&this.resetStartLocationFromNode(expr,typeParameters),expr.typeParameters=typeParameters,expr}),state);if(!arrow.error&&!arrow.aborted)return typeParameters&&this.reportReservedArrowTypeParam(typeParameters),arrow.node;if(!jsx&&(assert(!this.hasPlugin("jsx")),typeCast=this.tryParse((()=>super.parseMaybeAssign(...args)),state),!typeCast.error))return typeCast.node;if(null!=(_jsx2=jsx)&&_jsx2.node)return this.state=jsx.failState,jsx.node;if(arrow.node)return this.state=arrow.failState,typeParameters&&this.reportReservedArrowTypeParam(typeParameters),arrow.node;if(null!=(_typeCast=typeCast)&&_typeCast.node)return this.state=typeCast.failState,typeCast.node;if(null!=(_jsx3=jsx)&&_jsx3.thrown)throw jsx.error;if(arrow.thrown)throw arrow.error;if(null!=(_typeCast2=typeCast)&&_typeCast2.thrown)throw typeCast.error;throw (null==(_jsx4=jsx)?void 0:_jsx4.error)||arrow.error||(null==(_typeCast3=typeCast)?void 0:_typeCast3.error)}reportReservedArrowTypeParam(node){var _node$extra;1!==node.params.length||null!=(_node$extra=node.extra)&&_node$extra.trailingComma||!this.getPluginOption("typescript","disallowAmbiguousJSXLike")||this.raise(TSErrors.ReservedArrowTypeParam,{node});}parseMaybeUnary(refExpressionErrors){return !this.hasPlugin("jsx")&&this.match(45)?this.tsParseTypeAssertion():super.parseMaybeUnary(refExpressionErrors)}parseArrow(node){if(this.match(14)){const result=this.tryParse((abort=>{const returnType=this.tsParseTypeOrTypePredicateAnnotation(14);return !this.canInsertSemicolon()&&this.match(19)||abort(),returnType}));if(result.aborted)return;result.thrown||(result.error&&(this.state=result.failState),node.returnType=result.node);}return super.parseArrow(node)}parseAssignableListItemTypes(param){this.eat(17)&&("Identifier"===param.type||this.state.isAmbientContext||this.state.inType||this.raise(TSErrors.PatternIsOptional,{node:param}),param.optional=!0);const type=this.tsTryParseTypeAnnotation();return type&&(param.typeAnnotation=type),this.resetEndLocation(param),param}isAssignable(node,isBinding){switch(node.type){case"TSTypeCastExpression":return this.isAssignable(node.expression,isBinding);case"TSParameterProperty":return !0;default:return super.isAssignable(node,isBinding)}}toAssignable(node,isLHS=!1){switch(node.type){case"TSTypeCastExpression":return super.toAssignable(this.typeCastToParameter(node),isLHS);case"TSParameterProperty":default:return super.toAssignable(node,isLHS);case"ParenthesizedExpression":return this.toAssignableParenthesizedExpression(node,isLHS);case"TSAsExpression":case"TSNonNullExpression":case"TSTypeAssertion":return node.expression=this.toAssignable(node.expression,isLHS),node}}toAssignableParenthesizedExpression(node,isLHS){switch(node.expression.type){case"TSAsExpression":case"TSNonNullExpression":case"TSTypeAssertion":case"ParenthesizedExpression":return node.expression=this.toAssignable(node.expression,isLHS),node;default:return super.toAssignable(node,isLHS)}}checkLVal(expr,contextDescription,...args){var _expr$extra2;switch(expr.type){case"TSTypeCastExpression":return;case"TSParameterProperty":return void this.checkLVal(expr.parameter,"parameter property",...args);case"TSAsExpression":case"TSTypeAssertion":if(!(args[0]||"parenthesized expression"===contextDescription||null!=(_expr$extra2=expr.extra)&&_expr$extra2.parenthesized)){this.raise(ErrorMessages.InvalidLhs,{node:expr},contextDescription);break}return void this.checkLVal(expr.expression,"parenthesized expression",...args);case"TSNonNullExpression":return void this.checkLVal(expr.expression,contextDescription,...args);default:return void super.checkLVal(expr,contextDescription,...args)}}parseBindingAtom(){return 74===this.state.type?this.parseIdentifier(!0):super.parseBindingAtom()}parseMaybeDecoratorArguments(expr){if(this.match(45)){const typeArguments=this.tsParseTypeArguments();if(this.match(10)){const call=super.parseMaybeDecoratorArguments(expr);return call.typeParameters=typeArguments,call}this.unexpected(null,10);}return super.parseMaybeDecoratorArguments(expr)}checkCommaAfterRest(close){return this.state.isAmbientContext&&this.match(12)&&this.lookaheadCharCode()===close?(this.next(),!1):super.checkCommaAfterRest(close)}isClassMethod(){return this.match(45)||super.isClassMethod()}isClassProperty(){return this.match(35)||this.match(14)||super.isClassProperty()}parseMaybeDefault(...args){const node=super.parseMaybeDefault(...args);return "AssignmentPattern"===node.type&&node.typeAnnotation&&node.right.start<node.typeAnnotation.start&&this.raise(TSErrors.TypeAnnotationAfterAssign,{node:node.typeAnnotation}),node}getTokenFromCode(code){if(this.state.inType){if(62===code)return this.finishOp(46,1);if(60===code)return this.finishOp(45,1)}return super.getTokenFromCode(code)}reScan_lt_gt(){const{type}=this.state;45===type?(this.state.pos-=1,this.readToken_lt()):46===type&&(this.state.pos-=1,this.readToken_gt());}toAssignableList(exprList){for(let i=0;i<exprList.length;i++){const expr=exprList[i];if(expr)switch(expr.type){case"TSTypeCastExpression":exprList[i]=this.typeCastToParameter(expr);break;case"TSAsExpression":case"TSTypeAssertion":this.state.maybeInArrowParameters?this.raise(TSErrors.UnexpectedTypeCastInParameter,{node:expr}):exprList[i]=this.typeCastToParameter(expr);}}return super.toAssignableList(...arguments)}typeCastToParameter(node){return node.expression.typeAnnotation=node.typeAnnotation,this.resetEndLocation(node.expression,node.typeAnnotation.loc.end),node.expression}shouldParseArrow(params){return this.match(14)?params.every((expr=>this.isAssignable(expr,!0))):super.shouldParseArrow(params)}shouldParseAsyncArrow(){return this.match(14)||super.shouldParseAsyncArrow()}canHaveLeadingDecorator(){return super.canHaveLeadingDecorator()||this.isAbstractClass()}jsxParseOpeningElementAfterName(node){if(this.match(45)){const typeArguments=this.tsTryParseAndCatch((()=>this.tsParseTypeArguments()));typeArguments&&(node.typeParameters=typeArguments);}return super.jsxParseOpeningElementAfterName(node)}getGetterSetterExpectedParamCount(method){const baseCount=super.getGetterSetterExpectedParamCount(method),firstParam=this.getObjectOrClassMethodParams(method)[0];return firstParam&&this.isThisParam(firstParam)?baseCount+1:baseCount}parseCatchClauseParam(){const param=super.parseCatchClauseParam(),type=this.tsTryParseTypeAnnotation();return type&&(param.typeAnnotation=type,this.resetEndLocation(param)),param}tsInAmbientContext(cb){const oldIsAmbientContext=this.state.isAmbientContext;this.state.isAmbientContext=!0;try{return cb()}finally{this.state.isAmbientContext=oldIsAmbientContext;}}parseClass(node,...args){const oldInAbstractClass=this.state.inAbstractClass;this.state.inAbstractClass=!!node.abstract;try{return super.parseClass(node,...args)}finally{this.state.inAbstractClass=oldInAbstractClass;}}tsParseAbstractDeclaration(node){if(this.match(76))return node.abstract=!0,this.parseClass(node,!0,!1);if(this.isContextual(121)){if(!this.hasFollowingLineBreak())return node.abstract=!0,this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer,{node}),this.next(),this.tsParseInterfaceDeclaration(node)}else this.unexpected(null,76);}parseMethod(...args){const method=super.parseMethod(...args);if(method.abstract){if(this.hasPlugin("estree")?!!method.value.body:!!method.body){const{key}=method;this.raise(TSErrors.AbstractMethodHasImplementation,{node:method},"Identifier"!==key.type||method.computed?`[${this.input.slice(key.start,key.end)}]`:key.name);}}return method}tsParseTypeParameterName(){return this.parseIdentifier().name}shouldParseAsAmbientContext(){return !!this.getPluginOption("typescript","dts")}parse(){return this.shouldParseAsAmbientContext()&&(this.state.isAmbientContext=!0),super.parse()}getExpression(){return this.shouldParseAsAmbientContext()&&(this.state.isAmbientContext=!0),super.getExpression()}parseExportSpecifier(node,isString,isInTypeExport,isMaybeTypeOnly){return !isString&&isMaybeTypeOnly?(this.parseTypeOnlyImportExportSpecifier(node,!1,isInTypeExport),this.finishNode(node,"ExportSpecifier")):(node.exportKind="value",super.parseExportSpecifier(node,isString,isInTypeExport,isMaybeTypeOnly))}parseImportSpecifier(specifier,importedIsString,isInTypeOnlyImport,isMaybeTypeOnly){return !importedIsString&&isMaybeTypeOnly?(this.parseTypeOnlyImportExportSpecifier(specifier,!0,isInTypeOnlyImport),this.finishNode(specifier,"ImportSpecifier")):(specifier.importKind="value",super.parseImportSpecifier(specifier,importedIsString,isInTypeOnlyImport,isMaybeTypeOnly))}parseTypeOnlyImportExportSpecifier(node,isImport,isInTypeOnlyImportExport){const leftOfAsKey=isImport?"imported":"local",rightOfAsKey=isImport?"local":"exported";let rightOfAs,leftOfAs=node[leftOfAsKey],hasTypeSpecifier=!1,canParseAsKeyword=!0;const loc=leftOfAs.loc.start;if(this.isContextual(89)){const firstAs=this.parseIdentifier();if(this.isContextual(89)){const secondAs=this.parseIdentifier();tokenIsKeywordOrIdentifier(this.state.type)?(hasTypeSpecifier=!0,leftOfAs=firstAs,rightOfAs=this.parseIdentifier(),canParseAsKeyword=!1):(rightOfAs=secondAs,canParseAsKeyword=!1);}else tokenIsKeywordOrIdentifier(this.state.type)?(canParseAsKeyword=!1,rightOfAs=this.parseIdentifier()):(hasTypeSpecifier=!0,leftOfAs=firstAs);}else tokenIsKeywordOrIdentifier(this.state.type)&&(hasTypeSpecifier=!0,leftOfAs=this.parseIdentifier());hasTypeSpecifier&&isInTypeOnlyImportExport&&this.raise(isImport?TSErrors.TypeModifierIsUsedInTypeImports:TSErrors.TypeModifierIsUsedInTypeExports,{at:loc}),node[leftOfAsKey]=leftOfAs,node[rightOfAsKey]=rightOfAs;node[isImport?"importKind":"exportKind"]=hasTypeSpecifier?"type":"value",canParseAsKeyword&&this.eatContextual(89)&&(node[rightOfAsKey]=isImport?this.parseIdentifier():this.parseModuleExportName()),node[rightOfAsKey]||(node[rightOfAsKey]=cloneIdentifier(node[leftOfAsKey])),isImport&&this.checkLVal(node[rightOfAsKey],"import specifier",9);}},v8intrinsic:superClass=>class extends superClass{parseV8Intrinsic(){if(this.match(50)){const v8IntrinsicStartLoc=this.state.startLoc,node=this.startNode();if(this.next(),tokenIsIdentifier(this.state.type)){const name=this.parseIdentifierName(this.state.start),identifier=this.createIdentifier(node,name);if(identifier.type="V8IntrinsicIdentifier",this.match(10))return identifier}this.unexpected(v8IntrinsicStartLoc);}}parseExprAtom(){return this.parseV8Intrinsic()||super.parseExprAtom(...arguments)}},placeholders:superClass=>class extends superClass{parsePlaceholder(expectedNode){if(this.match(136)){const node=this.startNode();return this.next(),this.assertNoSpace("Unexpected space in placeholder."),node.name=super.parseIdentifier(!0),this.assertNoSpace("Unexpected space in placeholder."),this.expect(136),this.finishPlaceholder(node,expectedNode)}}finishPlaceholder(node,expectedNode){const isFinished=!(!node.expectedNode||"Placeholder"!==node.type);return node.expectedNode=expectedNode,isFinished?node:this.finishNode(node,"Placeholder")}getTokenFromCode(code){return 37===code&&37===this.input.charCodeAt(this.state.pos+1)?this.finishOp(136,2):super.getTokenFromCode(...arguments)}parseExprAtom(){return this.parsePlaceholder("Expression")||super.parseExprAtom(...arguments)}parseIdentifier(){return this.parsePlaceholder("Identifier")||super.parseIdentifier(...arguments)}checkReservedWord(word){void 0!==word&&super.checkReservedWord(...arguments);}parseBindingAtom(){return this.parsePlaceholder("Pattern")||super.parseBindingAtom(...arguments)}checkLVal(expr){"Placeholder"!==expr.type&&super.checkLVal(...arguments);}toAssignable(node){return node&&"Placeholder"===node.type&&"Expression"===node.expectedNode?(node.expectedNode="Pattern",node):super.toAssignable(...arguments)}isLet(context){if(super.isLet(context))return !0;if(!this.isContextual(95))return !1;if(context)return !1;return 136===this.lookahead().type}verifyBreakContinue(node){node.label&&"Placeholder"===node.label.type||super.verifyBreakContinue(...arguments);}parseExpressionStatement(node,expr){if("Placeholder"!==expr.type||expr.extra&&expr.extra.parenthesized)return super.parseExpressionStatement(...arguments);if(this.match(14)){const stmt=node;return stmt.label=this.finishPlaceholder(expr,"Identifier"),this.next(),stmt.body=this.parseStatement("label"),this.finishNode(stmt,"LabeledStatement")}return this.semicolon(),node.name=expr.name,this.finishPlaceholder(node,"Statement")}parseBlock(){return this.parsePlaceholder("BlockStatement")||super.parseBlock(...arguments)}parseFunctionId(){return this.parsePlaceholder("Identifier")||super.parseFunctionId(...arguments)}parseClass(node,isStatement,optionalId){const type=isStatement?"ClassDeclaration":"ClassExpression";this.next(),this.takeDecorators(node);const oldStrict=this.state.strict,placeholder=this.parsePlaceholder("Identifier");if(placeholder){if(!(this.match(77)||this.match(136)||this.match(5))){if(optionalId||!isStatement)return node.id=null,node.body=this.finishPlaceholder(placeholder,"ClassBody"),this.finishNode(node,type);throw this.raise(PlaceholderErrors.ClassNameIsRequired,{at:this.state.startLoc})}node.id=placeholder;}else this.parseClassId(node,isStatement,optionalId);return this.parseClassSuper(node),node.body=this.parsePlaceholder("ClassBody")||this.parseClassBody(!!node.superClass,oldStrict),this.finishNode(node,type)}parseExport(node){const placeholder=this.parsePlaceholder("Identifier");if(!placeholder)return super.parseExport(...arguments);if(!this.isContextual(93)&&!this.match(12))return node.specifiers=[],node.source=null,node.declaration=this.finishPlaceholder(placeholder,"Declaration"),this.finishNode(node,"ExportNamedDeclaration");this.expectPlugin("exportDefaultFrom");const specifier=this.startNode();return specifier.exported=placeholder,node.specifiers=[this.finishNode(specifier,"ExportDefaultSpecifier")],super.parseExport(node)}isExportDefaultSpecifier(){if(this.match(61)){const next=this.nextTokenStart();if(this.isUnparsedContextual(next,"from")&&this.input.startsWith(tokenLabelName(136),this.nextTokenStartSince(next+4)))return !0}return super.isExportDefaultSpecifier()}maybeParseExportDefaultSpecifier(node){return !!(node.specifiers&&node.specifiers.length>0)||super.maybeParseExportDefaultSpecifier(...arguments)}checkExport(node){const{specifiers}=node;null!=specifiers&&specifiers.length&&(node.specifiers=specifiers.filter((node=>"Placeholder"===node.exported.type))),super.checkExport(node),node.specifiers=specifiers;}parseImport(node){const placeholder=this.parsePlaceholder("Identifier");if(!placeholder)return super.parseImport(...arguments);if(node.specifiers=[],!this.isContextual(93)&&!this.match(12))return node.source=this.finishPlaceholder(placeholder,"StringLiteral"),this.semicolon(),this.finishNode(node,"ImportDeclaration");const specifier=this.startNodeAtNode(placeholder);if(specifier.local=placeholder,this.finishNode(specifier,"ImportDefaultSpecifier"),node.specifiers.push(specifier),this.eat(12)){this.maybeParseStarImportSpecifier(node)||this.parseNamedImportSpecifiers(node);}return this.expectContextual(93),node.source=this.parseImportSource(),this.semicolon(),this.finishNode(node,"ImportDeclaration")}parseImportSource(){return this.parsePlaceholder("StringLiteral")||super.parseImportSource(...arguments)}}},mixinPluginNames=Object.keys(mixinPlugins),defaultOptions={sourceType:"script",sourceFilename:void 0,startColumn:0,startLine:1,allowAwaitOutsideFunction:!1,allowReturnOutsideFunction:!1,allowImportExportEverywhere:!1,allowSuperOutsideMethod:!1,allowUndeclaredExports:!1,plugins:[],strictMode:null,ranges:!1,tokens:!1,createParenthesizedExpressions:!1,errorRecovery:!1,attachComment:!0};const unwrapParenthesizedExpression=node=>"ParenthesizedExpression"===node.type?unwrapParenthesizedExpression(node.expression):node;const invalidHackPipeBodies=new Map([["ArrowFunctionExpression","arrow function"],["AssignmentExpression","assignment"],["ConditionalExpression","conditional"],["YieldExpression","yield"]]);const loopLabel={kind:"loop"},switchLabel={kind:"switch"},loneSurrogate=/[\uD800-\uDFFF]/u,keywordRelationalOperator=/in(?:stanceof)?/y;class Parser extends class extends class extends class extends class extends class extends class extends class extends class extends class{constructor(){this.sawUnambiguousESM=!1,this.ambiguousScriptDifferentAst=!1;}hasPlugin(pluginConfig){if("string"==typeof pluginConfig)return this.plugins.has(pluginConfig);{const[pluginName,pluginOptions]=pluginConfig;if(!this.hasPlugin(pluginName))return !1;const actualOptions=this.plugins.get(pluginName);for(const key of Object.keys(pluginOptions))if((null==actualOptions?void 0:actualOptions[key])!==pluginOptions[key])return !1;return !0}}getPluginOption(plugin,name){var _this$plugins$get;return null==(_this$plugins$get=this.plugins.get(plugin))?void 0:_this$plugins$get[name]}}{addComment(comment){this.filename&&(comment.loc.filename=this.filename),this.state.comments.push(comment);}processComment(node){const{commentStack}=this.state,commentStackLength=commentStack.length;if(0===commentStackLength)return;let i=commentStackLength-1;const lastCommentWS=commentStack[i];lastCommentWS.start===node.end&&(lastCommentWS.leadingNode=node,i--);const{start:nodeStart}=node;for(;i>=0;i--){const commentWS=commentStack[i],commentEnd=commentWS.end;if(!(commentEnd>nodeStart)){commentEnd===nodeStart&&(commentWS.trailingNode=node);break}commentWS.containingNode=node,this.finalizeComment(commentWS),commentStack.splice(i,1);}}finalizeComment(commentWS){const{comments}=commentWS;if(null!==commentWS.leadingNode||null!==commentWS.trailingNode)null!==commentWS.leadingNode&&setTrailingComments(commentWS.leadingNode,comments),null!==commentWS.trailingNode&&function(node,comments){void 0===node.leadingComments?node.leadingComments=comments:node.leadingComments.unshift(...comments);}(commentWS.trailingNode,comments);else {const{containingNode:node,start:commentStart}=commentWS;if(44===this.input.charCodeAt(commentStart-1))switch(node.type){case"ObjectExpression":case"ObjectPattern":case"RecordExpression":adjustInnerComments(node,node.properties,commentWS);break;case"CallExpression":case"OptionalCallExpression":adjustInnerComments(node,node.arguments,commentWS);break;case"FunctionDeclaration":case"FunctionExpression":case"ArrowFunctionExpression":case"ObjectMethod":case"ClassMethod":case"ClassPrivateMethod":adjustInnerComments(node,node.params,commentWS);break;case"ArrayExpression":case"ArrayPattern":case"TupleExpression":adjustInnerComments(node,node.elements,commentWS);break;case"ExportNamedDeclaration":case"ImportDeclaration":adjustInnerComments(node,node.specifiers,commentWS);break;default:setInnerComments(node,comments);}else setInnerComments(node,comments);}}finalizeRemainingComments(){const{commentStack}=this.state;for(let i=commentStack.length-1;i>=0;i--)this.finalizeComment(commentStack[i]);this.state.commentStack=[];}resetPreviousNodeTrailingComments(node){const{commentStack}=this.state,{length}=commentStack;if(0===length)return;const commentWS=commentStack[length-1];commentWS.leadingNode===node&&(commentWS.leadingNode=null);}takeSurroundingComments(node,start,end){const{commentStack}=this.state,commentStackLength=commentStack.length;if(0===commentStackLength)return;let i=commentStackLength-1;for(;i>=0;i--){const commentWS=commentStack[i],commentEnd=commentWS.end;if(commentWS.start===end)commentWS.leadingNode=node;else if(commentEnd===start)commentWS.trailingNode=node;else if(commentEnd<start)break}}}{raise({code,reasonCode,template},origin,...params){return this.raiseWithData(origin.node?origin.node.loc.start:origin.at,{code,reasonCode},template,...params)}raiseOverwrite(loc,{code,template},...params){const pos=indexes.get(loc),message=template.replace(/%(\d+)/g,((_,i)=>params[i]))+` (${loc.line}:${loc.column})`;if(this.options.errorRecovery){const errors=this.state.errors;for(let i=errors.length-1;i>=0;i--){const error=errors[i];if(error.pos===pos)return Object.assign(error,{message});if(error.pos<pos)break}}return this._raise({code,loc,pos},message)}raiseWithData(loc,data,errorTemplate,...params){const pos=indexes.get(loc),message=errorTemplate.replace(/%(\d+)/g,((_,i)=>params[i]))+` (${loc.line}:${loc.column})`;return this._raise(Object.assign({loc,pos},data),message)}_raise(errorContext,message){const err=new SyntaxError(message);if(Object.assign(err,errorContext),this.options.errorRecovery)return this.isLookahead||this.state.errors.push(err),err;throw err}}{constructor(options,input){super(),this.isLookahead=void 0,this.tokens=[],this.state=new State,this.state.init(options),this.input=input,this.length=input.length,this.isLookahead=!1;}pushToken(token){this.tokens.length=this.state.tokensLength,this.tokens.push(token),++this.state.tokensLength;}next(){this.checkKeywordEscapes(),this.options.tokens&&this.pushToken(new Token(this.state)),this.state.lastTokStart=this.state.start,this.state.lastTokEndLoc=this.state.endLoc,this.state.lastTokStartLoc=this.state.startLoc,this.nextToken();}eat(type){return !!this.match(type)&&(this.next(),!0)}match(type){return this.state.type===type}createLookaheadState(state){return {pos:state.pos,value:null,type:state.type,start:state.start,end:state.end,context:[this.curContext()],inType:state.inType,startLoc:state.startLoc,lastTokEndLoc:state.lastTokEndLoc,curLine:state.curLine,lineStart:state.lineStart,curPosition:state.curPosition}}lookahead(){const old=this.state;this.state=this.createLookaheadState(old),this.isLookahead=!0,this.nextToken(),this.isLookahead=!1;const curr=this.state;return this.state=old,curr}nextTokenStart(){return this.nextTokenStartSince(this.state.pos)}nextTokenStartSince(pos){return skipWhiteSpace.lastIndex=pos,skipWhiteSpace.test(this.input)?skipWhiteSpace.lastIndex:pos}lookaheadCharCode(){return this.input.charCodeAt(this.nextTokenStart())}codePointAtPos(pos){let cp=this.input.charCodeAt(pos);if(55296==(64512&cp)&&++pos<this.input.length){const trail=this.input.charCodeAt(pos);56320==(64512&trail)&&(cp=65536+((1023&cp)<<10)+(1023&trail));}return cp}setStrict(strict){this.state.strict=strict,strict&&(this.state.strictErrors.forEach((({message,loc})=>this.raise(message,{at:loc}))),this.state.strictErrors.clear());}curContext(){return this.state.context[this.state.context.length-1]}nextToken(){this.skipSpace(),this.state.start=this.state.pos,this.isLookahead||(this.state.startLoc=this.state.curPosition()),this.state.pos>=this.length?this.finishToken(131):this.getTokenFromCode(this.codePointAtPos(this.state.pos));}skipBlockComment(){let startLoc;this.isLookahead||(startLoc=this.state.curPosition());const start=this.state.pos,end=this.input.indexOf("*/",start+2);if(-1===end)throw this.raise(ErrorMessages.UnterminatedComment,{at:this.state.curPosition()});for(this.state.pos=end+2,lineBreakG.lastIndex=start+2;lineBreakG.test(this.input)&&lineBreakG.lastIndex<=end;)++this.state.curLine,this.state.lineStart=lineBreakG.lastIndex;if(this.isLookahead)return;const comment={type:"CommentBlock",value:this.input.slice(start+2,end),start,end:end+2,loc:new SourceLocation(startLoc,this.state.curPosition())};return this.options.tokens&&this.pushToken(comment),comment}skipLineComment(startSkip){const start=this.state.pos;let startLoc;this.isLookahead||(startLoc=this.state.curPosition());let ch=this.input.charCodeAt(this.state.pos+=startSkip);if(this.state.pos<this.length)for(;!isNewLine(ch)&&++this.state.pos<this.length;)ch=this.input.charCodeAt(this.state.pos);if(this.isLookahead)return;const end=this.state.pos,comment={type:"CommentLine",value:this.input.slice(start+startSkip,end),start,end,loc:new SourceLocation(startLoc,this.state.curPosition())};return this.options.tokens&&this.pushToken(comment),comment}skipSpace(){const spaceStart=this.state.pos,comments=[];loop:for(;this.state.pos<this.length;){const ch=this.input.charCodeAt(this.state.pos);switch(ch){case 32:case 160:case 9:++this.state.pos;break;case 13:10===this.input.charCodeAt(this.state.pos+1)&&++this.state.pos;case 10:case 8232:case 8233:++this.state.pos,++this.state.curLine,this.state.lineStart=this.state.pos;break;case 47:switch(this.input.charCodeAt(this.state.pos+1)){case 42:{const comment=this.skipBlockComment();void 0!==comment&&(this.addComment(comment),this.options.attachComment&&comments.push(comment));break}case 47:{const comment=this.skipLineComment(2);void 0!==comment&&(this.addComment(comment),this.options.attachComment&&comments.push(comment));break}default:break loop}break;default:if(isWhitespace(ch))++this.state.pos;else if(45!==ch||this.inModule){if(60!==ch||this.inModule)break loop;{const pos=this.state.pos;if(33!==this.input.charCodeAt(pos+1)||45!==this.input.charCodeAt(pos+2)||45!==this.input.charCodeAt(pos+3))break loop;{const comment=this.skipLineComment(4);void 0!==comment&&(this.addComment(comment),this.options.attachComment&&comments.push(comment));}}}else {const pos=this.state.pos;if(45!==this.input.charCodeAt(pos+1)||62!==this.input.charCodeAt(pos+2)||!(0===spaceStart||this.state.lineStart>spaceStart))break loop;{const comment=this.skipLineComment(3);void 0!==comment&&(this.addComment(comment),this.options.attachComment&&comments.push(comment));}}}}if(comments.length>0){const CommentWhitespace={start:spaceStart,end:this.state.pos,comments,leadingNode:null,trailingNode:null,containingNode:null};this.state.commentStack.push(CommentWhitespace);}}finishToken(type,val){this.state.end=this.state.pos,this.state.endLoc=this.state.curPosition();const prevType=this.state.type;this.state.type=type,this.state.value=val,this.isLookahead||this.updateContext(prevType);}replaceToken(type){this.state.type=type,this.updateContext();}readToken_numberSign(){if(0===this.state.pos&&this.readToken_interpreter())return;const nextPos=this.state.pos+1,next=this.codePointAtPos(nextPos);if(next>=48&&next<=57)throw this.raise(ErrorMessages.UnexpectedDigitAfterHash,{at:this.state.curPosition()});if(123===next||91===next&&this.hasPlugin("recordAndTuple")){if(this.expectPlugin("recordAndTuple"),"hash"!==this.getPluginOption("recordAndTuple","syntaxType"))throw this.raise(123===next?ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType:ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType,{at:this.state.curPosition()});this.state.pos+=2,123===next?this.finishToken(7):this.finishToken(1);}else isIdentifierStart(next)?(++this.state.pos,this.finishToken(130,this.readWord1(next))):92===next?(++this.state.pos,this.finishToken(130,this.readWord1())):this.finishOp(27,1);}readToken_dot(){const next=this.input.charCodeAt(this.state.pos+1);next>=48&&next<=57?this.readNumber(!0):46===next&&46===this.input.charCodeAt(this.state.pos+2)?(this.state.pos+=3,this.finishToken(21)):(++this.state.pos,this.finishToken(16));}readToken_slash(){61===this.input.charCodeAt(this.state.pos+1)?this.finishOp(31,2):this.finishOp(52,1);}readToken_interpreter(){if(0!==this.state.pos||this.length<2)return !1;let ch=this.input.charCodeAt(this.state.pos+1);if(33!==ch)return !1;const start=this.state.pos;for(this.state.pos+=1;!isNewLine(ch)&&++this.state.pos<this.length;)ch=this.input.charCodeAt(this.state.pos);const value=this.input.slice(start+2,this.state.pos);return this.finishToken(28,value),!0}readToken_mult_modulo(code){let type=42===code?51:50,width=1,next=this.input.charCodeAt(this.state.pos+1);42===code&&42===next&&(width++,next=this.input.charCodeAt(this.state.pos+2),type=53),61!==next||this.state.inType||(width++,type=37===code?33:30),this.finishOp(type,width);}readToken_pipe_amp(code){const next=this.input.charCodeAt(this.state.pos+1);if(next!==code){if(124===code){if(62===next)return void this.finishOp(37,2);if(this.hasPlugin("recordAndTuple")&&125===next){if("bar"!==this.getPluginOption("recordAndTuple","syntaxType"))throw this.raise(ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType,{at:this.state.curPosition()});return this.state.pos+=2,void this.finishToken(9)}if(this.hasPlugin("recordAndTuple")&&93===next){if("bar"!==this.getPluginOption("recordAndTuple","syntaxType"))throw this.raise(ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType,{at:this.state.curPosition()});return this.state.pos+=2,void this.finishToken(4)}}61!==next?this.finishOp(124===code?41:43,1):this.finishOp(30,2);}else 61===this.input.charCodeAt(this.state.pos+2)?this.finishOp(30,3):this.finishOp(124===code?39:40,2);}readToken_caret(){61!==this.input.charCodeAt(this.state.pos+1)||this.state.inType?this.finishOp(42,1):this.finishOp(32,2);}readToken_plus_min(code){const next=this.input.charCodeAt(this.state.pos+1);next!==code?61===next?this.finishOp(30,2):this.finishOp(49,1):this.finishOp(34,2);}readToken_lt(){const{pos}=this.state,next=this.input.charCodeAt(pos+1);if(60===next)return 61===this.input.charCodeAt(pos+2)?void this.finishOp(30,3):void this.finishOp(48,2);61!==next?this.finishOp(45,1):this.finishOp(47,2);}readToken_gt(){const{pos}=this.state,next=this.input.charCodeAt(pos+1);if(62===next){const size=62===this.input.charCodeAt(pos+2)?3:2;return 61===this.input.charCodeAt(pos+size)?void this.finishOp(30,size+1):void this.finishOp(48,size)}61!==next?this.finishOp(46,1):this.finishOp(47,2);}readToken_eq_excl(code){const next=this.input.charCodeAt(this.state.pos+1);if(61!==next)return 61===code&&62===next?(this.state.pos+=2,void this.finishToken(19)):void this.finishOp(61===code?29:35,1);this.finishOp(44,61===this.input.charCodeAt(this.state.pos+2)?3:2);}readToken_question(){const next=this.input.charCodeAt(this.state.pos+1),next2=this.input.charCodeAt(this.state.pos+2);63===next?61===next2?this.finishOp(30,3):this.finishOp(38,2):46!==next||next2>=48&&next2<=57?(++this.state.pos,this.finishToken(17)):(this.state.pos+=2,this.finishToken(18));}getTokenFromCode(code){switch(code){case 46:return void this.readToken_dot();case 40:return ++this.state.pos,void this.finishToken(10);case 41:return ++this.state.pos,void this.finishToken(11);case 59:return ++this.state.pos,void this.finishToken(13);case 44:return ++this.state.pos,void this.finishToken(12);case 91:if(this.hasPlugin("recordAndTuple")&&124===this.input.charCodeAt(this.state.pos+1)){if("bar"!==this.getPluginOption("recordAndTuple","syntaxType"))throw this.raise(ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType,{at:this.state.curPosition()});this.state.pos+=2,this.finishToken(2);}else ++this.state.pos,this.finishToken(0);return;case 93:return ++this.state.pos,void this.finishToken(3);case 123:if(this.hasPlugin("recordAndTuple")&&124===this.input.charCodeAt(this.state.pos+1)){if("bar"!==this.getPluginOption("recordAndTuple","syntaxType"))throw this.raise(ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType,{at:this.state.curPosition()});this.state.pos+=2,this.finishToken(6);}else ++this.state.pos,this.finishToken(5);return;case 125:return ++this.state.pos,void this.finishToken(8);case 58:return void(this.hasPlugin("functionBind")&&58===this.input.charCodeAt(this.state.pos+1)?this.finishOp(15,2):(++this.state.pos,this.finishToken(14)));case 63:return void this.readToken_question();case 96:return void this.readTemplateToken();case 48:{const next=this.input.charCodeAt(this.state.pos+1);if(120===next||88===next)return void this.readRadixNumber(16);if(111===next||79===next)return void this.readRadixNumber(8);if(98===next||66===next)return void this.readRadixNumber(2)}case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return void this.readNumber(!1);case 34:case 39:return void this.readString(code);case 47:return void this.readToken_slash();case 37:case 42:return void this.readToken_mult_modulo(code);case 124:case 38:return void this.readToken_pipe_amp(code);case 94:return void this.readToken_caret();case 43:case 45:return void this.readToken_plus_min(code);case 60:return void this.readToken_lt();case 62:return void this.readToken_gt();case 61:case 33:return void this.readToken_eq_excl(code);case 126:return void this.finishOp(36,1);case 64:return ++this.state.pos,void this.finishToken(26);case 35:return void this.readToken_numberSign();case 92:return void this.readWord();default:if(isIdentifierStart(code))return void this.readWord(code)}throw this.raise(ErrorMessages.InvalidOrUnexpectedToken,{at:this.state.curPosition()},String.fromCodePoint(code))}finishOp(type,size){const str=this.input.slice(this.state.pos,this.state.pos+size);this.state.pos+=size,this.finishToken(type,str);}readRegexp(){const startLoc=this.state.startLoc,start=this.state.start+1;let escaped,inClass,{pos}=this.state;for(;;++pos){if(pos>=this.length)throw this.raise(ErrorMessages.UnterminatedRegExp,{at:createPositionWithColumnOffset(startLoc,1)});const ch=this.input.charCodeAt(pos);if(isNewLine(ch))throw this.raise(ErrorMessages.UnterminatedRegExp,{at:createPositionWithColumnOffset(startLoc,1)});if(escaped)escaped=!1;else {if(91===ch)inClass=!0;else if(93===ch&&inClass)inClass=!1;else if(47===ch&&!inClass)break;escaped=92===ch;}}const content=this.input.slice(start,pos);++pos;let mods="";for(;pos<this.length;){const cp=this.codePointAtPos(pos),char=String.fromCharCode(cp);if(VALID_REGEX_FLAGS.has(cp))mods.includes(char)&&this.raise(ErrorMessages.DuplicateRegExpFlags,{at:createPositionWithColumnOffset(startLoc,pos+2-start)});else {if(!isIdentifierChar(cp)&&92!==cp)break;this.raise(ErrorMessages.MalformedRegExpFlags,{at:createPositionWithColumnOffset(startLoc,pos+2-start)});}++pos,mods+=char;}this.state.pos=pos,this.finishToken(129,{pattern:content,flags:mods});}readInt(radix,len,forceLen,allowNumSeparator=!0){const start=this.state.pos,forbiddenSiblings=16===radix?forbiddenNumericSeparatorSiblings.hex:forbiddenNumericSeparatorSiblings.decBinOct,allowedSiblings=16===radix?allowedNumericSeparatorSiblings.hex:10===radix?allowedNumericSeparatorSiblings.dec:8===radix?allowedNumericSeparatorSiblings.oct:allowedNumericSeparatorSiblings.bin;let invalid=!1,total=0;for(let i=0,e=null==len?1/0:len;i<e;++i){const code=this.input.charCodeAt(this.state.pos);let val;if(95!==code){if(val=code>=97?code-97+10:code>=65?code-65+10:_isDigit(code)?code-48:1/0,val>=radix)if(this.options.errorRecovery&&val<=9)val=0,this.raise(ErrorMessages.InvalidDigit,{at:this.state.curPosition()},radix);else {if(!forceLen)break;val=0,invalid=!0;}++this.state.pos,total=total*radix+val;}else {const prev=this.input.charCodeAt(this.state.pos-1),next=this.input.charCodeAt(this.state.pos+1);(-1===allowedSiblings.indexOf(next)||forbiddenSiblings.indexOf(prev)>-1||forbiddenSiblings.indexOf(next)>-1||Number.isNaN(next))&&this.raise(ErrorMessages.UnexpectedNumericSeparator,{at:this.state.curPosition()}),allowNumSeparator||this.raise(ErrorMessages.NumericSeparatorInEscapeSequence,{at:this.state.curPosition()}),++this.state.pos;}}return this.state.pos===start||null!=len&&this.state.pos-start!==len||invalid?null:total}readRadixNumber(radix){const startLoc=this.state.curPosition();let isBigInt=!1;this.state.pos+=2;const val=this.readInt(radix);null==val&&this.raise(ErrorMessages.InvalidDigit,{at:createPositionWithColumnOffset(startLoc,2)},radix);const next=this.input.charCodeAt(this.state.pos);if(110===next)++this.state.pos,isBigInt=!0;else if(109===next)throw this.raise(ErrorMessages.InvalidDecimal,{at:startLoc});if(isIdentifierStart(this.codePointAtPos(this.state.pos)))throw this.raise(ErrorMessages.NumberIdentifier,{at:this.state.curPosition()});if(isBigInt){const str=this.input.slice(indexes.get(startLoc),this.state.pos).replace(/[_n]/g,"");this.finishToken(127,str);}else this.finishToken(126,val);}readNumber(startsWithDot){const start=this.state.pos,startLoc=this.state.curPosition();let isFloat=!1,isBigInt=!1,isDecimal=!1,hasExponent=!1,isOctal=!1;startsWithDot||null!==this.readInt(10)||this.raise(ErrorMessages.InvalidNumber,{at:this.state.curPosition()});const hasLeadingZero=this.state.pos-start>=2&&48===this.input.charCodeAt(start);if(hasLeadingZero){const integer=this.input.slice(start,this.state.pos);if(this.recordStrictModeErrors(ErrorMessages.StrictOctalLiteral,startLoc),!this.state.strict){const underscorePos=integer.indexOf("_");underscorePos>0&&this.raise(ErrorMessages.ZeroDigitNumericSeparator,{at:createPositionWithColumnOffset(startLoc,underscorePos)});}isOctal=hasLeadingZero&&!/[89]/.test(integer);}let next=this.input.charCodeAt(this.state.pos);if(46!==next||isOctal||(++this.state.pos,this.readInt(10),isFloat=!0,next=this.input.charCodeAt(this.state.pos)),69!==next&&101!==next||isOctal||(next=this.input.charCodeAt(++this.state.pos),43!==next&&45!==next||++this.state.pos,null===this.readInt(10)&&this.raise(ErrorMessages.InvalidOrMissingExponent,{at:startLoc}),isFloat=!0,hasExponent=!0,next=this.input.charCodeAt(this.state.pos)),110===next&&((isFloat||hasLeadingZero)&&this.raise(ErrorMessages.InvalidBigIntLiteral,{at:startLoc}),++this.state.pos,isBigInt=!0),109===next&&(this.expectPlugin("decimal",this.state.curPosition()),(hasExponent||hasLeadingZero)&&this.raise(ErrorMessages.InvalidDecimal,{at:startLoc}),++this.state.pos,isDecimal=!0),isIdentifierStart(this.codePointAtPos(this.state.pos)))throw this.raise(ErrorMessages.NumberIdentifier,{at:this.state.curPosition()});const str=this.input.slice(start,this.state.pos).replace(/[_mn]/g,"");if(isBigInt)return void this.finishToken(127,str);if(isDecimal)return void this.finishToken(128,str);const val=isOctal?parseInt(str,8):parseFloat(str);this.finishToken(126,val);}readCodePoint(throwOnInvalid){let code;if(123===this.input.charCodeAt(this.state.pos)){if(++this.state.pos,code=this.readHexChar(this.input.indexOf("}",this.state.pos)-this.state.pos,!0,throwOnInvalid),++this.state.pos,null!==code&&code>1114111){if(!throwOnInvalid)return null;this.raise(ErrorMessages.InvalidCodePoint,{at:this.state.curPosition()});}}else code=this.readHexChar(4,!1,throwOnInvalid);return code}readString(quote){let out="",chunkStart=++this.state.pos;for(;;){if(this.state.pos>=this.length)throw this.raise(ErrorMessages.UnterminatedString,{at:this.state.startLoc});const ch=this.input.charCodeAt(this.state.pos);if(ch===quote)break;if(92===ch)out+=this.input.slice(chunkStart,this.state.pos),out+=this.readEscapedChar(!1),chunkStart=this.state.pos;else if(8232===ch||8233===ch)++this.state.pos,++this.state.curLine,this.state.lineStart=this.state.pos;else {if(isNewLine(ch))throw this.raise(ErrorMessages.UnterminatedString,{at:this.state.startLoc});++this.state.pos;}}out+=this.input.slice(chunkStart,this.state.pos++),this.finishToken(125,out);}readTemplateContinuation(){this.match(8)||this.unexpected(null,8),this.state.pos--,this.readTemplateToken();}readTemplateToken(){let out="",chunkStart=this.state.pos,containsInvalid=!1;for(++this.state.pos;;){if(this.state.pos>=this.length)throw this.raise(ErrorMessages.UnterminatedTemplate,{at:createPositionWithColumnOffset(this.state.startLoc,1)});const ch=this.input.charCodeAt(this.state.pos);if(96===ch)return ++this.state.pos,out+=this.input.slice(chunkStart,this.state.pos),void this.finishToken(24,containsInvalid?null:out);if(36===ch&&123===this.input.charCodeAt(this.state.pos+1))return this.state.pos+=2,out+=this.input.slice(chunkStart,this.state.pos),void this.finishToken(25,containsInvalid?null:out);if(92===ch){out+=this.input.slice(chunkStart,this.state.pos);const escaped=this.readEscapedChar(!0);null===escaped?containsInvalid=!0:out+=escaped,chunkStart=this.state.pos;}else if(isNewLine(ch)){switch(out+=this.input.slice(chunkStart,this.state.pos),++this.state.pos,ch){case 13:10===this.input.charCodeAt(this.state.pos)&&++this.state.pos;case 10:out+="\n";break;default:out+=String.fromCharCode(ch);}++this.state.curLine,this.state.lineStart=this.state.pos,chunkStart=this.state.pos;}else ++this.state.pos;}}recordStrictModeErrors(message,loc){const index=indexes.get(loc);this.state.strict&&!this.state.strictErrors.has(index)?this.raise(message,{at:loc}):this.state.strictErrors.set(index,{loc,message});}readEscapedChar(inTemplate){const throwOnInvalid=!inTemplate,ch=this.input.charCodeAt(++this.state.pos);switch(++this.state.pos,ch){case 110:return "\n";case 114:return "\r";case 120:{const code=this.readHexChar(2,!1,throwOnInvalid);return null===code?null:String.fromCharCode(code)}case 117:{const code=this.readCodePoint(throwOnInvalid);return null===code?null:String.fromCodePoint(code)}case 116:return "\t";case 98:return "\b";case 118:return "\v";case 102:return "\f";case 13:10===this.input.charCodeAt(this.state.pos)&&++this.state.pos;case 10:this.state.lineStart=this.state.pos,++this.state.curLine;case 8232:case 8233:return "";case 56:case 57:if(inTemplate)return null;this.recordStrictModeErrors(ErrorMessages.StrictNumericEscape,createPositionWithColumnOffset(this.state.curPosition(),-1));default:if(ch>=48&&ch<=55){const codePos=createPositionWithColumnOffset(this.state.curPosition(),-1);let octalStr=this.input.substr(this.state.pos-1,3).match(/^[0-7]+/)[0],octal=parseInt(octalStr,8);octal>255&&(octalStr=octalStr.slice(0,-1),octal=parseInt(octalStr,8)),this.state.pos+=octalStr.length-1;const next=this.input.charCodeAt(this.state.pos);if("0"!==octalStr||56===next||57===next){if(inTemplate)return null;this.recordStrictModeErrors(ErrorMessages.StrictNumericEscape,codePos);}return String.fromCharCode(octal)}return String.fromCharCode(ch)}}readHexChar(len,forceLen,throwOnInvalid){const codeLoc=this.state.curPosition(),n=this.readInt(16,len,forceLen,!1);return null===n&&(throwOnInvalid?this.raise(ErrorMessages.InvalidEscapeSequence,{at:codeLoc}):this.state.pos=indexes.get(codeLoc)-1),n}readWord1(firstCode){this.state.containsEsc=!1;let word="";const start=this.state.pos;let chunkStart=this.state.pos;for(void 0!==firstCode&&(this.state.pos+=firstCode<=65535?1:2);this.state.pos<this.length;){const ch=this.codePointAtPos(this.state.pos);if(isIdentifierChar(ch))this.state.pos+=ch<=65535?1:2;else {if(92!==ch)break;{this.state.containsEsc=!0,word+=this.input.slice(chunkStart,this.state.pos);const escStart=this.state.curPosition(),identifierCheck=this.state.pos===start?isIdentifierStart:isIdentifierChar;if(117!==this.input.charCodeAt(++this.state.pos)){this.raise(ErrorMessages.MissingUnicodeEscape,{at:this.state.curPosition()}),chunkStart=this.state.pos-1;continue}++this.state.pos;const esc=this.readCodePoint(!0);null!==esc&&(identifierCheck(esc)||this.raise(ErrorMessages.EscapedCharNotAnIdentifier,{at:escStart}),word+=String.fromCodePoint(esc)),chunkStart=this.state.pos;}}}return word+this.input.slice(chunkStart,this.state.pos)}readWord(firstCode){const word=this.readWord1(firstCode),type=keywords$1.get(word);void 0!==type?this.finishToken(type,tokenLabelName(type)):this.finishToken(124,word);}checkKeywordEscapes(){const{type}=this.state;tokenIsKeyword(type)&&this.state.containsEsc&&this.raise(ErrorMessages.InvalidEscapedReservedWord,{at:this.state.startLoc},tokenLabelName(type));}updateContext(prevType){}}{addExtra(node,key,value,enumerable=!0){if(!node)return;const extra=node.extra=node.extra||{};enumerable?extra[key]=value:Object.defineProperty(extra,key,{enumerable,value});}isContextual(token){return this.state.type===token&&!this.state.containsEsc}isUnparsedContextual(nameStart,name){const nameEnd=nameStart+name.length;if(this.input.slice(nameStart,nameEnd)===name){const nextCh=this.input.charCodeAt(nameEnd);return !(isIdentifierChar(nextCh)||55296==(64512&nextCh))}return !1}isLookaheadContextual(name){const next=this.nextTokenStart();return this.isUnparsedContextual(next,name)}eatContextual(token){return !!this.isContextual(token)&&(this.next(),!0)}expectContextual(token,template){if(!this.eatContextual(token)){if(null!=template)throw this.raise(template,{at:this.state.startLoc});throw this.unexpected(null,token)}}canInsertSemicolon(){return this.match(131)||this.match(8)||this.hasPrecedingLineBreak()}hasPrecedingLineBreak(){return lineBreak.test(this.input.slice(indexes.get(this.state.lastTokEndLoc),this.state.start))}hasFollowingLineBreak(){return skipWhiteSpaceToLineBreak.lastIndex=this.state.end,skipWhiteSpaceToLineBreak.test(this.input)}isLineTerminator(){return this.eat(13)||this.canInsertSemicolon()}semicolon(allowAsi=!0){(allowAsi?this.isLineTerminator():this.eat(13))||this.raise(ErrorMessages.MissingSemicolon,{at:this.state.lastTokEndLoc});}expect(type,loc){this.eat(type)||this.unexpected(loc,type);}assertNoSpace(message="Unexpected space."){this.state.start>indexes.get(this.state.lastTokEndLoc)&&this.raise({code:ErrorCodes.SyntaxError,reasonCode:"UnexpectedSpace",template:message},{at:this.state.lastTokEndLoc});}unexpected(loc,type){throw this.raise({code:ErrorCodes.SyntaxError,reasonCode:"UnexpectedToken",template:null!=type?`Unexpected token, expected "${tokenLabelName(type)}"`:"Unexpected token"},{at:null!=loc?loc:this.state.startLoc})}getPluginNamesFromConfigs(pluginConfigs){return pluginConfigs.map((c=>"string"==typeof c?c:c[0]))}expectPlugin(pluginConfig,loc){if(!this.hasPlugin(pluginConfig))throw this.raiseWithData(null!=loc?loc:this.state.startLoc,{missingPlugin:this.getPluginNamesFromConfigs([pluginConfig])},`This experimental syntax requires enabling the parser plugin: ${JSON.stringify(pluginConfig)}.`);return !0}expectOnePlugin(pluginConfigs){if(!pluginConfigs.some((c=>this.hasPlugin(c))))throw this.raiseWithData(this.state.startLoc,{missingPlugin:this.getPluginNamesFromConfigs(pluginConfigs)},`This experimental syntax requires enabling one of the following parser plugin(s): ${pluginConfigs.map((c=>JSON.stringify(c))).join(", ")}.`)}tryParse(fn,oldState=this.state.clone()){const abortSignal={node:null};try{const node=fn(((node=null)=>{throw abortSignal.node=node,abortSignal}));if(this.state.errors.length>oldState.errors.length){const failState=this.state;return this.state=oldState,this.state.tokensLength=failState.tokensLength,{node,error:failState.errors[oldState.errors.length],thrown:!1,aborted:!1,failState}}return {node,error:null,thrown:!1,aborted:!1,failState:null}}catch(error){const failState=this.state;if(this.state=oldState,error instanceof SyntaxError)return {node:null,error,thrown:!0,aborted:!1,failState};if(error===abortSignal)return {node:abortSignal.node,error:null,thrown:!1,aborted:!0,failState};throw error}}checkExpressionErrors(refExpressionErrors,andThrow){if(!refExpressionErrors)return !1;const{shorthandAssignLoc,doubleProtoLoc,optionalParametersLoc}=refExpressionErrors;if(!andThrow)return !!shorthandAssignLoc||!!doubleProtoLoc||!!optionalParametersLoc;null!=shorthandAssignLoc&&this.raise(ErrorMessages.InvalidCoverInitializedName,{at:shorthandAssignLoc}),null!=doubleProtoLoc&&this.raise(ErrorMessages.DuplicateProto,{at:doubleProtoLoc}),null!=optionalParametersLoc&&this.unexpected(optionalParametersLoc);}isLiteralPropertyName(){return tokenIsLiteralPropertyName(this.state.type)}isPrivateName(node){return "PrivateName"===node.type}getPrivateNameSV(node){return node.id.name}hasPropertyAsPrivateName(node){return ("MemberExpression"===node.type||"OptionalMemberExpression"===node.type)&&this.isPrivateName(node.property)}isOptionalChain(node){return "OptionalMemberExpression"===node.type||"OptionalCallExpression"===node.type}isObjectProperty(node){return "ObjectProperty"===node.type}isObjectMethod(node){return "ObjectMethod"===node.type}initializeScopes(inModule="module"===this.options.sourceType){const oldLabels=this.state.labels;this.state.labels=[];const oldExportedIdentifiers=this.exportedIdentifiers;this.exportedIdentifiers=new Set;const oldInModule=this.inModule;this.inModule=inModule;const oldScope=this.scope,ScopeHandler=this.getScopeHandler();this.scope=new ScopeHandler(this.raise.bind(this),this.inModule);const oldProdParam=this.prodParam;this.prodParam=new ProductionParameterHandler;const oldClassScope=this.classScope;this.classScope=new ClassScopeHandler(this.raise.bind(this));const oldExpressionScope=this.expressionScope;return this.expressionScope=new ExpressionScopeHandler(this.raise.bind(this)),()=>{this.state.labels=oldLabels,this.exportedIdentifiers=oldExportedIdentifiers,this.inModule=oldInModule,this.scope=oldScope,this.prodParam=oldProdParam,this.classScope=oldClassScope,this.expressionScope=oldExpressionScope;}}enterInitialScopes(){let paramFlags=0;this.inModule&&(paramFlags|=2),this.scope.enter(1),this.prodParam.enter(paramFlags);}}{startNode(){return new Node(this,this.state.start,this.state.startLoc)}startNodeAt(pos,loc){return new Node(this,pos,loc)}startNodeAtNode(type){return this.startNodeAt(type.start,type.loc.start)}finishNode(node,type){return this.finishNodeAt(node,type,this.state.lastTokEndLoc)}finishNodeAt(node,type,endLoc){return node.type=type,node.end=indexes.get(endLoc),node.loc.end=endLoc,this.options.ranges&&(node.range[1]=node.end),this.options.attachComment&&this.processComment(node),node}resetStartLocation(node,start,startLoc){node.start=start,node.loc.start=startLoc,this.options.ranges&&(node.range[0]=start);}resetEndLocation(node,endLoc=this.state.lastTokEndLoc){node.end=indexes.get(endLoc),node.loc.end=endLoc,this.options.ranges&&(node.range[1]=node.end);}resetStartLocationFromNode(node,locationNode){this.resetStartLocation(node,locationNode.start,locationNode.loc.start);}}{toAssignable(node,isLHS=!1){var _node$extra,_node$extra3;let parenthesized;switch(("ParenthesizedExpression"===node.type||null!=(_node$extra=node.extra)&&_node$extra.parenthesized)&&(parenthesized=unwrapParenthesizedExpression(node),isLHS?"Identifier"===parenthesized.type?this.expressionScope.recordParenthesizedIdentifierError(ErrorMessages.InvalidParenthesizedAssignment,node.loc.start):"MemberExpression"!==parenthesized.type&&this.raise(ErrorMessages.InvalidParenthesizedAssignment,{node}):this.raise(ErrorMessages.InvalidParenthesizedAssignment,{node})),node.type){case"Identifier":case"ObjectPattern":case"ArrayPattern":case"AssignmentPattern":case"RestElement":break;case"ObjectExpression":node.type="ObjectPattern";for(let i=0,length=node.properties.length,last=length-1;i<length;i++){var _node$extra2;const prop=node.properties[i],isLast=i===last;this.toAssignableObjectExpressionProp(prop,isLast,isLHS),isLast&&"RestElement"===prop.type&&null!=(_node$extra2=node.extra)&&_node$extra2.trailingCommaLoc&&this.raise(ErrorMessages.RestTrailingComma,{at:node.extra.trailingCommaLoc});}break;case"ObjectProperty":this.toAssignable(node.value,isLHS);break;case"SpreadElement":{this.checkToRestConversion(node),node.type="RestElement";const arg=node.argument;this.toAssignable(arg,isLHS);break}case"ArrayExpression":node.type="ArrayPattern",this.toAssignableList(node.elements,null==(_node$extra3=node.extra)?void 0:_node$extra3.trailingCommaLoc,isLHS);break;case"AssignmentExpression":"="!==node.operator&&this.raise(ErrorMessages.MissingEqInAssignment,{at:node.left.loc.end}),node.type="AssignmentPattern",delete node.operator,this.toAssignable(node.left,isLHS);break;case"ParenthesizedExpression":this.toAssignable(parenthesized,isLHS);}return node}toAssignableObjectExpressionProp(prop,isLast,isLHS){"ObjectMethod"===prop.type?this.raise("get"===prop.kind||"set"===prop.kind?ErrorMessages.PatternHasAccessor:ErrorMessages.PatternHasMethod,{node:prop.key}):"SpreadElement"!==prop.type||isLast?this.toAssignable(prop,isLHS):this.raise(ErrorMessages.RestTrailingComma,{node:prop});}toAssignableList(exprList,trailingCommaLoc,isLHS){let end=exprList.length;if(end){const last=exprList[end-1];if("RestElement"===(null==last?void 0:last.type))--end;else if("SpreadElement"===(null==last?void 0:last.type)){last.type="RestElement";let arg=last.argument;this.toAssignable(arg,isLHS),arg=unwrapParenthesizedExpression(arg),"Identifier"!==arg.type&&"MemberExpression"!==arg.type&&"ArrayPattern"!==arg.type&&"ObjectPattern"!==arg.type&&this.unexpected(arg.start),trailingCommaLoc&&this.raise(ErrorMessages.RestTrailingComma,{at:trailingCommaLoc}),--end;}}for(let i=0;i<end;i++){const elt=exprList[i];elt&&(this.toAssignable(elt,isLHS),"RestElement"===elt.type&&this.raise(ErrorMessages.RestTrailingComma,{node:elt}));}return exprList}isAssignable(node,isBinding){switch(node.type){case"Identifier":case"ObjectPattern":case"ArrayPattern":case"AssignmentPattern":case"RestElement":return !0;case"ObjectExpression":{const last=node.properties.length-1;return node.properties.every(((prop,i)=>"ObjectMethod"!==prop.type&&(i===last||"SpreadElement"!==prop.type)&&this.isAssignable(prop)))}case"ObjectProperty":return this.isAssignable(node.value);case"SpreadElement":return this.isAssignable(node.argument);case"ArrayExpression":return node.elements.every((element=>null===element||this.isAssignable(element)));case"AssignmentExpression":return "="===node.operator;case"ParenthesizedExpression":return this.isAssignable(node.expression);case"MemberExpression":case"OptionalMemberExpression":return !isBinding;default:return !1}}toReferencedList(exprList,isParenthesizedExpr){return exprList}toReferencedListDeep(exprList,isParenthesizedExpr){this.toReferencedList(exprList,isParenthesizedExpr);for(const expr of exprList)"ArrayExpression"===(null==expr?void 0:expr.type)&&this.toReferencedListDeep(expr.elements);}parseSpread(refExpressionErrors,refNeedsArrowPos){const node=this.startNode();return this.next(),node.argument=this.parseMaybeAssignAllowIn(refExpressionErrors,void 0,refNeedsArrowPos),this.finishNode(node,"SpreadElement")}parseRestBinding(){const node=this.startNode();return this.next(),node.argument=this.parseBindingAtom(),this.finishNode(node,"RestElement")}parseBindingAtom(){switch(this.state.type){case 0:{const node=this.startNode();return this.next(),node.elements=this.parseBindingList(3,93,!0),this.finishNode(node,"ArrayPattern")}case 5:return this.parseObjectLike(8,!0)}return this.parseIdentifier()}parseBindingList(close,closeCharCode,allowEmpty,allowModifiers){const elts=[];let first=!0;for(;!this.eat(close);)if(first?first=!1:this.expect(12),allowEmpty&&this.match(12))elts.push(null);else {if(this.eat(close))break;if(this.match(21)){if(elts.push(this.parseAssignableListItemTypes(this.parseRestBinding())),!this.checkCommaAfterRest(closeCharCode)){this.expect(close);break}}else {const decorators=[];for(this.match(26)&&this.hasPlugin("decorators")&&this.raise(ErrorMessages.UnsupportedParameterDecorator,{at:this.state.startLoc});this.match(26);)decorators.push(this.parseDecorator());elts.push(this.parseAssignableListItem(allowModifiers,decorators));}}return elts}parseBindingRestProperty(prop){return this.next(),prop.argument=this.parseIdentifier(),this.checkCommaAfterRest(125),this.finishNode(prop,"RestElement")}parseBindingProperty(){const prop=this.startNode(),{type,start:startPos,startLoc}=this.state;return 21===type?this.parseBindingRestProperty(prop):(this.parsePropertyName(prop),prop.method=!1,this.parseObjPropValue(prop,startPos,startLoc,!1,!1,!0,!1),prop)}parseAssignableListItem(allowModifiers,decorators){const left=this.parseMaybeDefault();this.parseAssignableListItemTypes(left);const elt=this.parseMaybeDefault(left.start,left.loc.start,left);return decorators.length&&(left.decorators=decorators),elt}parseAssignableListItemTypes(param){return param}parseMaybeDefault(startPos,startLoc,left){var _startLoc,_startPos,_left;if(startLoc=null!=(_startLoc=startLoc)?_startLoc:this.state.startLoc,startPos=null!=(_startPos=startPos)?_startPos:this.state.start,left=null!=(_left=left)?_left:this.parseBindingAtom(),!this.eat(29))return left;const node=this.startNodeAt(startPos,startLoc);return node.left=left,node.right=this.parseMaybeAssignAllowIn(),this.finishNode(node,"AssignmentPattern")}checkLVal(expr,contextDescription,bindingType=64,checkClashes,disallowLetBinding,strictModeChanged=!1){switch(expr.type){case"Identifier":{const{name}=expr;this.state.strict&&(strictModeChanged?isStrictBindReservedWord(name,this.inModule):isStrictBindOnlyReservedWord(name))&&this.raise(64===bindingType?ErrorMessages.StrictEvalArguments:ErrorMessages.StrictEvalArgumentsBinding,{node:expr},name),checkClashes&&(checkClashes.has(name)?this.raise(ErrorMessages.ParamDupe,{node:expr}):checkClashes.add(name)),disallowLetBinding&&"let"===name&&this.raise(ErrorMessages.LetInLexicalBinding,{node:expr}),64&bindingType||this.scope.declareName(name,bindingType,expr.loc.start);break}case"MemberExpression":64!==bindingType&&this.raise(ErrorMessages.InvalidPropertyBindingPattern,{node:expr});break;case"ObjectPattern":for(let prop of expr.properties){if(this.isObjectProperty(prop))prop=prop.value;else if(this.isObjectMethod(prop))continue;this.checkLVal(prop,"object destructuring pattern",bindingType,checkClashes,disallowLetBinding);}break;case"ArrayPattern":for(const elem of expr.elements)elem&&this.checkLVal(elem,"array destructuring pattern",bindingType,checkClashes,disallowLetBinding);break;case"AssignmentPattern":this.checkLVal(expr.left,"assignment pattern",bindingType,checkClashes);break;case"RestElement":this.checkLVal(expr.argument,"rest element",bindingType,checkClashes);break;case"ParenthesizedExpression":this.checkLVal(expr.expression,"parenthesized expression",bindingType,checkClashes);break;default:this.raise(64===bindingType?ErrorMessages.InvalidLhs:ErrorMessages.InvalidLhsBinding,{node:expr},contextDescription);}}checkToRestConversion(node){"Identifier"!==node.argument.type&&"MemberExpression"!==node.argument.type&&this.raise(ErrorMessages.InvalidRestAssignmentPattern,{node:node.argument});}checkCommaAfterRest(close){return !!this.match(12)&&(this.raise(this.lookaheadCharCode()===close?ErrorMessages.RestTrailingComma:ErrorMessages.ElementAfterRest,{at:this.state.startLoc}),!0)}}{checkProto(prop,isRecord,protoRef,refExpressionErrors){if("SpreadElement"===prop.type||this.isObjectMethod(prop)||prop.computed||prop.shorthand)return;const key=prop.key;if("__proto__"===("Identifier"===key.type?key.name:key.value)){if(isRecord)return void this.raise(ErrorMessages.RecordNoProto,{node:key});protoRef.used&&(refExpressionErrors?null===refExpressionErrors.doubleProtoLoc&&(refExpressionErrors.doubleProtoLoc=key.loc.start):this.raise(ErrorMessages.DuplicateProto,{node:key})),protoRef.used=!0;}}shouldExitDescending(expr,potentialArrowAt){return "ArrowFunctionExpression"===expr.type&&expr.start===potentialArrowAt}getExpression(){this.enterInitialScopes(),this.nextToken();const expr=this.parseExpression();return this.match(131)||this.unexpected(),this.finalizeRemainingComments(),expr.comments=this.state.comments,expr.errors=this.state.errors,this.options.tokens&&(expr.tokens=this.tokens),expr}parseExpression(disallowIn,refExpressionErrors){return disallowIn?this.disallowInAnd((()=>this.parseExpressionBase(refExpressionErrors))):this.allowInAnd((()=>this.parseExpressionBase(refExpressionErrors)))}parseExpressionBase(refExpressionErrors){const startPos=this.state.start,startLoc=this.state.startLoc,expr=this.parseMaybeAssign(refExpressionErrors);if(this.match(12)){const node=this.startNodeAt(startPos,startLoc);for(node.expressions=[expr];this.eat(12);)node.expressions.push(this.parseMaybeAssign(refExpressionErrors));return this.toReferencedList(node.expressions),this.finishNode(node,"SequenceExpression")}return expr}parseMaybeAssignDisallowIn(refExpressionErrors,afterLeftParse){return this.disallowInAnd((()=>this.parseMaybeAssign(refExpressionErrors,afterLeftParse)))}parseMaybeAssignAllowIn(refExpressionErrors,afterLeftParse){return this.allowInAnd((()=>this.parseMaybeAssign(refExpressionErrors,afterLeftParse)))}setOptionalParametersError(refExpressionErrors,resultError){var _resultError$loc;refExpressionErrors.optionalParametersLoc=null!=(_resultError$loc=null==resultError?void 0:resultError.loc)?_resultError$loc:this.state.startLoc;}parseMaybeAssign(refExpressionErrors,afterLeftParse){const startPos=this.state.start,startLoc=this.state.startLoc;if(this.isContextual(101)&&this.prodParam.hasYield){let left=this.parseYield();return afterLeftParse&&(left=afterLeftParse.call(this,left,startPos,startLoc)),left}let ownExpressionErrors;refExpressionErrors?ownExpressionErrors=!1:(refExpressionErrors=new ExpressionErrors,ownExpressionErrors=!0);const{type}=this.state;(10===type||tokenIsIdentifier(type))&&(this.state.potentialArrowAt=this.state.start);let left=this.parseMaybeConditional(refExpressionErrors);if(afterLeftParse&&(left=afterLeftParse.call(this,left,startPos,startLoc)),(token=this.state.type)>=29&&token<=33){const node=this.startNodeAt(startPos,startLoc),operator=this.state.value;return node.operator=operator,this.match(29)?(node.left=this.toAssignable(left,!0),null!=refExpressionErrors.doubleProtoLoc&&indexes.get(refExpressionErrors.doubleProtoLoc)>=startPos&&(refExpressionErrors.doubleProtoLoc=null),null!=refExpressionErrors.shorthandAssignLoc&&indexes.get(refExpressionErrors.shorthandAssignLoc)>=startPos&&(refExpressionErrors.shorthandAssignLoc=null)):node.left=left,this.checkLVal(left,"assignment expression"),this.next(),node.right=this.parseMaybeAssign(),this.finishNode(node,"AssignmentExpression")}var token;return ownExpressionErrors&&this.checkExpressionErrors(refExpressionErrors,!0),left}parseMaybeConditional(refExpressionErrors){const startPos=this.state.start,startLoc=this.state.startLoc,potentialArrowAt=this.state.potentialArrowAt,expr=this.parseExprOps(refExpressionErrors);return this.shouldExitDescending(expr,potentialArrowAt)?expr:this.parseConditional(expr,startPos,startLoc,refExpressionErrors)}parseConditional(expr,startPos,startLoc,refExpressionErrors){if(this.eat(17)){const node=this.startNodeAt(startPos,startLoc);return node.test=expr,node.consequent=this.parseMaybeAssignAllowIn(),this.expect(14),node.alternate=this.parseMaybeAssign(),this.finishNode(node,"ConditionalExpression")}return expr}parseMaybeUnaryOrPrivate(refExpressionErrors){return this.match(130)?this.parsePrivateName():this.parseMaybeUnary(refExpressionErrors)}parseExprOps(refExpressionErrors){const startPos=this.state.start,startLoc=this.state.startLoc,potentialArrowAt=this.state.potentialArrowAt,expr=this.parseMaybeUnaryOrPrivate(refExpressionErrors);return this.shouldExitDescending(expr,potentialArrowAt)?expr:this.parseExprOp(expr,startPos,startLoc,-1)}parseExprOp(left,leftStartPos,leftStartLoc,minPrec){if(this.isPrivateName(left)){const value=this.getPrivateNameSV(left);(minPrec>=tokenOperatorPrecedence(54)||!this.prodParam.hasIn||!this.match(54))&&this.raise(ErrorMessages.PrivateInExpectedIn,{node:left},value),this.classScope.usePrivateName(value,left.loc.start);}const op=this.state.type;if((token=op)>=37&&token<=55&&(this.prodParam.hasIn||!this.match(54))){let prec=tokenOperatorPrecedence(op);if(prec>minPrec){if(37===op){if(this.expectPlugin("pipelineOperator"),this.state.inFSharpPipelineDirectBody)return left;this.checkPipelineAtInfixOperator(left,leftStartLoc);}const node=this.startNodeAt(leftStartPos,leftStartLoc);node.left=left,node.operator=this.state.value;const logical=39===op||40===op,coalesce=38===op;if(coalesce&&(prec=tokenOperatorPrecedence(40)),this.next(),37===op&&this.hasPlugin(["pipelineOperator",{proposal:"minimal"}])&&92===this.state.type&&this.prodParam.hasAwait)throw this.raise(ErrorMessages.UnexpectedAwaitAfterPipelineBody,{at:this.state.startLoc});node.right=this.parseExprOpRightExpr(op,prec),this.finishNode(node,logical||coalesce?"LogicalExpression":"BinaryExpression");const nextOp=this.state.type;if(coalesce&&(39===nextOp||40===nextOp)||logical&&38===nextOp)throw this.raise(ErrorMessages.MixingCoalesceWithLogical,{at:this.state.startLoc});return this.parseExprOp(node,leftStartPos,leftStartLoc,minPrec)}}var token;return left}parseExprOpRightExpr(op,prec){const startPos=this.state.start,startLoc=this.state.startLoc;if(37===op)switch(this.getPluginOption("pipelineOperator","proposal")){case"hack":return this.withTopicBindingContext((()=>this.parseHackPipeBody()));case"smart":return this.withTopicBindingContext((()=>{if(this.prodParam.hasYield&&this.isContextual(101))throw this.raise(ErrorMessages.PipeBodyIsTighter,{at:this.state.startLoc},this.state.value);return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op,prec),startPos,startLoc)}));case"fsharp":return this.withSoloAwaitPermittingContext((()=>this.parseFSharpPipelineBody(prec)))}return this.parseExprOpBaseRightExpr(op,prec)}parseExprOpBaseRightExpr(op,prec){const startPos=this.state.start,startLoc=this.state.startLoc;return this.parseExprOp(this.parseMaybeUnaryOrPrivate(),startPos,startLoc,53===op?prec-1:prec)}parseHackPipeBody(){var _body$extra;const{startLoc}=this.state,body=this.parseMaybeAssign();return !invalidHackPipeBodies.has(body.type)||null!=(_body$extra=body.extra)&&_body$extra.parenthesized||this.raise(ErrorMessages.PipeUnparenthesizedBody,{at:startLoc},invalidHackPipeBodies.get(body.type)),this.topicReferenceWasUsedInCurrentContext()||this.raise(ErrorMessages.PipeTopicUnused,{at:startLoc}),body}checkExponentialAfterUnary(node){this.match(53)&&this.raise(ErrorMessages.UnexpectedTokenUnaryExponentiation,{node:node.argument});}parseMaybeUnary(refExpressionErrors,sawUnary){const startPos=this.state.start,startLoc=this.state.startLoc,isAwait=this.isContextual(92);if(isAwait&&this.isAwaitAllowed()){this.next();const expr=this.parseAwait(startPos,startLoc);return sawUnary||this.checkExponentialAfterUnary(expr),expr}const update=this.match(34),node=this.startNode();if(token=this.state.type,tokenPrefixes[token]){node.operator=this.state.value,node.prefix=!0,this.match(68)&&this.expectPlugin("throwExpressions");const isDelete=this.match(85);if(this.next(),node.argument=this.parseMaybeUnary(null,!0),this.checkExpressionErrors(refExpressionErrors,!0),this.state.strict&&isDelete){const arg=node.argument;"Identifier"===arg.type?this.raise(ErrorMessages.StrictDelete,{node}):this.hasPropertyAsPrivateName(arg)&&this.raise(ErrorMessages.DeletePrivateField,{node});}if(!update)return sawUnary||this.checkExponentialAfterUnary(node),this.finishNode(node,"UnaryExpression")}var token;const expr=this.parseUpdate(node,update,refExpressionErrors);if(isAwait){const{type}=this.state;if((this.hasPlugin("v8intrinsic")?tokenCanStartExpression(type):tokenCanStartExpression(type)&&!this.match(50))&&!this.isAmbiguousAwait())return this.raiseOverwrite(startLoc,ErrorMessages.AwaitNotInAsyncContext),this.parseAwait(startPos,startLoc)}return expr}parseUpdate(node,update,refExpressionErrors){if(update)return this.checkLVal(node.argument,"prefix operation"),this.finishNode(node,"UpdateExpression");const startPos=this.state.start,startLoc=this.state.startLoc;let expr=this.parseExprSubscripts(refExpressionErrors);if(this.checkExpressionErrors(refExpressionErrors,!1))return expr;for(;34===this.state.type&&!this.canInsertSemicolon();){const node=this.startNodeAt(startPos,startLoc);node.operator=this.state.value,node.prefix=!1,node.argument=expr,this.checkLVal(expr,"postfix operation"),this.next(),expr=this.finishNode(node,"UpdateExpression");}return expr}parseExprSubscripts(refExpressionErrors){const startPos=this.state.start,startLoc=this.state.startLoc,potentialArrowAt=this.state.potentialArrowAt,expr=this.parseExprAtom(refExpressionErrors);return this.shouldExitDescending(expr,potentialArrowAt)?expr:this.parseSubscripts(expr,startPos,startLoc)}parseSubscripts(base,startPos,startLoc,noCalls){const state={optionalChainMember:!1,maybeAsyncArrow:this.atPossibleAsyncArrow(base),stop:!1};do{base=this.parseSubscript(base,startPos,startLoc,noCalls,state),state.maybeAsyncArrow=!1;}while(!state.stop);return base}parseSubscript(base,startPos,startLoc,noCalls,state){const{type}=this.state;if(!noCalls&&15===type)return this.parseBind(base,startPos,startLoc,noCalls,state);if(tokenIsTemplate(type))return this.parseTaggedTemplateExpression(base,startPos,startLoc,state);let optional=!1;if(18===type){if(noCalls&&40===this.lookaheadCharCode())return state.stop=!0,base;state.optionalChainMember=optional=!0,this.next();}if(!noCalls&&this.match(10))return this.parseCoverCallAndAsyncArrowHead(base,startPos,startLoc,state,optional);{const computed=this.eat(0);return computed||optional||this.eat(16)?this.parseMember(base,startPos,startLoc,state,computed,optional):(state.stop=!0,base)}}parseMember(base,startPos,startLoc,state,computed,optional){const node=this.startNodeAt(startPos,startLoc);return node.object=base,node.computed=computed,computed?(node.property=this.parseExpression(),this.expect(3)):this.match(130)?("Super"===base.type&&this.raise(ErrorMessages.SuperPrivateField,{at:startLoc}),this.classScope.usePrivateName(this.state.value,this.state.startLoc),node.property=this.parsePrivateName()):node.property=this.parseIdentifier(!0),state.optionalChainMember?(node.optional=optional,this.finishNode(node,"OptionalMemberExpression")):this.finishNode(node,"MemberExpression")}parseBind(base,startPos,startLoc,noCalls,state){const node=this.startNodeAt(startPos,startLoc);return node.object=base,this.next(),node.callee=this.parseNoCallExpr(),state.stop=!0,this.parseSubscripts(this.finishNode(node,"BindExpression"),startPos,startLoc,noCalls)}parseCoverCallAndAsyncArrowHead(base,startPos,startLoc,state,optional){const oldMaybeInArrowParameters=this.state.maybeInArrowParameters;let refExpressionErrors=null;this.state.maybeInArrowParameters=!0,this.next();let node=this.startNodeAt(startPos,startLoc);return node.callee=base,state.maybeAsyncArrow&&(this.expressionScope.enter(new ArrowHeadParsingScope(2)),refExpressionErrors=new ExpressionErrors),state.optionalChainMember&&(node.optional=optional),node.arguments=optional?this.parseCallExpressionArguments(11):this.parseCallExpressionArguments(11,"Import"===base.type,"Super"!==base.type,node,refExpressionErrors),this.finishCallExpression(node,state.optionalChainMember),state.maybeAsyncArrow&&this.shouldParseAsyncArrow()&&!optional?(state.stop=!0,this.expressionScope.validateAsPattern(),this.expressionScope.exit(),node=this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos,startLoc),node)):(state.maybeAsyncArrow&&(this.checkExpressionErrors(refExpressionErrors,!0),this.expressionScope.exit()),this.toReferencedArguments(node)),this.state.maybeInArrowParameters=oldMaybeInArrowParameters,node}toReferencedArguments(node,isParenthesizedExpr){this.toReferencedListDeep(node.arguments,isParenthesizedExpr);}parseTaggedTemplateExpression(base,startPos,startLoc,state){const node=this.startNodeAt(startPos,startLoc);return node.tag=base,node.quasi=this.parseTemplate(!0),state.optionalChainMember&&this.raise(ErrorMessages.OptionalChainingNoTemplate,{at:startLoc}),this.finishNode(node,"TaggedTemplateExpression")}atPossibleAsyncArrow(base){return "Identifier"===base.type&&"async"===base.name&&indexes.get(this.state.lastTokEndLoc)===base.end&&!this.canInsertSemicolon()&&base.end-base.start==5&&base.start===this.state.potentialArrowAt}finishCallExpression(node,optional){if("Import"===node.callee.type)if(2===node.arguments.length&&(this.hasPlugin("moduleAttributes")||this.expectPlugin("importAssertions")),0===node.arguments.length||node.arguments.length>2)this.raise(ErrorMessages.ImportCallArity,{node},this.hasPlugin("importAssertions")||this.hasPlugin("moduleAttributes")?"one or two arguments":"one argument");else for(const arg of node.arguments)"SpreadElement"===arg.type&&this.raise(ErrorMessages.ImportCallSpreadArgument,{node:arg});return this.finishNode(node,optional?"OptionalCallExpression":"CallExpression")}parseCallExpressionArguments(close,dynamicImport,allowPlaceholder,nodeForExtra,refExpressionErrors){const elts=[];let first=!0;const oldInFSharpPipelineDirectBody=this.state.inFSharpPipelineDirectBody;for(this.state.inFSharpPipelineDirectBody=!1;!this.eat(close);){if(first)first=!1;else if(this.expect(12),this.match(close)){!dynamicImport||this.hasPlugin("importAssertions")||this.hasPlugin("moduleAttributes")||this.raise(ErrorMessages.ImportCallArgumentTrailingComma,{at:this.state.lastTokStartLoc}),nodeForExtra&&this.addTrailingCommaExtraToNode(nodeForExtra),this.next();break}elts.push(this.parseExprListItem(!1,refExpressionErrors,allowPlaceholder));}return this.state.inFSharpPipelineDirectBody=oldInFSharpPipelineDirectBody,elts}shouldParseAsyncArrow(){return this.match(19)&&!this.canInsertSemicolon()}parseAsyncArrowFromCallExpression(node,call){var _call$extra;return this.resetPreviousNodeTrailingComments(call),this.expect(19),this.parseArrowExpression(node,call.arguments,!0,null==(_call$extra=call.extra)?void 0:_call$extra.trailingCommaLoc),call.innerComments&&setInnerComments(node,call.innerComments),call.callee.trailingComments&&setInnerComments(node,call.callee.trailingComments),node}parseNoCallExpr(){const startPos=this.state.start,startLoc=this.state.startLoc;return this.parseSubscripts(this.parseExprAtom(),startPos,startLoc,!0)}parseExprAtom(refExpressionErrors){let node;const{type}=this.state;switch(type){case 75:return this.parseSuper();case 79:return node=this.startNode(),this.next(),this.match(16)?this.parseImportMetaProperty(node):(this.match(10)||this.raise(ErrorMessages.UnsupportedImport,{at:this.state.lastTokStartLoc}),this.finishNode(node,"Import"));case 74:return node=this.startNode(),this.next(),this.finishNode(node,"ThisExpression");case 86:return this.parseDo(this.startNode(),!1);case 52:case 31:return this.readRegexp(),this.parseRegExpLiteral(this.state.value);case 126:return this.parseNumericLiteral(this.state.value);case 127:return this.parseBigIntLiteral(this.state.value);case 128:return this.parseDecimalLiteral(this.state.value);case 125:return this.parseStringLiteral(this.state.value);case 80:return this.parseNullLiteral();case 81:return this.parseBooleanLiteral(!0);case 82:return this.parseBooleanLiteral(!1);case 10:{const canBeArrow=this.state.potentialArrowAt===this.state.start;return this.parseParenAndDistinguishExpression(canBeArrow)}case 2:case 1:return this.parseArrayLike(2===this.state.type?4:3,!1,!0);case 0:return this.parseArrayLike(3,!0,!1,refExpressionErrors);case 6:case 7:return this.parseObjectLike(6===this.state.type?9:8,!1,!0);case 5:return this.parseObjectLike(8,!1,!1,refExpressionErrors);case 64:return this.parseFunctionOrFunctionSent();case 26:this.parseDecorators();case 76:return node=this.startNode(),this.takeDecorators(node),this.parseClass(node,!1);case 73:return this.parseNewOrNewTarget();case 25:case 24:return this.parseTemplate(!1);case 15:{node=this.startNode(),this.next(),node.object=null;const callee=node.callee=this.parseNoCallExpr();if("MemberExpression"===callee.type)return this.finishNode(node,"BindExpression");throw this.raise(ErrorMessages.UnsupportedBind,{node:callee})}case 130:return this.raise(ErrorMessages.PrivateInExpectedIn,{at:this.state.startLoc},this.state.value),this.parsePrivateName();case 33:return this.parseTopicReferenceThenEqualsSign(50,"%");case 32:return this.parseTopicReferenceThenEqualsSign(42,"^");case 42:case 50:case 27:{const pipeProposal=this.getPluginOption("pipelineOperator","proposal");if(pipeProposal)return this.parseTopicReference(pipeProposal);throw this.unexpected()}case 45:{const lookaheadCh=this.input.codePointAt(this.nextTokenStart());if(isIdentifierStart(lookaheadCh)||62===lookaheadCh){this.expectOnePlugin(["jsx","flow","typescript"]);break}throw this.unexpected()}default:if(tokenIsIdentifier(type)){if(this.isContextual(119)&&123===this.lookaheadCharCode()&&!this.hasFollowingLineBreak())return this.parseModuleExpression();const canBeArrow=this.state.potentialArrowAt===this.state.start,containsEsc=this.state.containsEsc,id=this.parseIdentifier();if(!containsEsc&&"async"===id.name&&!this.canInsertSemicolon()){const{type}=this.state;if(64===type)return this.resetPreviousNodeTrailingComments(id),this.next(),this.parseFunction(this.startNodeAtNode(id),void 0,!0);if(tokenIsIdentifier(type))return 61===this.lookaheadCharCode()?this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id)):id;if(86===type)return this.resetPreviousNodeTrailingComments(id),this.parseDo(this.startNodeAtNode(id),!0)}return canBeArrow&&this.match(19)&&!this.canInsertSemicolon()?(this.next(),this.parseArrowExpression(this.startNodeAtNode(id),[id],!1)):id}throw this.unexpected()}}parseTopicReferenceThenEqualsSign(topicTokenType,topicTokenValue){const pipeProposal=this.getPluginOption("pipelineOperator","proposal");if(pipeProposal)return this.state.type=topicTokenType,this.state.value=topicTokenValue,this.state.pos--,this.state.end--,this.state.endLoc=createPositionWithColumnOffset(this.state.endLoc,-1),this.parseTopicReference(pipeProposal);throw this.unexpected()}parseTopicReference(pipeProposal){const node=this.startNode(),startLoc=this.state.startLoc,tokenType=this.state.type;return this.next(),this.finishTopicReference(node,startLoc,pipeProposal,tokenType)}finishTopicReference(node,startLoc,pipeProposal,tokenType){if(this.testTopicReferenceConfiguration(pipeProposal,startLoc,tokenType)){const nodeType="smart"===pipeProposal?"PipelinePrimaryTopicReference":"TopicReference";return this.topicReferenceIsAllowedInCurrentContext()||this.raise("smart"===pipeProposal?ErrorMessages.PrimaryTopicNotAllowed:ErrorMessages.PipeTopicUnbound,{at:startLoc}),this.registerTopicReference(),this.finishNode(node,nodeType)}throw this.raise(ErrorMessages.PipeTopicUnconfiguredToken,{at:startLoc},tokenLabelName(tokenType))}testTopicReferenceConfiguration(pipeProposal,startLoc,tokenType){switch(pipeProposal){case"hack":return this.hasPlugin(["pipelineOperator",{topicToken:tokenLabelName(tokenType)}]);case"smart":return 27===tokenType;default:throw this.raise(ErrorMessages.PipeTopicRequiresHackPipes,{at:startLoc})}}parseAsyncArrowUnaryFunction(node){this.prodParam.enter(functionFlags(!0,this.prodParam.hasYield));const params=[this.parseIdentifier()];return this.prodParam.exit(),this.hasPrecedingLineBreak()&&this.raise(ErrorMessages.LineTerminatorBeforeArrow,{at:this.state.curPosition()}),this.expect(19),this.parseArrowExpression(node,params,!0),node}parseDo(node,isAsync){this.expectPlugin("doExpressions"),isAsync&&this.expectPlugin("asyncDoExpressions"),node.async=isAsync,this.next();const oldLabels=this.state.labels;return this.state.labels=[],isAsync?(this.prodParam.enter(2),node.body=this.parseBlock(),this.prodParam.exit()):node.body=this.parseBlock(),this.state.labels=oldLabels,this.finishNode(node,"DoExpression")}parseSuper(){const node=this.startNode();return this.next(),!this.match(10)||this.scope.allowDirectSuper||this.options.allowSuperOutsideMethod?this.scope.allowSuper||this.options.allowSuperOutsideMethod||this.raise(ErrorMessages.UnexpectedSuper,{node}):this.raise(ErrorMessages.SuperNotAllowed,{node}),this.match(10)||this.match(0)||this.match(16)||this.raise(ErrorMessages.UnsupportedSuper,{node}),this.finishNode(node,"Super")}parsePrivateName(){const node=this.startNode(),id=this.startNodeAt(this.state.start+1,new Position(this.state.curLine,this.state.start+1-this.state.lineStart,this.state.start+1)),name=this.state.value;return this.next(),node.id=this.createIdentifier(id,name),this.finishNode(node,"PrivateName")}parseFunctionOrFunctionSent(){const node=this.startNode();if(this.next(),this.prodParam.hasYield&&this.match(16)){const meta=this.createIdentifier(this.startNodeAtNode(node),"function");return this.next(),this.match(98)?this.expectPlugin("functionSent"):this.hasPlugin("functionSent")||this.unexpected(),this.parseMetaProperty(node,meta,"sent")}return this.parseFunction(node)}parseMetaProperty(node,meta,propertyName){node.meta=meta;const containsEsc=this.state.containsEsc;return node.property=this.parseIdentifier(!0),(node.property.name!==propertyName||containsEsc)&&this.raise(ErrorMessages.UnsupportedMetaProperty,{node:node.property},meta.name,propertyName),this.finishNode(node,"MetaProperty")}parseImportMetaProperty(node){const id=this.createIdentifier(this.startNodeAtNode(node),"import");return this.next(),this.isContextual(96)&&(this.inModule||this.raise(SourceTypeModuleErrorMessages.ImportMetaOutsideModule,{node:id}),this.sawUnambiguousESM=!0),this.parseMetaProperty(node,id,"meta")}parseLiteralAtNode(value,type,node){return this.addExtra(node,"rawValue",value),this.addExtra(node,"raw",this.input.slice(node.start,this.state.end)),node.value=value,this.next(),this.finishNode(node,type)}parseLiteral(value,type){const node=this.startNode();return this.parseLiteralAtNode(value,type,node)}parseStringLiteral(value){return this.parseLiteral(value,"StringLiteral")}parseNumericLiteral(value){return this.parseLiteral(value,"NumericLiteral")}parseBigIntLiteral(value){return this.parseLiteral(value,"BigIntLiteral")}parseDecimalLiteral(value){return this.parseLiteral(value,"DecimalLiteral")}parseRegExpLiteral(value){const node=this.parseLiteral(value.value,"RegExpLiteral");return node.pattern=value.pattern,node.flags=value.flags,node}parseBooleanLiteral(value){const node=this.startNode();return node.value=value,this.next(),this.finishNode(node,"BooleanLiteral")}parseNullLiteral(){const node=this.startNode();return this.next(),this.finishNode(node,"NullLiteral")}parseParenAndDistinguishExpression(canBeArrow){const startPos=this.state.start,startLoc=this.state.startLoc;let val;this.next(),this.expressionScope.enter(new ArrowHeadParsingScope(1));const oldMaybeInArrowParameters=this.state.maybeInArrowParameters,oldInFSharpPipelineDirectBody=this.state.inFSharpPipelineDirectBody;this.state.maybeInArrowParameters=!0,this.state.inFSharpPipelineDirectBody=!1;const innerStartPos=this.state.start,innerStartLoc=this.state.startLoc,exprList=[],refExpressionErrors=new ExpressionErrors;let spreadStartLoc,optionalCommaStartLoc,first=!0;for(;!this.match(11);){if(first)first=!1;else if(this.expect(12,null===refExpressionErrors.optionalParametersLoc?null:refExpressionErrors.optionalParametersLoc),this.match(11)){optionalCommaStartLoc=this.state.startLoc;break}if(this.match(21)){const spreadNodeStartPos=this.state.start,spreadNodeStartLoc=this.state.startLoc;if(spreadStartLoc=this.state.startLoc,exprList.push(this.parseParenItem(this.parseRestBinding(),spreadNodeStartPos,spreadNodeStartLoc)),!this.checkCommaAfterRest(41))break}else exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors,this.parseParenItem));}const innerEndLoc=this.state.lastTokEndLoc;this.expect(11),this.state.maybeInArrowParameters=oldMaybeInArrowParameters,this.state.inFSharpPipelineDirectBody=oldInFSharpPipelineDirectBody;let arrowNode=this.startNodeAt(startPos,startLoc);if(canBeArrow&&this.shouldParseArrow(exprList)&&(arrowNode=this.parseArrow(arrowNode)))return this.expressionScope.validateAsPattern(),this.expressionScope.exit(),this.parseArrowExpression(arrowNode,exprList,!1),arrowNode;if(this.expressionScope.exit(),exprList.length||this.unexpected(this.state.lastTokStartLoc),optionalCommaStartLoc&&this.unexpected(optionalCommaStartLoc),spreadStartLoc&&this.unexpected(spreadStartLoc),this.checkExpressionErrors(refExpressionErrors,!0),this.toReferencedListDeep(exprList,!0),exprList.length>1?(val=this.startNodeAt(innerStartPos,innerStartLoc),val.expressions=exprList,this.finishNode(val,"SequenceExpression"),this.resetEndLocation(val,innerEndLoc)):val=exprList[0],!this.options.createParenthesizedExpressions)return this.addExtra(val,"parenthesized",!0),this.addExtra(val,"parenStart",startPos),this.takeSurroundingComments(val,startPos,indexes.get(this.state.lastTokEndLoc)),val;const parenExpression=this.startNodeAt(startPos,startLoc);return parenExpression.expression=val,this.finishNode(parenExpression,"ParenthesizedExpression"),parenExpression}shouldParseArrow(params){return !this.canInsertSemicolon()}parseArrow(node){if(this.eat(19))return node}parseParenItem(node,startPos,startLoc){return node}parseNewOrNewTarget(){const node=this.startNode();if(this.next(),this.match(16)){const meta=this.createIdentifier(this.startNodeAtNode(node),"new");this.next();const metaProp=this.parseMetaProperty(node,meta,"target");return this.scope.inNonArrowFunction||this.scope.inClass||this.raise(ErrorMessages.UnexpectedNewTarget,{node:metaProp}),metaProp}return this.parseNew(node)}parseNew(node){return node.callee=this.parseNoCallExpr(),"Import"===node.callee.type?this.raise(ErrorMessages.ImportCallNotNewExpression,{node:node.callee}):this.isOptionalChain(node.callee)?this.raise(ErrorMessages.OptionalChainingNoNew,{at:this.state.lastTokEndLoc}):this.eat(18)&&this.raise(ErrorMessages.OptionalChainingNoNew,{at:this.state.startLoc}),this.parseNewArguments(node),this.finishNode(node,"NewExpression")}parseNewArguments(node){if(this.eat(10)){const args=this.parseExprList(11);this.toReferencedList(args),node.arguments=args;}else node.arguments=[];}parseTemplateElement(isTagged){const{start,startLoc,end,value}=this.state,elemStart=start+1,elem=this.startNodeAt(elemStart,createPositionWithColumnOffset(startLoc,1));null===value&&(isTagged||this.raise(ErrorMessages.InvalidEscapeSequenceTemplate,{at:createPositionWithColumnOffset(startLoc,2)}));const isTail=this.match(24),endOffset=isTail?-1:-2,elemEnd=end+endOffset;return elem.value={raw:this.input.slice(elemStart,elemEnd).replace(/\r\n?/g,"\n"),cooked:null===value?null:value.slice(1,endOffset)},elem.tail=isTail,this.next(),this.finishNode(elem,"TemplateElement"),this.resetEndLocation(elem,createPositionWithColumnOffset(this.state.lastTokEndLoc,endOffset)),elem}parseTemplate(isTagged){const node=this.startNode();node.expressions=[];let curElt=this.parseTemplateElement(isTagged);for(node.quasis=[curElt];!curElt.tail;)node.expressions.push(this.parseTemplateSubstitution()),this.readTemplateContinuation(),node.quasis.push(curElt=this.parseTemplateElement(isTagged));return this.finishNode(node,"TemplateLiteral")}parseTemplateSubstitution(){return this.parseExpression()}parseObjectLike(close,isPattern,isRecord,refExpressionErrors){isRecord&&this.expectPlugin("recordAndTuple");const oldInFSharpPipelineDirectBody=this.state.inFSharpPipelineDirectBody;this.state.inFSharpPipelineDirectBody=!1;const propHash=Object.create(null);let first=!0;const node=this.startNode();for(node.properties=[],this.next();!this.match(close);){if(first)first=!1;else if(this.expect(12),this.match(close)){this.addTrailingCommaExtraToNode(node);break}let prop;isPattern?prop=this.parseBindingProperty():(prop=this.parsePropertyDefinition(refExpressionErrors),this.checkProto(prop,isRecord,propHash,refExpressionErrors)),isRecord&&!this.isObjectProperty(prop)&&"SpreadElement"!==prop.type&&this.raise(ErrorMessages.InvalidRecordProperty,{node:prop}),prop.shorthand&&this.addExtra(prop,"shorthand",!0),node.properties.push(prop);}this.next(),this.state.inFSharpPipelineDirectBody=oldInFSharpPipelineDirectBody;let type="ObjectExpression";return isPattern?type="ObjectPattern":isRecord&&(type="RecordExpression"),this.finishNode(node,type)}addTrailingCommaExtraToNode(node){this.addExtra(node,"trailingComma",this.state.lastTokStart),this.addExtra(node,"trailingCommaLoc",this.state.lastTokStartLoc,!1);}maybeAsyncOrAccessorProp(prop){return !prop.computed&&"Identifier"===prop.key.type&&(this.isLiteralPropertyName()||this.match(0)||this.match(51))}parsePropertyDefinition(refExpressionErrors){let decorators=[];if(this.match(26))for(this.hasPlugin("decorators")&&this.raise(ErrorMessages.UnsupportedPropertyDecorator,{at:this.state.startLoc});this.match(26);)decorators.push(this.parseDecorator());const prop=this.startNode();let startPos,startLoc,isAsync=!1,isAccessor=!1;if(this.match(21))return decorators.length&&this.unexpected(),this.parseSpread();decorators.length&&(prop.decorators=decorators,decorators=[]),prop.method=!1,refExpressionErrors&&(startPos=this.state.start,startLoc=this.state.startLoc);let isGenerator=this.eat(51);this.parsePropertyNamePrefixOperator(prop);const containsEsc=this.state.containsEsc,key=this.parsePropertyName(prop);if(!isGenerator&&!containsEsc&&this.maybeAsyncOrAccessorProp(prop)){const keyName=key.name;"async"!==keyName||this.hasPrecedingLineBreak()||(isAsync=!0,this.resetPreviousNodeTrailingComments(key),isGenerator=this.eat(51),this.parsePropertyName(prop)),"get"!==keyName&&"set"!==keyName||(isAccessor=!0,this.resetPreviousNodeTrailingComments(key),prop.kind=keyName,this.match(51)&&(isGenerator=!0,this.raise(ErrorMessages.AccessorIsGenerator,{at:this.state.curPosition()},keyName),this.next()),this.parsePropertyName(prop));}return this.parseObjPropValue(prop,startPos,startLoc,isGenerator,isAsync,!1,isAccessor,refExpressionErrors),prop}getGetterSetterExpectedParamCount(method){return "get"===method.kind?0:1}getObjectOrClassMethodParams(method){return method.params}checkGetterSetterParams(method){var _params;const paramCount=this.getGetterSetterExpectedParamCount(method),params=this.getObjectOrClassMethodParams(method);params.length!==paramCount&&this.raise("get"===method.kind?ErrorMessages.BadGetterArity:ErrorMessages.BadSetterArity,{node:method}),"set"===method.kind&&"RestElement"===(null==(_params=params[params.length-1])?void 0:_params.type)&&this.raise(ErrorMessages.BadSetterRestParameter,{node:method});}parseObjectMethod(prop,isGenerator,isAsync,isPattern,isAccessor){return isAccessor?(this.parseMethod(prop,isGenerator,!1,!1,!1,"ObjectMethod"),this.checkGetterSetterParams(prop),prop):isAsync||isGenerator||this.match(10)?(isPattern&&this.unexpected(),prop.kind="method",prop.method=!0,this.parseMethod(prop,isGenerator,isAsync,!1,!1,"ObjectMethod")):void 0}parseObjectProperty(prop,startPos,startLoc,isPattern,refExpressionErrors){if(prop.shorthand=!1,this.eat(14))return prop.value=isPattern?this.parseMaybeDefault(this.state.start,this.state.startLoc):this.parseMaybeAssignAllowIn(refExpressionErrors),this.finishNode(prop,"ObjectProperty");if(!prop.computed&&"Identifier"===prop.key.type){if(this.checkReservedWord(prop.key.name,prop.key.loc.start,!0,!1),isPattern)prop.value=this.parseMaybeDefault(startPos,startLoc,cloneIdentifier(prop.key));else if(this.match(29)){const shorthandAssignLoc=this.state.startLoc;null!=refExpressionErrors?null===refExpressionErrors.shorthandAssignLoc&&(refExpressionErrors.shorthandAssignLoc=shorthandAssignLoc):this.raise(ErrorMessages.InvalidCoverInitializedName,{at:shorthandAssignLoc}),prop.value=this.parseMaybeDefault(startPos,startLoc,cloneIdentifier(prop.key));}else prop.value=cloneIdentifier(prop.key);return prop.shorthand=!0,this.finishNode(prop,"ObjectProperty")}}parseObjPropValue(prop,startPos,startLoc,isGenerator,isAsync,isPattern,isAccessor,refExpressionErrors){const node=this.parseObjectMethod(prop,isGenerator,isAsync,isPattern,isAccessor)||this.parseObjectProperty(prop,startPos,startLoc,isPattern,refExpressionErrors);return node||this.unexpected(),node}parsePropertyName(prop){if(this.eat(0))prop.computed=!0,prop.key=this.parseMaybeAssignAllowIn(),this.expect(3);else {const{type,value}=this.state;let key;if(tokenIsKeywordOrIdentifier(type))key=this.parseIdentifier(!0);else switch(type){case 126:key=this.parseNumericLiteral(value);break;case 125:key=this.parseStringLiteral(value);break;case 127:key=this.parseBigIntLiteral(value);break;case 128:key=this.parseDecimalLiteral(value);break;case 130:this.raise(ErrorMessages.UnexpectedPrivateField,{at:createPositionWithColumnOffset(this.state.startLoc,1)}),key=this.parsePrivateName();break;default:throw this.unexpected()}prop.key=key,130!==type&&(prop.computed=!1);}return prop.key}initFunction(node,isAsync){node.id=null,node.generator=!1,node.async=!!isAsync;}parseMethod(node,isGenerator,isAsync,isConstructor,allowDirectSuper,type,inClassScope=!1){this.initFunction(node,isAsync),node.generator=!!isGenerator;const allowModifiers=isConstructor;return this.scope.enter(18|(inClassScope?64:0)|(allowDirectSuper?32:0)),this.prodParam.enter(functionFlags(isAsync,node.generator)),this.parseFunctionParams(node,allowModifiers),this.parseFunctionBodyAndFinish(node,type,!0),this.prodParam.exit(),this.scope.exit(),node}parseArrayLike(close,canBePattern,isTuple,refExpressionErrors){isTuple&&this.expectPlugin("recordAndTuple");const oldInFSharpPipelineDirectBody=this.state.inFSharpPipelineDirectBody;this.state.inFSharpPipelineDirectBody=!1;const node=this.startNode();return this.next(),node.elements=this.parseExprList(close,!isTuple,refExpressionErrors,node),this.state.inFSharpPipelineDirectBody=oldInFSharpPipelineDirectBody,this.finishNode(node,isTuple?"TupleExpression":"ArrayExpression")}parseArrowExpression(node,params,isAsync,trailingCommaLoc){this.scope.enter(6);let flags=functionFlags(isAsync,!1);!this.match(5)&&this.prodParam.hasIn&&(flags|=8),this.prodParam.enter(flags),this.initFunction(node,isAsync);const oldMaybeInArrowParameters=this.state.maybeInArrowParameters;return params&&(this.state.maybeInArrowParameters=!0,this.setArrowFunctionParameters(node,params,trailingCommaLoc)),this.state.maybeInArrowParameters=!1,this.parseFunctionBody(node,!0),this.prodParam.exit(),this.scope.exit(),this.state.maybeInArrowParameters=oldMaybeInArrowParameters,this.finishNode(node,"ArrowFunctionExpression")}setArrowFunctionParameters(node,params,trailingCommaLoc){node.params=this.toAssignableList(params,trailingCommaLoc,!1);}parseFunctionBodyAndFinish(node,type,isMethod=!1){this.parseFunctionBody(node,!1,isMethod),this.finishNode(node,type);}parseFunctionBody(node,allowExpression,isMethod=!1){const isExpression=allowExpression&&!this.match(5);if(this.expressionScope.enter(newExpressionScope()),isExpression)node.body=this.parseMaybeAssign(),this.checkParams(node,!1,allowExpression,!1);else {const oldStrict=this.state.strict,oldLabels=this.state.labels;this.state.labels=[],this.prodParam.enter(4|this.prodParam.currentFlags()),node.body=this.parseBlock(!0,!1,(hasStrictModeDirective=>{const nonSimple=!this.isSimpleParamList(node.params);if(hasStrictModeDirective&&nonSimple){const errorOrigin="method"!==node.kind&&"constructor"!==node.kind||!node.key?{node}:{at:node.key.loc.end};this.raise(ErrorMessages.IllegalLanguageModeDirective,errorOrigin);}const strictModeChanged=!oldStrict&&this.state.strict;this.checkParams(node,!(this.state.strict||allowExpression||isMethod||nonSimple),allowExpression,strictModeChanged),this.state.strict&&node.id&&this.checkLVal(node.id,"function name",65,void 0,void 0,strictModeChanged);})),this.prodParam.exit(),this.state.labels=oldLabels;}this.expressionScope.exit();}isSimpleParamList(params){for(let i=0,len=params.length;i<len;i++)if("Identifier"!==params[i].type)return !1;return !0}checkParams(node,allowDuplicates,isArrowFunction,strictModeChanged=!0){const checkClashes=new Set;for(const param of node.params)this.checkLVal(param,"function parameter list",5,allowDuplicates?null:checkClashes,void 0,strictModeChanged);}parseExprList(close,allowEmpty,refExpressionErrors,nodeForExtra){const elts=[];let first=!0;for(;!this.eat(close);){if(first)first=!1;else if(this.expect(12),this.match(close)){nodeForExtra&&this.addTrailingCommaExtraToNode(nodeForExtra),this.next();break}elts.push(this.parseExprListItem(allowEmpty,refExpressionErrors));}return elts}parseExprListItem(allowEmpty,refExpressionErrors,allowPlaceholder){let elt;if(this.match(12))allowEmpty||this.raise(ErrorMessages.UnexpectedToken,{at:this.state.curPosition()},","),elt=null;else if(this.match(21)){const spreadNodeStartPos=this.state.start,spreadNodeStartLoc=this.state.startLoc;elt=this.parseParenItem(this.parseSpread(refExpressionErrors),spreadNodeStartPos,spreadNodeStartLoc);}else if(this.match(17)){this.expectPlugin("partialApplication"),allowPlaceholder||this.raise(ErrorMessages.UnexpectedArgumentPlaceholder,{at:this.state.startLoc});const node=this.startNode();this.next(),elt=this.finishNode(node,"ArgumentPlaceholder");}else elt=this.parseMaybeAssignAllowIn(refExpressionErrors,this.parseParenItem);return elt}parseIdentifier(liberal){const node=this.startNode(),name=this.parseIdentifierName(node.start,liberal);return this.createIdentifier(node,name)}createIdentifier(node,name){return node.name=name,node.loc.identifierName=name,this.finishNode(node,"Identifier")}parseIdentifierName(pos,liberal){let name;const{startLoc,type}=this.state;if(!tokenIsKeywordOrIdentifier(type))throw this.unexpected();name=this.state.value;const tokenIsKeyword=type<=88;return liberal?tokenIsKeyword&&this.replaceToken(124):this.checkReservedWord(name,startLoc,tokenIsKeyword,!1),this.next(),name}checkReservedWord(word,startLoc,checkKeywords,isBinding){if(word.length>10)return;if(!function(word){return reservedWordLikeSet.has(word)}(word))return;if("yield"===word){if(this.prodParam.hasYield)return void this.raise(ErrorMessages.YieldBindingIdentifier,{at:startLoc})}else if("await"===word){if(this.prodParam.hasAwait)return void this.raise(ErrorMessages.AwaitBindingIdentifier,{at:startLoc});if(this.scope.inStaticBlock)return void this.raise(ErrorMessages.AwaitBindingIdentifierInStaticBlock,{at:startLoc});this.expressionScope.recordAsyncArrowParametersError(ErrorMessages.AwaitBindingIdentifier,startLoc);}else if("arguments"===word&&this.scope.inClassAndNotInNonArrowFunction)return void this.raise(ErrorMessages.ArgumentsInClass,{at:startLoc});if(checkKeywords&&function(word){return keywords.has(word)}(word))return void this.raise(ErrorMessages.UnexpectedKeyword,{at:startLoc},word);(this.state.strict?isBinding?isStrictBindReservedWord:isStrictReservedWord:isReservedWord)(word,this.inModule)&&this.raise(ErrorMessages.UnexpectedReservedWord,{at:startLoc},word);}isAwaitAllowed(){return !!this.prodParam.hasAwait||!(!this.options.allowAwaitOutsideFunction||this.scope.inFunction)}parseAwait(startPos,startLoc){const node=this.startNodeAt(startPos,startLoc);return this.expressionScope.recordParameterInitializerError(node.loc.start,ErrorMessages.AwaitExpressionFormalParameter),this.eat(51)&&this.raise(ErrorMessages.ObsoleteAwaitStar,{node}),this.scope.inFunction||this.options.allowAwaitOutsideFunction||(this.isAmbiguousAwait()?this.ambiguousScriptDifferentAst=!0:this.sawUnambiguousESM=!0),this.state.soloAwait||(node.argument=this.parseMaybeUnary(null,!0)),this.finishNode(node,"AwaitExpression")}isAmbiguousAwait(){if(this.hasPrecedingLineBreak())return !0;const{type}=this.state;return 49===type||10===type||0===type||tokenIsTemplate(type)||129===type||52===type||this.hasPlugin("v8intrinsic")&&50===type}parseYield(){const node=this.startNode();this.expressionScope.recordParameterInitializerError(node.loc.start,ErrorMessages.YieldInParameter),this.next();let delegating=!1,argument=null;if(!this.hasPrecedingLineBreak())switch(delegating=this.eat(51),this.state.type){case 13:case 131:case 8:case 11:case 3:case 9:case 14:case 12:if(!delegating)break;default:argument=this.parseMaybeAssign();}return node.delegate=delegating,node.argument=argument,this.finishNode(node,"YieldExpression")}checkPipelineAtInfixOperator(left,leftStartLoc){this.hasPlugin(["pipelineOperator",{proposal:"smart"}])&&"SequenceExpression"===left.type&&this.raise(ErrorMessages.PipelineHeadSequenceExpression,{at:leftStartLoc});}parseSmartPipelineBodyInStyle(childExpr,startPos,startLoc){const bodyNode=this.startNodeAt(startPos,startLoc);return this.isSimpleReference(childExpr)?(bodyNode.callee=childExpr,this.finishNode(bodyNode,"PipelineBareFunction")):(this.checkSmartPipeTopicBodyEarlyErrors(startLoc),bodyNode.expression=childExpr,this.finishNode(bodyNode,"PipelineTopicExpression"))}isSimpleReference(expression){switch(expression.type){case"MemberExpression":return !expression.computed&&this.isSimpleReference(expression.object);case"Identifier":return !0;default:return !1}}checkSmartPipeTopicBodyEarlyErrors(startLoc){if(this.match(19))throw this.raise(ErrorMessages.PipelineBodyNoArrow,{at:this.state.startLoc});this.topicReferenceWasUsedInCurrentContext()||this.raise(ErrorMessages.PipelineTopicUnused,{at:startLoc});}withTopicBindingContext(callback){const outerContextTopicState=this.state.topicContext;this.state.topicContext={maxNumOfResolvableTopics:1,maxTopicIndex:null};try{return callback()}finally{this.state.topicContext=outerContextTopicState;}}withSmartMixTopicForbiddingContext(callback){if(!this.hasPlugin(["pipelineOperator",{proposal:"smart"}]))return callback();{const outerContextTopicState=this.state.topicContext;this.state.topicContext={maxNumOfResolvableTopics:0,maxTopicIndex:null};try{return callback()}finally{this.state.topicContext=outerContextTopicState;}}}withSoloAwaitPermittingContext(callback){const outerContextSoloAwaitState=this.state.soloAwait;this.state.soloAwait=!0;try{return callback()}finally{this.state.soloAwait=outerContextSoloAwaitState;}}allowInAnd(callback){const flags=this.prodParam.currentFlags();if(8&~flags){this.prodParam.enter(8|flags);try{return callback()}finally{this.prodParam.exit();}}return callback()}disallowInAnd(callback){const flags=this.prodParam.currentFlags();if(8&flags){this.prodParam.enter(-9&flags);try{return callback()}finally{this.prodParam.exit();}}return callback()}registerTopicReference(){this.state.topicContext.maxTopicIndex=0;}topicReferenceIsAllowedInCurrentContext(){return this.state.topicContext.maxNumOfResolvableTopics>=1}topicReferenceWasUsedInCurrentContext(){return null!=this.state.topicContext.maxTopicIndex&&this.state.topicContext.maxTopicIndex>=0}parseFSharpPipelineBody(prec){const startPos=this.state.start,startLoc=this.state.startLoc;this.state.potentialArrowAt=this.state.start;const oldInFSharpPipelineDirectBody=this.state.inFSharpPipelineDirectBody;this.state.inFSharpPipelineDirectBody=!0;const ret=this.parseExprOp(this.parseMaybeUnaryOrPrivate(),startPos,startLoc,prec);return this.state.inFSharpPipelineDirectBody=oldInFSharpPipelineDirectBody,ret}parseModuleExpression(){this.expectPlugin("moduleBlocks");const node=this.startNode();this.next(),this.eat(5);const revertScopes=this.initializeScopes(!0);this.enterInitialScopes();const program=this.startNode();try{node.body=this.parseProgram(program,8,"module");}finally{revertScopes();}return this.eat(8),this.finishNode(node,"ModuleExpression")}parsePropertyNamePrefixOperator(prop){}}{parseTopLevel(file,program){return file.program=this.parseProgram(program),file.comments=this.state.comments,this.options.tokens&&(file.tokens=function(tokens,input){for(let i=0;i<tokens.length;i++){const token=tokens[i],{type}=token;if("number"==typeof type){if(130===type){const{loc,start,value,end}=token,hashEndPos=start+1,hashEndLoc=createPositionWithColumnOffset(loc.start,1);tokens.splice(i,1,new Token({type:getExportedToken(27),value:"#",start,end:hashEndPos,startLoc:loc.start,endLoc:hashEndLoc}),new Token({type:getExportedToken(124),value,start:hashEndPos,end,startLoc:hashEndLoc,endLoc:loc.end})),i++;continue}if(tokenIsTemplate(type)){const{loc,start,value,end}=token,backquoteEnd=start+1,backquoteEndLoc=createPositionWithColumnOffset(loc.start,1);let startToken,templateValue,templateElementEnd,templateElementEndLoc,endToken;startToken=96===input.charCodeAt(start)?new Token({type:getExportedToken(22),value:"`",start,end:backquoteEnd,startLoc:loc.start,endLoc:backquoteEndLoc}):new Token({type:getExportedToken(8),value:"}",start,end:backquoteEnd,startLoc:loc.start,endLoc:backquoteEndLoc}),24===type?(templateElementEnd=end-1,templateElementEndLoc=createPositionWithColumnOffset(loc.end,-1),templateValue=null===value?null:value.slice(1,-1),endToken=new Token({type:getExportedToken(22),value:"`",start:templateElementEnd,end,startLoc:templateElementEndLoc,endLoc:loc.end})):(templateElementEnd=end-2,templateElementEndLoc=createPositionWithColumnOffset(loc.end,-2),templateValue=null===value?null:value.slice(1,-2),endToken=new Token({type:getExportedToken(23),value:"${",start:templateElementEnd,end,startLoc:templateElementEndLoc,endLoc:loc.end})),tokens.splice(i,1,startToken,new Token({type:getExportedToken(20),value:templateValue,start:backquoteEnd,end:templateElementEnd,startLoc:backquoteEndLoc,endLoc:templateElementEndLoc}),endToken),i+=2;continue}token.type=getExportedToken(type);}}return tokens}(this.tokens,this.input)),this.finishNode(file,"File")}parseProgram(program,end=131,sourceType=this.options.sourceType){if(program.sourceType=sourceType,program.interpreter=this.parseInterpreterDirective(),this.parseBlockBody(program,!0,!0,end),this.inModule&&!this.options.allowUndeclaredExports&&this.scope.undefinedExports.size>0)for(const[name,loc]of Array.from(this.scope.undefinedExports))this.raise(ErrorMessages.ModuleExportUndefined,{at:loc},name);return this.finishNode(program,"Program")}stmtToDirective(stmt){const directive=stmt;directive.type="Directive",directive.value=directive.expression,delete directive.expression;const directiveLiteral=directive.value,expressionValue=directiveLiteral.value,raw=this.input.slice(directiveLiteral.start,directiveLiteral.end),val=directiveLiteral.value=raw.slice(1,-1);return this.addExtra(directiveLiteral,"raw",raw),this.addExtra(directiveLiteral,"rawValue",val),this.addExtra(directiveLiteral,"expressionValue",expressionValue),directiveLiteral.type="DirectiveLiteral",directive}parseInterpreterDirective(){if(!this.match(28))return null;const node=this.startNode();return node.value=this.state.value,this.next(),this.finishNode(node,"InterpreterDirective")}isLet(context){return !!this.isContextual(95)&&this.isLetKeyword(context)}isLetKeyword(context){const next=this.nextTokenStart(),nextCh=this.codePointAtPos(next);if(92===nextCh||91===nextCh)return !0;if(context)return !1;if(123===nextCh)return !0;if(isIdentifierStart(nextCh)){if(keywordRelationalOperator.lastIndex=next,keywordRelationalOperator.test(this.input)){const endCh=this.codePointAtPos(keywordRelationalOperator.lastIndex);if(!isIdentifierChar(endCh)&&92!==endCh)return !1}return !0}return !1}parseStatement(context,topLevel){return this.match(26)&&this.parseDecorators(!0),this.parseStatementContent(context,topLevel)}parseStatementContent(context,topLevel){let starttype=this.state.type;const node=this.startNode();let kind;switch(this.isLet(context)&&(starttype=70,kind="let"),starttype){case 56:return this.parseBreakContinueStatement(node,!0);case 59:return this.parseBreakContinueStatement(node,!1);case 60:return this.parseDebuggerStatement(node);case 86:return this.parseDoStatement(node);case 87:return this.parseForStatement(node);case 64:if(46===this.lookaheadCharCode())break;return context&&(this.state.strict?this.raise(ErrorMessages.StrictFunction,{at:this.state.startLoc}):"if"!==context&&"label"!==context&&this.raise(ErrorMessages.SloppyFunction,{at:this.state.startLoc})),this.parseFunctionStatement(node,!1,!context);case 76:return context&&this.unexpected(),this.parseClass(node,!0);case 65:return this.parseIfStatement(node);case 66:return this.parseReturnStatement(node);case 67:return this.parseSwitchStatement(node);case 68:return this.parseThrowStatement(node);case 69:return this.parseTryStatement(node);case 71:case 70:return kind=kind||this.state.value,context&&"var"!==kind&&this.raise(ErrorMessages.UnexpectedLexicalDeclaration,{at:this.state.startLoc}),this.parseVarStatement(node,kind);case 88:return this.parseWhileStatement(node);case 72:return this.parseWithStatement(node);case 5:return this.parseBlock();case 13:return this.parseEmptyStatement(node);case 79:{const nextTokenCharCode=this.lookaheadCharCode();if(40===nextTokenCharCode||46===nextTokenCharCode)break}case 78:{let result;return this.options.allowImportExportEverywhere||topLevel||this.raise(ErrorMessages.UnexpectedImportExport,{at:this.state.startLoc}),this.next(),79===starttype?(result=this.parseImport(node),"ImportDeclaration"!==result.type||result.importKind&&"value"!==result.importKind||(this.sawUnambiguousESM=!0)):(result=this.parseExport(node),("ExportNamedDeclaration"!==result.type||result.exportKind&&"value"!==result.exportKind)&&("ExportAllDeclaration"!==result.type||result.exportKind&&"value"!==result.exportKind)&&"ExportDefaultDeclaration"!==result.type||(this.sawUnambiguousESM=!0)),this.assertModuleNodeAllowed(node),result}default:if(this.isAsyncFunction())return context&&this.raise(ErrorMessages.AsyncFunctionInSingleStatementContext,{at:this.state.startLoc}),this.next(),this.parseFunctionStatement(node,!0,!context)}const maybeName=this.state.value,expr=this.parseExpression();return tokenIsIdentifier(starttype)&&"Identifier"===expr.type&&this.eat(14)?this.parseLabeledStatement(node,maybeName,expr,context):this.parseExpressionStatement(node,expr)}assertModuleNodeAllowed(node){this.options.allowImportExportEverywhere||this.inModule||this.raise(SourceTypeModuleErrorMessages.ImportOutsideModule,{node});}takeDecorators(node){const decorators=this.state.decoratorStack[this.state.decoratorStack.length-1];decorators.length&&(node.decorators=decorators,this.resetStartLocationFromNode(node,decorators[0]),this.state.decoratorStack[this.state.decoratorStack.length-1]=[]);}canHaveLeadingDecorator(){return this.match(76)}parseDecorators(allowExport){const currentContextDecorators=this.state.decoratorStack[this.state.decoratorStack.length-1];for(;this.match(26);){const decorator=this.parseDecorator();currentContextDecorators.push(decorator);}if(this.match(78))allowExport||this.unexpected(),this.hasPlugin("decorators")&&!this.getPluginOption("decorators","decoratorsBeforeExport")&&this.raise(ErrorMessages.DecoratorExportClass,{at:this.state.startLoc});else if(!this.canHaveLeadingDecorator())throw this.raise(ErrorMessages.UnexpectedLeadingDecorator,{at:this.state.startLoc})}parseDecorator(){this.expectOnePlugin(["decorators-legacy","decorators"]);const node=this.startNode();if(this.next(),this.hasPlugin("decorators")){this.state.decoratorStack.push([]);const startPos=this.state.start,startLoc=this.state.startLoc;let expr;if(this.eat(10))expr=this.parseExpression(),this.expect(11);else for(expr=this.parseIdentifier(!1);this.eat(16);){const node=this.startNodeAt(startPos,startLoc);node.object=expr,node.property=this.parseIdentifier(!0),node.computed=!1,expr=this.finishNode(node,"MemberExpression");}node.expression=this.parseMaybeDecoratorArguments(expr),this.state.decoratorStack.pop();}else node.expression=this.parseExprSubscripts();return this.finishNode(node,"Decorator")}parseMaybeDecoratorArguments(expr){if(this.eat(10)){const node=this.startNodeAtNode(expr);return node.callee=expr,node.arguments=this.parseCallExpressionArguments(11,!1),this.toReferencedList(node.arguments),this.finishNode(node,"CallExpression")}return expr}parseBreakContinueStatement(node,isBreak){return this.next(),this.isLineTerminator()?node.label=null:(node.label=this.parseIdentifier(),this.semicolon()),this.verifyBreakContinue(node,isBreak),this.finishNode(node,isBreak?"BreakStatement":"ContinueStatement")}verifyBreakContinue(node,isBreak){let i;for(i=0;i<this.state.labels.length;++i){const lab=this.state.labels[i];if(null==node.label||lab.name===node.label.name){if(null!=lab.kind&&(isBreak||"loop"===lab.kind))break;if(node.label&&isBreak)break}}i===this.state.labels.length&&this.raise(ErrorMessages.IllegalBreakContinue,{node},isBreak?"break":"continue");}parseDebuggerStatement(node){return this.next(),this.semicolon(),this.finishNode(node,"DebuggerStatement")}parseHeaderExpression(){this.expect(10);const val=this.parseExpression();return this.expect(11),val}parseDoStatement(node){return this.next(),this.state.labels.push(loopLabel),node.body=this.withSmartMixTopicForbiddingContext((()=>this.parseStatement("do"))),this.state.labels.pop(),this.expect(88),node.test=this.parseHeaderExpression(),this.eat(13),this.finishNode(node,"DoWhileStatement")}parseForStatement(node){this.next(),this.state.labels.push(loopLabel);let awaitAt=null;if(this.isAwaitAllowed()&&this.eatContextual(92)&&(awaitAt=this.state.lastTokStartLoc),this.scope.enter(0),this.expect(10),this.match(13))return null!==awaitAt&&this.unexpected(awaitAt),this.parseFor(node,null);const startsWithLet=this.isContextual(95),isLet=startsWithLet&&this.isLetKeyword();if(this.match(70)||this.match(71)||isLet){const init=this.startNode(),kind=isLet?"let":this.state.value;return this.next(),this.parseVar(init,!0,kind),this.finishNode(init,"VariableDeclaration"),(this.match(54)||this.isContextual(97))&&1===init.declarations.length?this.parseForIn(node,init,awaitAt):(null!==awaitAt&&this.unexpected(awaitAt),this.parseFor(node,init))}const startsWithAsync=this.isContextual(91),refExpressionErrors=new ExpressionErrors,init=this.parseExpression(!0,refExpressionErrors),isForOf=this.isContextual(97);if(isForOf&&(startsWithLet&&this.raise(ErrorMessages.ForOfLet,{node:init}),null===awaitAt&&startsWithAsync&&"Identifier"===init.type&&this.raise(ErrorMessages.ForOfAsync,{node:init})),isForOf||this.match(54)){this.toAssignable(init,!0);const description=isForOf?"for-of statement":"for-in statement";return this.checkLVal(init,description),this.parseForIn(node,init,awaitAt)}return this.checkExpressionErrors(refExpressionErrors,!0),null!==awaitAt&&this.unexpected(awaitAt),this.parseFor(node,init)}parseFunctionStatement(node,isAsync,declarationPosition){return this.next(),this.parseFunction(node,1|(declarationPosition?0:2),isAsync)}parseIfStatement(node){return this.next(),node.test=this.parseHeaderExpression(),node.consequent=this.parseStatement("if"),node.alternate=this.eat(62)?this.parseStatement("if"):null,this.finishNode(node,"IfStatement")}parseReturnStatement(node){return this.prodParam.hasReturn||this.options.allowReturnOutsideFunction||this.raise(ErrorMessages.IllegalReturn,{at:this.state.startLoc}),this.next(),this.isLineTerminator()?node.argument=null:(node.argument=this.parseExpression(),this.semicolon()),this.finishNode(node,"ReturnStatement")}parseSwitchStatement(node){this.next(),node.discriminant=this.parseHeaderExpression();const cases=node.cases=[];let cur,sawDefault;for(this.expect(5),this.state.labels.push(switchLabel),this.scope.enter(0);!this.match(8);)if(this.match(57)||this.match(61)){const isCase=this.match(57);cur&&this.finishNode(cur,"SwitchCase"),cases.push(cur=this.startNode()),cur.consequent=[],this.next(),isCase?cur.test=this.parseExpression():(sawDefault&&this.raise(ErrorMessages.MultipleDefaultsInSwitch,{at:this.state.lastTokStartLoc}),sawDefault=!0,cur.test=null),this.expect(14);}else cur?cur.consequent.push(this.parseStatement(null)):this.unexpected();return this.scope.exit(),cur&&this.finishNode(cur,"SwitchCase"),this.next(),this.state.labels.pop(),this.finishNode(node,"SwitchStatement")}parseThrowStatement(node){return this.next(),this.hasPrecedingLineBreak()&&this.raise(ErrorMessages.NewlineAfterThrow,{at:this.state.lastTokEndLoc}),node.argument=this.parseExpression(),this.semicolon(),this.finishNode(node,"ThrowStatement")}parseCatchClauseParam(){const param=this.parseBindingAtom(),simple="Identifier"===param.type;return this.scope.enter(simple?8:0),this.checkLVal(param,"catch clause",9),param}parseTryStatement(node){if(this.next(),node.block=this.parseBlock(),node.handler=null,this.match(58)){const clause=this.startNode();this.next(),this.match(10)?(this.expect(10),clause.param=this.parseCatchClauseParam(),this.expect(11)):(clause.param=null,this.scope.enter(0)),clause.body=this.withSmartMixTopicForbiddingContext((()=>this.parseBlock(!1,!1))),this.scope.exit(),node.handler=this.finishNode(clause,"CatchClause");}return node.finalizer=this.eat(63)?this.parseBlock():null,node.handler||node.finalizer||this.raise(ErrorMessages.NoCatchOrFinally,{node}),this.finishNode(node,"TryStatement")}parseVarStatement(node,kind){return this.next(),this.parseVar(node,!1,kind),this.semicolon(),this.finishNode(node,"VariableDeclaration")}parseWhileStatement(node){return this.next(),node.test=this.parseHeaderExpression(),this.state.labels.push(loopLabel),node.body=this.withSmartMixTopicForbiddingContext((()=>this.parseStatement("while"))),this.state.labels.pop(),this.finishNode(node,"WhileStatement")}parseWithStatement(node){return this.state.strict&&this.raise(ErrorMessages.StrictWith,{at:this.state.startLoc}),this.next(),node.object=this.parseHeaderExpression(),node.body=this.withSmartMixTopicForbiddingContext((()=>this.parseStatement("with"))),this.finishNode(node,"WithStatement")}parseEmptyStatement(node){return this.next(),this.finishNode(node,"EmptyStatement")}parseLabeledStatement(node,maybeName,expr,context){for(const label of this.state.labels)label.name===maybeName&&this.raise(ErrorMessages.LabelRedeclaration,{node:expr},maybeName);const kind=(token=this.state.type)>=86&&token<=88?"loop":this.match(67)?"switch":null;var token;for(let i=this.state.labels.length-1;i>=0;i--){const label=this.state.labels[i];if(label.statementStart!==node.start)break;label.statementStart=this.state.start,label.kind=kind;}return this.state.labels.push({name:maybeName,kind,statementStart:this.state.start}),node.body=this.parseStatement(context?-1===context.indexOf("label")?context+"label":context:"label"),this.state.labels.pop(),node.label=expr,this.finishNode(node,"LabeledStatement")}parseExpressionStatement(node,expr){return node.expression=expr,this.semicolon(),this.finishNode(node,"ExpressionStatement")}parseBlock(allowDirectives=!1,createNewLexicalScope=!0,afterBlockParse){const node=this.startNode();return allowDirectives&&this.state.strictErrors.clear(),this.expect(5),createNewLexicalScope&&this.scope.enter(0),this.parseBlockBody(node,allowDirectives,!1,8,afterBlockParse),createNewLexicalScope&&this.scope.exit(),this.finishNode(node,"BlockStatement")}isValidDirective(stmt){return "ExpressionStatement"===stmt.type&&"StringLiteral"===stmt.expression.type&&!stmt.expression.extra.parenthesized}parseBlockBody(node,allowDirectives,topLevel,end,afterBlockParse){const body=node.body=[],directives=node.directives=[];this.parseBlockOrModuleBlockBody(body,allowDirectives?directives:void 0,topLevel,end,afterBlockParse);}parseBlockOrModuleBlockBody(body,directives,topLevel,end,afterBlockParse){const oldStrict=this.state.strict;let hasStrictModeDirective=!1,parsedNonDirective=!1;for(;!this.match(end);){const stmt=this.parseStatement(null,topLevel);if(directives&&!parsedNonDirective){if(this.isValidDirective(stmt)){const directive=this.stmtToDirective(stmt);directives.push(directive),hasStrictModeDirective||"use strict"!==directive.value.value||(hasStrictModeDirective=!0,this.setStrict(!0));continue}parsedNonDirective=!0,this.state.strictErrors.clear();}body.push(stmt);}afterBlockParse&&afterBlockParse.call(this,hasStrictModeDirective),oldStrict||this.setStrict(!1),this.next();}parseFor(node,init){return node.init=init,this.semicolon(!1),node.test=this.match(13)?null:this.parseExpression(),this.semicolon(!1),node.update=this.match(11)?null:this.parseExpression(),this.expect(11),node.body=this.withSmartMixTopicForbiddingContext((()=>this.parseStatement("for"))),this.scope.exit(),this.state.labels.pop(),this.finishNode(node,"ForStatement")}parseForIn(node,init,awaitAt){const isForIn=this.match(54);return this.next(),isForIn?null!==awaitAt&&this.unexpected(awaitAt):node.await=null!==awaitAt,"VariableDeclaration"!==init.type||null==init.declarations[0].init||isForIn&&!this.state.strict&&"var"===init.kind&&"Identifier"===init.declarations[0].id.type||this.raise(ErrorMessages.ForInOfLoopInitializer,{node:init},isForIn?"for-in":"for-of"),"AssignmentPattern"===init.type&&this.raise(ErrorMessages.InvalidLhs,{node:init},"for-loop"),node.left=init,node.right=isForIn?this.parseExpression():this.parseMaybeAssignAllowIn(),this.expect(11),node.body=this.withSmartMixTopicForbiddingContext((()=>this.parseStatement("for"))),this.scope.exit(),this.state.labels.pop(),this.finishNode(node,isForIn?"ForInStatement":"ForOfStatement")}parseVar(node,isFor,kind){const declarations=node.declarations=[],isTypescript=this.hasPlugin("typescript");for(node.kind=kind;;){const decl=this.startNode();if(this.parseVarId(decl,kind),this.eat(29)?decl.init=isFor?this.parseMaybeAssignDisallowIn():this.parseMaybeAssignAllowIn():("const"!==kind||this.match(54)||this.isContextual(97)?"Identifier"===decl.id.type||isFor&&(this.match(54)||this.isContextual(97))||this.raise(ErrorMessages.DeclarationMissingInitializer,{at:this.state.lastTokEndLoc},"Complex binding patterns"):isTypescript||this.raise(ErrorMessages.DeclarationMissingInitializer,{at:this.state.lastTokEndLoc},"Const declarations"),decl.init=null),declarations.push(this.finishNode(decl,"VariableDeclarator")),!this.eat(12))break}return node}parseVarId(decl,kind){decl.id=this.parseBindingAtom(),this.checkLVal(decl.id,"variable declaration","var"===kind?5:9,void 0,"var"!==kind);}parseFunction(node,statement=0,isAsync=!1){const isStatement=1&statement,isHangingStatement=2&statement,requireId=!(!isStatement||4&statement);this.initFunction(node,isAsync),this.match(51)&&isHangingStatement&&this.raise(ErrorMessages.GeneratorInSingleStatementContext,{at:this.state.startLoc}),node.generator=this.eat(51),isStatement&&(node.id=this.parseFunctionId(requireId));const oldMaybeInArrowParameters=this.state.maybeInArrowParameters;return this.state.maybeInArrowParameters=!1,this.scope.enter(2),this.prodParam.enter(functionFlags(isAsync,node.generator)),isStatement||(node.id=this.parseFunctionId()),this.parseFunctionParams(node,!1),this.withSmartMixTopicForbiddingContext((()=>{this.parseFunctionBodyAndFinish(node,isStatement?"FunctionDeclaration":"FunctionExpression");})),this.prodParam.exit(),this.scope.exit(),isStatement&&!isHangingStatement&&this.registerFunctionStatementId(node),this.state.maybeInArrowParameters=oldMaybeInArrowParameters,node}parseFunctionId(requireId){return requireId||tokenIsIdentifier(this.state.type)?this.parseIdentifier():null}parseFunctionParams(node,allowModifiers){this.expect(10),this.expressionScope.enter(new ExpressionScope(3)),node.params=this.parseBindingList(11,41,!1,allowModifiers),this.expressionScope.exit();}registerFunctionStatementId(node){node.id&&this.scope.declareName(node.id.name,this.state.strict||node.generator||node.async?this.scope.treatFunctionsAsVar?5:9:17,node.id.loc.start);}parseClass(node,isStatement,optionalId){this.next(),this.takeDecorators(node);const oldStrict=this.state.strict;return this.state.strict=!0,this.parseClassId(node,isStatement,optionalId),this.parseClassSuper(node),node.body=this.parseClassBody(!!node.superClass,oldStrict),this.finishNode(node,isStatement?"ClassDeclaration":"ClassExpression")}isClassProperty(){return this.match(29)||this.match(13)||this.match(8)}isClassMethod(){return this.match(10)}isNonstaticConstructor(method){return !(method.computed||method.static||"constructor"!==method.key.name&&"constructor"!==method.key.value)}parseClassBody(hadSuperClass,oldStrict){this.classScope.enter();const state={hadConstructor:!1,hadSuperClass};let decorators=[];const classBody=this.startNode();if(classBody.body=[],this.expect(5),this.withSmartMixTopicForbiddingContext((()=>{for(;!this.match(8);){if(this.eat(13)){if(decorators.length>0)throw this.raise(ErrorMessages.DecoratorSemicolon,{at:this.state.lastTokEndLoc});continue}if(this.match(26)){decorators.push(this.parseDecorator());continue}const member=this.startNode();decorators.length&&(member.decorators=decorators,this.resetStartLocationFromNode(member,decorators[0]),decorators=[]),this.parseClassMember(classBody,member,state),"constructor"===member.kind&&member.decorators&&member.decorators.length>0&&this.raise(ErrorMessages.DecoratorConstructor,{node:member});}})),this.state.strict=oldStrict,this.next(),decorators.length)throw this.raise(ErrorMessages.TrailingDecorator,{at:this.state.startLoc});return this.classScope.exit(),this.finishNode(classBody,"ClassBody")}parseClassMemberFromModifier(classBody,member){const key=this.parseIdentifier(!0);if(this.isClassMethod()){const method=member;return method.kind="method",method.computed=!1,method.key=key,method.static=!1,this.pushClassMethod(classBody,method,!1,!1,!1,!1),!0}if(this.isClassProperty()){const prop=member;return prop.computed=!1,prop.key=key,prop.static=!1,classBody.body.push(this.parseClassProperty(prop)),!0}return this.resetPreviousNodeTrailingComments(key),!1}parseClassMember(classBody,member,state){const isStatic=this.isContextual(100);if(isStatic){if(this.parseClassMemberFromModifier(classBody,member))return;if(this.eat(5))return void this.parseClassStaticBlock(classBody,member)}this.parseClassMemberWithIsStatic(classBody,member,state,isStatic);}parseClassMemberWithIsStatic(classBody,member,state,isStatic){const publicMethod=member,privateMethod=member,publicProp=member,privateProp=member,method=publicMethod,publicMember=publicMethod;if(member.static=isStatic,this.parsePropertyNamePrefixOperator(member),this.eat(51)){method.kind="method";const isPrivateName=this.match(130);return this.parseClassElementName(method),isPrivateName?void this.pushClassPrivateMethod(classBody,privateMethod,!0,!1):(this.isNonstaticConstructor(publicMethod)&&this.raise(ErrorMessages.ConstructorIsGenerator,{node:publicMethod.key}),void this.pushClassMethod(classBody,publicMethod,!0,!1,!1,!1))}const isContextual=tokenIsIdentifier(this.state.type)&&!this.state.containsEsc,isPrivate=this.match(130),key=this.parseClassElementName(member),maybeQuestionTokenStartLoc=this.state.startLoc;if(this.parsePostMemberNameModifiers(publicMember),this.isClassMethod()){if(method.kind="method",isPrivate)return void this.pushClassPrivateMethod(classBody,privateMethod,!1,!1);const isConstructor=this.isNonstaticConstructor(publicMethod);let allowsDirectSuper=!1;isConstructor&&(publicMethod.kind="constructor",state.hadConstructor&&!this.hasPlugin("typescript")&&this.raise(ErrorMessages.DuplicateConstructor,{node:key}),isConstructor&&this.hasPlugin("typescript")&&member.override&&this.raise(ErrorMessages.OverrideOnConstructor,{node:key}),state.hadConstructor=!0,allowsDirectSuper=state.hadSuperClass),this.pushClassMethod(classBody,publicMethod,!1,!1,isConstructor,allowsDirectSuper);}else if(this.isClassProperty())isPrivate?this.pushClassPrivateProperty(classBody,privateProp):this.pushClassProperty(classBody,publicProp);else if(isContextual&&"async"===key.name&&!this.isLineTerminator()){this.resetPreviousNodeTrailingComments(key);const isGenerator=this.eat(51);publicMember.optional&&this.unexpected(maybeQuestionTokenStartLoc),method.kind="method";const isPrivate=this.match(130);this.parseClassElementName(method),this.parsePostMemberNameModifiers(publicMember),isPrivate?this.pushClassPrivateMethod(classBody,privateMethod,isGenerator,!0):(this.isNonstaticConstructor(publicMethod)&&this.raise(ErrorMessages.ConstructorIsAsync,{node:publicMethod.key}),this.pushClassMethod(classBody,publicMethod,isGenerator,!0,!1,!1));}else if(!isContextual||"get"!==key.name&&"set"!==key.name||this.match(51)&&this.isLineTerminator())this.isLineTerminator()?isPrivate?this.pushClassPrivateProperty(classBody,privateProp):this.pushClassProperty(classBody,publicProp):this.unexpected();else {this.resetPreviousNodeTrailingComments(key),method.kind=key.name;const isPrivate=this.match(130);this.parseClassElementName(publicMethod),isPrivate?this.pushClassPrivateMethod(classBody,privateMethod,!1,!1):(this.isNonstaticConstructor(publicMethod)&&this.raise(ErrorMessages.ConstructorIsAccessor,{node:publicMethod.key}),this.pushClassMethod(classBody,publicMethod,!1,!1,!1,!1)),this.checkGetterSetterParams(publicMethod);}}parseClassElementName(member){const{type,value}=this.state;if(124!==type&&125!==type||!member.static||"prototype"!==value||this.raise(ErrorMessages.StaticPrototype,{at:this.state.startLoc}),130===type){"constructor"===value&&this.raise(ErrorMessages.ConstructorClassPrivateField,{at:this.state.startLoc});const key=this.parsePrivateName();return member.key=key,key}return this.parsePropertyName(member)}parseClassStaticBlock(classBody,member){var _member$decorators;this.scope.enter(208);const oldLabels=this.state.labels;this.state.labels=[],this.prodParam.enter(0);const body=member.body=[];this.parseBlockOrModuleBlockBody(body,void 0,!1,8),this.prodParam.exit(),this.scope.exit(),this.state.labels=oldLabels,classBody.body.push(this.finishNode(member,"StaticBlock")),null!=(_member$decorators=member.decorators)&&_member$decorators.length&&this.raise(ErrorMessages.DecoratorStaticBlock,{node:member});}pushClassProperty(classBody,prop){prop.computed||"constructor"!==prop.key.name&&"constructor"!==prop.key.value||this.raise(ErrorMessages.ConstructorClassField,{node:prop.key}),classBody.body.push(this.parseClassProperty(prop));}pushClassPrivateProperty(classBody,prop){const node=this.parseClassPrivateProperty(prop);classBody.body.push(node),this.classScope.declarePrivateName(this.getPrivateNameSV(node.key),0,node.key.loc.start);}pushClassMethod(classBody,method,isGenerator,isAsync,isConstructor,allowsDirectSuper){classBody.body.push(this.parseMethod(method,isGenerator,isAsync,isConstructor,allowsDirectSuper,"ClassMethod",!0));}pushClassPrivateMethod(classBody,method,isGenerator,isAsync){const node=this.parseMethod(method,isGenerator,isAsync,!1,!1,"ClassPrivateMethod",!0);classBody.body.push(node);const kind="get"===node.kind?node.static?6:2:"set"===node.kind?node.static?5:1:0;this.declareClassPrivateMethodInScope(node,kind);}declareClassPrivateMethodInScope(node,kind){this.classScope.declarePrivateName(this.getPrivateNameSV(node.key),kind,node.key.loc.start);}parsePostMemberNameModifiers(methodOrProp){}parseClassPrivateProperty(node){return this.parseInitializer(node),this.semicolon(),this.finishNode(node,"ClassPrivateProperty")}parseClassProperty(node){return this.parseInitializer(node),this.semicolon(),this.finishNode(node,"ClassProperty")}parseInitializer(node){this.scope.enter(80),this.expressionScope.enter(newExpressionScope()),this.prodParam.enter(0),node.value=this.eat(29)?this.parseMaybeAssignAllowIn():null,this.expressionScope.exit(),this.prodParam.exit(),this.scope.exit();}parseClassId(node,isStatement,optionalId,bindingType=139){if(tokenIsIdentifier(this.state.type))node.id=this.parseIdentifier(),isStatement&&this.checkLVal(node.id,"class name",bindingType);else {if(!optionalId&&isStatement)throw this.raise(ErrorMessages.MissingClassName,{at:this.state.startLoc});node.id=null;}}parseClassSuper(node){node.superClass=this.eat(77)?this.parseExprSubscripts():null;}parseExport(node){const hasDefault=this.maybeParseExportDefaultSpecifier(node),parseAfterDefault=!hasDefault||this.eat(12),hasStar=parseAfterDefault&&this.eatExportStar(node),hasNamespace=hasStar&&this.maybeParseExportNamespaceSpecifier(node),parseAfterNamespace=parseAfterDefault&&(!hasNamespace||this.eat(12)),isFromRequired=hasDefault||hasStar;if(hasStar&&!hasNamespace)return hasDefault&&this.unexpected(),this.parseExportFrom(node,!0),this.finishNode(node,"ExportAllDeclaration");const hasSpecifiers=this.maybeParseExportNamedSpecifiers(node);if(hasDefault&&parseAfterDefault&&!hasStar&&!hasSpecifiers||hasNamespace&&parseAfterNamespace&&!hasSpecifiers)throw this.unexpected(null,5);let hasDeclaration;if(isFromRequired||hasSpecifiers?(hasDeclaration=!1,this.parseExportFrom(node,isFromRequired)):hasDeclaration=this.maybeParseExportDeclaration(node),isFromRequired||hasSpecifiers||hasDeclaration)return this.checkExport(node,!0,!1,!!node.source),this.finishNode(node,"ExportNamedDeclaration");if(this.eat(61))return node.declaration=this.parseExportDefaultExpression(),this.checkExport(node,!0,!0),this.finishNode(node,"ExportDefaultDeclaration");throw this.unexpected(null,5)}eatExportStar(node){return this.eat(51)}maybeParseExportDefaultSpecifier(node){if(this.isExportDefaultSpecifier()){this.expectPlugin("exportDefaultFrom");const specifier=this.startNode();return specifier.exported=this.parseIdentifier(!0),node.specifiers=[this.finishNode(specifier,"ExportDefaultSpecifier")],!0}return !1}maybeParseExportNamespaceSpecifier(node){if(this.isContextual(89)){node.specifiers||(node.specifiers=[]);const specifier=this.startNodeAt(this.state.lastTokStart,this.state.lastTokStartLoc);return this.next(),specifier.exported=this.parseModuleExportName(),node.specifiers.push(this.finishNode(specifier,"ExportNamespaceSpecifier")),!0}return !1}maybeParseExportNamedSpecifiers(node){if(this.match(5)){node.specifiers||(node.specifiers=[]);const isTypeExport="type"===node.exportKind;return node.specifiers.push(...this.parseExportSpecifiers(isTypeExport)),node.source=null,node.declaration=null,this.hasPlugin("importAssertions")&&(node.assertions=[]),!0}return !1}maybeParseExportDeclaration(node){return !!this.shouldParseExportDeclaration()&&(node.specifiers=[],node.source=null,this.hasPlugin("importAssertions")&&(node.assertions=[]),node.declaration=this.parseExportDeclaration(node),!0)}isAsyncFunction(){if(!this.isContextual(91))return !1;const next=this.nextTokenStart();return !lineBreak.test(this.input.slice(this.state.pos,next))&&this.isUnparsedContextual(next,"function")}parseExportDefaultExpression(){const expr=this.startNode(),isAsync=this.isAsyncFunction();if(this.match(64)||isAsync)return this.next(),isAsync&&this.next(),this.parseFunction(expr,5,isAsync);if(this.match(76))return this.parseClass(expr,!0,!0);if(this.match(26))return this.hasPlugin("decorators")&&this.getPluginOption("decorators","decoratorsBeforeExport")&&this.raise(ErrorMessages.DecoratorBeforeExport,{at:this.state.startLoc}),this.parseDecorators(!1),this.parseClass(expr,!0,!0);if(this.match(71)||this.match(70)||this.isLet())throw this.raise(ErrorMessages.UnsupportedDefaultExport,{at:this.state.startLoc});const res=this.parseMaybeAssignAllowIn();return this.semicolon(),res}parseExportDeclaration(node){return this.parseStatement(null)}isExportDefaultSpecifier(){const{type}=this.state;if(tokenIsIdentifier(type)){if(91===type&&!this.state.containsEsc||95===type)return !1;if((122===type||121===type)&&!this.state.containsEsc){const{type:nextType}=this.lookahead();if(tokenIsIdentifier(nextType)&&93!==nextType||5===nextType)return this.expectOnePlugin(["flow","typescript"]),!1}}else if(!this.match(61))return !1;const next=this.nextTokenStart(),hasFrom=this.isUnparsedContextual(next,"from");if(44===this.input.charCodeAt(next)||tokenIsIdentifier(this.state.type)&&hasFrom)return !0;if(this.match(61)&&hasFrom){const nextAfterFrom=this.input.charCodeAt(this.nextTokenStartSince(next+4));return 34===nextAfterFrom||39===nextAfterFrom}return !1}parseExportFrom(node,expect){if(this.eatContextual(93)){node.source=this.parseImportSource(),this.checkExport(node);const assertions=this.maybeParseImportAssertions();assertions&&(node.assertions=assertions);}else expect&&this.unexpected();this.semicolon();}shouldParseExportDeclaration(){const{type}=this.state;if(26===type&&(this.expectOnePlugin(["decorators","decorators-legacy"]),this.hasPlugin("decorators"))){if(this.getPluginOption("decorators","decoratorsBeforeExport"))throw this.raise(ErrorMessages.DecoratorBeforeExport,{at:this.state.startLoc});return !0}return 70===type||71===type||64===type||76===type||this.isLet()||this.isAsyncFunction()}checkExport(node,checkNames,isDefault,isFrom){if(checkNames)if(isDefault){if(this.checkDuplicateExports(node,"default"),this.hasPlugin("exportDefaultFrom")){var _declaration$extra;const declaration=node.declaration;"Identifier"!==declaration.type||"from"!==declaration.name||declaration.end-declaration.start!=4||null!=(_declaration$extra=declaration.extra)&&_declaration$extra.parenthesized||this.raise(ErrorMessages.ExportDefaultFromAsIdentifier,{node:declaration});}}else if(node.specifiers&&node.specifiers.length)for(const specifier of node.specifiers){const{exported}=specifier,exportedName="Identifier"===exported.type?exported.name:exported.value;if(this.checkDuplicateExports(specifier,exportedName),!isFrom&&specifier.local){const{local}=specifier;"Identifier"!==local.type?this.raise(ErrorMessages.ExportBindingIsString,{node:specifier},local.value,exportedName):(this.checkReservedWord(local.name,local.loc.start,!0,!1),this.scope.checkLocalExport(local));}}else if(node.declaration)if("FunctionDeclaration"===node.declaration.type||"ClassDeclaration"===node.declaration.type){const id=node.declaration.id;if(!id)throw new Error("Assertion failure");this.checkDuplicateExports(node,id.name);}else if("VariableDeclaration"===node.declaration.type)for(const declaration of node.declaration.declarations)this.checkDeclaration(declaration.id);if(this.state.decoratorStack[this.state.decoratorStack.length-1].length)throw this.raise(ErrorMessages.UnsupportedDecoratorExport,{node})}checkDeclaration(node){if("Identifier"===node.type)this.checkDuplicateExports(node,node.name);else if("ObjectPattern"===node.type)for(const prop of node.properties)this.checkDeclaration(prop);else if("ArrayPattern"===node.type)for(const elem of node.elements)elem&&this.checkDeclaration(elem);else "ObjectProperty"===node.type?this.checkDeclaration(node.value):"RestElement"===node.type?this.checkDeclaration(node.argument):"AssignmentPattern"===node.type&&this.checkDeclaration(node.left);}checkDuplicateExports(node,name){this.exportedIdentifiers.has(name)&&this.raise("default"===name?ErrorMessages.DuplicateDefaultExport:ErrorMessages.DuplicateExport,{node},name),this.exportedIdentifiers.add(name);}parseExportSpecifiers(isInTypeExport){const nodes=[];let first=!0;for(this.expect(5);!this.eat(8);){if(first)first=!1;else if(this.expect(12),this.eat(8))break;const isMaybeTypeOnly=this.isContextual(122),isString=this.match(125),node=this.startNode();node.local=this.parseModuleExportName(),nodes.push(this.parseExportSpecifier(node,isString,isInTypeExport,isMaybeTypeOnly));}return nodes}parseExportSpecifier(node,isString,isInTypeExport,isMaybeTypeOnly){return this.eatContextual(89)?node.exported=this.parseModuleExportName():isString?node.exported=cloneStringLiteral(node.local):node.exported||(node.exported=cloneIdentifier(node.local)),this.finishNode(node,"ExportSpecifier")}parseModuleExportName(){if(this.match(125)){const result=this.parseStringLiteral(this.state.value),surrogate=result.value.match(loneSurrogate);return surrogate&&this.raise(ErrorMessages.ModuleExportNameHasLoneSurrogate,{node:result},surrogate[0].charCodeAt(0).toString(16)),result}return this.parseIdentifier(!0)}parseImport(node){if(node.specifiers=[],!this.match(125)){const parseNext=!this.maybeParseDefaultImportSpecifier(node)||this.eat(12),hasStar=parseNext&&this.maybeParseStarImportSpecifier(node);parseNext&&!hasStar&&this.parseNamedImportSpecifiers(node),this.expectContextual(93);}node.source=this.parseImportSource();const assertions=this.maybeParseImportAssertions();if(assertions)node.assertions=assertions;else {const attributes=this.maybeParseModuleAttributes();attributes&&(node.attributes=attributes);}return this.semicolon(),this.finishNode(node,"ImportDeclaration")}parseImportSource(){return this.match(125)||this.unexpected(),this.parseExprAtom()}shouldParseDefaultImport(node){return tokenIsIdentifier(this.state.type)}parseImportSpecifierLocal(node,specifier,type,contextDescription){specifier.local=this.parseIdentifier(),this.checkLVal(specifier.local,contextDescription,9),node.specifiers.push(this.finishNode(specifier,type));}parseAssertEntries(){const attrs=[],attrNames=new Set;do{if(this.match(8))break;const node=this.startNode(),keyName=this.state.value;if(attrNames.has(keyName)&&this.raise(ErrorMessages.ModuleAttributesWithDuplicateKeys,{at:this.state.startLoc},keyName),attrNames.add(keyName),this.match(125)?node.key=this.parseStringLiteral(keyName):node.key=this.parseIdentifier(!0),this.expect(14),!this.match(125))throw this.raise(ErrorMessages.ModuleAttributeInvalidValue,{at:this.state.startLoc});node.value=this.parseStringLiteral(this.state.value),this.finishNode(node,"ImportAttribute"),attrs.push(node);}while(this.eat(12));return attrs}maybeParseModuleAttributes(){if(!this.match(72)||this.hasPrecedingLineBreak())return this.hasPlugin("moduleAttributes")?[]:null;this.expectPlugin("moduleAttributes"),this.next();const attrs=[],attributes=new Set;do{const node=this.startNode();if(node.key=this.parseIdentifier(!0),"type"!==node.key.name&&this.raise(ErrorMessages.ModuleAttributeDifferentFromType,{node:node.key},node.key.name),attributes.has(node.key.name)&&this.raise(ErrorMessages.ModuleAttributesWithDuplicateKeys,{node:node.key},node.key.name),attributes.add(node.key.name),this.expect(14),!this.match(125))throw this.raise(ErrorMessages.ModuleAttributeInvalidValue,{at:this.state.startLoc});node.value=this.parseStringLiteral(this.state.value),this.finishNode(node,"ImportAttribute"),attrs.push(node);}while(this.eat(12));return attrs}maybeParseImportAssertions(){if(!this.isContextual(90)||this.hasPrecedingLineBreak())return this.hasPlugin("importAssertions")?[]:null;this.expectPlugin("importAssertions"),this.next(),this.eat(5);const attrs=this.parseAssertEntries();return this.eat(8),attrs}maybeParseDefaultImportSpecifier(node){return !!this.shouldParseDefaultImport(node)&&(this.parseImportSpecifierLocal(node,this.startNode(),"ImportDefaultSpecifier","default import specifier"),!0)}maybeParseStarImportSpecifier(node){if(this.match(51)){const specifier=this.startNode();return this.next(),this.expectContextual(89),this.parseImportSpecifierLocal(node,specifier,"ImportNamespaceSpecifier","import namespace specifier"),!0}return !1}parseNamedImportSpecifiers(node){let first=!0;for(this.expect(5);!this.eat(8);){if(first)first=!1;else {if(this.eat(14))throw this.raise(ErrorMessages.DestructureNamedImport,{at:this.state.startLoc});if(this.expect(12),this.eat(8))break}const specifier=this.startNode(),importedIsString=this.match(125),isMaybeTypeOnly=this.isContextual(122);specifier.imported=this.parseModuleExportName();const importSpecifier=this.parseImportSpecifier(specifier,importedIsString,"type"===node.importKind||"typeof"===node.importKind,isMaybeTypeOnly);node.specifiers.push(importSpecifier);}}parseImportSpecifier(specifier,importedIsString,isInTypeOnlyImport,isMaybeTypeOnly){if(this.eatContextual(89))specifier.local=this.parseIdentifier();else {const{imported}=specifier;if(importedIsString)throw this.raise(ErrorMessages.ImportBindingIsString,{node:specifier},imported.value);this.checkReservedWord(imported.name,specifier.loc.start,!0,!0),specifier.local||(specifier.local=cloneIdentifier(imported));}return this.checkLVal(specifier.local,"import specifier",9),this.finishNode(specifier,"ImportSpecifier")}isThisParam(param){return "Identifier"===param.type&&"this"===param.name}}{constructor(options,input){super(options=function(opts){const options={};for(const key of Object.keys(defaultOptions))options[key]=opts&&null!=opts[key]?opts[key]:defaultOptions[key];return options}(options),input),this.options=options,this.initializeScopes(),this.plugins=function(plugins){const pluginMap=new Map;for(const plugin of plugins){const[name,options]=Array.isArray(plugin)?plugin:[plugin,{}];pluginMap.has(name)||pluginMap.set(name,options||{});}return pluginMap}(this.options.plugins),this.filename=options.sourceFilename;}getScopeHandler(){return ScopeHandler}parse(){this.enterInitialScopes();const file=this.startNode(),program=this.startNode();return this.nextToken(),file.errors=null,this.parseTopLevel(file,program),file.errors=this.state.errors,file}}const tokTypes=function(internalTokenTypes){const tokenTypes={};for(const typeName of Object.keys(internalTokenTypes))tokenTypes[typeName]=getExportedToken(internalTokenTypes[typeName]);return tokenTypes}(tt);function getParser(options,input){let cls=Parser;return null!=options&&options.plugins&&(!function(plugins){if(hasPlugin(plugins,"decorators")){if(hasPlugin(plugins,"decorators-legacy"))throw new Error("Cannot use the decorators and decorators-legacy plugin together");const decoratorsBeforeExport=getPluginOption(plugins,"decorators","decoratorsBeforeExport");if(null==decoratorsBeforeExport)throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");if("boolean"!=typeof decoratorsBeforeExport)throw new Error("'decoratorsBeforeExport' must be a boolean.")}if(hasPlugin(plugins,"flow")&&hasPlugin(plugins,"typescript"))throw new Error("Cannot combine flow and typescript plugins.");if(hasPlugin(plugins,"placeholders")&&hasPlugin(plugins,"v8intrinsic"))throw new Error("Cannot combine placeholders and v8intrinsic plugins.");if(hasPlugin(plugins,"pipelineOperator")){const proposal=getPluginOption(plugins,"pipelineOperator","proposal");if(!PIPELINE_PROPOSALS.includes(proposal)){const proposalList=PIPELINE_PROPOSALS.map((p=>`"${p}"`)).join(", ");throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`)}const tupleSyntaxIsHash=hasPlugin(plugins,["recordAndTuple",{syntaxType:"hash"}]);if("hack"===proposal){if(hasPlugin(plugins,"placeholders"))throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");if(hasPlugin(plugins,"v8intrinsic"))throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");const topicToken=getPluginOption(plugins,"pipelineOperator","topicToken");if(!TOPIC_TOKENS.includes(topicToken)){const tokenList=TOPIC_TOKENS.map((t=>`"${t}"`)).join(", ");throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`)}if("#"===topicToken&&tupleSyntaxIsHash)throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.')}else if("smart"===proposal&&tupleSyntaxIsHash)throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.')}if(hasPlugin(plugins,"moduleAttributes")){if(hasPlugin(plugins,"importAssertions"))throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");if("may-2020"!==getPluginOption(plugins,"moduleAttributes","version"))throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.")}if(hasPlugin(plugins,"recordAndTuple")&&!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins,"recordAndTuple","syntaxType")))throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: "+RECORD_AND_TUPLE_SYNTAX_TYPES.map((p=>`'${p}'`)).join(", "));if(hasPlugin(plugins,"asyncDoExpressions")&&!hasPlugin(plugins,"doExpressions")){const error=new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");throw error.missingPlugins="doExpressions",error}}(options.plugins),cls=function(pluginsFromOptions){const pluginList=mixinPluginNames.filter((name=>hasPlugin(pluginsFromOptions,name))),key=pluginList.join("/");let cls=parserClassCache[key];if(!cls){cls=Parser;for(const plugin of pluginList)cls=mixinPlugins[plugin](cls);parserClassCache[key]=cls;}return cls}(options.plugins)),new cls(options,input)}const parserClassCache={};exports.parse=function(input,options){var _options;if("unambiguous"!==(null==(_options=options)?void 0:_options.sourceType))return getParser(options,input).parse();options=Object.assign({},options);try{options.sourceType="module";const parser=getParser(options,input),ast=parser.parse();if(parser.sawUnambiguousESM)return ast;if(parser.ambiguousScriptDifferentAst)try{return options.sourceType="script",getParser(options,input).parse()}catch(_unused){}else ast.program.sourceType="script";return ast}catch(moduleError){try{return options.sourceType="script",getParser(options,input).parse()}catch(_unused2){}throw moduleError}},exports.parseExpression=function(input,options){const parser=getParser(options,input);return parser.options.strictMode&&(parser.state.strict=!0),parser.getExpression()},exports.tokTypes=tokTypes;},"./node_modules/@babel/plugin-proposal-decorators/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _helperPluginUtils=__webpack_require__("./node_modules/@babel/helper-plugin-utils/lib/index.js"),_pluginSyntaxDecorators=__webpack_require__("./node_modules/@babel/plugin-syntax-decorators/lib/index.js"),_helperCreateClassFeaturesPlugin=__webpack_require__("./node_modules/@babel/helper-create-class-features-plugin/lib/index.js"),_transformerLegacy=__webpack_require__("./node_modules/@babel/plugin-proposal-decorators/lib/transformer-legacy.js"),_default=(0, _helperPluginUtils.declare)(((api,options)=>{api.assertVersion(7);const{legacy=!1}=options;if("boolean"!=typeof legacy)throw new Error("'legacy' must be a boolean.");const{decoratorsBeforeExport}=options;if(void 0===decoratorsBeforeExport){if(!legacy)throw new Error("The decorators plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you want to use the legacy decorators semantics, you can set the 'legacy: true' option.")}else {if(legacy)throw new Error("'decoratorsBeforeExport' can't be used with legacy decorators.");if("boolean"!=typeof decoratorsBeforeExport)throw new Error("'decoratorsBeforeExport' must be a boolean.")}return legacy?{name:"proposal-decorators",inherits:_pluginSyntaxDecorators.default,manipulateOptions({generatorOpts}){generatorOpts.decoratorsBeforeExport=decoratorsBeforeExport;},visitor:_transformerLegacy.default}:(0, _helperCreateClassFeaturesPlugin.createClassFeaturePlugin)({name:"proposal-decorators",api,feature:_helperCreateClassFeaturesPlugin.FEATURES.decorators,manipulateOptions({generatorOpts,parserOpts}){parserOpts.plugins.push(["decorators",{decoratorsBeforeExport}]),generatorOpts.decoratorsBeforeExport=decoratorsBeforeExport;}})}));exports.default=_default;},"./node_modules/@babel/plugin-proposal-decorators/lib/transformer-legacy.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _core=__webpack_require__("./node_modules/@babel/core/lib/index.js");const buildClassDecorator=(0, _core.template)("\n  DECORATOR(CLASS_REF = INNER) || CLASS_REF;\n"),buildClassPrototype=(0, _core.template)("\n  CLASS_REF.prototype;\n"),buildGetDescriptor=(0, _core.template)("\n    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);\n"),buildGetObjectInitializer=(0, _core.template)("\n    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        initializer: function(){\n            return TEMP;\n        }\n    })\n"),WARNING_CALLS=new WeakSet;function applyEnsureOrdering(path){const identDecorators=(path.isClass()?[path].concat(path.get("body.body")):path.get("properties")).reduce(((acc,prop)=>acc.concat(prop.node.decorators||[])),[]).filter((decorator=>!_core.types.isIdentifier(decorator.expression)));if(0!==identDecorators.length)return _core.types.sequenceExpression(identDecorators.map((decorator=>{const expression=decorator.expression,id=decorator.expression=path.scope.generateDeclaredUidIdentifier("dec");return _core.types.assignmentExpression("=",id,expression)})).concat([path.node]))}function hasClassDecorators(classNode){return !(!classNode.decorators||!classNode.decorators.length)}function hasMethodDecorators(body){return body.some((node=>{var _node$decorators;return null==(_node$decorators=node.decorators)?void 0:_node$decorators.length}))}function applyTargetDecorators(path,state,decoratedProps){const name=path.scope.generateDeclaredUidIdentifier(path.isClass()?"class":"obj"),exprs=decoratedProps.reduce((function(acc,node){const decorators=node.decorators||[];if(node.decorators=null,0===decorators.length)return acc;if(node.computed)throw path.buildCodeFrameError("Computed method/property decorators are not yet supported.");const property=_core.types.isLiteral(node.key)?node.key:_core.types.stringLiteral(node.key.name),target=path.isClass()&&!node.static?buildClassPrototype({CLASS_REF:name}).expression:name;if(_core.types.isClassProperty(node,{static:!1})){const descriptor=path.scope.generateDeclaredUidIdentifier("descriptor"),initializer=node.value?_core.types.functionExpression(null,[],_core.types.blockStatement([_core.types.returnStatement(node.value)])):_core.types.nullLiteral();node.value=_core.types.callExpression(state.addHelper("initializerWarningHelper"),[descriptor,_core.types.thisExpression()]),WARNING_CALLS.add(node.value),acc.push(_core.types.assignmentExpression("=",_core.types.cloneNode(descriptor),_core.types.callExpression(state.addHelper("applyDecoratedDescriptor"),[_core.types.cloneNode(target),_core.types.cloneNode(property),_core.types.arrayExpression(decorators.map((dec=>_core.types.cloneNode(dec.expression)))),_core.types.objectExpression([_core.types.objectProperty(_core.types.identifier("configurable"),_core.types.booleanLiteral(!0)),_core.types.objectProperty(_core.types.identifier("enumerable"),_core.types.booleanLiteral(!0)),_core.types.objectProperty(_core.types.identifier("writable"),_core.types.booleanLiteral(!0)),_core.types.objectProperty(_core.types.identifier("initializer"),initializer)])])));}else acc.push(_core.types.callExpression(state.addHelper("applyDecoratedDescriptor"),[_core.types.cloneNode(target),_core.types.cloneNode(property),_core.types.arrayExpression(decorators.map((dec=>_core.types.cloneNode(dec.expression)))),_core.types.isObjectProperty(node)||_core.types.isClassProperty(node,{static:!0})?buildGetObjectInitializer({TEMP:path.scope.generateDeclaredUidIdentifier("init"),TARGET:_core.types.cloneNode(target),PROPERTY:_core.types.cloneNode(property)}).expression:buildGetDescriptor({TARGET:_core.types.cloneNode(target),PROPERTY:_core.types.cloneNode(property)}).expression,_core.types.cloneNode(target)]));return acc}),[]);return _core.types.sequenceExpression([_core.types.assignmentExpression("=",_core.types.cloneNode(name),path.node),_core.types.sequenceExpression(exprs),_core.types.cloneNode(name)])}function decoratedClassToExpression({node,scope}){if(!hasClassDecorators(node)&&!hasMethodDecorators(node.body.body))return;const ref=node.id?_core.types.cloneNode(node.id):scope.generateUidIdentifier("class");return _core.types.variableDeclaration("let",[_core.types.variableDeclarator(ref,_core.types.toExpression(node))])}var _default={ExportDefaultDeclaration(path){const decl=path.get("declaration");if(!decl.isClassDeclaration())return;const replacement=decoratedClassToExpression(decl);if(replacement){const[varDeclPath]=path.replaceWithMultiple([replacement,_core.types.exportNamedDeclaration(null,[_core.types.exportSpecifier(_core.types.cloneNode(replacement.declarations[0].id),_core.types.identifier("default"))])]);decl.node.id||path.scope.registerDeclaration(varDeclPath);}},ClassDeclaration(path){const replacement=decoratedClassToExpression(path);replacement&&path.replaceWith(replacement);},ClassExpression(path,state){const decoratedClass=applyEnsureOrdering(path)||function(classPath){if(!hasClassDecorators(classPath.node))return;const decorators=classPath.node.decorators||[];classPath.node.decorators=null;const name=classPath.scope.generateDeclaredUidIdentifier("class");return decorators.map((dec=>dec.expression)).reverse().reduce((function(acc,decorator){return buildClassDecorator({CLASS_REF:_core.types.cloneNode(name),DECORATOR:_core.types.cloneNode(decorator),INNER:acc}).expression}),classPath.node)}(path)||function(path,state){if(hasMethodDecorators(path.node.body.body))return applyTargetDecorators(path,state,path.node.body.body)}(path,state);decoratedClass&&path.replaceWith(decoratedClass);},ObjectExpression(path,state){const decoratedObject=applyEnsureOrdering(path)||function(path,state){if(hasMethodDecorators(path.node.properties))return applyTargetDecorators(path,state,path.node.properties)}(path,state);decoratedObject&&path.replaceWith(decoratedObject);},AssignmentExpression(path,state){WARNING_CALLS.has(path.node.right)&&path.replaceWith(_core.types.callExpression(state.addHelper("initializerDefineProperty"),[_core.types.cloneNode(path.get("left.object").node),_core.types.stringLiteral(path.get("left.property").node.name||path.get("left.property").node.value),_core.types.cloneNode(path.get("right.arguments")[0].node),_core.types.cloneNode(path.get("right.arguments")[1].node)]));},CallExpression(path,state){3===path.node.arguments.length&&WARNING_CALLS.has(path.node.arguments[2])&&path.node.callee.name===state.addHelper("defineProperty").name&&path.replaceWith(_core.types.callExpression(state.addHelper("initializerDefineProperty"),[_core.types.cloneNode(path.get("arguments")[0].node),_core.types.cloneNode(path.get("arguments")[1].node),_core.types.cloneNode(path.get("arguments.2.arguments")[0].node),_core.types.cloneNode(path.get("arguments.2.arguments")[1].node)]));}};exports.default=_default;},"./node_modules/@babel/plugin-proposal-nullish-coalescing-operator/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _helperPluginUtils=__webpack_require__("./node_modules/@babel/helper-plugin-utils/lib/index.js"),_pluginSyntaxNullishCoalescingOperator=__webpack_require__("./node_modules/@babel/plugin-syntax-nullish-coalescing-operator/lib/index.js"),_core=__webpack_require__("./node_modules/@babel/core/lib/index.js"),_default=(0, _helperPluginUtils.declare)(((api,{loose=!1})=>{var _api$assumption;api.assertVersion(7);const noDocumentAll=null!=(_api$assumption=api.assumption("noDocumentAll"))?_api$assumption:loose;return {name:"proposal-nullish-coalescing-operator",inherits:_pluginSyntaxNullishCoalescingOperator.default,visitor:{LogicalExpression(path){const{node,scope}=path;if("??"!==node.operator)return;let ref,assignment;if(scope.isStatic(node.left))ref=node.left,assignment=_core.types.cloneNode(node.left);else {if(scope.path.isPattern())return void path.replaceWith(_core.template.ast`(() => ${path.node})()`);ref=scope.generateUidIdentifierBasedOnNode(node.left),scope.push({id:_core.types.cloneNode(ref)}),assignment=_core.types.assignmentExpression("=",ref,node.left);}path.replaceWith(_core.types.conditionalExpression(noDocumentAll?_core.types.binaryExpression("!=",assignment,_core.types.nullLiteral()):_core.types.logicalExpression("&&",_core.types.binaryExpression("!==",assignment,_core.types.nullLiteral()),_core.types.binaryExpression("!==",_core.types.cloneNode(ref),scope.buildUndefinedNode())),_core.types.cloneNode(ref),node.right));}}}}));exports.default=_default;},"./node_modules/@babel/plugin-proposal-optional-chaining/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0});var helperPluginUtils=__webpack_require__("./node_modules/@babel/helper-plugin-utils/lib/index.js"),syntaxOptionalChaining=__webpack_require__("./node_modules/@babel/plugin-syntax-optional-chaining/lib/index.js"),core=__webpack_require__("./node_modules/@babel/core/lib/index.js"),helperSkipTransparentExpressionWrappers=__webpack_require__("./node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js");function _interopDefaultLegacy(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var syntaxOptionalChaining__default=_interopDefaultLegacy(syntaxOptionalChaining);function willPathCastToBoolean(path){const maybeWrapped=findOutermostTransparentParent(path),{node,parentPath}=maybeWrapped;if(parentPath.isLogicalExpression()){const{operator,right}=parentPath.node;if("&&"===operator||"||"===operator||"??"===operator&&node===right)return willPathCastToBoolean(parentPath)}if(parentPath.isSequenceExpression()){const{expressions}=parentPath.node;return expressions[expressions.length-1]!==node||willPathCastToBoolean(parentPath)}return parentPath.isConditional({test:node})||parentPath.isUnaryExpression({operator:"!"})||parentPath.isLoop({test:node})}function findOutermostTransparentParent(path){let maybeWrapped=path;return path.findParent((p=>{if(!helperSkipTransparentExpressionWrappers.isTransparentExprWrapper(p.node))return !0;maybeWrapped=p;})),maybeWrapped}const{ast}=core.template.expression;function isSimpleMemberExpression(expression){return expression=helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(expression),core.types.isIdentifier(expression)||core.types.isSuper(expression)||core.types.isMemberExpression(expression)&&!expression.computed&&isSimpleMemberExpression(expression.object)}function transform(path,{pureGetters,noDocumentAll}){const{scope}=path,maybeWrapped=findOutermostTransparentParent(path),{parentPath}=maybeWrapped,willReplacementCastToBoolean=willPathCastToBoolean(maybeWrapped);let isDeleteOperation=!1;const parentIsCall=parentPath.isCallExpression({callee:maybeWrapped.node})&&path.isOptionalMemberExpression(),optionals=[];let optionalPath=path;if(scope.path.isPattern()&&function(path){let optionalPath=path;const{scope}=path;for(;optionalPath.isOptionalMemberExpression()||optionalPath.isOptionalCallExpression();){const{node}=optionalPath,childKey=optionalPath.isOptionalMemberExpression()?"object":"callee",childPath=helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get(childKey));if(node.optional)return !scope.isStatic(childPath.node);optionalPath=childPath;}}(optionalPath))return void path.replaceWith(core.template.ast`(() => ${path.node})()`);for(;optionalPath.isOptionalMemberExpression()||optionalPath.isOptionalCallExpression();){const{node}=optionalPath;node.optional&&optionals.push(node),optionalPath.isOptionalMemberExpression()?(optionalPath.node.type="MemberExpression",optionalPath=helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("object"))):optionalPath.isOptionalCallExpression()&&(optionalPath.node.type="CallExpression",optionalPath=helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("callee")));}let replacementPath=path;parentPath.isUnaryExpression({operator:"delete"})&&(replacementPath=parentPath,isDeleteOperation=!0);for(let i=optionals.length-1;i>=0;i--){const node=optionals[i],isCall=core.types.isCallExpression(node),replaceKey=isCall?"callee":"object",chainWithTypes=node[replaceKey],chain=helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(chainWithTypes);let ref,check;if(isCall&&core.types.isIdentifier(chain,{name:"eval"})?(check=ref=chain,node[replaceKey]=core.types.sequenceExpression([core.types.numericLiteral(0),ref])):pureGetters&&isCall&&isSimpleMemberExpression(chain)?check=ref=chainWithTypes:(ref=scope.maybeGenerateMemoised(chain),ref?(check=core.types.assignmentExpression("=",core.types.cloneNode(ref),chainWithTypes),node[replaceKey]=ref):check=ref=chainWithTypes),isCall&&core.types.isMemberExpression(chain))if(pureGetters&&isSimpleMemberExpression(chain))node.callee=chainWithTypes;else {const{object}=chain;let context=scope.maybeGenerateMemoised(object);context?chain.object=core.types.assignmentExpression("=",context,object):context=core.types.isSuper(object)?core.types.thisExpression():object,node.arguments.unshift(core.types.cloneNode(context)),node.callee=core.types.memberExpression(node.callee,core.types.identifier("call"));}let replacement=replacementPath.node;if(0===i&&parentIsCall){var _baseRef;const object=helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(replacement.object);let baseRef;pureGetters&&isSimpleMemberExpression(object)||(baseRef=scope.maybeGenerateMemoised(object),baseRef&&(replacement.object=core.types.assignmentExpression("=",baseRef,object))),replacement=core.types.callExpression(core.types.memberExpression(replacement,core.types.identifier("bind")),[core.types.cloneNode(null!=(_baseRef=baseRef)?_baseRef:object)]);}if(willReplacementCastToBoolean){const nonNullishCheck=noDocumentAll?ast`${core.types.cloneNode(check)} != null`:ast`
            ${core.types.cloneNode(check)} !== null && ${core.types.cloneNode(ref)} !== void 0`;replacementPath.replaceWith(core.types.logicalExpression("&&",nonNullishCheck,replacement)),replacementPath=helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(replacementPath.get("right"));}else {const nullishCheck=noDocumentAll?ast`${core.types.cloneNode(check)} == null`:ast`
            ${core.types.cloneNode(check)} === null || ${core.types.cloneNode(ref)} === void 0`,returnValue=isDeleteOperation?ast`true`:ast`void 0`;replacementPath.replaceWith(core.types.conditionalExpression(nullishCheck,returnValue,replacement)),replacementPath=helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(replacementPath.get("alternate"));}}}var index=helperPluginUtils.declare(((api,options)=>{var _api$assumption,_api$assumption2;api.assertVersion(7);const{loose=!1}=options,noDocumentAll=null!=(_api$assumption=api.assumption("noDocumentAll"))?_api$assumption:loose,pureGetters=null!=(_api$assumption2=api.assumption("pureGetters"))?_api$assumption2:loose;return {name:"proposal-optional-chaining",inherits:syntaxOptionalChaining__default.default.default,visitor:{"OptionalCallExpression|OptionalMemberExpression"(path){transform(path,{noDocumentAll,pureGetters});}}}}));exports.default=index,exports.transform=transform;},"./node_modules/@babel/plugin-syntax-class-properties/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _default=(0, __webpack_require__("./node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((api=>(api.assertVersion(7),{name:"syntax-class-properties",manipulateOptions(opts,parserOpts){parserOpts.plugins.push("classProperties","classPrivateProperties","classPrivateMethods");}})));exports.default=_default;},"./node_modules/@babel/plugin-syntax-decorators/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _default=(0, __webpack_require__("./node_modules/@babel/helper-plugin-utils/lib/index.js").declare)(((api,options)=>{api.assertVersion(7);const{legacy=!1}=options;if("boolean"!=typeof legacy)throw new Error("'legacy' must be a boolean.");const{decoratorsBeforeExport}=options;if(void 0===decoratorsBeforeExport){if(!legacy)throw new Error("The '@babel/plugin-syntax-decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you want to use the legacy decorators semantics, you can set the 'legacy: true' option.")}else {if(legacy)throw new Error("'decoratorsBeforeExport' can't be used with legacy decorators.");if("boolean"!=typeof decoratorsBeforeExport)throw new Error("'decoratorsBeforeExport' must be a boolean.")}return {name:"syntax-decorators",manipulateOptions(opts,parserOpts){parserOpts.plugins.push(legacy?"decorators-legacy":["decorators",{decoratorsBeforeExport}]);}}}));exports.default=_default;},"./node_modules/@babel/plugin-syntax-nullish-coalescing-operator/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _default=(0, __webpack_require__("./node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((api=>(api.assertVersion(7),{name:"syntax-nullish-coalescing-operator",manipulateOptions(opts,parserOpts){parserOpts.plugins.push("nullishCoalescingOperator");}})));exports.default=_default;},"./node_modules/@babel/plugin-syntax-optional-chaining/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _default=(0, __webpack_require__("./node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((api=>(api.assertVersion(7),{name:"syntax-optional-chaining",manipulateOptions(opts,parserOpts){parserOpts.plugins.push("optionalChaining");}})));exports.default=_default;},"./node_modules/@babel/plugin-syntax-typescript/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{function removePlugin(plugins,name){const indices=[];plugins.forEach(((plugin,i)=>{(Array.isArray(plugin)?plugin[0]:plugin)===name&&indices.unshift(i);}));for(const i of indices)plugins.splice(i,1);}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _default=(0, __webpack_require__("./node_modules/@babel/helper-plugin-utils/lib/index.js").declare)(((api,{isTSX,disallowAmbiguousJSXLike})=>(api.assertVersion(7),{name:"syntax-typescript",manipulateOptions(opts,parserOpts){const{plugins}=parserOpts;removePlugin(plugins,"flow"),removePlugin(plugins,"jsx"),parserOpts.plugins.push(["typescript",{disallowAmbiguousJSXLike}],"classProperties"),parserOpts.plugins.push("objectRestSpread"),isTSX&&parserOpts.plugins.push("jsx");}})));exports.default=_default;},"./node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _helperPluginUtils=__webpack_require__("./node_modules/@babel/helper-plugin-utils/lib/index.js"),_helperModuleTransforms=__webpack_require__("./node_modules/@babel/helper-module-transforms/lib/index.js"),_helperSimpleAccess=__webpack_require__("./node_modules/@babel/helper-simple-access/lib/index.js"),_core=__webpack_require__("./node_modules/@babel/core/lib/index.js"),_utils=__webpack_require__("./node_modules/babel-plugin-dynamic-import-node/utils.js"),_default=(0, _helperPluginUtils.declare)(((api,options)=>{var _api$assumption,_api$assumption2,_api$assumption3;api.assertVersion(7);const transformImportCall=(0, _utils.createDynamicImportTransform)(api),{strictNamespace=!1,mjsStrictNamespace=!0,allowTopLevelThis,strict,strictMode,noInterop,importInterop,lazy=!1,allowCommonJSExports=!0}=options,constantReexports=null!=(_api$assumption=api.assumption("constantReexports"))?_api$assumption:options.loose,enumerableModuleMeta=null!=(_api$assumption2=api.assumption("enumerableModuleMeta"))?_api$assumption2:options.loose,noIncompleteNsImportDetection=null!=(_api$assumption3=api.assumption("noIncompleteNsImportDetection"))&&_api$assumption3;if(!("boolean"==typeof lazy||"function"==typeof lazy||Array.isArray(lazy)&&lazy.every((item=>"string"==typeof item))))throw new Error(".lazy must be a boolean, array of strings, or a function");if("boolean"!=typeof strictNamespace)throw new Error(".strictNamespace must be a boolean, or undefined");if("boolean"!=typeof mjsStrictNamespace)throw new Error(".mjsStrictNamespace must be a boolean, or undefined");const getAssertion=localName=>_core.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${localName}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `,moduleExportsVisitor={ReferencedIdentifier(path){const localName=path.node.name;if("module"!==localName&&"exports"!==localName)return;const localBinding=path.scope.getBinding(localName);this.scope.getBinding(localName)!==localBinding||path.parentPath.isObjectProperty({value:path.node})&&path.parentPath.parentPath.isObjectPattern()||path.parentPath.isAssignmentExpression({left:path.node})||path.isAssignmentExpression({left:path.node})||path.replaceWith(getAssertion(localName));},AssignmentExpression(path){const left=path.get("left");if(left.isIdentifier()){const localName=path.node.name;if("module"!==localName&&"exports"!==localName)return;const localBinding=path.scope.getBinding(localName);if(this.scope.getBinding(localName)!==localBinding)return;const right=path.get("right");right.replaceWith(_core.types.sequenceExpression([right.node,getAssertion(localName)]));}else if(left.isPattern()){const ids=left.getOuterBindingIdentifiers(),localName=Object.keys(ids).filter((localName=>("module"===localName||"exports"===localName)&&this.scope.getBinding(localName)===path.scope.getBinding(localName)))[0];if(localName){const right=path.get("right");right.replaceWith(_core.types.sequenceExpression([right.node,getAssertion(localName)]));}}}};return {name:"transform-modules-commonjs",pre(){this.file.set("@babel/plugin-transform-modules-*","commonjs");},visitor:{CallExpression(path){if(!this.file.has("@babel/plugin-proposal-dynamic-import"))return;if(!path.get("callee").isImport())return;let{scope}=path;do{scope.rename("require");}while(scope=scope.parent);transformImportCall(this,path.get("callee"));},Program:{exit(path,state){if(!(0, _helperModuleTransforms.isModule)(path))return;path.scope.rename("exports"),path.scope.rename("module"),path.scope.rename("require"),path.scope.rename("__filename"),path.scope.rename("__dirname"),allowCommonJSExports||((0, _helperSimpleAccess.default)(path,new Set(["module","exports"])),path.traverse(moduleExportsVisitor,{scope:path.scope}));let moduleName=(0, _helperModuleTransforms.getModuleName)(this.file.opts,options);moduleName&&(moduleName=_core.types.stringLiteral(moduleName));const{meta,headers}=(0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path,{exportName:"exports",constantReexports,enumerableModuleMeta,strict,strictMode,allowTopLevelThis,noInterop,importInterop,lazy,esNamespaceOnly:"string"==typeof state.filename&&/\.mjs$/.test(state.filename)?mjsStrictNamespace:strictNamespace,noIncompleteNsImportDetection});for(const[source,metadata]of meta.source){const loadExpr=_core.types.callExpression(_core.types.identifier("require"),[_core.types.stringLiteral(source)]);let header;if((0, _helperModuleTransforms.isSideEffectImport)(metadata)){if(metadata.lazy)throw new Error("Assertion failure");header=_core.types.expressionStatement(loadExpr);}else {const init=(0, _helperModuleTransforms.wrapInterop)(path,loadExpr,metadata.interop)||loadExpr;header=metadata.lazy?_core.template.ast`
                  function ${metadata.name}() {
                    const data = ${init};
                    ${metadata.name} = function(){ return data; };
                    return data;
                  }
                `:_core.template.ast`
                  var ${metadata.name} = ${init};
                `;}header.loc=metadata.loc,headers.push(header),headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta,metadata,constantReexports));}(0, _helperModuleTransforms.ensureStatementsHoisted)(headers),path.unshiftContainer("body",headers),path.get("body").forEach((path=>{-1!==headers.indexOf(path.node)&&path.isVariableDeclaration()&&path.scope.registerDeclaration(path);}));}}}}}));exports.default=_default;},"./node_modules/@babel/plugin-transform-typescript/lib/const-enum.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(path,t){const{name}=path.node.id,parentIsExport=path.parentPath.isExportNamedDeclaration();let isExported=parentIsExport;!isExported&&t.isProgram(path.parent)&&(isExported=path.parent.body.some((stmt=>t.isExportNamedDeclaration(stmt)&&!stmt.source&&stmt.specifiers.some((spec=>t.isExportSpecifier(spec)&&spec.local.name===name)))));const entries=(0, _enum.translateEnumValues)(path,t);if(isExported){const obj=t.objectExpression(entries.map((([name,value])=>t.objectProperty(t.isValidIdentifier(name)?t.identifier(name):t.stringLiteral(name),value))));return void(path.scope.hasOwnBinding(name)?(parentIsExport?path.parentPath:path).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier("Object"),t.identifier("assign")),[path.node.id,obj]))):(path.replaceWith(t.variableDeclaration("var",[t.variableDeclarator(path.node.id,obj)])),path.scope.registerDeclaration(path)))}const entriesMap=new Map(entries);path.scope.path.traverse({Scope(path){path.scope.hasOwnBinding(name)&&path.skip();},MemberExpression(path){if(!t.isIdentifier(path.node.object,{name}))return;let key;if(path.node.computed){if(!t.isStringLiteral(path.node.property))return;key=path.node.property.value;}else {if(!t.isIdentifier(path.node.property))return;key=path.node.property.name;}entriesMap.has(key)&&path.replaceWith(t.cloneNode(entriesMap.get(key)));}}),path.remove();};var _enum=__webpack_require__("./node_modules/@babel/plugin-transform-typescript/lib/enum.js");},"./node_modules/@babel/plugin-transform-typescript/lib/enum.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(path,t){const{node}=path;if(node.declare)return void path.remove();const name=node.id.name,fill=function(path,t,id){const assignments=translateEnumValues(path,t).map((([memberName,memberValue])=>{return isString=t.isStringLiteral(memberValue),options={ENUM:t.cloneNode(id),NAME:memberName,VALUE:memberValue},(isString?buildStringAssignment:buildNumericAssignment)(options);var isString,options;}));return buildEnumWrapper({ID:t.cloneNode(id),ASSIGNMENTS:assignments})}(path,t,node.id);switch(path.parent.type){case"BlockStatement":case"ExportNamedDeclaration":case"Program":if(path.insertAfter(fill),function seen(parentPath){if(parentPath.isExportDeclaration())return seen(parentPath.parentPath);return !!parentPath.getData(name)||(parentPath.setData(name,!0),!1)}(path.parentPath))path.remove();else {const isGlobal=t.isProgram(path.parent);path.scope.registerDeclaration(path.replaceWith(function(id,t,kind){return t.variableDeclaration(kind,[t.variableDeclarator(id)])}(node.id,t,isGlobal?"var":"let"))[0]);}break;default:throw new Error(`Unexpected enum parent '${path.parent.type}`)}},exports.translateEnumValues=translateEnumValues;var _core=__webpack_require__("./node_modules/@babel/core/lib/index.js"),_assert=__webpack_require__("assert");const buildEnumWrapper=(0, _core.template)("\n  (function (ID) {\n    ASSIGNMENTS;\n  })(ID || (ID = {}));\n"),buildStringAssignment=(0, _core.template)('\n  ENUM["NAME"] = VALUE;\n'),buildNumericAssignment=(0, _core.template)('\n  ENUM[ENUM["NAME"] = VALUE] = "NAME";\n');function ReferencedIdentifier(expr,state){const{seen,path,t}=state,name=expr.node.name;seen.has(name)&&!expr.scope.hasOwnBinding(name)&&(expr.replaceWith(t.memberExpression(t.cloneNode(path.node.id),t.cloneNode(expr.node))),expr.skip());}const enumSelfReferenceVisitor={ReferencedIdentifier};function translateEnumValues(path,t){const seen=new Map;let lastName,constValue=-1;return path.get("members").map((memberPath=>{const member=memberPath.node,name=t.isIdentifier(member.id)?member.id.name:member.id.value,initializer=member.initializer;let value;if(initializer)if(constValue=function(expr,seen){return evalConstant(expr);function evalConstant(expr){switch(expr.type){case"StringLiteral":return expr.value;case"UnaryExpression":return evalUnaryExpression(expr);case"BinaryExpression":return evalBinaryExpression(expr);case"NumericLiteral":return expr.value;case"ParenthesizedExpression":return evalConstant(expr.expression);case"Identifier":return seen.get(expr.name);case"TemplateLiteral":if(1===expr.quasis.length)return expr.quasis[0].value.cooked;default:return}}function evalUnaryExpression({argument,operator}){const value=evalConstant(argument);if(void 0!==value)switch(operator){case"+":return value;case"-":return -value;case"~":return ~value;default:return}}function evalBinaryExpression(expr){const left=evalConstant(expr.left);if(void 0===left)return;const right=evalConstant(expr.right);if(void 0!==right)switch(expr.operator){case"|":return left|right;case"&":return left&right;case">>":return left>>right;case">>>":return left>>>right;case"<<":return left<<right;case"^":return left^right;case"*":return left*right;case"/":return left/right;case"+":return left+right;case"-":return left-right;case"%":return left%right;default:return}}}(initializer,seen),void 0!==constValue)seen.set(name,constValue),"number"==typeof constValue?value=t.numericLiteral(constValue):(_assert("string"==typeof constValue),value=t.stringLiteral(constValue));else {const initializerPath=memberPath.get("initializer");initializerPath.isReferencedIdentifier()?ReferencedIdentifier(initializerPath,{t,seen,path}):initializerPath.traverse(enumSelfReferenceVisitor,{t,seen,path}),value=initializerPath.node,seen.set(name,void 0);}else if("number"==typeof constValue)constValue+=1,value=t.numericLiteral(constValue),seen.set(name,constValue);else {if("string"==typeof constValue)throw path.buildCodeFrameError("Enum member must have initializer.");{const lastRef=t.memberExpression(t.cloneNode(path.node.id),t.stringLiteral(lastName),!0);value=t.binaryExpression("+",t.numericLiteral(1),lastRef),seen.set(name,void 0);}}return lastName=name,[name,value]}))}},"./node_modules/@babel/plugin-transform-typescript/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _helperPluginUtils=__webpack_require__("./node_modules/@babel/helper-plugin-utils/lib/index.js"),_pluginSyntaxTypescript=__webpack_require__("./node_modules/@babel/plugin-syntax-typescript/lib/index.js"),_core=__webpack_require__("./node_modules/@babel/core/lib/index.js"),_helperCreateClassFeaturesPlugin=__webpack_require__("./node_modules/@babel/helper-create-class-features-plugin/lib/index.js"),_constEnum=__webpack_require__("./node_modules/@babel/plugin-transform-typescript/lib/const-enum.js"),_enum=__webpack_require__("./node_modules/@babel/plugin-transform-typescript/lib/enum.js"),_namespace=__webpack_require__("./node_modules/@babel/plugin-transform-typescript/lib/namespace.js");function isInType(path){switch(path.parent.type){case"TSTypeReference":case"TSQualifiedName":case"TSExpressionWithTypeArguments":case"TSTypeQuery":return !0;case"ExportSpecifier":return "type"===path.parentPath.parent.exportKind;default:return !1}}const GLOBAL_TYPES=new WeakMap,NEEDS_EXPLICIT_ESM=new WeakMap,PARSED_PARAMS=new WeakSet;function isGlobalType(path,name){const program=path.find((path=>path.isProgram())).node;return !path.scope.hasOwnBinding(name)&&(!!GLOBAL_TYPES.get(program).has(name)||(console.warn(`The exported identifier "${name}" is not declared in Babel's scope tracker\nas a JavaScript value binding, and "@babel/plugin-transform-typescript"\nnever encountered it as a TypeScript type declaration.\nIt will be treated as a JavaScript value.\n\nThis problem is likely caused by another plugin injecting\n"${name}" without registering it in the scope tracker. If you are the author\n of that plugin, please use "scope.registerDeclaration(declarationPath)".`),!1))}function registerGlobalType(programNode,name){GLOBAL_TYPES.get(programNode).add(name);}var _default=(0, _helperPluginUtils.declare)(((api,opts)=>{api.assertVersion(7);const JSX_PRAGMA_REGEX=/\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/,{allowNamespaces=!0,jsxPragma="React.createElement",jsxPragmaFrag="React.Fragment",onlyRemoveTypeImports=!1,optimizeConstEnums=!1}=opts;var{allowDeclareFields=!1}=opts;const classMemberVisitors={field(path){const{node}=path;if(!allowDeclareFields&&node.declare)throw path.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");if(node.declare){if(node.value)throw path.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");node.decorators||path.remove();}else if(node.definite){if(node.value)throw path.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");allowDeclareFields||node.decorators||path.remove();}else allowDeclareFields||node.value||node.decorators||_core.types.isClassPrivateProperty(node)||path.remove();node.accessibility&&(node.accessibility=null),node.abstract&&(node.abstract=null),node.readonly&&(node.readonly=null),node.optional&&(node.optional=null),node.typeAnnotation&&(node.typeAnnotation=null),node.definite&&(node.definite=null),node.declare&&(node.declare=null),node.override&&(node.override=null);},method({node}){node.accessibility&&(node.accessibility=null),node.abstract&&(node.abstract=null),node.optional&&(node.optional=null),node.override&&(node.override=null);},constructor(path,classPath){path.node.accessibility&&(path.node.accessibility=null);const parameterProperties=[];for(const param of path.node.params)"TSParameterProperty"!==param.type||PARSED_PARAMS.has(param.parameter)||(PARSED_PARAMS.add(param.parameter),parameterProperties.push(param.parameter));if(parameterProperties.length){const assigns=parameterProperties.map((p=>{let id;if(_core.types.isIdentifier(p))id=p;else {if(!_core.types.isAssignmentPattern(p)||!_core.types.isIdentifier(p.left))throw path.buildCodeFrameError("Parameter properties can not be destructuring patterns.");id=p.left;}return _core.template.statement.ast`
              this.${_core.types.cloneNode(id)} = ${_core.types.cloneNode(id)}`}));(0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath,path,assigns);}}};return {name:"transform-typescript",inherits:_pluginSyntaxTypescript.default,visitor:{Pattern:visitPattern,Identifier:visitPattern,RestElement:visitPattern,Program:{enter(path,state){const{file}=state;let fileJsxPragma=null,fileJsxPragmaFrag=null;const programNode=path.node;if(GLOBAL_TYPES.has(programNode)||GLOBAL_TYPES.set(programNode,new Set),file.ast.comments)for(const comment of file.ast.comments){const jsxMatches=JSX_PRAGMA_REGEX.exec(comment.value);jsxMatches&&(jsxMatches[1]?fileJsxPragmaFrag=jsxMatches[2]:fileJsxPragma=jsxMatches[2]);}let pragmaImportName=fileJsxPragma||jsxPragma;pragmaImportName&&([pragmaImportName]=pragmaImportName.split("."));let pragmaFragImportName=fileJsxPragmaFrag||jsxPragmaFrag;pragmaFragImportName&&([pragmaFragImportName]=pragmaFragImportName.split("."));for(let stmt of path.get("body"))if(stmt.isImportDeclaration()){if(NEEDS_EXPLICIT_ESM.has(state.file.ast.program)||NEEDS_EXPLICIT_ESM.set(state.file.ast.program,!0),"type"===stmt.node.importKind){for(const specifier of stmt.node.specifiers)registerGlobalType(programNode,specifier.local.name);stmt.remove();continue}const importsToRemove=new Set,specifiersLength=stmt.node.specifiers.length,isAllSpecifiersElided=()=>specifiersLength>0&&specifiersLength===importsToRemove.size;for(const specifier of stmt.node.specifiers)if("ImportSpecifier"===specifier.type&&"type"===specifier.importKind){registerGlobalType(programNode,specifier.local.name);const binding=stmt.scope.getBinding(specifier.local.name);binding&&importsToRemove.add(binding.path);}if(onlyRemoveTypeImports)NEEDS_EXPLICIT_ESM.set(path.node,!1);else {if(0===stmt.node.specifiers.length){NEEDS_EXPLICIT_ESM.set(path.node,!1);continue}for(const specifier of stmt.node.specifiers){const binding=stmt.scope.getBinding(specifier.local.name);binding&&!importsToRemove.has(binding.path)&&(isImportTypeOnly({binding,programPath:path,pragmaImportName,pragmaFragImportName})?importsToRemove.add(binding.path):NEEDS_EXPLICIT_ESM.set(path.node,!1));}}if(isAllSpecifiersElided())stmt.remove();else for(const importPath of importsToRemove)importPath.remove();}else if(stmt.isExportDeclaration()&&(stmt=stmt.get("declaration")),stmt.isVariableDeclaration({declare:!0}))for(const name of Object.keys(stmt.getBindingIdentifiers()))registerGlobalType(programNode,name);else (stmt.isTSTypeAliasDeclaration()||stmt.isTSDeclareFunction()&&stmt.get("id").isIdentifier()||stmt.isTSInterfaceDeclaration()||stmt.isClassDeclaration({declare:!0})||stmt.isTSEnumDeclaration({declare:!0})||stmt.isTSModuleDeclaration({declare:!0})&&stmt.get("id").isIdentifier())&&registerGlobalType(programNode,stmt.node.id.name);},exit(path){"module"===path.node.sourceType&&NEEDS_EXPLICIT_ESM.get(path.node)&&path.pushContainer("body",_core.types.exportNamedDeclaration());}},ExportNamedDeclaration(path,state){NEEDS_EXPLICIT_ESM.has(state.file.ast.program)||NEEDS_EXPLICIT_ESM.set(state.file.ast.program,!0),"type"!==path.node.exportKind?path.node.source&&path.node.specifiers.length>0&&path.node.specifiers.every((specifier=>"ExportSpecifier"===specifier.type&&"type"===specifier.exportKind))||!path.node.source&&path.node.specifiers.length>0&&path.node.specifiers.every((specifier=>_core.types.isExportSpecifier(specifier)&&isGlobalType(path,specifier.local.name)))?path.remove():NEEDS_EXPLICIT_ESM.set(state.file.ast.program,!1):path.remove();},ExportSpecifier(path){(!path.parent.source&&isGlobalType(path,path.node.local.name)||"type"===path.node.exportKind)&&path.remove();},ExportDefaultDeclaration(path,state){NEEDS_EXPLICIT_ESM.has(state.file.ast.program)||NEEDS_EXPLICIT_ESM.set(state.file.ast.program,!0),_core.types.isIdentifier(path.node.declaration)&&isGlobalType(path,path.node.declaration.name)?path.remove():NEEDS_EXPLICIT_ESM.set(state.file.ast.program,!1);},TSDeclareFunction(path){path.remove();},TSDeclareMethod(path){path.remove();},VariableDeclaration(path){path.node.declare&&path.remove();},VariableDeclarator({node}){node.definite&&(node.definite=null);},TSIndexSignature(path){path.remove();},ClassDeclaration(path){const{node}=path;node.declare&&path.remove();},Class(path){const{node}=path;node.typeParameters&&(node.typeParameters=null),node.superTypeParameters&&(node.superTypeParameters=null),node.implements&&(node.implements=null),node.abstract&&(node.abstract=null),path.get("body.body").forEach((child=>{child.isClassMethod()||child.isClassPrivateMethod()?"constructor"===child.node.kind?classMemberVisitors.constructor(child,path):classMemberVisitors.method(child):(child.isClassProperty()||child.isClassPrivateProperty())&&classMemberVisitors.field(child);}));},Function(path){const{node,scope}=path;node.typeParameters&&(node.typeParameters=null),node.returnType&&(node.returnType=null);const params=node.params;params.length>0&&_core.types.isIdentifier(params[0],{name:"this"})&&params.shift();const paramsPath=path.get("params");for(const p of paramsPath)"TSParameterProperty"===p.type&&(p.replaceWith(p.get("parameter")),scope.registerBinding("param",p));},TSModuleDeclaration(path){(0, _namespace.default)(path,_core.types,allowNamespaces);},TSInterfaceDeclaration(path){path.remove();},TSTypeAliasDeclaration(path){path.remove();},TSEnumDeclaration(path){optimizeConstEnums&&path.node.const?(0, _constEnum.default)(path,_core.types):(0, _enum.default)(path,_core.types);},TSImportEqualsDeclaration(path){if(_core.types.isTSExternalModuleReference(path.node.moduleReference))throw path.buildCodeFrameError(`\`import ${path.node.id.name} = require('${path.node.moduleReference.expression.value}')\` is not supported by @babel/plugin-transform-typescript\nPlease consider using \`import ${path.node.id.name} from '${path.node.moduleReference.expression.value}';\` alongside Typescript's --allowSyntheticDefaultImports option.`);path.replaceWith(_core.types.variableDeclaration("var",[_core.types.variableDeclarator(path.node.id,entityNameToExpr(path.node.moduleReference))]));},TSExportAssignment(path){throw path.buildCodeFrameError("`export =` is not supported by @babel/plugin-transform-typescript\nPlease consider using `export <value>;`.")},TSTypeAssertion(path){path.replaceWith(path.node.expression);},TSAsExpression(path){let{node}=path;do{node=node.expression;}while(_core.types.isTSAsExpression(node));path.replaceWith(node);},TSNonNullExpression(path){path.replaceWith(path.node.expression);},CallExpression(path){path.node.typeParameters=null;},OptionalCallExpression(path){path.node.typeParameters=null;},NewExpression(path){path.node.typeParameters=null;},JSXOpeningElement(path){path.node.typeParameters=null;},TaggedTemplateExpression(path){path.node.typeParameters=null;}}};function entityNameToExpr(node){return _core.types.isTSQualifiedName(node)?_core.types.memberExpression(entityNameToExpr(node.left),node.right):node}function visitPattern({node}){node.typeAnnotation&&(node.typeAnnotation=null),_core.types.isIdentifier(node)&&node.optional&&(node.optional=null);}function isImportTypeOnly({binding,programPath,pragmaImportName,pragmaFragImportName}){for(const path of binding.referencePaths)if(!isInType(path))return !1;if(binding.identifier.name!==pragmaImportName&&binding.identifier.name!==pragmaFragImportName)return !0;let sourceFileHasJsx=!1;return programPath.traverse({"JSXElement|JSXFragment"(path){sourceFileHasJsx=!0,path.stop();}}),!sourceFileHasJsx}}));exports.default=_default;},"./node_modules/@babel/plugin-transform-typescript/lib/namespace.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(path,t,allowNamespaces){if(path.node.declare||"StringLiteral"===path.node.id.type)return void path.remove();if(!allowNamespaces)throw path.hub.file.buildCodeFrameError(path.node.id,"Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");const name=path.node.id.name,value=handleNested(path,t,t.cloneDeep(path.node)),bound=path.scope.hasOwnBinding(name);"ExportNamedDeclaration"===path.parent.type?bound?path.parentPath.replaceWith(value):(path.parentPath.insertAfter(value),path.replaceWith(getDeclaration(t,name)),path.scope.registerDeclaration(path.parentPath)):bound?path.replaceWith(value):path.scope.registerDeclaration(path.replaceWithMultiple([getDeclaration(t,name),value])[0]);};var _core=__webpack_require__("./node_modules/@babel/core/lib/index.js");function getDeclaration(t,name){return t.variableDeclaration("let",[t.variableDeclarator(t.identifier(name))])}function getMemberExpression(t,name,itemName){return t.memberExpression(t.identifier(name),t.identifier(itemName))}function handleVariableDeclaration(node,name,hub){if("const"!==node.kind)throw hub.file.buildCodeFrameError(node,"Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");const{declarations}=node;if(declarations.every((declarator=>_core.types.isIdentifier(declarator.id)))){for(const declarator of declarations)declarator.init=_core.types.assignmentExpression("=",getMemberExpression(_core.types,name,declarator.id.name),declarator.init);return [node]}const bindingIdentifiers=_core.types.getBindingIdentifiers(node),assignments=[];for(const idName in bindingIdentifiers)assignments.push(_core.types.assignmentExpression("=",getMemberExpression(_core.types,name,idName),_core.types.cloneNode(bindingIdentifiers[idName])));return [node,_core.types.expressionStatement(_core.types.sequenceExpression(assignments))]}function buildNestedAmbiendModuleError(path,node){throw path.hub.buildError(node,"Ambient modules cannot be nested in other modules or namespaces.",Error)}function handleNested(path,t,node,parentExport){const names=new Set,realName=node.id;t.assertIdentifier(realName);const name=path.scope.generateUid(realName.name),namespaceTopLevel=t.isTSModuleBlock(node.body)?node.body.body:[t.exportNamedDeclaration(node.body)];for(let i=0;i<namespaceTopLevel.length;i++){const subNode=namespaceTopLevel[i];switch(subNode.type){case"TSModuleDeclaration":{if(!t.isIdentifier(subNode.id))throw buildNestedAmbiendModuleError(path,subNode);const transformed=handleNested(path,t,subNode),moduleName=subNode.id.name;names.has(moduleName)?namespaceTopLevel[i]=transformed:(names.add(moduleName),namespaceTopLevel.splice(i++,1,getDeclaration(t,moduleName),transformed));continue}case"TSEnumDeclaration":case"FunctionDeclaration":case"ClassDeclaration":names.add(subNode.id.name);continue;case"VariableDeclaration":for(const name in t.getBindingIdentifiers(subNode))names.add(name);continue;default:continue;case"ExportNamedDeclaration":}switch(subNode.declaration.type){case"TSEnumDeclaration":case"FunctionDeclaration":case"ClassDeclaration":{const itemName=subNode.declaration.id.name;names.add(itemName),namespaceTopLevel.splice(i++,1,subNode.declaration,t.expressionStatement(t.assignmentExpression("=",getMemberExpression(t,name,itemName),t.identifier(itemName))));break}case"VariableDeclaration":{const nodes=handleVariableDeclaration(subNode.declaration,name,path.hub);namespaceTopLevel.splice(i,nodes.length,...nodes),i+=nodes.length-1;break}case"TSModuleDeclaration":{if(!t.isIdentifier(subNode.declaration.id))throw buildNestedAmbiendModuleError(path,subNode.declaration);const transformed=handleNested(path,t,subNode.declaration,t.identifier(name)),moduleName=subNode.declaration.id.name;names.has(moduleName)?namespaceTopLevel[i]=transformed:(names.add(moduleName),namespaceTopLevel.splice(i++,1,getDeclaration(t,moduleName),transformed));}}}let fallthroughValue=t.objectExpression([]);if(parentExport){const memberExpr=t.memberExpression(parentExport,realName);fallthroughValue=_core.template.expression.ast`
      ${t.cloneNode(memberExpr)} ||
        (${t.cloneNode(memberExpr)} = ${fallthroughValue})
    `;}return _core.template.statement.ast`
    (function (${t.identifier(name)}) {
      ${namespaceTopLevel}
    })(${realName} || (${t.cloneNode(realName)} = ${fallthroughValue}));
  `}},"./node_modules/@babel/template/lib/builder.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function createTemplateBuilder(formatter,defaultOpts){const templateFnCache=new WeakMap,templateAstCache=new WeakMap,cachedOpts=defaultOpts||(0, _options.validate)(null);return Object.assign(((tpl,...args)=>{if("string"==typeof tpl){if(args.length>1)throw new Error("Unexpected extra params.");return extendedTrace((0,_string.default)(formatter,tpl,(0,_options.merge)(cachedOpts,(0,_options.validate)(args[0]))))}if(Array.isArray(tpl)){let builder=templateFnCache.get(tpl);return builder||(builder=(0, _literal.default)(formatter,tpl,cachedOpts),templateFnCache.set(tpl,builder)),extendedTrace(builder(args))}if("object"==typeof tpl&&tpl){if(args.length>0)throw new Error("Unexpected extra params.");return createTemplateBuilder(formatter,(0, _options.merge)(cachedOpts,(0, _options.validate)(tpl)))}throw new Error("Unexpected template param "+typeof tpl)}),{ast:(tpl,...args)=>{if("string"==typeof tpl){if(args.length>1)throw new Error("Unexpected extra params.");return (0, _string.default)(formatter,tpl,(0, _options.merge)((0, _options.merge)(cachedOpts,(0, _options.validate)(args[0])),NO_PLACEHOLDER))()}if(Array.isArray(tpl)){let builder=templateAstCache.get(tpl);return builder||(builder=(0, _literal.default)(formatter,tpl,(0, _options.merge)(cachedOpts,NO_PLACEHOLDER)),templateAstCache.set(tpl,builder)),builder(args)()}throw new Error("Unexpected template param "+typeof tpl)}})};var _options=__webpack_require__("./node_modules/@babel/template/lib/options.js"),_string=__webpack_require__("./node_modules/@babel/template/lib/string.js"),_literal=__webpack_require__("./node_modules/@babel/template/lib/literal.js");const NO_PLACEHOLDER=(0, _options.validate)({placeholderPattern:!1});function extendedTrace(fn){let rootStack="";try{throw new Error}catch(error){error.stack&&(rootStack=error.stack.split("\n").slice(3).join("\n"));}return arg=>{try{return fn(arg)}catch(err){throw err.stack+=`\n    =============\n${rootStack}`,err}}}},"./node_modules/@babel/template/lib/formatters.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.statements=exports.statement=exports.smart=exports.program=exports.expression=void 0;var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{assertExpressionStatement}=_t;function makeStatementFormatter(fn){return {code:str=>`/* @babel/template */;\n${str}`,validate:()=>{},unwrap:ast=>fn(ast.program.body.slice(1))}}const smart=makeStatementFormatter((body=>body.length>1?body:body[0]));exports.smart=smart;const statements=makeStatementFormatter((body=>body));exports.statements=statements;const statement=makeStatementFormatter((body=>{if(0===body.length)throw new Error("Found nothing to return.");if(body.length>1)throw new Error("Found multiple statements but wanted one");return body[0]}));exports.statement=statement;const expression={code:str=>`(\n${str}\n)`,validate:ast=>{if(ast.program.body.length>1)throw new Error("Found multiple statements but wanted one");if(0===expression.unwrap(ast).start)throw new Error("Parse result included parens.")},unwrap:({program})=>{const[stmt]=program.body;return assertExpressionStatement(stmt),stmt.expression}};exports.expression=expression;exports.program={code:str=>str,validate:()=>{},unwrap:ast=>ast.program};},"./node_modules/@babel/template/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.statements=exports.statement=exports.smart=exports.program=exports.expression=exports.default=void 0;var formatters=__webpack_require__("./node_modules/@babel/template/lib/formatters.js"),_builder=__webpack_require__("./node_modules/@babel/template/lib/builder.js");const smart=(0, _builder.default)(formatters.smart);exports.smart=smart;const statement=(0, _builder.default)(formatters.statement);exports.statement=statement;const statements=(0, _builder.default)(formatters.statements);exports.statements=statements;const expression=(0, _builder.default)(formatters.expression);exports.expression=expression;const program=(0, _builder.default)(formatters.program);exports.program=program;var _default=Object.assign(smart.bind(void 0),{smart,statement,statements,expression,program,ast:smart.ast});exports.default=_default;},"./node_modules/@babel/template/lib/literal.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(formatter,tpl,opts){const{metadata,names}=function(formatter,tpl,opts){let names,nameSet,metadata,prefix="";do{prefix+="$";const result=buildTemplateCode(tpl,prefix);names=result.names,nameSet=new Set(names),metadata=(0, _parse.default)(formatter,formatter.code(result.code),{parser:opts.parser,placeholderWhitelist:new Set(result.names.concat(opts.placeholderWhitelist?Array.from(opts.placeholderWhitelist):[])),placeholderPattern:opts.placeholderPattern,preserveComments:opts.preserveComments,syntacticPlaceholders:opts.syntacticPlaceholders});}while(metadata.placeholders.some((placeholder=>placeholder.isDuplicate&&nameSet.has(placeholder.name))));return {metadata,names}}(formatter,tpl,opts);return arg=>{const defaultReplacements={};return arg.forEach(((replacement,i)=>{defaultReplacements[names[i]]=replacement;})),arg=>{const replacements=(0, _options.normalizeReplacements)(arg);return replacements&&Object.keys(replacements).forEach((key=>{if(Object.prototype.hasOwnProperty.call(defaultReplacements,key))throw new Error("Unexpected replacement overlap.")})),formatter.unwrap((0, _populate.default)(metadata,replacements?Object.assign(replacements,defaultReplacements):defaultReplacements))}}};var _options=__webpack_require__("./node_modules/@babel/template/lib/options.js"),_parse=__webpack_require__("./node_modules/@babel/template/lib/parse.js"),_populate=__webpack_require__("./node_modules/@babel/template/lib/populate.js");function buildTemplateCode(tpl,prefix){const names=[];let code=tpl[0];for(let i=1;i<tpl.length;i++){const value=`${prefix}${i-1}`;names.push(value),code+=value+tpl[i];}return {names,code}}},"./node_modules/@babel/template/lib/options.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.merge=function(a,b){const{placeholderWhitelist=a.placeholderWhitelist,placeholderPattern=a.placeholderPattern,preserveComments=a.preserveComments,syntacticPlaceholders=a.syntacticPlaceholders}=b;return {parser:Object.assign({},a.parser,b.parser),placeholderWhitelist,placeholderPattern,preserveComments,syntacticPlaceholders}},exports.normalizeReplacements=function(replacements){if(Array.isArray(replacements))return replacements.reduce(((acc,replacement,i)=>(acc["$"+i]=replacement,acc)),{});if("object"==typeof replacements||null==replacements)return replacements||void 0;throw new Error("Template replacements must be an array, object, null, or undefined")},exports.validate=function(opts){if(null!=opts&&"object"!=typeof opts)throw new Error("Unknown template options.");const _ref=opts||{},{placeholderWhitelist,placeholderPattern,preserveComments,syntacticPlaceholders}=_ref,parser=function(source,excluded){if(null==source)return {};var key,i,target={},sourceKeys=Object.keys(source);for(i=0;i<sourceKeys.length;i++)key=sourceKeys[i],excluded.indexOf(key)>=0||(target[key]=source[key]);return target}(_ref,_excluded);if(null!=placeholderWhitelist&&!(placeholderWhitelist instanceof Set))throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");if(null!=placeholderPattern&&!(placeholderPattern instanceof RegExp)&&!1!==placeholderPattern)throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");if(null!=preserveComments&&"boolean"!=typeof preserveComments)throw new Error("'.preserveComments' must be a boolean, null, or undefined");if(null!=syntacticPlaceholders&&"boolean"!=typeof syntacticPlaceholders)throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");if(!0===syntacticPlaceholders&&(null!=placeholderWhitelist||null!=placeholderPattern))throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");return {parser,placeholderWhitelist:placeholderWhitelist||void 0,placeholderPattern:null==placeholderPattern?void 0:placeholderPattern,preserveComments:null==preserveComments?void 0:preserveComments,syntacticPlaceholders:null==syntacticPlaceholders?void 0:syntacticPlaceholders}};const _excluded=["placeholderWhitelist","placeholderPattern","preserveComments","syntacticPlaceholders"];},"./node_modules/@babel/template/lib/parse.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(formatter,code,opts){const{placeholderWhitelist,placeholderPattern,preserveComments,syntacticPlaceholders}=opts,ast=function(code,parserOpts,syntacticPlaceholders){const plugins=(parserOpts.plugins||[]).slice();!1!==syntacticPlaceholders&&plugins.push("placeholders");parserOpts=Object.assign({allowReturnOutsideFunction:!0,allowSuperOutsideMethod:!0,sourceType:"module"},parserOpts,{plugins});try{return (0,_parser.parse)(code,parserOpts)}catch(err){const loc=err.loc;throw loc&&(err.message+="\n"+(0, _codeFrame.codeFrameColumns)(code,{start:loc}),err.code="BABEL_TEMPLATE_PARSE_ERROR"),err}}(code,opts.parser,syntacticPlaceholders);removePropertiesDeep(ast,{preserveComments}),formatter.validate(ast);const syntactic={placeholders:[],placeholderNames:new Set},legacy={placeholders:[],placeholderNames:new Set},isLegacyRef={value:void 0};return traverse(ast,placeholderVisitorHandler,{syntactic,legacy,isLegacyRef,placeholderWhitelist,placeholderPattern,syntacticPlaceholders}),Object.assign({ast},isLegacyRef.value?legacy:syntactic)};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js"),_parser=__webpack_require__("./node_modules/@babel/parser/lib/index.js"),_codeFrame=__webpack_require__("./stubs/babel_codeframe.js");const{isCallExpression,isExpressionStatement,isFunction,isIdentifier,isJSXIdentifier,isNewExpression,isPlaceholder,isStatement,isStringLiteral,removePropertiesDeep,traverse}=_t,PATTERN=/^[_$A-Z0-9]+$/;function placeholderVisitorHandler(node,ancestors,state){var _state$placeholderWhi;let name;if(isPlaceholder(node)){if(!1===state.syntacticPlaceholders)throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");name=node.name.name,state.isLegacyRef.value=!1;}else {if(!1===state.isLegacyRef.value||state.syntacticPlaceholders)return;if(isIdentifier(node)||isJSXIdentifier(node))name=node.name,state.isLegacyRef.value=!0;else {if(!isStringLiteral(node))return;name=node.value,state.isLegacyRef.value=!0;}}if(!state.isLegacyRef.value&&(null!=state.placeholderPattern||null!=state.placeholderWhitelist))throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");if(state.isLegacyRef.value&&(!1===state.placeholderPattern||!(state.placeholderPattern||PATTERN).test(name))&&(null==(_state$placeholderWhi=state.placeholderWhitelist)||!_state$placeholderWhi.has(name)))return;ancestors=ancestors.slice();const{node:parent,key}=ancestors[ancestors.length-1];let type;isStringLiteral(node)||isPlaceholder(node,{expectedNode:"StringLiteral"})?type="string":isNewExpression(parent)&&"arguments"===key||isCallExpression(parent)&&"arguments"===key||isFunction(parent)&&"params"===key?type="param":isExpressionStatement(parent)&&!isPlaceholder(node)?(type="statement",ancestors=ancestors.slice(0,-1)):type=isStatement(node)&&isPlaceholder(node)?"statement":"other";const{placeholders,placeholderNames}=state.isLegacyRef.value?state.legacy:state.syntactic;placeholders.push({name,type,resolve:ast=>function(ast,ancestors){let parent=ast;for(let i=0;i<ancestors.length-1;i++){const{key,index}=ancestors[i];parent=void 0===index?parent[key]:parent[key][index];}const{key,index}=ancestors[ancestors.length-1];return {parent,key,index}}(ast,ancestors),isDuplicate:placeholderNames.has(name)}),placeholderNames.add(name);}},"./node_modules/@babel/template/lib/populate.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(metadata,replacements){const ast=cloneNode(metadata.ast);replacements&&(metadata.placeholders.forEach((placeholder=>{if(!Object.prototype.hasOwnProperty.call(replacements,placeholder.name)){const placeholderName=placeholder.name;throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}\n            - { placeholderPattern: /^${placeholderName}$/ }`)}})),Object.keys(replacements).forEach((key=>{if(!metadata.placeholderNames.has(key))throw new Error(`Unknown substitution "${key}" given`)})));return metadata.placeholders.slice().reverse().forEach((placeholder=>{try{!function(placeholder,ast,replacement){placeholder.isDuplicate&&(Array.isArray(replacement)?replacement=replacement.map((node=>cloneNode(node))):"object"==typeof replacement&&(replacement=cloneNode(replacement)));const{parent,key,index}=placeholder.resolve(ast);if("string"===placeholder.type){if("string"==typeof replacement&&(replacement=stringLiteral(replacement)),!replacement||!isStringLiteral(replacement))throw new Error("Expected string substitution")}else if("statement"===placeholder.type)void 0===index?replacement?Array.isArray(replacement)?replacement=blockStatement(replacement):"string"==typeof replacement?replacement=expressionStatement(identifier(replacement)):isStatement(replacement)||(replacement=expressionStatement(replacement)):replacement=emptyStatement():replacement&&!Array.isArray(replacement)&&("string"==typeof replacement&&(replacement=identifier(replacement)),isStatement(replacement)||(replacement=expressionStatement(replacement)));else if("param"===placeholder.type){if("string"==typeof replacement&&(replacement=identifier(replacement)),void 0===index)throw new Error("Assertion failure.")}else if("string"==typeof replacement&&(replacement=identifier(replacement)),Array.isArray(replacement))throw new Error("Cannot replace single expression with an array.");if(void 0===index)validate(parent,key,replacement),parent[key]=replacement;else {const items=parent[key].slice();"statement"===placeholder.type||"param"===placeholder.type?null==replacement?items.splice(index,1):Array.isArray(replacement)?items.splice(index,1,...replacement):items[index]=replacement:items[index]=replacement,validate(parent,key,items),parent[key]=items;}}(placeholder,ast,replacements&&replacements[placeholder.name]||null);}catch(e){throw e.message=`@babel/template placeholder "${placeholder.name}": ${e.message}`,e}})),ast};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{blockStatement,cloneNode,emptyStatement,expressionStatement,identifier,isStatement,isStringLiteral,stringLiteral,validate}=_t;},"./node_modules/@babel/template/lib/string.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(formatter,code,opts){let metadata;return code=formatter.code(code),arg=>{const replacements=(0, _options.normalizeReplacements)(arg);return metadata||(metadata=(0, _parse.default)(formatter,code,opts)),formatter.unwrap((0, _populate.default)(metadata,replacements))}};var _options=__webpack_require__("./node_modules/@babel/template/lib/options.js"),_parse=__webpack_require__("./node_modules/@babel/template/lib/parse.js"),_populate=__webpack_require__("./node_modules/@babel/template/lib/populate.js");},"./node_modules/@babel/traverse/lib/cache.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.clear=function(){clearPath(),clearScope();},exports.clearPath=clearPath,exports.clearScope=clearScope,exports.scope=exports.path=void 0;let path=new WeakMap;exports.path=path;let scope=new WeakMap;function clearPath(){exports.path=path=new WeakMap;}function clearScope(){exports.scope=scope=new WeakMap;}exports.scope=scope;},"./node_modules/@babel/traverse/lib/context.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _path=__webpack_require__("./node_modules/@babel/traverse/lib/path/index.js"),_t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{VISITOR_KEYS}=_t;exports.default=class{constructor(scope,opts,state,parentPath){this.queue=null,this.priorityQueue=null,this.parentPath=parentPath,this.scope=scope,this.state=state,this.opts=opts;}shouldVisit(node){const opts=this.opts;if(opts.enter||opts.exit)return !0;if(opts[node.type])return !0;const keys=VISITOR_KEYS[node.type];if(null==keys||!keys.length)return !1;for(const key of keys)if(node[key])return !0;return !1}create(node,obj,key,listKey){return _path.default.get({parentPath:this.parentPath,parent:node,container:obj,key,listKey})}maybeQueue(path,notPriority){this.queue&&(notPriority?this.queue.push(path):this.priorityQueue.push(path));}visitMultiple(container,parent,listKey){if(0===container.length)return !1;const queue=[];for(let key=0;key<container.length;key++){const node=container[key];node&&this.shouldVisit(node)&&queue.push(this.create(parent,container,key,listKey));}return this.visitQueue(queue)}visitSingle(node,key){return !!this.shouldVisit(node[key])&&this.visitQueue([this.create(node,node,key)])}visitQueue(queue){this.queue=queue,this.priorityQueue=[];const visited=new WeakSet;let stop=!1;for(const path of queue){if(path.resync(),0!==path.contexts.length&&path.contexts[path.contexts.length-1]===this||path.pushContext(this),null===path.key)continue;const{node}=path;if(!visited.has(node)){if(node&&visited.add(node),path.visit()){stop=!0;break}if(this.priorityQueue.length&&(stop=this.visitQueue(this.priorityQueue),this.priorityQueue=[],this.queue=queue,stop))break}}for(const path of queue)path.popContext();return this.queue=null,stop}visit(node,key){const nodes=node[key];return !!nodes&&(Array.isArray(nodes)?this.visitMultiple(nodes,node,key):this.visitSingle(node,key))}};},"./node_modules/@babel/traverse/lib/hub.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;exports.default=class{getCode(){}getScope(){}addHelper(){throw new Error("Helpers are not supported by the default hub.")}buildError(node,msg,Error=TypeError){return new Error(msg)}};},"./node_modules/@babel/traverse/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"Hub",{enumerable:!0,get:function(){return _hub.default}}),Object.defineProperty(exports,"NodePath",{enumerable:!0,get:function(){return _path.default}}),Object.defineProperty(exports,"Scope",{enumerable:!0,get:function(){return _scope.default}}),exports.visitors=exports.default=void 0;var visitors=__webpack_require__("./node_modules/@babel/traverse/lib/visitors.js");exports.visitors=visitors;var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js"),cache=__webpack_require__("./node_modules/@babel/traverse/lib/cache.js"),_traverseNode=__webpack_require__("./node_modules/@babel/traverse/lib/traverse-node.js"),_path=__webpack_require__("./node_modules/@babel/traverse/lib/path/index.js"),_scope=__webpack_require__("./node_modules/@babel/traverse/lib/scope/index.js"),_hub=__webpack_require__("./node_modules/@babel/traverse/lib/hub.js");const{VISITOR_KEYS,removeProperties,traverseFast}=_t;function traverse(parent,opts={},scope,state,parentPath){if(parent){if(!opts.noScope&&!scope&&"Program"!==parent.type&&"File"!==parent.type)throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${parent.type} node without passing scope and parentPath.`);VISITOR_KEYS[parent.type]&&(visitors.explode(opts),(0, _traverseNode.traverseNode)(parent,opts,scope,state,parentPath));}}var _default=traverse;function hasDenylistedType(path,state){path.node.type===state.type&&(state.has=!0,path.stop());}exports.default=_default,traverse.visitors=visitors,traverse.verify=visitors.verify,traverse.explode=visitors.explode,traverse.cheap=function(node,enter){return traverseFast(node,enter)},traverse.node=function(node,opts,scope,state,path,skipKeys){(0, _traverseNode.traverseNode)(node,opts,scope,state,path,skipKeys);},traverse.clearNode=function(node,opts){removeProperties(node,opts),cache.path.delete(node);},traverse.removeProperties=function(tree,opts){return traverseFast(tree,traverse.clearNode,opts),tree},traverse.hasType=function(tree,type,denylistTypes){if(null!=denylistTypes&&denylistTypes.includes(tree.type))return !1;if(tree.type===type)return !0;const state={has:!1,type};return traverse(tree,{noScope:!0,denylist:denylistTypes,enter:hasDenylistedType},null,state),state.has},traverse.cache=cache;},"./node_modules/@babel/traverse/lib/path/ancestry.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.find=function(callback){let path=this;do{if(callback(path))return path}while(path=path.parentPath);return null},exports.findParent=function(callback){let path=this;for(;path=path.parentPath;)if(callback(path))return path;return null},exports.getAncestry=function(){let path=this;const paths=[];do{paths.push(path);}while(path=path.parentPath);return paths},exports.getDeepestCommonAncestorFrom=function(paths,filter){if(!paths.length)return this;if(1===paths.length)return paths[0];let lastCommonIndex,lastCommon,minDepth=1/0;const ancestries=paths.map((path=>{const ancestry=[];do{ancestry.unshift(path);}while((path=path.parentPath)&&path!==this);return ancestry.length<minDepth&&(minDepth=ancestry.length),ancestry})),first=ancestries[0];depthLoop:for(let i=0;i<minDepth;i++){const shouldMatch=first[i];for(const ancestry of ancestries)if(ancestry[i]!==shouldMatch)break depthLoop;lastCommonIndex=i,lastCommon=shouldMatch;}if(lastCommon)return filter?filter(lastCommon,lastCommonIndex,ancestries):lastCommon;throw new Error("Couldn't find intersection")},exports.getEarliestCommonAncestorFrom=function(paths){return this.getDeepestCommonAncestorFrom(paths,(function(deepest,i,ancestries){let earliest;const keys=VISITOR_KEYS[deepest.type];for(const ancestry of ancestries){const path=ancestry[i+1];if(!earliest){earliest=path;continue}if(path.listKey&&earliest.listKey===path.listKey&&path.key<earliest.key){earliest=path;continue}keys.indexOf(earliest.parentKey)>keys.indexOf(path.parentKey)&&(earliest=path);}return earliest}))},exports.getFunctionParent=function(){return this.findParent((p=>p.isFunction()))},exports.getStatementParent=function(){let path=this;do{if(!path.parentPath||Array.isArray(path.container)&&path.isStatement())break;path=path.parentPath;}while(path);if(path&&(path.isProgram()||path.isFile()))throw new Error("File/Program node, we can't possibly find a statement parent to this");return path},exports.inType=function(...candidateTypes){let path=this;for(;path;){for(const type of candidateTypes)if(path.node.type===type)return !0;path=path.parentPath;}return !1},exports.isAncestor=function(maybeDescendant){return maybeDescendant.isDescendant(this)},exports.isDescendant=function(maybeAncestor){return !!this.findParent((parent=>parent===maybeAncestor))};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");__webpack_require__("./node_modules/@babel/traverse/lib/path/index.js");const{VISITOR_KEYS}=_t;},"./node_modules/@babel/traverse/lib/path/comments.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.addComment=function(type,content,line){_addComment(this.node,type,content,line);},exports.addComments=function(type,comments){_addComments(this.node,type,comments);},exports.shareCommentsWithSiblings=function(){if("string"==typeof this.key)return;const node=this.node;if(!node)return;const trailing=node.trailingComments,leading=node.leadingComments;if(!trailing&&!leading)return;const prev=this.getSibling(this.key-1),next=this.getSibling(this.key+1),hasPrev=Boolean(prev.node),hasNext=Boolean(next.node);hasPrev&&!hasNext?prev.addComments("trailing",trailing):hasNext&&!hasPrev&&next.addComments("leading",leading);};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{addComment:_addComment,addComments:_addComments}=_t;},"./node_modules/@babel/traverse/lib/path/context.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports._call=function(fns){if(!fns)return !1;for(const fn of fns){if(!fn)continue;const node=this.node;if(!node)return !0;const ret=fn.call(this.state,this,this.state);if(ret&&"object"==typeof ret&&"function"==typeof ret.then)throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");if(ret)throw new Error(`Unexpected return value from visitor method ${fn}`);if(this.node!==node)return !0;if(this._traverseFlags>0)return !0}return !1},exports._getQueueContexts=function(){let path=this,contexts=this.contexts;for(;!contexts.length&&(path=path.parentPath,path);)contexts=path.contexts;return contexts},exports._resyncKey=function(){if(!this.container)return;if(this.node===this.container[this.key])return;if(Array.isArray(this.container)){for(let i=0;i<this.container.length;i++)if(this.container[i]===this.node)return this.setKey(i)}else for(const key of Object.keys(this.container))if(this.container[key]===this.node)return this.setKey(key);this.key=null;},exports._resyncList=function(){if(!this.parent||!this.inList)return;const newContainer=this.parent[this.listKey];if(this.container===newContainer)return;this.container=newContainer||null;},exports._resyncParent=function(){this.parentPath&&(this.parent=this.parentPath.node);},exports._resyncRemoved=function(){null!=this.key&&this.container&&this.container[this.key]===this.node||this._markRemoved();},exports.call=function(key){const opts=this.opts;if(this.debug(key),this.node&&this._call(opts[key]))return !0;if(this.node)return this._call(opts[this.node.type]&&opts[this.node.type][key]);return !1},exports.isBlacklisted=exports.isDenylisted=function(){var _this$opts$denylist;const denylist=null!=(_this$opts$denylist=this.opts.denylist)?_this$opts$denylist:this.opts.blacklist;return denylist&&denylist.indexOf(this.node.type)>-1},exports.popContext=function(){this.contexts.pop(),this.contexts.length>0?this.setContext(this.contexts[this.contexts.length-1]):this.setContext(void 0);},exports.pushContext=function(context){this.contexts.push(context),this.setContext(context);},exports.requeue=function(pathToQueue=this){if(pathToQueue.removed)return;const contexts=this.contexts;for(const context of contexts)context.maybeQueue(pathToQueue);},exports.resync=function(){if(this.removed)return;this._resyncParent(),this._resyncList(),this._resyncKey();},exports.setContext=function(context){null!=this.skipKeys&&(this.skipKeys={});this._traverseFlags=0,context&&(this.context=context,this.state=context.state,this.opts=context.opts);return this.setScope(),this},exports.setKey=function(key){var _this$node;this.key=key,this.node=this.container[this.key],this.type=null==(_this$node=this.node)?void 0:_this$node.type;},exports.setScope=function(){if(this.opts&&this.opts.noScope)return;let target,path=this.parentPath;"key"===this.key&&path.isMethod()&&(path=path.parentPath);for(;path&&!target;){if(path.opts&&path.opts.noScope)return;target=path.scope,path=path.parentPath;}this.scope=this.getScope(target),this.scope&&this.scope.init();},exports.setup=function(parentPath,container,listKey,key){this.listKey=listKey,this.container=container,this.parentPath=parentPath||this.parentPath,this.setKey(key);},exports.skip=function(){this.shouldSkip=!0;},exports.skipKey=function(key){null==this.skipKeys&&(this.skipKeys={});this.skipKeys[key]=!0;},exports.stop=function(){this._traverseFlags|=_index.SHOULD_SKIP|_index.SHOULD_STOP;},exports.visit=function(){if(!this.node)return !1;if(this.isDenylisted())return !1;if(this.opts.shouldSkip&&this.opts.shouldSkip(this))return !1;const currentContext=this.context;if(this.shouldSkip||this.call("enter"))return this.debug("Skip..."),this.shouldStop;return restoreContext(this,currentContext),this.debug("Recursing into..."),this.shouldStop=(0, _traverseNode.traverseNode)(this.node,this.opts,this.scope,this.state,this,this.skipKeys),restoreContext(this,currentContext),this.call("exit"),this.shouldStop};var _traverseNode=__webpack_require__("./node_modules/@babel/traverse/lib/traverse-node.js"),_index=__webpack_require__("./node_modules/@babel/traverse/lib/path/index.js");function restoreContext(path,context){path.context!==context&&(path.context=context,path.state=context.state,path.opts=context.opts);}},"./node_modules/@babel/traverse/lib/path/conversion.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.arrowFunctionToExpression=function({allowInsertArrow=!0,specCompliant=!1,noNewArrows=!specCompliant}={}){if(!this.isArrowFunctionExpression())throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");const{thisBinding,fnPath:fn}=hoistFunctionEnvironment(this,noNewArrows,allowInsertArrow);if(fn.ensureBlock(),fn.node.type="FunctionExpression",!noNewArrows){const checkBinding=thisBinding?null:fn.scope.generateUidIdentifier("arrowCheckId");checkBinding&&fn.parentPath.scope.push({id:checkBinding,init:objectExpression([])}),fn.get("body").unshiftContainer("body",expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"),[thisExpression(),identifier(checkBinding?checkBinding.name:thisBinding)]))),fn.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this,!0)||fn.node,identifier("bind")),[checkBinding?identifier(checkBinding.name):thisExpression()]));}},exports.arrowFunctionToShadowed=function(){if(!this.isArrowFunctionExpression())return;this.arrowFunctionToExpression();},exports.ensureBlock=function(){const body=this.get("body"),bodyNode=body.node;if(Array.isArray(body))throw new Error("Can't convert array path to a block statement");if(!bodyNode)throw new Error("Can't convert node without a body");if(body.isBlockStatement())return bodyNode;const statements=[];let key,listKey,stringPath="body";body.isStatement()?(listKey="body",key=0,statements.push(body.node)):(stringPath+=".body.0",this.isFunction()?(key="argument",statements.push(returnStatement(body.node))):(key="expression",statements.push(expressionStatement(body.node))));this.node.body=blockStatement(statements);const parentPath=this.get(stringPath);return body.setup(parentPath,listKey?parentPath.node[listKey]:parentPath.node,listKey,key),this.node},exports.toComputedKey=function(){let key;if(this.isMemberExpression())key=this.node.property;else {if(!this.isProperty()&&!this.isMethod())throw new ReferenceError("todo");key=this.node.key;}this.node.computed||isIdentifier(key)&&(key=stringLiteral(key.name));return key},exports.unwrapFunctionEnvironment=function(){if(!this.isArrowFunctionExpression()&&!this.isFunctionExpression()&&!this.isFunctionDeclaration())throw this.buildCodeFrameError("Can only unwrap the environment of a function.");hoistFunctionEnvironment(this);};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js"),_helperEnvironmentVisitor=__webpack_require__("./node_modules/@babel/helper-environment-visitor/lib/index.js"),_helperFunctionName=__webpack_require__("./node_modules/@babel/helper-function-name/lib/index.js"),_visitors=__webpack_require__("./node_modules/@babel/traverse/lib/visitors.js");const{arrowFunctionExpression,assignmentExpression,binaryExpression,blockStatement,callExpression,conditionalExpression,expressionStatement,identifier,isIdentifier,jsxIdentifier,logicalExpression,LOGICAL_OPERATORS,memberExpression,metaProperty,numericLiteral,objectExpression,restElement,returnStatement,sequenceExpression,spreadElement,stringLiteral,super:_super,thisExpression,toExpression,unaryExpression}=_t;const getSuperCallsVisitor=(0, _visitors.merge)([{CallExpression(child,{allSuperCalls}){child.get("callee").isSuper()&&allSuperCalls.push(child);}},_helperEnvironmentVisitor.default]);function hoistFunctionEnvironment(fnPath,noNewArrows=!0,allowInsertArrow=!0){let arrowParent,thisEnvFn=fnPath.findParent((p=>p.isArrowFunctionExpression()?(null!=arrowParent||(arrowParent=p),!1):p.isFunction()||p.isProgram()||p.isClassProperty({static:!1})||p.isClassPrivateProperty({static:!1})));const inConstructor=thisEnvFn.isClassMethod({kind:"constructor"});if(thisEnvFn.isClassProperty()||thisEnvFn.isClassPrivateProperty())if(arrowParent)thisEnvFn=arrowParent;else {if(!allowInsertArrow)throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");fnPath.replaceWith(callExpression(arrowFunctionExpression([],toExpression(fnPath.node)),[])),thisEnvFn=fnPath.get("callee"),fnPath=thisEnvFn.get("body");}const{thisPaths,argumentsPaths,newTargetPaths,superProps,superCalls}=function(fnPath){const thisPaths=[],argumentsPaths=[],newTargetPaths=[],superProps=[],superCalls=[];return fnPath.traverse(getScopeInformationVisitor,{thisPaths,argumentsPaths,newTargetPaths,superProps,superCalls}),{thisPaths,argumentsPaths,newTargetPaths,superProps,superCalls}}(fnPath);if(inConstructor&&superCalls.length>0){if(!allowInsertArrow)throw superCalls[0].buildCodeFrameError("Unable to handle nested super() usage in arrow");const allSuperCalls=[];thisEnvFn.traverse(getSuperCallsVisitor,{allSuperCalls});const superBinding=function(thisEnvFn){return getBinding(thisEnvFn,"supercall",(()=>{const argsBinding=thisEnvFn.scope.generateUidIdentifier("args");return arrowFunctionExpression([restElement(argsBinding)],callExpression(_super(),[spreadElement(identifier(argsBinding.name))]))}))}(thisEnvFn);allSuperCalls.forEach((superCall=>{const callee=identifier(superBinding);callee.loc=superCall.node.callee.loc,superCall.get("callee").replaceWith(callee);}));}if(argumentsPaths.length>0){const argumentsBinding=getBinding(thisEnvFn,"arguments",(()=>{const args=()=>identifier("arguments");return thisEnvFn.scope.path.isProgram()?conditionalExpression(binaryExpression("===",unaryExpression("typeof",args()),stringLiteral("undefined")),thisEnvFn.scope.buildUndefinedNode(),args()):args()}));argumentsPaths.forEach((argumentsChild=>{const argsRef=identifier(argumentsBinding);argsRef.loc=argumentsChild.node.loc,argumentsChild.replaceWith(argsRef);}));}if(newTargetPaths.length>0){const newTargetBinding=getBinding(thisEnvFn,"newtarget",(()=>metaProperty(identifier("new"),identifier("target"))));newTargetPaths.forEach((targetChild=>{const targetRef=identifier(newTargetBinding);targetRef.loc=targetChild.node.loc,targetChild.replaceWith(targetRef);}));}if(superProps.length>0){if(!allowInsertArrow)throw superProps[0].buildCodeFrameError("Unable to handle nested super.prop usage");superProps.reduce(((acc,superProp)=>acc.concat(function(superProp){if(superProp.parentPath.isAssignmentExpression()&&"="!==superProp.parentPath.node.operator){const assignmentPath=superProp.parentPath,op=assignmentPath.node.operator.slice(0,-1),value=assignmentPath.node.right,isLogicalAssignment=function(op){return LOGICAL_OPERATORS.includes(op)}(op);if(superProp.node.computed){const tmp=superProp.scope.generateDeclaredUidIdentifier("tmp"),object=superProp.node.object,property=superProp.node.property;assignmentPath.get("left").replaceWith(memberExpression(object,assignmentExpression("=",tmp,property),!0)),assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment?"=":op,memberExpression(object,identifier(tmp.name),!0),value));}else {const object=superProp.node.object,property=superProp.node.property;assignmentPath.get("left").replaceWith(memberExpression(object,property)),assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment?"=":op,memberExpression(object,identifier(property.name)),value));}return isLogicalAssignment?assignmentPath.replaceWith(logicalExpression(op,assignmentPath.node.left,assignmentPath.node.right)):assignmentPath.node.operator="=",[assignmentPath.get("left"),assignmentPath.get("right").get("left")]}if(superProp.parentPath.isUpdateExpression()){const updateExpr=superProp.parentPath,tmp=superProp.scope.generateDeclaredUidIdentifier("tmp"),computedKey=superProp.node.computed?superProp.scope.generateDeclaredUidIdentifier("prop"):null,parts=[assignmentExpression("=",tmp,memberExpression(superProp.node.object,computedKey?assignmentExpression("=",computedKey,superProp.node.property):superProp.node.property,superProp.node.computed)),assignmentExpression("=",memberExpression(superProp.node.object,computedKey?identifier(computedKey.name):superProp.node.property,superProp.node.computed),binaryExpression(superProp.parentPath.node.operator[0],identifier(tmp.name),numericLiteral(1)))];superProp.parentPath.node.prefix||parts.push(identifier(tmp.name)),updateExpr.replaceWith(sequenceExpression(parts));return [updateExpr.get("expressions.0.right"),updateExpr.get("expressions.1.left")]}return [superProp];function rightExpression(op,left,right){return "="===op?assignmentExpression("=",left,right):binaryExpression(op,left,right)}}(superProp))),[]).forEach((superProp=>{const key=superProp.node.computed?"":superProp.get("property").node.name,isAssignment=superProp.parentPath.isAssignmentExpression({left:superProp.node}),isCall=superProp.parentPath.isCallExpression({callee:superProp.node}),superBinding=function(thisEnvFn,isAssignment,propName){return getBinding(thisEnvFn,`superprop_${isAssignment?"set":"get"}:${propName||""}`,(()=>{const argsList=[];let fnBody;if(propName)fnBody=memberExpression(_super(),identifier(propName));else {const method=thisEnvFn.scope.generateUidIdentifier("prop");argsList.unshift(method),fnBody=memberExpression(_super(),identifier(method.name),!0);}if(isAssignment){const valueIdent=thisEnvFn.scope.generateUidIdentifier("value");argsList.push(valueIdent),fnBody=assignmentExpression("=",fnBody,identifier(valueIdent.name));}return arrowFunctionExpression(argsList,fnBody)}))}(thisEnvFn,isAssignment,key),args=[];if(superProp.node.computed&&args.push(superProp.get("property").node),isAssignment){const value=superProp.parentPath.node.right;args.push(value);}const call=callExpression(identifier(superBinding),args);isCall?(superProp.parentPath.unshiftContainer("arguments",thisExpression()),superProp.replaceWith(memberExpression(call,identifier("call"))),thisPaths.push(superProp.parentPath.get("arguments.0"))):isAssignment?superProp.parentPath.replaceWith(call):superProp.replaceWith(call);}));}let thisBinding;return (thisPaths.length>0||!noNewArrows)&&(thisBinding=function(thisEnvFn,inConstructor){return getBinding(thisEnvFn,"this",(thisBinding=>{if(!inConstructor||!hasSuperClass(thisEnvFn))return thisExpression();thisEnvFn.traverse(assignSuperThisVisitor,{supers:new WeakSet,thisBinding});}))}(thisEnvFn,inConstructor),(noNewArrows||inConstructor&&hasSuperClass(thisEnvFn))&&(thisPaths.forEach((thisChild=>{const thisRef=thisChild.isJSX()?jsxIdentifier(thisBinding):identifier(thisBinding);thisRef.loc=thisChild.node.loc,thisChild.replaceWith(thisRef);})),noNewArrows||(thisBinding=null))),{thisBinding,fnPath}}function hasSuperClass(thisEnvFn){return thisEnvFn.isClassMethod()&&!!thisEnvFn.parentPath.parentPath.node.superClass}const assignSuperThisVisitor=(0, _visitors.merge)([{CallExpression(child,{supers,thisBinding}){child.get("callee").isSuper()&&(supers.has(child.node)||(supers.add(child.node),child.replaceWithMultiple([child.node,assignmentExpression("=",identifier(thisBinding),identifier("this"))])));}},_helperEnvironmentVisitor.default]);function getBinding(thisEnvFn,key,init){const cacheKey="binding:"+key;let data=thisEnvFn.getData(cacheKey);if(!data){const id=thisEnvFn.scope.generateUidIdentifier(key);data=id.name,thisEnvFn.setData(cacheKey,data),thisEnvFn.scope.push({id,init:init(data)});}return data}const getScopeInformationVisitor=(0, _visitors.merge)([{ThisExpression(child,{thisPaths}){thisPaths.push(child);},JSXIdentifier(child,{thisPaths}){"this"===child.node.name&&(child.parentPath.isJSXMemberExpression({object:child.node})||child.parentPath.isJSXOpeningElement({name:child.node}))&&thisPaths.push(child);},CallExpression(child,{superCalls}){child.get("callee").isSuper()&&superCalls.push(child);},MemberExpression(child,{superProps}){child.get("object").isSuper()&&superProps.push(child);},Identifier(child,{argumentsPaths}){if(!child.isReferencedIdentifier({name:"arguments"}))return;let curr=child.scope;do{if(curr.hasOwnBinding("arguments"))return void curr.rename("arguments");if(curr.path.isFunction()&&!curr.path.isArrowFunctionExpression())break}while(curr=curr.parent);argumentsPaths.push(child);},MetaProperty(child,{newTargetPaths}){child.get("meta").isIdentifier({name:"new"})&&child.get("property").isIdentifier({name:"target"})&&newTargetPaths.push(child);}},_helperEnvironmentVisitor.default]);},"./node_modules/@babel/traverse/lib/path/evaluation.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.evaluate=function(){const state={confident:!0,deoptPath:null,seen:new Map};let value=evaluateCached(this,state);state.confident||(value=void 0);return {confident:state.confident,deopt:state.deoptPath,value}},exports.evaluateTruthy=function(){const res=this.evaluate();if(res.confident)return !!res.value};const VALID_CALLEES=["String","Number","Math"],INVALID_METHODS=["random"];function deopt(path,state){state.confident&&(state.deoptPath=path,state.confident=!1);}function evaluateCached(path,state){const{node}=path,{seen}=state;if(seen.has(node)){const existing=seen.get(node);return existing.resolved?existing.value:void deopt(path,state)}{const item={resolved:!1};seen.set(node,item);const val=function(path,state){if(!state.confident)return;if(path.isSequenceExpression()){const exprs=path.get("expressions");return evaluateCached(exprs[exprs.length-1],state)}if(path.isStringLiteral()||path.isNumericLiteral()||path.isBooleanLiteral())return path.node.value;if(path.isNullLiteral())return null;if(path.isTemplateLiteral())return evaluateQuasis(path,path.node.quasis,state);if(path.isTaggedTemplateExpression()&&path.get("tag").isMemberExpression()){const object=path.get("tag.object"),{node:{name}}=object,property=path.get("tag.property");if(object.isIdentifier()&&"String"===name&&!path.scope.getBinding(name)&&property.isIdentifier()&&"raw"===property.node.name)return evaluateQuasis(path,path.node.quasi.quasis,state,!0)}if(path.isConditionalExpression()){const testResult=evaluateCached(path.get("test"),state);if(!state.confident)return;return evaluateCached(testResult?path.get("consequent"):path.get("alternate"),state)}if(path.isExpressionWrapper())return evaluateCached(path.get("expression"),state);if(path.isMemberExpression()&&!path.parentPath.isCallExpression({callee:path.node})){const property=path.get("property"),object=path.get("object");if(object.isLiteral()&&property.isIdentifier()){const value=object.node.value,type=typeof value;if("number"===type||"string"===type)return value[property.node.name]}}if(path.isReferencedIdentifier()){const binding=path.scope.getBinding(path.node.name);if(binding&&binding.constantViolations.length>0)return deopt(binding.path,state);if(binding&&path.node.start<binding.path.node.end)return deopt(binding.path,state);if(null!=binding&&binding.hasValue)return binding.value;{if("undefined"===path.node.name)return binding?deopt(binding.path,state):void 0;if("Infinity"===path.node.name)return binding?deopt(binding.path,state):1/0;if("NaN"===path.node.name)return binding?deopt(binding.path,state):NaN;const resolved=path.resolve();return resolved===path?deopt(path,state):evaluateCached(resolved,state)}}if(path.isUnaryExpression({prefix:!0})){if("void"===path.node.operator)return;const argument=path.get("argument");if("typeof"===path.node.operator&&(argument.isFunction()||argument.isClass()))return "function";const arg=evaluateCached(argument,state);if(!state.confident)return;switch(path.node.operator){case"!":return !arg;case"+":return +arg;case"-":return -arg;case"~":return ~arg;case"typeof":return typeof arg}}if(path.isArrayExpression()){const arr=[],elems=path.get("elements");for(const elem of elems){const elemValue=elem.evaluate();if(!elemValue.confident)return deopt(elemValue.deopt,state);arr.push(elemValue.value);}return arr}if(path.isObjectExpression()){const obj={},props=path.get("properties");for(const prop of props){if(prop.isObjectMethod()||prop.isSpreadElement())return deopt(prop,state);let key=prop.get("key");if(prop.node.computed){if(key=key.evaluate(),!key.confident)return deopt(key.deopt,state);key=key.value;}else key=key.isIdentifier()?key.node.name:key.node.value;let value=prop.get("value").evaluate();if(!value.confident)return deopt(value.deopt,state);value=value.value,obj[key]=value;}return obj}if(path.isLogicalExpression()){const wasConfident=state.confident,left=evaluateCached(path.get("left"),state),leftConfident=state.confident;state.confident=wasConfident;const right=evaluateCached(path.get("right"),state),rightConfident=state.confident;switch(path.node.operator){case"||":if(state.confident=leftConfident&&(!!left||rightConfident),!state.confident)return;return left||right;case"&&":if(state.confident=leftConfident&&(!left||rightConfident),!state.confident)return;return left&&right}}if(path.isBinaryExpression()){const left=evaluateCached(path.get("left"),state);if(!state.confident)return;const right=evaluateCached(path.get("right"),state);if(!state.confident)return;switch(path.node.operator){case"-":return left-right;case"+":return left+right;case"/":return left/right;case"*":return left*right;case"%":return left%right;case"**":return Math.pow(left,right);case"<":return left<right;case">":return left>right;case"<=":return left<=right;case">=":return left>=right;case"==":return left==right;case"!=":return left!=right;case"===":return left===right;case"!==":return left!==right;case"|":return left|right;case"&":return left&right;case"^":return left^right;case"<<":return left<<right;case">>":return left>>right;case">>>":return left>>>right}}if(path.isCallExpression()){const callee=path.get("callee");let context,func;if(callee.isIdentifier()&&!path.scope.getBinding(callee.node.name)&&VALID_CALLEES.indexOf(callee.node.name)>=0&&(func=commonjsGlobal[callee.node.name]),callee.isMemberExpression()){const object=callee.get("object"),property=callee.get("property");if(object.isIdentifier()&&property.isIdentifier()&&VALID_CALLEES.indexOf(object.node.name)>=0&&INVALID_METHODS.indexOf(property.node.name)<0&&(context=commonjsGlobal[object.node.name],func=context[property.node.name]),object.isLiteral()&&property.isIdentifier()){const type=typeof object.node.value;"string"!==type&&"number"!==type||(context=object.node.value,func=context[property.node.name]);}}if(func){const args=path.get("arguments").map((arg=>evaluateCached(arg,state)));if(!state.confident)return;return func.apply(context,args)}}deopt(path,state);}(path,state);return state.confident&&(item.resolved=!0,item.value=val),val}}function evaluateQuasis(path,quasis,state,raw=!1){let str="",i=0;const exprs=path.get("expressions");for(const elem of quasis){if(!state.confident)break;str+=raw?elem.value.raw:elem.value.cooked;const expr=exprs[i++];expr&&(str+=String(evaluateCached(expr,state)));}if(state.confident)return str}},"./node_modules/@babel/traverse/lib/path/family.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports._getKey=function(key,context){const node=this.node,container=node[key];return Array.isArray(container)?container.map(((_,i)=>_index.default.get({listKey:key,parentPath:this,parent:node,container,key:i}).setContext(context))):_index.default.get({parentPath:this,parent:node,container:node,key}).setContext(context)},exports._getPattern=function(parts,context){let path=this;for(const part of parts)path="."===part?path.parentPath:Array.isArray(path)?path[part]:path.get(part,context);return path},exports.get=function(key,context=!0){!0===context&&(context=this.context);const parts=key.split(".");return 1===parts.length?this._getKey(key,context):this._getPattern(parts,context)},exports.getAllNextSiblings=function(){let _key=this.key,sibling=this.getSibling(++_key);const siblings=[];for(;sibling.node;)siblings.push(sibling),sibling=this.getSibling(++_key);return siblings},exports.getAllPrevSiblings=function(){let _key=this.key,sibling=this.getSibling(--_key);const siblings=[];for(;sibling.node;)siblings.push(sibling),sibling=this.getSibling(--_key);return siblings},exports.getBindingIdentifierPaths=function(duplicates=!1,outerOnly=!1){const search=[this],ids=Object.create(null);for(;search.length;){const id=search.shift();if(!id)continue;if(!id.node)continue;const keys=_getBindingIdentifiers.keys[id.node.type];if(id.isIdentifier())if(duplicates){(ids[id.node.name]=ids[id.node.name]||[]).push(id);}else ids[id.node.name]=id;else if(id.isExportDeclaration()){const declaration=id.get("declaration");isDeclaration(declaration)&&search.push(declaration);}else {if(outerOnly){if(id.isFunctionDeclaration()){search.push(id.get("id"));continue}if(id.isFunctionExpression())continue}if(keys)for(let i=0;i<keys.length;i++){const key=keys[i],child=id.get(key);Array.isArray(child)?search.push(...child):child.node&&search.push(child);}}}return ids},exports.getBindingIdentifiers=function(duplicates){return _getBindingIdentifiers(this.node,duplicates)},exports.getCompletionRecords=function(){return _getCompletionRecords(this,{canHaveBreak:!1,shouldPopulateBreak:!1,inCaseClause:!1}).map((r=>r.path))},exports.getNextSibling=function(){return this.getSibling(this.key+1)},exports.getOpposite=function(){if("left"===this.key)return this.getSibling("right");if("right"===this.key)return this.getSibling("left");return null},exports.getOuterBindingIdentifierPaths=function(duplicates){return this.getBindingIdentifierPaths(duplicates,!0)},exports.getOuterBindingIdentifiers=function(duplicates){return _getOuterBindingIdentifiers(this.node,duplicates)},exports.getPrevSibling=function(){return this.getSibling(this.key-1)},exports.getSibling=function(key){return _index.default.get({parentPath:this.parentPath,parent:this.parent,container:this.container,listKey:this.listKey,key}).setContext(this.context)};var _index=__webpack_require__("./node_modules/@babel/traverse/lib/path/index.js"),_t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{getBindingIdentifiers:_getBindingIdentifiers,getOuterBindingIdentifiers:_getOuterBindingIdentifiers,isDeclaration,numericLiteral,unaryExpression}=_t;function addCompletionRecords(path,records,context){return path&&records.push(..._getCompletionRecords(path,context)),records}function normalCompletionToBreak(completions){completions.forEach((c=>{c.type=1;}));}function replaceBreakStatementInBreakCompletion(completions,reachable){completions.forEach((c=>{c.path.isBreakStatement({label:null})&&(reachable?c.path.replaceWith(unaryExpression("void",numericLiteral(0))):c.path.remove());}));}function getStatementListCompletion(paths,context){const completions=[];if(context.canHaveBreak){let lastNormalCompletions=[];for(let i=0;i<paths.length;i++){const path=paths[i],newContext=Object.assign({},context,{inCaseClause:!1});path.isBlockStatement()&&(context.inCaseClause||context.shouldPopulateBreak)?newContext.shouldPopulateBreak=!0:newContext.shouldPopulateBreak=!1;const statementCompletions=_getCompletionRecords(path,newContext);if(statementCompletions.length>0&&statementCompletions.every((c=>1===c.type))){lastNormalCompletions.length>0&&statementCompletions.every((c=>c.path.isBreakStatement({label:null})))?(normalCompletionToBreak(lastNormalCompletions),completions.push(...lastNormalCompletions),lastNormalCompletions.some((c=>c.path.isDeclaration()))&&(completions.push(...statementCompletions),replaceBreakStatementInBreakCompletion(statementCompletions,!0)),replaceBreakStatementInBreakCompletion(statementCompletions,!1)):(completions.push(...statementCompletions),context.shouldPopulateBreak||replaceBreakStatementInBreakCompletion(statementCompletions,!0));break}if(i===paths.length-1)completions.push(...statementCompletions);else {lastNormalCompletions=[];for(let i=0;i<statementCompletions.length;i++){const c=statementCompletions[i];1===c.type&&completions.push(c),0===c.type&&lastNormalCompletions.push(c);}}}}else if(paths.length)for(let i=paths.length-1;i>=0;i--){const pathCompletions=_getCompletionRecords(paths[i],context);if(pathCompletions.length>1||1===pathCompletions.length&&!pathCompletions[0].path.isVariableDeclaration()){completions.push(...pathCompletions);break}}return completions}function _getCompletionRecords(path,context){let records=[];if(path.isIfStatement())records=addCompletionRecords(path.get("consequent"),records,context),records=addCompletionRecords(path.get("alternate"),records,context);else {if(path.isDoExpression()||path.isFor()||path.isWhile()||path.isLabeledStatement())return addCompletionRecords(path.get("body"),records,context);if(path.isProgram()||path.isBlockStatement())return getStatementListCompletion(path.get("body"),context);if(path.isFunction())return _getCompletionRecords(path.get("body"),context);if(path.isTryStatement())records=addCompletionRecords(path.get("block"),records,context),records=addCompletionRecords(path.get("handler"),records,context);else {if(path.isCatchClause())return addCompletionRecords(path.get("body"),records,context);if(path.isSwitchStatement())return function(cases,records,context){let lastNormalCompletions=[];for(let i=0;i<cases.length;i++){const caseCompletions=_getCompletionRecords(cases[i],context),normalCompletions=[],breakCompletions=[];for(const c of caseCompletions)0===c.type&&normalCompletions.push(c),1===c.type&&breakCompletions.push(c);normalCompletions.length&&(lastNormalCompletions=normalCompletions),records.push(...breakCompletions);}return records.push(...lastNormalCompletions),records}(path.get("cases"),records,context);if(path.isSwitchCase())return getStatementListCompletion(path.get("consequent"),{canHaveBreak:!0,shouldPopulateBreak:!1,inCaseClause:!0});path.isBreakStatement()?records.push(function(path){return {type:1,path}}(path)):records.push(function(path){return {type:0,path}}(path));}}return records}},"./node_modules/@babel/traverse/lib/path/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=exports.SHOULD_STOP=exports.SHOULD_SKIP=exports.REMOVED=void 0;var virtualTypes=__webpack_require__("./node_modules/@babel/traverse/lib/path/lib/virtual-types.js"),_debug=__webpack_require__("./node_modules/debug/src/index.js"),_index=__webpack_require__("./node_modules/@babel/traverse/lib/index.js"),_scope=__webpack_require__("./node_modules/@babel/traverse/lib/scope/index.js"),_t=__webpack_require__("./node_modules/@babel/types/lib/index.js"),t=_t,_cache=__webpack_require__("./node_modules/@babel/traverse/lib/cache.js"),_generator=__webpack_require__("./node_modules/@babel/generator/lib/index.js"),NodePath_ancestry=__webpack_require__("./node_modules/@babel/traverse/lib/path/ancestry.js"),NodePath_inference=__webpack_require__("./node_modules/@babel/traverse/lib/path/inference/index.js"),NodePath_replacement=__webpack_require__("./node_modules/@babel/traverse/lib/path/replacement.js"),NodePath_evaluation=__webpack_require__("./node_modules/@babel/traverse/lib/path/evaluation.js"),NodePath_conversion=__webpack_require__("./node_modules/@babel/traverse/lib/path/conversion.js"),NodePath_introspection=__webpack_require__("./node_modules/@babel/traverse/lib/path/introspection.js"),NodePath_context=__webpack_require__("./node_modules/@babel/traverse/lib/path/context.js"),NodePath_removal=__webpack_require__("./node_modules/@babel/traverse/lib/path/removal.js"),NodePath_modification=__webpack_require__("./node_modules/@babel/traverse/lib/path/modification.js"),NodePath_family=__webpack_require__("./node_modules/@babel/traverse/lib/path/family.js"),NodePath_comments=__webpack_require__("./node_modules/@babel/traverse/lib/path/comments.js");const{validate}=_t,debug=_debug("babel");exports.REMOVED=1;exports.SHOULD_STOP=2;exports.SHOULD_SKIP=4;class NodePath{constructor(hub,parent){this.contexts=[],this.state=null,this.opts=null,this._traverseFlags=0,this.skipKeys=null,this.parentPath=null,this.container=null,this.listKey=null,this.key=null,this.node=null,this.type=null,this.parent=parent,this.hub=hub,this.data=null,this.context=null,this.scope=null;}static get({hub,parentPath,parent,container,listKey,key}){if(!hub&&parentPath&&(hub=parentPath.hub),!parent)throw new Error("To get a node path the parent needs to exist");const targetNode=container[key];let paths=_cache.path.get(parent);paths||(paths=new Map,_cache.path.set(parent,paths));let path=paths.get(targetNode);return path||(path=new NodePath(hub,parent),targetNode&&paths.set(targetNode,path)),path.setup(parentPath,container,listKey,key),path}getScope(scope){return this.isScope()?new _scope.default(this):scope}setData(key,val){return null==this.data&&(this.data=Object.create(null)),this.data[key]=val}getData(key,def){null==this.data&&(this.data=Object.create(null));let val=this.data[key];return void 0===val&&void 0!==def&&(val=this.data[key]=def),val}buildCodeFrameError(msg,Error=SyntaxError){return this.hub.buildError(this.node,msg,Error)}traverse(visitor,state){(0, _index.default)(this.node,visitor,this.scope,state,this);}set(key,node){validate(this.node,key,node),this.node[key]=node;}getPathLocation(){const parts=[];let path=this;do{let key=path.key;path.inList&&(key=`${path.listKey}[${key}]`),parts.unshift(key);}while(path=path.parentPath);return parts.join(".")}debug(message){debug.enabled&&debug(`${this.getPathLocation()} ${this.type}: ${message}`);}toString(){return (0, _generator.default)(this.node).code}get inList(){return !!this.listKey}set inList(inList){inList||(this.listKey=null);}get parentKey(){return this.listKey||this.key}get shouldSkip(){return !!(4&this._traverseFlags)}set shouldSkip(v){v?this._traverseFlags|=4:this._traverseFlags&=-5;}get shouldStop(){return !!(2&this._traverseFlags)}set shouldStop(v){v?this._traverseFlags|=2:this._traverseFlags&=-3;}get removed(){return !!(1&this._traverseFlags)}set removed(v){v?this._traverseFlags|=1:this._traverseFlags&=-2;}}Object.assign(NodePath.prototype,NodePath_ancestry,NodePath_inference,NodePath_replacement,NodePath_evaluation,NodePath_conversion,NodePath_introspection,NodePath_context,NodePath_removal,NodePath_modification,NodePath_family,NodePath_comments);for(const type of t.TYPES){const typeKey=`is${type}`,fn=t[typeKey];NodePath.prototype[typeKey]=function(opts){return fn(this.node,opts)},NodePath.prototype[`assert${type}`]=function(opts){if(!fn(this.node,opts))throw new TypeError(`Expected node path of type ${type}`)};}for(const type of Object.keys(virtualTypes)){if("_"===type[0])continue;t.TYPES.indexOf(type)<0&&t.TYPES.push(type);const virtualType=virtualTypes[type];NodePath.prototype[`is${type}`]=function(opts){return virtualType.checkPath(this,opts)};}var _default=NodePath;exports.default=_default;},"./node_modules/@babel/traverse/lib/path/inference/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports._getTypeAnnotation=function(){const node=this.node;if(!node){if("init"===this.key&&this.parentPath.isVariableDeclarator()){const declar=this.parentPath.parentPath,declarParent=declar.parentPath;return "left"===declar.key&&declarParent.isForInStatement()?stringTypeAnnotation():"left"===declar.key&&declarParent.isForOfStatement()?anyTypeAnnotation():voidTypeAnnotation()}return}if(node.typeAnnotation)return node.typeAnnotation;if(typeAnnotationInferringNodes.has(node))return;typeAnnotationInferringNodes.add(node);try{var _inferer;let inferer=inferers[node.type];if(inferer)return inferer.call(this,node);if(inferer=inferers[this.parentPath.type],null!=(_inferer=inferer)&&_inferer.validParent)return this.parentPath.getTypeAnnotation()}finally{typeAnnotationInferringNodes.delete(node);}},exports.baseTypeStrictlyMatches=function(rightArg){const left=this.getTypeAnnotation(),right=rightArg.getTypeAnnotation();if(!isAnyTypeAnnotation(left)&&isFlowBaseAnnotation(left))return right.type===left.type;return !1},exports.couldBeBaseType=function(name){const type=this.getTypeAnnotation();if(isAnyTypeAnnotation(type))return !0;if(isUnionTypeAnnotation(type)){for(const type2 of type.types)if(isAnyTypeAnnotation(type2)||_isBaseType(name,type2,!0))return !0;return !1}return _isBaseType(name,type,!0)},exports.getTypeAnnotation=function(){if(this.typeAnnotation)return this.typeAnnotation;let type=this._getTypeAnnotation()||anyTypeAnnotation();isTypeAnnotation(type)&&(type=type.typeAnnotation);return this.typeAnnotation=type},exports.isBaseType=function(baseName,soft){return _isBaseType(baseName,this.getTypeAnnotation(),soft)},exports.isGenericType=function(genericName){const type=this.getTypeAnnotation();return isGenericTypeAnnotation(type)&&isIdentifier(type.id,{name:genericName})};var inferers=__webpack_require__("./node_modules/@babel/traverse/lib/path/inference/inferers.js"),_t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{anyTypeAnnotation,isAnyTypeAnnotation,isBooleanTypeAnnotation,isEmptyTypeAnnotation,isFlowBaseAnnotation,isGenericTypeAnnotation,isIdentifier,isMixedTypeAnnotation,isNumberTypeAnnotation,isStringTypeAnnotation,isTypeAnnotation,isUnionTypeAnnotation,isVoidTypeAnnotation,stringTypeAnnotation,voidTypeAnnotation}=_t;const typeAnnotationInferringNodes=new WeakSet;function _isBaseType(baseName,type,soft){if("string"===baseName)return isStringTypeAnnotation(type);if("number"===baseName)return isNumberTypeAnnotation(type);if("boolean"===baseName)return isBooleanTypeAnnotation(type);if("any"===baseName)return isAnyTypeAnnotation(type);if("mixed"===baseName)return isMixedTypeAnnotation(type);if("empty"===baseName)return isEmptyTypeAnnotation(type);if("void"===baseName)return isVoidTypeAnnotation(type);if(soft)return !1;throw new Error(`Unknown base type ${baseName}`)}},"./node_modules/@babel/traverse/lib/path/inference/inferer-reference.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node){if(!this.isReferenced())return;const binding=this.scope.getBinding(node.name);if(binding)return binding.identifier.typeAnnotation?binding.identifier.typeAnnotation:function(binding,path,name){const types=[],functionConstantViolations=[];let constantViolations=getConstantViolationsBefore(binding,path,functionConstantViolations);const testType=getConditionalAnnotation(binding,path,name);if(testType){const testConstantViolations=getConstantViolationsBefore(binding,testType.ifStatement);constantViolations=constantViolations.filter((path=>testConstantViolations.indexOf(path)<0)),types.push(testType.typeAnnotation);}if(constantViolations.length){constantViolations.push(...functionConstantViolations);for(const violation of constantViolations)types.push(violation.getTypeAnnotation());}if(!types.length)return;if(isTSTypeAnnotation(types[0])&&createTSUnionType)return createTSUnionType(types);if(createFlowUnionType)return createFlowUnionType(types);return createUnionTypeAnnotation(types)}(binding,this,node.name);if("undefined"===node.name)return voidTypeAnnotation();if("NaN"===node.name||"Infinity"===node.name)return numberTypeAnnotation();node.name;};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{BOOLEAN_NUMBER_BINARY_OPERATORS,createFlowUnionType,createTSUnionType,createTypeAnnotationBasedOnTypeof,createUnionTypeAnnotation,isTSTypeAnnotation,numberTypeAnnotation,voidTypeAnnotation}=_t;function getConstantViolationsBefore(binding,path,functions){const violations=binding.constantViolations.slice();return violations.unshift(binding.path),violations.filter((violation=>{const status=(violation=violation.resolve())._guessExecutionStatusRelativeTo(path);return functions&&"unknown"===status&&functions.push(violation),"before"===status}))}function inferAnnotationFromBinaryExpression(name,path){const operator=path.node.operator,right=path.get("right").resolve(),left=path.get("left").resolve();let target,typeofPath,typePath;if(left.isIdentifier({name})?target=right:right.isIdentifier({name})&&(target=left),target)return "==="===operator?target.getTypeAnnotation():BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator)>=0?numberTypeAnnotation():void 0;if("==="!==operator&&"=="!==operator)return;if(left.isUnaryExpression({operator:"typeof"})?(typeofPath=left,typePath=right):right.isUnaryExpression({operator:"typeof"})&&(typeofPath=right,typePath=left),!typeofPath)return;if(!typeofPath.get("argument").isIdentifier({name}))return;if(typePath=typePath.resolve(),!typePath.isLiteral())return;const typeValue=typePath.node.value;return "string"==typeof typeValue?createTypeAnnotationBasedOnTypeof(typeValue):void 0}function getConditionalAnnotation(binding,path,name){const ifStatement=function(binding,path,name){let parentPath;for(;parentPath=path.parentPath;){if(parentPath.isIfStatement()||parentPath.isConditionalExpression()){if("test"===path.key)return;return parentPath}if(parentPath.isFunction()&&parentPath.parentPath.scope.getBinding(name)!==binding)return;path=parentPath;}}(binding,path,name);if(!ifStatement)return;const paths=[ifStatement.get("test")],types=[];for(let i=0;i<paths.length;i++){const path=paths[i];if(path.isLogicalExpression())"&&"===path.node.operator&&(paths.push(path.get("left")),paths.push(path.get("right")));else if(path.isBinaryExpression()){const type=inferAnnotationFromBinaryExpression(name,path);type&&types.push(type);}}return types.length?isTSTypeAnnotation(types[0])&&createTSUnionType?{typeAnnotation:createTSUnionType(types),ifStatement}:createFlowUnionType?{typeAnnotation:createFlowUnionType(types),ifStatement}:{typeAnnotation:createUnionTypeAnnotation(types),ifStatement}:getConditionalAnnotation(ifStatement,name)}},"./node_modules/@babel/traverse/lib/path/inference/inferers.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.ArrayExpression=ArrayExpression,exports.AssignmentExpression=function(){return this.get("right").getTypeAnnotation()},exports.BinaryExpression=function(node){const operator=node.operator;if(NUMBER_BINARY_OPERATORS.indexOf(operator)>=0)return numberTypeAnnotation();if(BOOLEAN_BINARY_OPERATORS.indexOf(operator)>=0)return booleanTypeAnnotation();if("+"===operator){const right=this.get("right"),left=this.get("left");return left.isBaseType("number")&&right.isBaseType("number")?numberTypeAnnotation():left.isBaseType("string")||right.isBaseType("string")?stringTypeAnnotation():unionTypeAnnotation([stringTypeAnnotation(),numberTypeAnnotation()])}},exports.BooleanLiteral=function(){return booleanTypeAnnotation()},exports.CallExpression=function(){const{callee}=this.node;if(isObjectKeys(callee))return arrayTypeAnnotation(stringTypeAnnotation());if(isArrayFrom(callee)||isObjectValues(callee))return arrayTypeAnnotation(anyTypeAnnotation());if(isObjectEntries(callee))return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(),anyTypeAnnotation()]));return resolveCall(this.get("callee"))},exports.ConditionalExpression=function(){const argumentTypes=[this.get("consequent").getTypeAnnotation(),this.get("alternate").getTypeAnnotation()];if(isTSTypeAnnotation(argumentTypes[0])&&createTSUnionType)return createTSUnionType(argumentTypes);if(createFlowUnionType)return createFlowUnionType(argumentTypes);return createUnionTypeAnnotation(argumentTypes)},exports.ClassDeclaration=exports.ClassExpression=exports.FunctionDeclaration=exports.ArrowFunctionExpression=exports.FunctionExpression=function(){return genericTypeAnnotation(identifier("Function"))},Object.defineProperty(exports,"Identifier",{enumerable:!0,get:function(){return _infererReference.default}}),exports.LogicalExpression=function(){const argumentTypes=[this.get("left").getTypeAnnotation(),this.get("right").getTypeAnnotation()];if(isTSTypeAnnotation(argumentTypes[0])&&createTSUnionType)return createTSUnionType(argumentTypes);if(createFlowUnionType)return createFlowUnionType(argumentTypes);return createUnionTypeAnnotation(argumentTypes)},exports.NewExpression=function(node){if(this.get("callee").isIdentifier())return genericTypeAnnotation(node.callee)},exports.NullLiteral=function(){return nullLiteralTypeAnnotation()},exports.NumericLiteral=function(){return numberTypeAnnotation()},exports.ObjectExpression=function(){return genericTypeAnnotation(identifier("Object"))},exports.ParenthesizedExpression=function(){return this.get("expression").getTypeAnnotation()},exports.RegExpLiteral=function(){return genericTypeAnnotation(identifier("RegExp"))},exports.RestElement=RestElement,exports.SequenceExpression=function(){return this.get("expressions").pop().getTypeAnnotation()},exports.StringLiteral=function(){return stringTypeAnnotation()},exports.TaggedTemplateExpression=function(){return resolveCall(this.get("tag"))},exports.TemplateLiteral=function(){return stringTypeAnnotation()},exports.TypeCastExpression=TypeCastExpression,exports.UnaryExpression=function(node){const operator=node.operator;if("void"===operator)return voidTypeAnnotation();if(NUMBER_UNARY_OPERATORS.indexOf(operator)>=0)return numberTypeAnnotation();if(STRING_UNARY_OPERATORS.indexOf(operator)>=0)return stringTypeAnnotation();if(BOOLEAN_UNARY_OPERATORS.indexOf(operator)>=0)return booleanTypeAnnotation()},exports.UpdateExpression=function(node){const operator=node.operator;if("++"===operator||"--"===operator)return numberTypeAnnotation()},exports.VariableDeclarator=function(){var _type;if(!this.get("id").isIdentifier())return;const init=this.get("init");let type=init.getTypeAnnotation();"AnyTypeAnnotation"===(null==(_type=type)?void 0:_type.type)&&init.isCallExpression()&&init.get("callee").isIdentifier({name:"Array"})&&!init.scope.hasBinding("Array",!0)&&(type=ArrayExpression());return type};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js"),_infererReference=__webpack_require__("./node_modules/@babel/traverse/lib/path/inference/inferer-reference.js");const{BOOLEAN_BINARY_OPERATORS,BOOLEAN_UNARY_OPERATORS,NUMBER_BINARY_OPERATORS,NUMBER_UNARY_OPERATORS,STRING_UNARY_OPERATORS,anyTypeAnnotation,arrayTypeAnnotation,booleanTypeAnnotation,buildMatchMemberExpression,createFlowUnionType,createTSUnionType,createUnionTypeAnnotation,genericTypeAnnotation,identifier,isTSTypeAnnotation,nullLiteralTypeAnnotation,numberTypeAnnotation,stringTypeAnnotation,tupleTypeAnnotation,unionTypeAnnotation,voidTypeAnnotation}=_t;function TypeCastExpression(node){return node.typeAnnotation}function ArrayExpression(){return genericTypeAnnotation(identifier("Array"))}function RestElement(){return ArrayExpression()}TypeCastExpression.validParent=!0,RestElement.validParent=!0;const isArrayFrom=buildMatchMemberExpression("Array.from"),isObjectKeys=buildMatchMemberExpression("Object.keys"),isObjectValues=buildMatchMemberExpression("Object.values"),isObjectEntries=buildMatchMemberExpression("Object.entries");function resolveCall(callee){if((callee=callee.resolve()).isFunction()){if(callee.is("async"))return callee.is("generator")?genericTypeAnnotation(identifier("AsyncIterator")):genericTypeAnnotation(identifier("Promise"));if(callee.node.returnType)return callee.node.returnType}}},"./node_modules/@babel/traverse/lib/path/introspection.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports._guessExecutionStatusRelativeTo=function(target){const funcParent={this:getOuterFunction(this),target:getOuterFunction(target)};if(funcParent.target.node!==funcParent.this.node)return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);const paths={target:target.getAncestry(),this:this.getAncestry()};if(paths.target.indexOf(this)>=0)return "after";if(paths.this.indexOf(target)>=0)return "before";let commonPath;const commonIndex={target:0,this:0};for(;!commonPath&&commonIndex.this<paths.this.length;){const path=paths.this[commonIndex.this];commonIndex.target=paths.target.indexOf(path),commonIndex.target>=0?commonPath=path:commonIndex.this++;}if(!commonPath)throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");if(isExecutionUncertainInList(paths.this,commonIndex.this-1)||isExecutionUncertainInList(paths.target,commonIndex.target-1))return "unknown";const divergence={this:paths.this[commonIndex.this-1],target:paths.target[commonIndex.target-1]};if(divergence.target.listKey&&divergence.this.listKey&&divergence.target.container===divergence.this.container)return divergence.target.key>divergence.this.key?"before":"after";const keys=VISITOR_KEYS[commonPath.type],keyPosition={this:keys.indexOf(divergence.this.parentKey),target:keys.indexOf(divergence.target.parentKey)};return keyPosition.target>keyPosition.this?"before":"after"},exports._guessExecutionStatusRelativeToDifferentFunctions=function(target){if(!target.isFunctionDeclaration()||target.parentPath.isExportDeclaration())return "unknown";const binding=target.scope.getBinding(target.node.id.name);if(!binding.references)return "before";const referencePaths=binding.referencePaths;let allStatus;for(const path of referencePaths){if(!!path.find((path=>path.node===target.node)))continue;if("callee"!==path.key||!path.parentPath.isCallExpression())return "unknown";if(executionOrderCheckedNodes.has(path.node))continue;executionOrderCheckedNodes.add(path.node);const status=this._guessExecutionStatusRelativeTo(path);if(executionOrderCheckedNodes.delete(path.node),allStatus&&allStatus!==status)return "unknown";allStatus=status;}return allStatus},exports._resolve=function(dangerous,resolved){if(resolved&&resolved.indexOf(this)>=0)return;if((resolved=resolved||[]).push(this),this.isVariableDeclarator()){if(this.get("id").isIdentifier())return this.get("init").resolve(dangerous,resolved)}else if(this.isReferencedIdentifier()){const binding=this.scope.getBinding(this.node.name);if(!binding)return;if(!binding.constant)return;if("module"===binding.kind)return;if(binding.path!==this){const ret=binding.path.resolve(dangerous,resolved);if(this.find((parent=>parent.node===ret.node)))return;return ret}}else {if(this.isTypeCastExpression())return this.get("expression").resolve(dangerous,resolved);if(dangerous&&this.isMemberExpression()){const targetKey=this.toComputedKey();if(!isLiteral(targetKey))return;const targetName=targetKey.value,target=this.get("object").resolve(dangerous,resolved);if(target.isObjectExpression()){const props=target.get("properties");for(const prop of props){if(!prop.isProperty())continue;const key=prop.get("key");let match=prop.isnt("computed")&&key.isIdentifier({name:targetName});if(match=match||key.isLiteral({value:targetName}),match)return prop.get("value").resolve(dangerous,resolved)}}else if(target.isArrayExpression()&&!isNaN(+targetName)){const elem=target.get("elements")[targetName];if(elem)return elem.resolve(dangerous,resolved)}}}},exports.canHaveVariableDeclarationOrExpression=function(){return ("init"===this.key||"left"===this.key)&&this.parentPath.isFor()},exports.canSwapBetweenExpressionAndStatement=function(replacement){if("body"!==this.key||!this.parentPath.isArrowFunctionExpression())return !1;if(this.isExpression())return isBlockStatement(replacement);if(this.isBlockStatement())return isExpression(replacement);return !1},exports.equals=function(key,value){return this.node[key]===value},exports.getSource=function(){const node=this.node;if(node.end){const code=this.hub.getCode();if(code)return code.slice(node.start,node.end)}return ""},exports.has=has,exports.is=void 0,exports.isCompletionRecord=function(allowInsideFunction){let path=this,first=!0;do{const container=path.container;if(path.isFunction()&&!first)return !!allowInsideFunction;if(first=!1,Array.isArray(container)&&path.key!==container.length-1)return !1}while((path=path.parentPath)&&!path.isProgram());return !0},exports.isConstantExpression=function(){if(this.isIdentifier()){const binding=this.scope.getBinding(this.node.name);return !!binding&&binding.constant}if(this.isLiteral())return !this.isRegExpLiteral()&&(!this.isTemplateLiteral()||this.get("expressions").every((expression=>expression.isConstantExpression())));if(this.isUnaryExpression())return "void"===this.node.operator&&this.get("argument").isConstantExpression();if(this.isBinaryExpression())return this.get("left").isConstantExpression()&&this.get("right").isConstantExpression();return !1},exports.isInStrictMode=function(){const start=this.isProgram()?this:this.parentPath;return !!start.find((path=>{if(path.isProgram({sourceType:"module"}))return !0;if(path.isClass())return !0;if(!path.isProgram()&&!path.isFunction())return !1;if(path.isArrowFunctionExpression()&&!path.get("body").isBlockStatement())return !1;const body=path.isFunction()?path.node.body:path.node;for(const directive of body.directives)if("use strict"===directive.value.value)return !0}))},exports.isNodeType=function(type){return isType(this.type,type)},exports.isStatementOrBlock=function(){return !this.parentPath.isLabeledStatement()&&!isBlockStatement(this.container)&&STATEMENT_OR_BLOCK_KEYS.includes(this.key)},exports.isStatic=function(){return this.scope.isStatic(this.node)},exports.isnt=function(key){return !this.has(key)},exports.matchesPattern=function(pattern,allowPartial){return _matchesPattern(this.node,pattern,allowPartial)},exports.referencesImport=function(moduleSource,importName){if(!this.isReferencedIdentifier()){if((this.isMemberExpression()||this.isOptionalMemberExpression())&&(this.node.computed?isStringLiteral(this.node.property,{value:importName}):this.node.property.name===importName)){const object=this.get("object");return object.isReferencedIdentifier()&&object.referencesImport(moduleSource,"*")}return !1}const binding=this.scope.getBinding(this.node.name);if(!binding||"module"!==binding.kind)return !1;const path=binding.path,parent=path.parentPath;if(!parent.isImportDeclaration())return !1;if(parent.node.source.value!==moduleSource)return !1;if(!importName)return !0;if(path.isImportDefaultSpecifier()&&"default"===importName)return !0;if(path.isImportNamespaceSpecifier()&&"*"===importName)return !0;if(path.isImportSpecifier()&&isIdentifier(path.node.imported,{name:importName}))return !0;return !1},exports.resolve=function(dangerous,resolved){return this._resolve(dangerous,resolved)||this},exports.willIMaybeExecuteBefore=function(target){return "after"!==this._guessExecutionStatusRelativeTo(target)};var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{STATEMENT_OR_BLOCK_KEYS,VISITOR_KEYS,isBlockStatement,isExpression,isIdentifier,isLiteral,isStringLiteral,isType,matchesPattern:_matchesPattern}=_t;function has(key){const val=this.node&&this.node[key];return val&&Array.isArray(val)?!!val.length:!!val}const is=has;function getOuterFunction(path){return (path.scope.getFunctionParent()||path.scope.getProgramParent()).path}function isExecutionUncertain(type,key){switch(type){case"LogicalExpression":case"AssignmentPattern":return "right"===key;case"ConditionalExpression":case"IfStatement":return "consequent"===key||"alternate"===key;case"WhileStatement":case"DoWhileStatement":case"ForInStatement":case"ForOfStatement":return "body"===key;case"ForStatement":return "body"===key||"update"===key;case"SwitchStatement":return "cases"===key;case"TryStatement":return "handler"===key;case"OptionalMemberExpression":return "property"===key;case"OptionalCallExpression":return "arguments"===key;default:return !1}}function isExecutionUncertainInList(paths,maxIndex){for(let i=0;i<maxIndex;i++){const path=paths[i];if(isExecutionUncertain(path.parent.type,path.parentKey))return !0}return !1}exports.is=is;const executionOrderCheckedNodes=new WeakSet;},"./node_modules/@babel/traverse/lib/path/lib/hoister.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js"),_t2=_t;const{react}=_t,{cloneNode,jsxExpressionContainer,variableDeclaration,variableDeclarator}=_t2,referenceVisitor={ReferencedIdentifier(path,state){if(path.isJSXIdentifier()&&react.isCompatTag(path.node.name)&&!path.parentPath.isJSXMemberExpression())return;if("this"===path.node.name){let scope=path.scope;do{if(scope.path.isFunction()&&!scope.path.isArrowFunctionExpression())break}while(scope=scope.parent);scope&&state.breakOnScopePaths.push(scope.path);}const binding=path.scope.getBinding(path.node.name);if(binding){for(const violation of binding.constantViolations)if(violation.scope!==binding.path.scope)return state.mutableBinding=!0,void path.stop();binding===state.scope.getBinding(path.node.name)&&(state.bindings[path.node.name]=binding);}}};exports.default=class{constructor(path,scope){this.breakOnScopePaths=void 0,this.bindings=void 0,this.mutableBinding=void 0,this.scopes=void 0,this.scope=void 0,this.path=void 0,this.attachAfter=void 0,this.breakOnScopePaths=[],this.bindings={},this.mutableBinding=!1,this.scopes=[],this.scope=scope,this.path=path,this.attachAfter=!1;}isCompatibleScope(scope){for(const key of Object.keys(this.bindings)){const binding=this.bindings[key];if(!scope.bindingIdentifierEquals(key,binding.identifier))return !1}return !0}getCompatibleScopes(){let scope=this.path.scope;do{if(!this.isCompatibleScope(scope))break;if(this.scopes.push(scope),this.breakOnScopePaths.indexOf(scope.path)>=0)break}while(scope=scope.parent)}getAttachmentPath(){let path=this._getAttachmentPath();if(!path)return;let targetScope=path.scope;if(targetScope.path===path&&(targetScope=path.scope.parent),targetScope.path.isProgram()||targetScope.path.isFunction())for(const name of Object.keys(this.bindings)){if(!targetScope.hasOwnBinding(name))continue;const binding=this.bindings[name];if("param"===binding.kind||"params"===binding.path.parentKey)continue;if(this.getAttachmentParentForPath(binding.path).key>=path.key){this.attachAfter=!0,path=binding.path;for(const violationPath of binding.constantViolations)this.getAttachmentParentForPath(violationPath).key>path.key&&(path=violationPath);}}return path}_getAttachmentPath(){const scope=this.scopes.pop();if(scope)if(scope.path.isFunction()){if(!this.hasOwnParamBindings(scope))return this.getNextScopeAttachmentParent();{if(this.scope===scope)return;const bodies=scope.path.get("body").get("body");for(let i=0;i<bodies.length;i++)if(!bodies[i].node._blockHoist)return bodies[i]}}else if(scope.path.isProgram())return this.getNextScopeAttachmentParent()}getNextScopeAttachmentParent(){const scope=this.scopes.pop();if(scope)return this.getAttachmentParentForPath(scope.path)}getAttachmentParentForPath(path){do{if(!path.parentPath||Array.isArray(path.container)&&path.isStatement())return path}while(path=path.parentPath)}hasOwnParamBindings(scope){for(const name of Object.keys(this.bindings)){if(!scope.hasOwnBinding(name))continue;const binding=this.bindings[name];if("param"===binding.kind&&binding.constant)return !0}return !1}run(){if(this.path.traverse(referenceVisitor,this),this.mutableBinding)return;this.getCompatibleScopes();const attachTo=this.getAttachmentPath();if(!attachTo)return;if(attachTo.getFunctionParent()===this.path.getFunctionParent())return;let uid=attachTo.scope.generateUidIdentifier("ref");const declarator=variableDeclarator(uid,this.path.node),insertFn=this.attachAfter?"insertAfter":"insertBefore",[attached]=attachTo[insertFn]([attachTo.isVariableDeclarator()?declarator:variableDeclaration("var",[declarator])]),parent=this.path.parentPath;return parent.isJSXElement()&&this.path.container===parent.node.children&&(uid=jsxExpressionContainer(uid)),this.path.replaceWith(cloneNode(uid)),attachTo.isVariableDeclarator()?attached.get("init"):attached.get("declarations.0.init")}};},"./node_modules/@babel/traverse/lib/path/lib/removal-hooks.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.hooks=void 0;exports.hooks=[function(self,parent){if("test"===self.key&&(parent.isWhile()||parent.isSwitchCase())||"declaration"===self.key&&parent.isExportDeclaration()||"body"===self.key&&parent.isLabeledStatement()||"declarations"===self.listKey&&parent.isVariableDeclaration()&&1===parent.node.declarations.length||"expression"===self.key&&parent.isExpressionStatement())return parent.remove(),!0},function(self,parent){if(parent.isSequenceExpression()&&1===parent.node.expressions.length)return parent.replaceWith(parent.node.expressions[0]),!0},function(self,parent){if(parent.isBinary())return "left"===self.key?parent.replaceWith(parent.node.right):parent.replaceWith(parent.node.left),!0},function(self,parent){if(parent.isIfStatement()&&("consequent"===self.key||"alternate"===self.key)||"body"===self.key&&(parent.isLoop()||parent.isArrowFunctionExpression()))return self.replaceWith({type:"BlockStatement",body:[]}),!0}];},"./node_modules/@babel/traverse/lib/path/lib/virtual-types.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.Var=exports.User=exports.Statement=exports.SpreadProperty=exports.Scope=exports.RestProperty=exports.ReferencedMemberExpression=exports.ReferencedIdentifier=exports.Referenced=exports.Pure=exports.NumericLiteralTypeAnnotation=exports.Generated=exports.ForAwaitStatement=exports.Flow=exports.Expression=exports.ExistentialTypeParam=exports.BlockScoped=exports.BindingIdentifier=void 0;var _t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{isBinding,isBlockScoped,isExportDeclaration,isExpression,isFlow,isForStatement,isForXStatement,isIdentifier,isImportDeclaration,isImportSpecifier,isJSXIdentifier,isJSXMemberExpression,isMemberExpression,isReferenced,isScope,isStatement,isVar,isVariableDeclaration,react}=_t,{isCompatTag}=react,ReferencedIdentifier={types:["Identifier","JSXIdentifier"],checkPath(path,opts){const{node,parent}=path;if(!isIdentifier(node,opts)&&!isJSXMemberExpression(parent,opts)){if(!isJSXIdentifier(node,opts))return !1;if(isCompatTag(node.name))return !1}return isReferenced(node,parent,path.parentPath.parent)}};exports.ReferencedIdentifier=ReferencedIdentifier;const ReferencedMemberExpression={types:["MemberExpression"],checkPath:({node,parent})=>isMemberExpression(node)&&isReferenced(node,parent)};exports.ReferencedMemberExpression=ReferencedMemberExpression;const BindingIdentifier={types:["Identifier"],checkPath(path){const{node,parent}=path,grandparent=path.parentPath.parent;return isIdentifier(node)&&isBinding(node,parent,grandparent)}};exports.BindingIdentifier=BindingIdentifier;const Statement={types:["Statement"],checkPath({node,parent}){if(isStatement(node)){if(isVariableDeclaration(node)){if(isForXStatement(parent,{left:node}))return !1;if(isForStatement(parent,{init:node}))return !1}return !0}return !1}};exports.Statement=Statement;const Expression={types:["Expression"],checkPath:path=>path.isIdentifier()?path.isReferencedIdentifier():isExpression(path.node)};exports.Expression=Expression;const Scope={types:["Scopable","Pattern"],checkPath:path=>isScope(path.node,path.parent)};exports.Scope=Scope;const Referenced={checkPath:path=>isReferenced(path.node,path.parent)};exports.Referenced=Referenced;const BlockScoped={checkPath:path=>isBlockScoped(path.node)};exports.BlockScoped=BlockScoped;const Var={types:["VariableDeclaration"],checkPath:path=>isVar(path.node)};exports.Var=Var;const User={checkPath:path=>path.node&&!!path.node.loc};exports.User=User;const Generated={checkPath:path=>!path.isUser()};exports.Generated=Generated;const Pure={checkPath:(path,opts)=>path.scope.isPure(path.node,opts)};exports.Pure=Pure;const Flow={types:["Flow","ImportDeclaration","ExportDeclaration","ImportSpecifier"],checkPath:({node})=>!!isFlow(node)||(isImportDeclaration(node)?"type"===node.importKind||"typeof"===node.importKind:isExportDeclaration(node)?"type"===node.exportKind:!!isImportSpecifier(node)&&("type"===node.importKind||"typeof"===node.importKind))};exports.Flow=Flow;const RestProperty={types:["RestElement"],checkPath:path=>path.parentPath&&path.parentPath.isObjectPattern()};exports.RestProperty=RestProperty;const SpreadProperty={types:["RestElement"],checkPath:path=>path.parentPath&&path.parentPath.isObjectExpression()};exports.SpreadProperty=SpreadProperty;exports.ExistentialTypeParam={types:["ExistsTypeAnnotation"]};exports.NumericLiteralTypeAnnotation={types:["NumberLiteralTypeAnnotation"]};const ForAwaitStatement={types:["ForOfStatement"],checkPath:({node})=>!0===node.await};exports.ForAwaitStatement=ForAwaitStatement;},"./node_modules/@babel/traverse/lib/path/modification.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports._containerInsert=function(from,nodes){this.updateSiblingKeys(from,nodes.length);const paths=[];this.container.splice(from,0,...nodes);for(let i=0;i<nodes.length;i++){const to=from+i,path=this.getSibling(to);paths.push(path),this.context&&this.context.queue&&path.pushContext(this.context);}const contexts=this._getQueueContexts();for(const path of paths){path.setScope(),path.debug("Inserted.");for(const context of contexts)context.maybeQueue(path,!0);}return paths},exports._containerInsertAfter=function(nodes){return this._containerInsert(this.key+1,nodes)},exports._containerInsertBefore=function(nodes){return this._containerInsert(this.key,nodes)},exports._verifyNodeList=function(nodes){if(!nodes)return [];Array.isArray(nodes)||(nodes=[nodes]);for(let i=0;i<nodes.length;i++){const node=nodes[i];let msg;if(node?"object"!=typeof node?msg="contains a non-object node":node.type?node instanceof _index.default&&(msg="has a NodePath when it expected a raw object"):msg="without a type":msg="has falsy node",msg){const type=Array.isArray(node)?"array":typeof node;throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`)}}return nodes},exports.hoist=function(scope=this.scope){return new _hoister.default(this,scope).run()},exports.insertAfter=function(nodes_){this._assertUnremoved();const nodes=this._verifyNodeList(nodes_),{parentPath}=this;if(parentPath.isExpressionStatement()||parentPath.isLabeledStatement()||parentPath.isExportNamedDeclaration()||parentPath.isExportDefaultDeclaration()&&this.isDeclaration())return parentPath.insertAfter(nodes.map((node=>isExpression(node)?expressionStatement(node):node)));if(this.isNodeType("Expression")&&!this.isJSXElement()&&!parentPath.isJSXElement()||parentPath.isForStatement()&&"init"===this.key){if(this.node){const node=this.node;let{scope}=this;if(scope.path.isPattern())return assertExpression(node),this.replaceWith(callExpression(arrowFunctionExpression([],node),[])),this.get("callee.body").insertAfter(nodes),[this];parentPath.isMethod({computed:!0,key:node})&&(scope=scope.parent);const temp=scope.generateDeclaredUidIdentifier();nodes.unshift(expressionStatement(assignmentExpression("=",cloneNode(temp),node))),nodes.push(expressionStatement(cloneNode(temp)));}return this.replaceExpressionWithStatements(nodes)}if(Array.isArray(this.container))return this._containerInsertAfter(nodes);if(this.isStatementOrBlock()){const node=this.node,shouldInsertCurrentNode=node&&(!this.isExpressionStatement()||null!=node.expression);return this.replaceWith(blockStatement(shouldInsertCurrentNode?[node]:[])),this.pushContainer("body",nodes)}throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?")},exports.insertBefore=function(nodes_){this._assertUnremoved();const nodes=this._verifyNodeList(nodes_),{parentPath}=this;if(parentPath.isExpressionStatement()||parentPath.isLabeledStatement()||parentPath.isExportNamedDeclaration()||parentPath.isExportDefaultDeclaration()&&this.isDeclaration())return parentPath.insertBefore(nodes);if(this.isNodeType("Expression")&&!this.isJSXElement()||parentPath.isForStatement()&&"init"===this.key)return this.node&&nodes.push(this.node),this.replaceExpressionWithStatements(nodes);if(Array.isArray(this.container))return this._containerInsertBefore(nodes);if(this.isStatementOrBlock()){const node=this.node,shouldInsertCurrentNode=node&&(!this.isExpressionStatement()||null!=node.expression);return this.replaceWith(blockStatement(shouldInsertCurrentNode?[node]:[])),this.unshiftContainer("body",nodes)}throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?")},exports.pushContainer=function(listKey,nodes){this._assertUnremoved();const verifiedNodes=this._verifyNodeList(nodes),container=this.node[listKey];return _index.default.get({parentPath:this,parent:this.node,container,listKey,key:container.length}).setContext(this.context).replaceWithMultiple(verifiedNodes)},exports.unshiftContainer=function(listKey,nodes){this._assertUnremoved(),nodes=this._verifyNodeList(nodes);return _index.default.get({parentPath:this,parent:this.node,container:this.node[listKey],listKey,key:0}).setContext(this.context)._containerInsertBefore(nodes)},exports.updateSiblingKeys=function(fromIndex,incrementBy){if(!this.parent)return;const paths=_cache.path.get(this.parent);for(const[,path]of paths)path.key>=fromIndex&&(path.key+=incrementBy);};var _cache=__webpack_require__("./node_modules/@babel/traverse/lib/cache.js"),_hoister=__webpack_require__("./node_modules/@babel/traverse/lib/path/lib/hoister.js"),_index=__webpack_require__("./node_modules/@babel/traverse/lib/path/index.js"),_t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{arrowFunctionExpression,assertExpression,assignmentExpression,blockStatement,callExpression,cloneNode,expressionStatement,isExpression}=_t;},"./node_modules/@babel/traverse/lib/path/removal.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports._assertUnremoved=function(){if(this.removed)throw this.buildCodeFrameError("NodePath has been removed so is read-only.")},exports._callRemovalHooks=function(){for(const fn of _removalHooks.hooks)if(fn(this,this.parentPath))return !0},exports._markRemoved=function(){this._traverseFlags|=_index.SHOULD_SKIP|_index.REMOVED,this.parent&&_cache.path.get(this.parent).delete(this.node);this.node=null;},exports._remove=function(){Array.isArray(this.container)?(this.container.splice(this.key,1),this.updateSiblingKeys(this.key,-1)):this._replaceWith(null);},exports._removeFromScope=function(){const bindings=this.getBindingIdentifiers();Object.keys(bindings).forEach((name=>this.scope.removeBinding(name)));},exports.remove=function(){var _this$opts;this._assertUnremoved(),this.resync(),null!=(_this$opts=this.opts)&&_this$opts.noScope||this._removeFromScope();if(this._callRemovalHooks())return void this._markRemoved();this.shareCommentsWithSiblings(),this._remove(),this._markRemoved();};var _removalHooks=__webpack_require__("./node_modules/@babel/traverse/lib/path/lib/removal-hooks.js"),_cache=__webpack_require__("./node_modules/@babel/traverse/lib/cache.js"),_index=__webpack_require__("./node_modules/@babel/traverse/lib/path/index.js");},"./node_modules/@babel/traverse/lib/path/replacement.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports._replaceWith=function(node){var _pathCache$get2;if(!this.container)throw new ReferenceError("Container is falsy");this.inList?validate(this.parent,this.key,[node]):validate(this.parent,this.key,node);this.debug(`Replace with ${null==node?void 0:node.type}`),null==(_pathCache$get2=_cache.path.get(this.parent))||_pathCache$get2.set(node,this).delete(this.node),this.node=this.container[this.key]=node;},exports.replaceExpressionWithStatements=function(nodes){this.resync();const nodesAsSequenceExpression=toSequenceExpression(nodes,this.scope);if(nodesAsSequenceExpression)return this.replaceWith(nodesAsSequenceExpression)[0].get("expressions");const functionParent=this.getFunctionParent(),isParentAsync=null==functionParent?void 0:functionParent.is("async"),isParentGenerator=null==functionParent?void 0:functionParent.is("generator"),container=arrowFunctionExpression([],blockStatement(nodes));this.replaceWith(callExpression(container,[]));const callee=this.get("callee");(0, _helperHoistVariables.default)(callee.get("body"),(id=>{this.scope.push({id});}),"var");const completionRecords=this.get("callee").getCompletionRecords();for(const path of completionRecords){if(!path.isExpressionStatement())continue;const loop=path.findParent((path=>path.isLoop()));if(loop){let uid=loop.getData("expressionReplacementReturnUid");uid?uid=identifier(uid.name):(uid=callee.scope.generateDeclaredUidIdentifier("ret"),callee.get("body").pushContainer("body",returnStatement(cloneNode(uid))),loop.setData("expressionReplacementReturnUid",uid)),path.get("expression").replaceWith(assignmentExpression("=",cloneNode(uid),path.node.expression));}else path.replaceWith(returnStatement(path.node.expression));}callee.arrowFunctionToExpression();const newCallee=callee,needToAwaitFunction=isParentAsync&&_index.default.hasType(this.get("callee.body").node,"AwaitExpression",FUNCTION_TYPES),needToYieldFunction=isParentGenerator&&_index.default.hasType(this.get("callee.body").node,"YieldExpression",FUNCTION_TYPES);needToAwaitFunction&&(newCallee.set("async",!0),needToYieldFunction||this.replaceWith(awaitExpression(this.node)));needToYieldFunction&&(newCallee.set("generator",!0),this.replaceWith(yieldExpression(this.node,!0)));return newCallee.get("body.body")},exports.replaceInline=function(nodes){if(this.resync(),Array.isArray(nodes)){if(Array.isArray(this.container)){nodes=this._verifyNodeList(nodes);const paths=this._containerInsertAfter(nodes);return this.remove(),paths}return this.replaceWithMultiple(nodes)}return this.replaceWith(nodes)},exports.replaceWith=function(replacement){if(this.resync(),this.removed)throw new Error("You can't replace this node, we've already removed it");replacement instanceof _index2.default&&(replacement=replacement.node);if(!replacement)throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");if(this.node===replacement)return [this];if(this.isProgram()&&!isProgram(replacement))throw new Error("You can only replace a Program root node with another Program node");if(Array.isArray(replacement))throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");if("string"==typeof replacement)throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");let nodePath="";this.isNodeType("Statement")&&isExpression(replacement)&&(this.canHaveVariableDeclarationOrExpression()||this.canSwapBetweenExpressionAndStatement(replacement)||this.parentPath.isExportDefaultDeclaration()||(replacement=expressionStatement(replacement),nodePath="expression"));if(this.isNodeType("Expression")&&isStatement(replacement)&&!this.canHaveVariableDeclarationOrExpression()&&!this.canSwapBetweenExpressionAndStatement(replacement))return this.replaceExpressionWithStatements([replacement]);const oldNode=this.node;oldNode&&(inheritsComments(replacement,oldNode),removeComments(oldNode));return this._replaceWith(replacement),this.type=replacement.type,this.setScope(),this.requeue(),[nodePath?this.get(nodePath):this]},exports.replaceWithMultiple=function(nodes){var _pathCache$get;this.resync(),nodes=this._verifyNodeList(nodes),inheritLeadingComments(nodes[0],this.node),inheritTrailingComments(nodes[nodes.length-1],this.node),null==(_pathCache$get=_cache.path.get(this.parent))||_pathCache$get.delete(this.node),this.node=this.container[this.key]=null;const paths=this.insertAfter(nodes);this.node?this.requeue():this.remove();return paths},exports.replaceWithSourceString=function(replacement){this.resync();try{replacement=`(${replacement})`,replacement=(0,_parser.parse)(replacement);}catch(err){const loc=err.loc;throw loc&&(err.message+=" - make sure this is an expression.\n"+(0, _codeFrame.codeFrameColumns)(replacement,{start:{line:loc.line,column:loc.column+1}}),err.code="BABEL_REPLACE_SOURCE_ERROR"),err}return replacement=replacement.program.body[0].expression,_index.default.removeProperties(replacement),this.replaceWith(replacement)};var _codeFrame=__webpack_require__("./stubs/babel_codeframe.js"),_index=__webpack_require__("./node_modules/@babel/traverse/lib/index.js"),_index2=__webpack_require__("./node_modules/@babel/traverse/lib/path/index.js"),_cache=__webpack_require__("./node_modules/@babel/traverse/lib/cache.js"),_parser=__webpack_require__("./node_modules/@babel/parser/lib/index.js"),_t=__webpack_require__("./node_modules/@babel/types/lib/index.js"),_helperHoistVariables=__webpack_require__("./node_modules/@babel/helper-hoist-variables/lib/index.js");const{FUNCTION_TYPES,arrowFunctionExpression,assignmentExpression,awaitExpression,blockStatement,callExpression,cloneNode,expressionStatement,identifier,inheritLeadingComments,inheritTrailingComments,inheritsComments,isExpression,isProgram,isStatement,removeComments,returnStatement,toSequenceExpression,validate,yieldExpression}=_t;},"./node_modules/@babel/traverse/lib/scope/binding.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;exports.default=class{constructor({identifier,scope,path,kind}){this.identifier=void 0,this.scope=void 0,this.path=void 0,this.kind=void 0,this.constantViolations=[],this.constant=!0,this.referencePaths=[],this.referenced=!1,this.references=0,this.identifier=identifier,this.scope=scope,this.path=path,this.kind=kind,this.clearValue();}deoptValue(){this.clearValue(),this.hasDeoptedValue=!0;}setValue(value){this.hasDeoptedValue||(this.hasValue=!0,this.value=value);}clearValue(){this.hasDeoptedValue=!1,this.hasValue=!1,this.value=null;}reassign(path){this.constant=!1,-1===this.constantViolations.indexOf(path)&&this.constantViolations.push(path);}reference(path){-1===this.referencePaths.indexOf(path)&&(this.referenced=!0,this.references++,this.referencePaths.push(path));}dereference(){this.references--,this.referenced=!!this.references;}};},"./node_modules/@babel/traverse/lib/scope/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _renamer=__webpack_require__("./node_modules/@babel/traverse/lib/scope/lib/renamer.js"),_index=__webpack_require__("./node_modules/@babel/traverse/lib/index.js"),_binding=__webpack_require__("./node_modules/@babel/traverse/lib/scope/binding.js"),_globals=__webpack_require__("./node_modules/@babel/traverse/node_modules/globals/index.js"),_t=__webpack_require__("./node_modules/@babel/types/lib/index.js"),_cache=__webpack_require__("./node_modules/@babel/traverse/lib/cache.js");const{NOT_LOCAL_BINDING,callExpression,cloneNode,getBindingIdentifiers,identifier,isArrayExpression,isBinary,isClass,isClassBody,isClassDeclaration,isExportAllDeclaration,isExportDefaultDeclaration,isExportNamedDeclaration,isFunctionDeclaration,isIdentifier,isImportDeclaration,isLiteral,isMethod,isModuleDeclaration,isModuleSpecifier,isObjectExpression,isProperty,isPureish,isSuper,isTaggedTemplateExpression,isTemplateLiteral,isThisExpression,isUnaryExpression,isVariableDeclaration,matchesPattern,memberExpression,numericLiteral,toIdentifier,unaryExpression,variableDeclaration,variableDeclarator}=_t;function gatherNodeParts(node,parts){switch(null==node?void 0:node.type){default:if(isModuleDeclaration(node))if((isExportAllDeclaration(node)||isExportNamedDeclaration(node)||isImportDeclaration(node))&&node.source)gatherNodeParts(node.source,parts);else if((isExportNamedDeclaration(node)||isImportDeclaration(node))&&node.specifiers&&node.specifiers.length)for(const e of node.specifiers)gatherNodeParts(e,parts);else (isExportDefaultDeclaration(node)||isExportNamedDeclaration(node))&&node.declaration&&gatherNodeParts(node.declaration,parts);else isModuleSpecifier(node)?gatherNodeParts(node.local,parts):isLiteral(node)&&parts.push(node.value);break;case"MemberExpression":case"OptionalMemberExpression":case"JSXMemberExpression":gatherNodeParts(node.object,parts),gatherNodeParts(node.property,parts);break;case"Identifier":case"JSXIdentifier":case"JSXOpeningElement":parts.push(node.name);break;case"CallExpression":case"OptionalCallExpression":case"NewExpression":gatherNodeParts(node.callee,parts);break;case"ObjectExpression":case"ObjectPattern":for(const e of node.properties)gatherNodeParts(e,parts);break;case"SpreadElement":case"RestElement":case"UnaryExpression":case"UpdateExpression":gatherNodeParts(node.argument,parts);break;case"ObjectProperty":case"ObjectMethod":case"ClassProperty":case"ClassMethod":case"ClassPrivateProperty":case"ClassPrivateMethod":gatherNodeParts(node.key,parts);break;case"ThisExpression":parts.push("this");break;case"Super":parts.push("super");break;case"Import":parts.push("import");break;case"DoExpression":parts.push("do");break;case"YieldExpression":parts.push("yield"),gatherNodeParts(node.argument,parts);break;case"AwaitExpression":parts.push("await"),gatherNodeParts(node.argument,parts);break;case"AssignmentExpression":gatherNodeParts(node.left,parts);break;case"VariableDeclarator":case"FunctionExpression":case"FunctionDeclaration":case"ClassExpression":case"ClassDeclaration":case"PrivateName":gatherNodeParts(node.id,parts);break;case"ParenthesizedExpression":gatherNodeParts(node.expression,parts);break;case"MetaProperty":gatherNodeParts(node.meta,parts),gatherNodeParts(node.property,parts);break;case"JSXElement":gatherNodeParts(node.openingElement,parts);break;case"JSXFragment":gatherNodeParts(node.openingFragment,parts);break;case"JSXOpeningFragment":parts.push("Fragment");break;case"JSXNamespacedName":gatherNodeParts(node.namespace,parts),gatherNodeParts(node.name,parts);}}const collectorVisitor={ForStatement(path){const declar=path.get("init");if(declar.isVar()){const{scope}=path;(scope.getFunctionParent()||scope.getProgramParent()).registerBinding("var",declar);}},Declaration(path){if(path.isBlockScoped())return;if(path.isImportDeclaration())return;if(path.isExportDeclaration())return;(path.scope.getFunctionParent()||path.scope.getProgramParent()).registerDeclaration(path);},ImportDeclaration(path){path.scope.getBlockParent().registerDeclaration(path);},ReferencedIdentifier(path,state){state.references.push(path);},ForXStatement(path,state){const left=path.get("left");if(left.isPattern()||left.isIdentifier())state.constantViolations.push(path);else if(left.isVar()){const{scope}=path;(scope.getFunctionParent()||scope.getProgramParent()).registerBinding("var",left);}},ExportDeclaration:{exit(path){const{node,scope}=path;if(isExportAllDeclaration(node))return;const declar=node.declaration;if(isClassDeclaration(declar)||isFunctionDeclaration(declar)){const id=declar.id;if(!id)return;const binding=scope.getBinding(id.name);null==binding||binding.reference(path);}else if(isVariableDeclaration(declar))for(const decl of declar.declarations)for(const name of Object.keys(getBindingIdentifiers(decl))){const binding=scope.getBinding(name);null==binding||binding.reference(path);}}},LabeledStatement(path){path.scope.getBlockParent().registerDeclaration(path);},AssignmentExpression(path,state){state.assignments.push(path);},UpdateExpression(path,state){state.constantViolations.push(path);},UnaryExpression(path,state){"delete"===path.node.operator&&state.constantViolations.push(path);},BlockScoped(path){let scope=path.scope;scope.path===path&&(scope=scope.parent);if(scope.getBlockParent().registerDeclaration(path),path.isClassDeclaration()&&path.node.id){const name=path.node.id.name;path.scope.bindings[name]=path.scope.parent.getBinding(name);}},CatchClause(path){path.scope.registerBinding("let",path);},Function(path){const params=path.get("params");for(const param of params)path.scope.registerBinding("param",param);path.isFunctionExpression()&&path.has("id")&&!path.get("id").node[NOT_LOCAL_BINDING]&&path.scope.registerBinding("local",path.get("id"),path);},ClassExpression(path){path.has("id")&&!path.get("id").node[NOT_LOCAL_BINDING]&&path.scope.registerBinding("local",path);}};let uid=0;class Scope{constructor(path){this.uid=void 0,this.path=void 0,this.block=void 0,this.labels=void 0,this.inited=void 0,this.bindings=void 0,this.references=void 0,this.globals=void 0,this.uids=void 0,this.data=void 0,this.crawling=void 0;const{node}=path,cached=_cache.scope.get(node);if((null==cached?void 0:cached.path)===path)return cached;_cache.scope.set(node,this),this.uid=uid++,this.block=node,this.path=path,this.labels=new Map,this.inited=!1;}get parent(){var _parent;let parent,path=this.path;do{const isKey="key"===path.key;path=path.parentPath,isKey&&path.isMethod()&&(path=path.parentPath),path&&path.isScope()&&(parent=path);}while(path&&!parent);return null==(_parent=parent)?void 0:_parent.scope}get parentBlock(){return this.path.parent}get hub(){return this.path.hub}traverse(node,opts,state){(0, _index.default)(node,opts,this,state,this.path);}generateDeclaredUidIdentifier(name){const id=this.generateUidIdentifier(name);return this.push({id}),cloneNode(id)}generateUidIdentifier(name){return identifier(this.generateUid(name))}generateUid(name="temp"){let uid;name=toIdentifier(name).replace(/^_+/,"").replace(/[0-9]+$/g,"");let i=1;do{uid=this._generateUid(name,i),i++;}while(this.hasLabel(uid)||this.hasBinding(uid)||this.hasGlobal(uid)||this.hasReference(uid));const program=this.getProgramParent();return program.references[uid]=!0,program.uids[uid]=!0,uid}_generateUid(name,i){let id=name;return i>1&&(id+=i),`_${id}`}generateUidBasedOnNode(node,defaultName){const parts=[];gatherNodeParts(node,parts);let id=parts.join("$");return id=id.replace(/^_/,"")||defaultName||"ref",this.generateUid(id.slice(0,20))}generateUidIdentifierBasedOnNode(node,defaultName){return identifier(this.generateUidBasedOnNode(node,defaultName))}isStatic(node){if(isThisExpression(node)||isSuper(node))return !0;if(isIdentifier(node)){const binding=this.getBinding(node.name);return binding?binding.constant:this.hasBinding(node.name)}return !1}maybeGenerateMemoised(node,dontPush){if(this.isStatic(node))return null;{const id=this.generateUidIdentifierBasedOnNode(node);return dontPush?id:(this.push({id}),cloneNode(id))}}checkBlockScopedCollisions(local,kind,name,id){if("param"===kind)return;if("local"===local.kind)return;if("let"===kind||"let"===local.kind||"const"===local.kind||"module"===local.kind||"param"===local.kind&&"const"===kind)throw this.hub.buildError(id,`Duplicate declaration "${name}"`,TypeError)}rename(oldName,newName,block){const binding=this.getBinding(oldName);if(binding)return newName=newName||this.generateUidIdentifier(oldName).name,new _renamer.default(binding,oldName,newName).rename(block)}_renameFromMap(map,oldName,newName,value){map[oldName]&&(map[newName]=value,map[oldName]=null);}dump(){const sep="-".repeat(60);console.log(sep);let scope=this;do{console.log("#",scope.block.type);for(const name of Object.keys(scope.bindings)){const binding=scope.bindings[name];console.log(" -",name,{constant:binding.constant,references:binding.references,violations:binding.constantViolations.length,kind:binding.kind});}}while(scope=scope.parent);console.log(sep);}toArray(node,i,arrayLikeIsIterable){if(isIdentifier(node)){const binding=this.getBinding(node.name);if(null!=binding&&binding.constant&&binding.path.isGenericType("Array"))return node}if(isArrayExpression(node))return node;if(isIdentifier(node,{name:"arguments"}))return callExpression(memberExpression(memberExpression(memberExpression(identifier("Array"),identifier("prototype")),identifier("slice")),identifier("call")),[node]);let helperName;const args=[node];return !0===i?helperName="toConsumableArray":i?(args.push(numericLiteral(i)),helperName="slicedToArray"):helperName="toArray",arrayLikeIsIterable&&(args.unshift(this.hub.addHelper(helperName)),helperName="maybeArrayLike"),callExpression(this.hub.addHelper(helperName),args)}hasLabel(name){return !!this.getLabel(name)}getLabel(name){return this.labels.get(name)}registerLabel(path){this.labels.set(path.node.label.name,path);}registerDeclaration(path){if(path.isLabeledStatement())this.registerLabel(path);else if(path.isFunctionDeclaration())this.registerBinding("hoisted",path.get("id"),path);else if(path.isVariableDeclaration()){const declarations=path.get("declarations");for(const declar of declarations)this.registerBinding(path.node.kind,declar);}else if(path.isClassDeclaration()){if(path.node.declare)return;this.registerBinding("let",path);}else if(path.isImportDeclaration()){const specifiers=path.get("specifiers");for(const specifier of specifiers)this.registerBinding("module",specifier);}else if(path.isExportDeclaration()){const declar=path.get("declaration");(declar.isClassDeclaration()||declar.isFunctionDeclaration()||declar.isVariableDeclaration())&&this.registerDeclaration(declar);}else this.registerBinding("unknown",path);}buildUndefinedNode(){return unaryExpression("void",numericLiteral(0),!0)}registerConstantViolation(path){const ids=path.getBindingIdentifiers();for(const name of Object.keys(ids)){const binding=this.getBinding(name);binding&&binding.reassign(path);}}registerBinding(kind,path,bindingPath=path){if(!kind)throw new ReferenceError("no `kind`");if(path.isVariableDeclaration()){const declarators=path.get("declarations");for(const declar of declarators)this.registerBinding(kind,declar);return}const parent=this.getProgramParent(),ids=path.getOuterBindingIdentifiers(!0);for(const name of Object.keys(ids)){parent.references[name]=!0;for(const id of ids[name]){const local=this.getOwnBinding(name);if(local){if(local.identifier===id)continue;this.checkBlockScopedCollisions(local,kind,name,id);}local?this.registerConstantViolation(bindingPath):this.bindings[name]=new _binding.default({identifier:id,scope:this,path:bindingPath,kind});}}}addGlobal(node){this.globals[node.name]=node;}hasUid(name){let scope=this;do{if(scope.uids[name])return !0}while(scope=scope.parent);return !1}hasGlobal(name){let scope=this;do{if(scope.globals[name])return !0}while(scope=scope.parent);return !1}hasReference(name){return !!this.getProgramParent().references[name]}isPure(node,constantsOnly){if(isIdentifier(node)){const binding=this.getBinding(node.name);return !!binding&&(!constantsOnly||binding.constant)}if(isClass(node))return !(node.superClass&&!this.isPure(node.superClass,constantsOnly))&&this.isPure(node.body,constantsOnly);if(isClassBody(node)){for(const method of node.body)if(!this.isPure(method,constantsOnly))return !1;return !0}if(isBinary(node))return this.isPure(node.left,constantsOnly)&&this.isPure(node.right,constantsOnly);if(isArrayExpression(node)){for(const elem of node.elements)if(!this.isPure(elem,constantsOnly))return !1;return !0}if(isObjectExpression(node)){for(const prop of node.properties)if(!this.isPure(prop,constantsOnly))return !1;return !0}if(isMethod(node))return !(node.computed&&!this.isPure(node.key,constantsOnly))&&("get"!==node.kind&&"set"!==node.kind);if(isProperty(node))return !(node.computed&&!this.isPure(node.key,constantsOnly))&&this.isPure(node.value,constantsOnly);if(isUnaryExpression(node))return this.isPure(node.argument,constantsOnly);if(isTaggedTemplateExpression(node))return matchesPattern(node.tag,"String.raw")&&!this.hasBinding("String",!0)&&this.isPure(node.quasi,constantsOnly);if(isTemplateLiteral(node)){for(const expression of node.expressions)if(!this.isPure(expression,constantsOnly))return !1;return !0}return isPureish(node)}setData(key,val){return this.data[key]=val}getData(key){let scope=this;do{const data=scope.data[key];if(null!=data)return data}while(scope=scope.parent)}removeData(key){let scope=this;do{null!=scope.data[key]&&(scope.data[key]=null);}while(scope=scope.parent)}init(){this.inited||(this.inited=!0,this.crawl());}crawl(){const path=this.path;this.references=Object.create(null),this.bindings=Object.create(null),this.globals=Object.create(null),this.uids=Object.create(null),this.data=Object.create(null);const programParent=this.getProgramParent();if(programParent.crawling)return;const state={references:[],constantViolations:[],assignments:[]};if(this.crawling=!0,"Program"!==path.type&&collectorVisitor._exploded){for(const visit of collectorVisitor.enter)visit(path,state);const typeVisitors=collectorVisitor[path.type];if(typeVisitors)for(const visit of typeVisitors.enter)visit(path,state);}path.traverse(collectorVisitor,state),this.crawling=!1;for(const path of state.assignments){const ids=path.getBindingIdentifiers();for(const name of Object.keys(ids))path.scope.getBinding(name)||programParent.addGlobal(ids[name]);path.scope.registerConstantViolation(path);}for(const ref of state.references){const binding=ref.scope.getBinding(ref.node.name);binding?binding.reference(ref):programParent.addGlobal(ref.node);}for(const path of state.constantViolations)path.scope.registerConstantViolation(path);}push(opts){let path=this.path;path.isBlockStatement()||path.isProgram()||(path=this.getBlockParent().path),path.isSwitchStatement()&&(path=(this.getFunctionParent()||this.getProgramParent()).path),(path.isLoop()||path.isCatchClause()||path.isFunction())&&(path.ensureBlock(),path=path.get("body"));const unique=opts.unique,kind=opts.kind||"var",blockHoist=null==opts._blockHoist?2:opts._blockHoist,dataKey=`declaration:${kind}:${blockHoist}`;let declarPath=!unique&&path.getData(dataKey);if(!declarPath){const declar=variableDeclaration(kind,[]);declar._blockHoist=blockHoist,[declarPath]=path.unshiftContainer("body",[declar]),unique||path.setData(dataKey,declarPath);}const declarator=variableDeclarator(opts.id,opts.init);declarPath.node.declarations.push(declarator),this.registerBinding(kind,declarPath.get("declarations").pop());}getProgramParent(){let scope=this;do{if(scope.path.isProgram())return scope}while(scope=scope.parent);throw new Error("Couldn't find a Program")}getFunctionParent(){let scope=this;do{if(scope.path.isFunctionParent())return scope}while(scope=scope.parent);return null}getBlockParent(){let scope=this;do{if(scope.path.isBlockParent())return scope}while(scope=scope.parent);throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...")}getAllBindings(){const ids=Object.create(null);let scope=this;do{for(const key of Object.keys(scope.bindings))key in ids==!1&&(ids[key]=scope.bindings[key]);scope=scope.parent;}while(scope);return ids}getAllBindingsOfKind(...kinds){const ids=Object.create(null);for(const kind of kinds){let scope=this;do{for(const name of Object.keys(scope.bindings)){const binding=scope.bindings[name];binding.kind===kind&&(ids[name]=binding);}scope=scope.parent;}while(scope)}return ids}bindingIdentifierEquals(name,node){return this.getBindingIdentifier(name)===node}getBinding(name){let previousPath,scope=this;do{const binding=scope.getOwnBinding(name);var _previousPath;if(binding){if(null==(_previousPath=previousPath)||!_previousPath.isPattern()||"param"===binding.kind||"local"===binding.kind)return binding}else if(!binding&&"arguments"===name&&scope.path.isFunction()&&!scope.path.isArrowFunctionExpression())break;previousPath=scope.path;}while(scope=scope.parent)}getOwnBinding(name){return this.bindings[name]}getBindingIdentifier(name){var _this$getBinding;return null==(_this$getBinding=this.getBinding(name))?void 0:_this$getBinding.identifier}getOwnBindingIdentifier(name){const binding=this.bindings[name];return null==binding?void 0:binding.identifier}hasOwnBinding(name){return !!this.getOwnBinding(name)}hasBinding(name,noGlobals){return !!name&&(!!this.hasOwnBinding(name)||(!!this.parentHasBinding(name,noGlobals)||(!!this.hasUid(name)||(!(noGlobals||!Scope.globals.includes(name))||!(noGlobals||!Scope.contextVariables.includes(name))))))}parentHasBinding(name,noGlobals){var _this$parent;return null==(_this$parent=this.parent)?void 0:_this$parent.hasBinding(name,noGlobals)}moveBindingTo(name,scope){const info=this.getBinding(name);info&&(info.scope.removeOwnBinding(name),info.scope=scope,scope.bindings[name]=info);}removeOwnBinding(name){delete this.bindings[name];}removeBinding(name){var _this$getBinding2;null==(_this$getBinding2=this.getBinding(name))||_this$getBinding2.scope.removeOwnBinding(name);let scope=this;do{scope.uids[name]&&(scope.uids[name]=!1);}while(scope=scope.parent)}}exports.default=Scope,Scope.globals=Object.keys(_globals.builtin),Scope.contextVariables=["arguments","undefined","Infinity","NaN"];},"./node_modules/@babel/traverse/lib/scope/lib/renamer.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;__webpack_require__("./node_modules/@babel/traverse/lib/scope/binding.js");var _helperSplitExportDeclaration=__webpack_require__("./node_modules/@babel/helper-split-export-declaration/lib/index.js"),_t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{VISITOR_KEYS,assignmentExpression,identifier,toExpression,variableDeclaration,variableDeclarator}=_t,renameVisitor={ReferencedIdentifier({node},state){node.name===state.oldName&&(node.name=state.newName);},Scope(path,state){path.scope.bindingIdentifierEquals(state.oldName,state.binding.identifier)||function(path){if(!path.isMethod()||!path.node.computed)return void path.skip();const keys=VISITOR_KEYS[path.type];for(const key of keys)"key"!==key&&path.skipKey(key);}(path);},"AssignmentExpression|Declaration|VariableDeclarator"(path,state){if(path.isVariableDeclaration())return;const ids=path.getOuterBindingIdentifiers();for(const name in ids)name===state.oldName&&(ids[name].name=state.newName);}};exports.default=class{constructor(binding,oldName,newName){this.newName=newName,this.oldName=oldName,this.binding=binding;}maybeConvertFromExportDeclaration(parentDeclar){const maybeExportDeclar=parentDeclar.parentPath;maybeExportDeclar.isExportDeclaration()&&(maybeExportDeclar.isExportDefaultDeclaration()&&!maybeExportDeclar.get("declaration").node.id||(0, _helperSplitExportDeclaration.default)(maybeExportDeclar));}maybeConvertFromClassFunctionDeclaration(path){}maybeConvertFromClassFunctionExpression(path){}rename(block){const{binding,oldName,newName}=this,{scope,path}=binding,parentDeclar=path.find((path=>path.isDeclaration()||path.isFunctionExpression()||path.isClassExpression()));if(parentDeclar){parentDeclar.getOuterBindingIdentifiers()[oldName]===binding.identifier&&this.maybeConvertFromExportDeclaration(parentDeclar);}const blockToTraverse=block||scope.block;"SwitchStatement"===(null==blockToTraverse?void 0:blockToTraverse.type)?blockToTraverse.cases.forEach((c=>{scope.traverse(c,renameVisitor,this);})):scope.traverse(blockToTraverse,renameVisitor,this),block||(scope.removeOwnBinding(oldName),scope.bindings[newName]=binding,this.binding.identifier.name=newName),parentDeclar&&(this.maybeConvertFromClassFunctionDeclaration(parentDeclar),this.maybeConvertFromClassFunctionExpression(parentDeclar));}};},"./node_modules/@babel/traverse/lib/traverse-node.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.traverseNode=function(node,opts,scope,state,path,skipKeys){const keys=VISITOR_KEYS[node.type];if(!keys)return !1;const context=new _context.default(scope,opts,state,path);for(const key of keys)if((!skipKeys||!skipKeys[key])&&context.visit(node,key))return !0;return !1};var _context=__webpack_require__("./node_modules/@babel/traverse/lib/context.js"),_t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{VISITOR_KEYS}=_t;},"./node_modules/@babel/traverse/lib/visitors.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.explode=explode,exports.merge=function(visitors,states=[],wrapper){const rootVisitor={};for(let i=0;i<visitors.length;i++){const visitor=visitors[i],state=states[i];explode(visitor);for(const type of Object.keys(visitor)){let visitorType=visitor[type];(state||wrapper)&&(visitorType=wrapWithStateOrWrapper(visitorType,state,wrapper));mergePair(rootVisitor[type]=rootVisitor[type]||{},visitorType);}}return rootVisitor},exports.verify=verify;var virtualTypes=__webpack_require__("./node_modules/@babel/traverse/lib/path/lib/virtual-types.js"),_t=__webpack_require__("./node_modules/@babel/types/lib/index.js");const{DEPRECATED_KEYS,FLIPPED_ALIAS_KEYS,TYPES}=_t;function explode(visitor){if(visitor._exploded)return visitor;visitor._exploded=!0;for(const nodeType of Object.keys(visitor)){if(shouldIgnoreKey(nodeType))continue;const parts=nodeType.split("|");if(1===parts.length)continue;const fns=visitor[nodeType];delete visitor[nodeType];for(const part of parts)visitor[part]=fns;}verify(visitor),delete visitor.__esModule,function(obj){for(const key of Object.keys(obj)){if(shouldIgnoreKey(key))continue;const fns=obj[key];"function"==typeof fns&&(obj[key]={enter:fns});}}(visitor),ensureCallbackArrays(visitor);for(const nodeType of Object.keys(visitor)){if(shouldIgnoreKey(nodeType))continue;const wrapper=virtualTypes[nodeType];if(!wrapper)continue;const fns=visitor[nodeType];for(const type of Object.keys(fns))fns[type]=wrapCheck(wrapper,fns[type]);if(delete visitor[nodeType],wrapper.types)for(const type of wrapper.types)visitor[type]?mergePair(visitor[type],fns):visitor[type]=fns;else mergePair(visitor,fns);}for(const nodeType of Object.keys(visitor)){if(shouldIgnoreKey(nodeType))continue;const fns=visitor[nodeType];let aliases=FLIPPED_ALIAS_KEYS[nodeType];const deprecatedKey=DEPRECATED_KEYS[nodeType];if(deprecatedKey&&(console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`),aliases=[deprecatedKey]),aliases){delete visitor[nodeType];for(const alias of aliases){const existing=visitor[alias];existing?mergePair(existing,fns):visitor[alias]=Object.assign({},fns);}}}for(const nodeType of Object.keys(visitor))shouldIgnoreKey(nodeType)||ensureCallbackArrays(visitor[nodeType]);return visitor}function verify(visitor){if(!visitor._verified){if("function"==typeof visitor)throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");for(const nodeType of Object.keys(visitor)){if("enter"!==nodeType&&"exit"!==nodeType||validateVisitorMethods(nodeType,visitor[nodeType]),shouldIgnoreKey(nodeType))continue;if(TYPES.indexOf(nodeType)<0)throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);const visitors=visitor[nodeType];if("object"==typeof visitors)for(const visitorKey of Object.keys(visitors)){if("enter"!==visitorKey&&"exit"!==visitorKey)throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);validateVisitorMethods(`${nodeType}.${visitorKey}`,visitors[visitorKey]);}}visitor._verified=!0;}}function validateVisitorMethods(path,val){const fns=[].concat(val);for(const fn of fns)if("function"!=typeof fn)throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`)}function wrapWithStateOrWrapper(oldVisitor,state,wrapper){const newVisitor={};for(const key of Object.keys(oldVisitor)){let fns=oldVisitor[key];Array.isArray(fns)&&(fns=fns.map((function(fn){let newFn=fn;return state&&(newFn=function(path){return fn.call(state,path,state)}),wrapper&&(newFn=wrapper(state.key,key,newFn)),newFn!==fn&&(newFn.toString=()=>fn.toString()),newFn})),newVisitor[key]=fns);}return newVisitor}function ensureCallbackArrays(obj){obj.enter&&!Array.isArray(obj.enter)&&(obj.enter=[obj.enter]),obj.exit&&!Array.isArray(obj.exit)&&(obj.exit=[obj.exit]);}function wrapCheck(wrapper,fn){const newFn=function(path){if(wrapper.checkPath(path))return fn.apply(this,arguments)};return newFn.toString=()=>fn.toString(),newFn}function shouldIgnoreKey(key){return "_"===key[0]||("enter"===key||"exit"===key||"shouldSkip"===key||("denylist"===key||"noScope"===key||"skipKeys"===key||"blacklist"===key))}function mergePair(dest,src){for(const key of Object.keys(src))dest[key]=[].concat(dest[key]||[],src[key]);}},"./node_modules/@babel/traverse/node_modules/globals/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{module.exports=__webpack_require__("./node_modules/@babel/traverse/node_modules/globals/globals.json");},"./node_modules/@babel/types/lib/asserts/assertNode.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node){if(!(0, _isNode.default)(node)){var _node$type;const type=null!=(_node$type=null==node?void 0:node.type)?_node$type:JSON.stringify(node);throw new TypeError(`Not a valid node of type "${type}"`)}};var _isNode=__webpack_require__("./node_modules/@babel/types/lib/validators/isNode.js");},"./node_modules/@babel/types/lib/asserts/generated/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.assertAnyTypeAnnotation=function(node,opts){assert("AnyTypeAnnotation",node,opts);},exports.assertArgumentPlaceholder=function(node,opts){assert("ArgumentPlaceholder",node,opts);},exports.assertArrayExpression=function(node,opts){assert("ArrayExpression",node,opts);},exports.assertArrayPattern=function(node,opts){assert("ArrayPattern",node,opts);},exports.assertArrayTypeAnnotation=function(node,opts){assert("ArrayTypeAnnotation",node,opts);},exports.assertArrowFunctionExpression=function(node,opts){assert("ArrowFunctionExpression",node,opts);},exports.assertAssignmentExpression=function(node,opts){assert("AssignmentExpression",node,opts);},exports.assertAssignmentPattern=function(node,opts){assert("AssignmentPattern",node,opts);},exports.assertAwaitExpression=function(node,opts){assert("AwaitExpression",node,opts);},exports.assertBigIntLiteral=function(node,opts){assert("BigIntLiteral",node,opts);},exports.assertBinary=function(node,opts){assert("Binary",node,opts);},exports.assertBinaryExpression=function(node,opts){assert("BinaryExpression",node,opts);},exports.assertBindExpression=function(node,opts){assert("BindExpression",node,opts);},exports.assertBlock=function(node,opts){assert("Block",node,opts);},exports.assertBlockParent=function(node,opts){assert("BlockParent",node,opts);},exports.assertBlockStatement=function(node,opts){assert("BlockStatement",node,opts);},exports.assertBooleanLiteral=function(node,opts){assert("BooleanLiteral",node,opts);},exports.assertBooleanLiteralTypeAnnotation=function(node,opts){assert("BooleanLiteralTypeAnnotation",node,opts);},exports.assertBooleanTypeAnnotation=function(node,opts){assert("BooleanTypeAnnotation",node,opts);},exports.assertBreakStatement=function(node,opts){assert("BreakStatement",node,opts);},exports.assertCallExpression=function(node,opts){assert("CallExpression",node,opts);},exports.assertCatchClause=function(node,opts){assert("CatchClause",node,opts);},exports.assertClass=function(node,opts){assert("Class",node,opts);},exports.assertClassBody=function(node,opts){assert("ClassBody",node,opts);},exports.assertClassDeclaration=function(node,opts){assert("ClassDeclaration",node,opts);},exports.assertClassExpression=function(node,opts){assert("ClassExpression",node,opts);},exports.assertClassImplements=function(node,opts){assert("ClassImplements",node,opts);},exports.assertClassMethod=function(node,opts){assert("ClassMethod",node,opts);},exports.assertClassPrivateMethod=function(node,opts){assert("ClassPrivateMethod",node,opts);},exports.assertClassPrivateProperty=function(node,opts){assert("ClassPrivateProperty",node,opts);},exports.assertClassProperty=function(node,opts){assert("ClassProperty",node,opts);},exports.assertCompletionStatement=function(node,opts){assert("CompletionStatement",node,opts);},exports.assertConditional=function(node,opts){assert("Conditional",node,opts);},exports.assertConditionalExpression=function(node,opts){assert("ConditionalExpression",node,opts);},exports.assertContinueStatement=function(node,opts){assert("ContinueStatement",node,opts);},exports.assertDebuggerStatement=function(node,opts){assert("DebuggerStatement",node,opts);},exports.assertDecimalLiteral=function(node,opts){assert("DecimalLiteral",node,opts);},exports.assertDeclaration=function(node,opts){assert("Declaration",node,opts);},exports.assertDeclareClass=function(node,opts){assert("DeclareClass",node,opts);},exports.assertDeclareExportAllDeclaration=function(node,opts){assert("DeclareExportAllDeclaration",node,opts);},exports.assertDeclareExportDeclaration=function(node,opts){assert("DeclareExportDeclaration",node,opts);},exports.assertDeclareFunction=function(node,opts){assert("DeclareFunction",node,opts);},exports.assertDeclareInterface=function(node,opts){assert("DeclareInterface",node,opts);},exports.assertDeclareModule=function(node,opts){assert("DeclareModule",node,opts);},exports.assertDeclareModuleExports=function(node,opts){assert("DeclareModuleExports",node,opts);},exports.assertDeclareOpaqueType=function(node,opts){assert("DeclareOpaqueType",node,opts);},exports.assertDeclareTypeAlias=function(node,opts){assert("DeclareTypeAlias",node,opts);},exports.assertDeclareVariable=function(node,opts){assert("DeclareVariable",node,opts);},exports.assertDeclaredPredicate=function(node,opts){assert("DeclaredPredicate",node,opts);},exports.assertDecorator=function(node,opts){assert("Decorator",node,opts);},exports.assertDirective=function(node,opts){assert("Directive",node,opts);},exports.assertDirectiveLiteral=function(node,opts){assert("DirectiveLiteral",node,opts);},exports.assertDoExpression=function(node,opts){assert("DoExpression",node,opts);},exports.assertDoWhileStatement=function(node,opts){assert("DoWhileStatement",node,opts);},exports.assertEmptyStatement=function(node,opts){assert("EmptyStatement",node,opts);},exports.assertEmptyTypeAnnotation=function(node,opts){assert("EmptyTypeAnnotation",node,opts);},exports.assertEnumBody=function(node,opts){assert("EnumBody",node,opts);},exports.assertEnumBooleanBody=function(node,opts){assert("EnumBooleanBody",node,opts);},exports.assertEnumBooleanMember=function(node,opts){assert("EnumBooleanMember",node,opts);},exports.assertEnumDeclaration=function(node,opts){assert("EnumDeclaration",node,opts);},exports.assertEnumDefaultedMember=function(node,opts){assert("EnumDefaultedMember",node,opts);},exports.assertEnumMember=function(node,opts){assert("EnumMember",node,opts);},exports.assertEnumNumberBody=function(node,opts){assert("EnumNumberBody",node,opts);},exports.assertEnumNumberMember=function(node,opts){assert("EnumNumberMember",node,opts);},exports.assertEnumStringBody=function(node,opts){assert("EnumStringBody",node,opts);},exports.assertEnumStringMember=function(node,opts){assert("EnumStringMember",node,opts);},exports.assertEnumSymbolBody=function(node,opts){assert("EnumSymbolBody",node,opts);},exports.assertExistsTypeAnnotation=function(node,opts){assert("ExistsTypeAnnotation",node,opts);},exports.assertExportAllDeclaration=function(node,opts){assert("ExportAllDeclaration",node,opts);},exports.assertExportDeclaration=function(node,opts){assert("ExportDeclaration",node,opts);},exports.assertExportDefaultDeclaration=function(node,opts){assert("ExportDefaultDeclaration",node,opts);},exports.assertExportDefaultSpecifier=function(node,opts){assert("ExportDefaultSpecifier",node,opts);},exports.assertExportNamedDeclaration=function(node,opts){assert("ExportNamedDeclaration",node,opts);},exports.assertExportNamespaceSpecifier=function(node,opts){assert("ExportNamespaceSpecifier",node,opts);},exports.assertExportSpecifier=function(node,opts){assert("ExportSpecifier",node,opts);},exports.assertExpression=function(node,opts){assert("Expression",node,opts);},exports.assertExpressionStatement=function(node,opts){assert("ExpressionStatement",node,opts);},exports.assertExpressionWrapper=function(node,opts){assert("ExpressionWrapper",node,opts);},exports.assertFile=function(node,opts){assert("File",node,opts);},exports.assertFlow=function(node,opts){assert("Flow",node,opts);},exports.assertFlowBaseAnnotation=function(node,opts){assert("FlowBaseAnnotation",node,opts);},exports.assertFlowDeclaration=function(node,opts){assert("FlowDeclaration",node,opts);},exports.assertFlowPredicate=function(node,opts){assert("FlowPredicate",node,opts);},exports.assertFlowType=function(node,opts){assert("FlowType",node,opts);},exports.assertFor=function(node,opts){assert("For",node,opts);},exports.assertForInStatement=function(node,opts){assert("ForInStatement",node,opts);},exports.assertForOfStatement=function(node,opts){assert("ForOfStatement",node,opts);},exports.assertForStatement=function(node,opts){assert("ForStatement",node,opts);},exports.assertForXStatement=function(node,opts){assert("ForXStatement",node,opts);},exports.assertFunction=function(node,opts){assert("Function",node,opts);},exports.assertFunctionDeclaration=function(node,opts){assert("FunctionDeclaration",node,opts);},exports.assertFunctionExpression=function(node,opts){assert("FunctionExpression",node,opts);},exports.assertFunctionParent=function(node,opts){assert("FunctionParent",node,opts);},exports.assertFunctionTypeAnnotation=function(node,opts){assert("FunctionTypeAnnotation",node,opts);},exports.assertFunctionTypeParam=function(node,opts){assert("FunctionTypeParam",node,opts);},exports.assertGenericTypeAnnotation=function(node,opts){assert("GenericTypeAnnotation",node,opts);},exports.assertIdentifier=function(node,opts){assert("Identifier",node,opts);},exports.assertIfStatement=function(node,opts){assert("IfStatement",node,opts);},exports.assertImmutable=function(node,opts){assert("Immutable",node,opts);},exports.assertImport=function(node,opts){assert("Import",node,opts);},exports.assertImportAttribute=function(node,opts){assert("ImportAttribute",node,opts);},exports.assertImportDeclaration=function(node,opts){assert("ImportDeclaration",node,opts);},exports.assertImportDefaultSpecifier=function(node,opts){assert("ImportDefaultSpecifier",node,opts);},exports.assertImportNamespaceSpecifier=function(node,opts){assert("ImportNamespaceSpecifier",node,opts);},exports.assertImportSpecifier=function(node,opts){assert("ImportSpecifier",node,opts);},exports.assertIndexedAccessType=function(node,opts){assert("IndexedAccessType",node,opts);},exports.assertInferredPredicate=function(node,opts){assert("InferredPredicate",node,opts);},exports.assertInterfaceDeclaration=function(node,opts){assert("InterfaceDeclaration",node,opts);},exports.assertInterfaceExtends=function(node,opts){assert("InterfaceExtends",node,opts);},exports.assertInterfaceTypeAnnotation=function(node,opts){assert("InterfaceTypeAnnotation",node,opts);},exports.assertInterpreterDirective=function(node,opts){assert("InterpreterDirective",node,opts);},exports.assertIntersectionTypeAnnotation=function(node,opts){assert("IntersectionTypeAnnotation",node,opts);},exports.assertJSX=function(node,opts){assert("JSX",node,opts);},exports.assertJSXAttribute=function(node,opts){assert("JSXAttribute",node,opts);},exports.assertJSXClosingElement=function(node,opts){assert("JSXClosingElement",node,opts);},exports.assertJSXClosingFragment=function(node,opts){assert("JSXClosingFragment",node,opts);},exports.assertJSXElement=function(node,opts){assert("JSXElement",node,opts);},exports.assertJSXEmptyExpression=function(node,opts){assert("JSXEmptyExpression",node,opts);},exports.assertJSXExpressionContainer=function(node,opts){assert("JSXExpressionContainer",node,opts);},exports.assertJSXFragment=function(node,opts){assert("JSXFragment",node,opts);},exports.assertJSXIdentifier=function(node,opts){assert("JSXIdentifier",node,opts);},exports.assertJSXMemberExpression=function(node,opts){assert("JSXMemberExpression",node,opts);},exports.assertJSXNamespacedName=function(node,opts){assert("JSXNamespacedName",node,opts);},exports.assertJSXOpeningElement=function(node,opts){assert("JSXOpeningElement",node,opts);},exports.assertJSXOpeningFragment=function(node,opts){assert("JSXOpeningFragment",node,opts);},exports.assertJSXSpreadAttribute=function(node,opts){assert("JSXSpreadAttribute",node,opts);},exports.assertJSXSpreadChild=function(node,opts){assert("JSXSpreadChild",node,opts);},exports.assertJSXText=function(node,opts){assert("JSXText",node,opts);},exports.assertLVal=function(node,opts){assert("LVal",node,opts);},exports.assertLabeledStatement=function(node,opts){assert("LabeledStatement",node,opts);},exports.assertLiteral=function(node,opts){assert("Literal",node,opts);},exports.assertLogicalExpression=function(node,opts){assert("LogicalExpression",node,opts);},exports.assertLoop=function(node,opts){assert("Loop",node,opts);},exports.assertMemberExpression=function(node,opts){assert("MemberExpression",node,opts);},exports.assertMetaProperty=function(node,opts){assert("MetaProperty",node,opts);},exports.assertMethod=function(node,opts){assert("Method",node,opts);},exports.assertMiscellaneous=function(node,opts){assert("Miscellaneous",node,opts);},exports.assertMixedTypeAnnotation=function(node,opts){assert("MixedTypeAnnotation",node,opts);},exports.assertModuleDeclaration=function(node,opts){assert("ModuleDeclaration",node,opts);},exports.assertModuleExpression=function(node,opts){assert("ModuleExpression",node,opts);},exports.assertModuleSpecifier=function(node,opts){assert("ModuleSpecifier",node,opts);},exports.assertNewExpression=function(node,opts){assert("NewExpression",node,opts);},exports.assertNoop=function(node,opts){assert("Noop",node,opts);},exports.assertNullLiteral=function(node,opts){assert("NullLiteral",node,opts);},exports.assertNullLiteralTypeAnnotation=function(node,opts){assert("NullLiteralTypeAnnotation",node,opts);},exports.assertNullableTypeAnnotation=function(node,opts){assert("NullableTypeAnnotation",node,opts);},exports.assertNumberLiteral=function(node,opts){console.trace("The node type NumberLiteral has been renamed to NumericLiteral"),assert("NumberLiteral",node,opts);},exports.assertNumberLiteralTypeAnnotation=function(node,opts){assert("NumberLiteralTypeAnnotation",node,opts);},exports.assertNumberTypeAnnotation=function(node,opts){assert("NumberTypeAnnotation",node,opts);},exports.assertNumericLiteral=function(node,opts){assert("NumericLiteral",node,opts);},exports.assertObjectExpression=function(node,opts){assert("ObjectExpression",node,opts);},exports.assertObjectMember=function(node,opts){assert("ObjectMember",node,opts);},exports.assertObjectMethod=function(node,opts){assert("ObjectMethod",node,opts);},exports.assertObjectPattern=function(node,opts){assert("ObjectPattern",node,opts);},exports.assertObjectProperty=function(node,opts){assert("ObjectProperty",node,opts);},exports.assertObjectTypeAnnotation=function(node,opts){assert("ObjectTypeAnnotation",node,opts);},exports.assertObjectTypeCallProperty=function(node,opts){assert("ObjectTypeCallProperty",node,opts);},exports.assertObjectTypeIndexer=function(node,opts){assert("ObjectTypeIndexer",node,opts);},exports.assertObjectTypeInternalSlot=function(node,opts){assert("ObjectTypeInternalSlot",node,opts);},exports.assertObjectTypeProperty=function(node,opts){assert("ObjectTypeProperty",node,opts);},exports.assertObjectTypeSpreadProperty=function(node,opts){assert("ObjectTypeSpreadProperty",node,opts);},exports.assertOpaqueType=function(node,opts){assert("OpaqueType",node,opts);},exports.assertOptionalCallExpression=function(node,opts){assert("OptionalCallExpression",node,opts);},exports.assertOptionalIndexedAccessType=function(node,opts){assert("OptionalIndexedAccessType",node,opts);},exports.assertOptionalMemberExpression=function(node,opts){assert("OptionalMemberExpression",node,opts);},exports.assertParenthesizedExpression=function(node,opts){assert("ParenthesizedExpression",node,opts);},exports.assertPattern=function(node,opts){assert("Pattern",node,opts);},exports.assertPatternLike=function(node,opts){assert("PatternLike",node,opts);},exports.assertPipelineBareFunction=function(node,opts){assert("PipelineBareFunction",node,opts);},exports.assertPipelinePrimaryTopicReference=function(node,opts){assert("PipelinePrimaryTopicReference",node,opts);},exports.assertPipelineTopicExpression=function(node,opts){assert("PipelineTopicExpression",node,opts);},exports.assertPlaceholder=function(node,opts){assert("Placeholder",node,opts);},exports.assertPrivate=function(node,opts){assert("Private",node,opts);},exports.assertPrivateName=function(node,opts){assert("PrivateName",node,opts);},exports.assertProgram=function(node,opts){assert("Program",node,opts);},exports.assertProperty=function(node,opts){assert("Property",node,opts);},exports.assertPureish=function(node,opts){assert("Pureish",node,opts);},exports.assertQualifiedTypeIdentifier=function(node,opts){assert("QualifiedTypeIdentifier",node,opts);},exports.assertRecordExpression=function(node,opts){assert("RecordExpression",node,opts);},exports.assertRegExpLiteral=function(node,opts){assert("RegExpLiteral",node,opts);},exports.assertRegexLiteral=function(node,opts){console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"),assert("RegexLiteral",node,opts);},exports.assertRestElement=function(node,opts){assert("RestElement",node,opts);},exports.assertRestProperty=function(node,opts){console.trace("The node type RestProperty has been renamed to RestElement"),assert("RestProperty",node,opts);},exports.assertReturnStatement=function(node,opts){assert("ReturnStatement",node,opts);},exports.assertScopable=function(node,opts){assert("Scopable",node,opts);},exports.assertSequenceExpression=function(node,opts){assert("SequenceExpression",node,opts);},exports.assertSpreadElement=function(node,opts){assert("SpreadElement",node,opts);},exports.assertSpreadProperty=function(node,opts){console.trace("The node type SpreadProperty has been renamed to SpreadElement"),assert("SpreadProperty",node,opts);},exports.assertStandardized=function(node,opts){assert("Standardized",node,opts);},exports.assertStatement=function(node,opts){assert("Statement",node,opts);},exports.assertStaticBlock=function(node,opts){assert("StaticBlock",node,opts);},exports.assertStringLiteral=function(node,opts){assert("StringLiteral",node,opts);},exports.assertStringLiteralTypeAnnotation=function(node,opts){assert("StringLiteralTypeAnnotation",node,opts);},exports.assertStringTypeAnnotation=function(node,opts){assert("StringTypeAnnotation",node,opts);},exports.assertSuper=function(node,opts){assert("Super",node,opts);},exports.assertSwitchCase=function(node,opts){assert("SwitchCase",node,opts);},exports.assertSwitchStatement=function(node,opts){assert("SwitchStatement",node,opts);},exports.assertSymbolTypeAnnotation=function(node,opts){assert("SymbolTypeAnnotation",node,opts);},exports.assertTSAnyKeyword=function(node,opts){assert("TSAnyKeyword",node,opts);},exports.assertTSArrayType=function(node,opts){assert("TSArrayType",node,opts);},exports.assertTSAsExpression=function(node,opts){assert("TSAsExpression",node,opts);},exports.assertTSBaseType=function(node,opts){assert("TSBaseType",node,opts);},exports.assertTSBigIntKeyword=function(node,opts){assert("TSBigIntKeyword",node,opts);},exports.assertTSBooleanKeyword=function(node,opts){assert("TSBooleanKeyword",node,opts);},exports.assertTSCallSignatureDeclaration=function(node,opts){assert("TSCallSignatureDeclaration",node,opts);},exports.assertTSConditionalType=function(node,opts){assert("TSConditionalType",node,opts);},exports.assertTSConstructSignatureDeclaration=function(node,opts){assert("TSConstructSignatureDeclaration",node,opts);},exports.assertTSConstructorType=function(node,opts){assert("TSConstructorType",node,opts);},exports.assertTSDeclareFunction=function(node,opts){assert("TSDeclareFunction",node,opts);},exports.assertTSDeclareMethod=function(node,opts){assert("TSDeclareMethod",node,opts);},exports.assertTSEntityName=function(node,opts){assert("TSEntityName",node,opts);},exports.assertTSEnumDeclaration=function(node,opts){assert("TSEnumDeclaration",node,opts);},exports.assertTSEnumMember=function(node,opts){assert("TSEnumMember",node,opts);},exports.assertTSExportAssignment=function(node,opts){assert("TSExportAssignment",node,opts);},exports.assertTSExpressionWithTypeArguments=function(node,opts){assert("TSExpressionWithTypeArguments",node,opts);},exports.assertTSExternalModuleReference=function(node,opts){assert("TSExternalModuleReference",node,opts);},exports.assertTSFunctionType=function(node,opts){assert("TSFunctionType",node,opts);},exports.assertTSImportEqualsDeclaration=function(node,opts){assert("TSImportEqualsDeclaration",node,opts);},exports.assertTSImportType=function(node,opts){assert("TSImportType",node,opts);},exports.assertTSIndexSignature=function(node,opts){assert("TSIndexSignature",node,opts);},exports.assertTSIndexedAccessType=function(node,opts){assert("TSIndexedAccessType",node,opts);},exports.assertTSInferType=function(node,opts){assert("TSInferType",node,opts);},exports.assertTSInterfaceBody=function(node,opts){assert("TSInterfaceBody",node,opts);},exports.assertTSInterfaceDeclaration=function(node,opts){assert("TSInterfaceDeclaration",node,opts);},exports.assertTSIntersectionType=function(node,opts){assert("TSIntersectionType",node,opts);},exports.assertTSIntrinsicKeyword=function(node,opts){assert("TSIntrinsicKeyword",node,opts);},exports.assertTSLiteralType=function(node,opts){assert("TSLiteralType",node,opts);},exports.assertTSMappedType=function(node,opts){assert("TSMappedType",node,opts);},exports.assertTSMethodSignature=function(node,opts){assert("TSMethodSignature",node,opts);},exports.assertTSModuleBlock=function(node,opts){assert("TSModuleBlock",node,opts);},exports.assertTSModuleDeclaration=function(node,opts){assert("TSModuleDeclaration",node,opts);},exports.assertTSNamedTupleMember=function(node,opts){assert("TSNamedTupleMember",node,opts);},exports.assertTSNamespaceExportDeclaration=function(node,opts){assert("TSNamespaceExportDeclaration",node,opts);},exports.assertTSNeverKeyword=function(node,opts){assert("TSNeverKeyword",node,opts);},exports.assertTSNonNullExpression=function(node,opts){assert("TSNonNullExpression",node,opts);},exports.assertTSNullKeyword=function(node,opts){assert("TSNullKeyword",node,opts);},exports.assertTSNumberKeyword=function(node,opts){assert("TSNumberKeyword",node,opts);},exports.assertTSObjectKeyword=function(node,opts){assert("TSObjectKeyword",node,opts);},exports.assertTSOptionalType=function(node,opts){assert("TSOptionalType",node,opts);},exports.assertTSParameterProperty=function(node,opts){assert("TSParameterProperty",node,opts);},exports.assertTSParenthesizedType=function(node,opts){assert("TSParenthesizedType",node,opts);},exports.assertTSPropertySignature=function(node,opts){assert("TSPropertySignature",node,opts);},exports.assertTSQualifiedName=function(node,opts){assert("TSQualifiedName",node,opts);},exports.assertTSRestType=function(node,opts){assert("TSRestType",node,opts);},exports.assertTSStringKeyword=function(node,opts){assert("TSStringKeyword",node,opts);},exports.assertTSSymbolKeyword=function(node,opts){assert("TSSymbolKeyword",node,opts);},exports.assertTSThisType=function(node,opts){assert("TSThisType",node,opts);},exports.assertTSTupleType=function(node,opts){assert("TSTupleType",node,opts);},exports.assertTSType=function(node,opts){assert("TSType",node,opts);},exports.assertTSTypeAliasDeclaration=function(node,opts){assert("TSTypeAliasDeclaration",node,opts);},exports.assertTSTypeAnnotation=function(node,opts){assert("TSTypeAnnotation",node,opts);},exports.assertTSTypeAssertion=function(node,opts){assert("TSTypeAssertion",node,opts);},exports.assertTSTypeElement=function(node,opts){assert("TSTypeElement",node,opts);},exports.assertTSTypeLiteral=function(node,opts){assert("TSTypeLiteral",node,opts);},exports.assertTSTypeOperator=function(node,opts){assert("TSTypeOperator",node,opts);},exports.assertTSTypeParameter=function(node,opts){assert("TSTypeParameter",node,opts);},exports.assertTSTypeParameterDeclaration=function(node,opts){assert("TSTypeParameterDeclaration",node,opts);},exports.assertTSTypeParameterInstantiation=function(node,opts){assert("TSTypeParameterInstantiation",node,opts);},exports.assertTSTypePredicate=function(node,opts){assert("TSTypePredicate",node,opts);},exports.assertTSTypeQuery=function(node,opts){assert("TSTypeQuery",node,opts);},exports.assertTSTypeReference=function(node,opts){assert("TSTypeReference",node,opts);},exports.assertTSUndefinedKeyword=function(node,opts){assert("TSUndefinedKeyword",node,opts);},exports.assertTSUnionType=function(node,opts){assert("TSUnionType",node,opts);},exports.assertTSUnknownKeyword=function(node,opts){assert("TSUnknownKeyword",node,opts);},exports.assertTSVoidKeyword=function(node,opts){assert("TSVoidKeyword",node,opts);},exports.assertTaggedTemplateExpression=function(node,opts){assert("TaggedTemplateExpression",node,opts);},exports.assertTemplateElement=function(node,opts){assert("TemplateElement",node,opts);},exports.assertTemplateLiteral=function(node,opts){assert("TemplateLiteral",node,opts);},exports.assertTerminatorless=function(node,opts){assert("Terminatorless",node,opts);},exports.assertThisExpression=function(node,opts){assert("ThisExpression",node,opts);},exports.assertThisTypeAnnotation=function(node,opts){assert("ThisTypeAnnotation",node,opts);},exports.assertThrowStatement=function(node,opts){assert("ThrowStatement",node,opts);},exports.assertTopicReference=function(node,opts){assert("TopicReference",node,opts);},exports.assertTryStatement=function(node,opts){assert("TryStatement",node,opts);},exports.assertTupleExpression=function(node,opts){assert("TupleExpression",node,opts);},exports.assertTupleTypeAnnotation=function(node,opts){assert("TupleTypeAnnotation",node,opts);},exports.assertTypeAlias=function(node,opts){assert("TypeAlias",node,opts);},exports.assertTypeAnnotation=function(node,opts){assert("TypeAnnotation",node,opts);},exports.assertTypeCastExpression=function(node,opts){assert("TypeCastExpression",node,opts);},exports.assertTypeParameter=function(node,opts){assert("TypeParameter",node,opts);},exports.assertTypeParameterDeclaration=function(node,opts){assert("TypeParameterDeclaration",node,opts);},exports.assertTypeParameterInstantiation=function(node,opts){assert("TypeParameterInstantiation",node,opts);},exports.assertTypeScript=function(node,opts){assert("TypeScript",node,opts);},exports.assertTypeofTypeAnnotation=function(node,opts){assert("TypeofTypeAnnotation",node,opts);},exports.assertUnaryExpression=function(node,opts){assert("UnaryExpression",node,opts);},exports.assertUnaryLike=function(node,opts){assert("UnaryLike",node,opts);},exports.assertUnionTypeAnnotation=function(node,opts){assert("UnionTypeAnnotation",node,opts);},exports.assertUpdateExpression=function(node,opts){assert("UpdateExpression",node,opts);},exports.assertUserWhitespacable=function(node,opts){assert("UserWhitespacable",node,opts);},exports.assertV8IntrinsicIdentifier=function(node,opts){assert("V8IntrinsicIdentifier",node,opts);},exports.assertVariableDeclaration=function(node,opts){assert("VariableDeclaration",node,opts);},exports.assertVariableDeclarator=function(node,opts){assert("VariableDeclarator",node,opts);},exports.assertVariance=function(node,opts){assert("Variance",node,opts);},exports.assertVoidTypeAnnotation=function(node,opts){assert("VoidTypeAnnotation",node,opts);},exports.assertWhile=function(node,opts){assert("While",node,opts);},exports.assertWhileStatement=function(node,opts){assert("WhileStatement",node,opts);},exports.assertWithStatement=function(node,opts){assert("WithStatement",node,opts);},exports.assertYieldExpression=function(node,opts){assert("YieldExpression",node,opts);};var _is=__webpack_require__("./node_modules/@babel/types/lib/validators/is.js");function assert(type,node,opts){if(!(0, _is.default)(type,node,opts))throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node.type}".`)}},"./node_modules/@babel/types/lib/ast-types/generated/index.js":()=>{},"./node_modules/@babel/types/lib/builders/builder.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(){const type=this,keys=_definitions.BUILDER_KEYS[type],countArgs=arguments.length;if(countArgs>keys.length)throw new Error(`${type}: Too many arguments passed. Received ${countArgs} but can receive no more than ${keys.length}`);const node={type};for(let i=0;i<keys.length;++i){const key=keys[i],field=_definitions.NODE_FIELDS[type][key];let arg;i<countArgs&&(arg=arguments[i]),void 0===arg&&(arg=Array.isArray(field.default)?[]:field.default),node[key]=arg;}for(const key in node)(0, _validate.default)(node,key,node[key]);return node};var _definitions=__webpack_require__("./node_modules/@babel/types/lib/definitions/index.js"),_validate=__webpack_require__("./node_modules/@babel/types/lib/validators/validate.js");},"./node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(types){const flattened=(0, _removeTypeDuplicates.default)(types);return 1===flattened.length?flattened[0]:(0, _generated.unionTypeAnnotation)(flattened)};var _generated=__webpack_require__("./node_modules/@babel/types/lib/builders/generated/index.js"),_removeTypeDuplicates=__webpack_require__("./node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js");},"./node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _generated=__webpack_require__("./node_modules/@babel/types/lib/builders/generated/index.js"),_default=function(type){switch(type){case"string":return (0, _generated.stringTypeAnnotation)();case"number":return (0, _generated.numberTypeAnnotation)();case"undefined":return (0, _generated.voidTypeAnnotation)();case"boolean":return (0, _generated.booleanTypeAnnotation)();case"function":return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));case"object":return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));case"symbol":return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));case"bigint":return (0, _generated.anyTypeAnnotation)()}throw new Error("Invalid typeof value: "+type)};exports.default=_default;},"./node_modules/@babel/types/lib/builders/generated/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.anyTypeAnnotation=function(){return _builder.default.apply("AnyTypeAnnotation",arguments)},exports.argumentPlaceholder=function(){return _builder.default.apply("ArgumentPlaceholder",arguments)},exports.arrayExpression=function(elements){return _builder.default.apply("ArrayExpression",arguments)},exports.arrayPattern=function(elements){return _builder.default.apply("ArrayPattern",arguments)},exports.arrayTypeAnnotation=function(elementType){return _builder.default.apply("ArrayTypeAnnotation",arguments)},exports.arrowFunctionExpression=function(params,body,async){return _builder.default.apply("ArrowFunctionExpression",arguments)},exports.assignmentExpression=function(operator,left,right){return _builder.default.apply("AssignmentExpression",arguments)},exports.assignmentPattern=function(left,right){return _builder.default.apply("AssignmentPattern",arguments)},exports.awaitExpression=function(argument){return _builder.default.apply("AwaitExpression",arguments)},exports.bigIntLiteral=function(value){return _builder.default.apply("BigIntLiteral",arguments)},exports.binaryExpression=function(operator,left,right){return _builder.default.apply("BinaryExpression",arguments)},exports.bindExpression=function(object,callee){return _builder.default.apply("BindExpression",arguments)},exports.blockStatement=function(body,directives){return _builder.default.apply("BlockStatement",arguments)},exports.booleanLiteral=function(value){return _builder.default.apply("BooleanLiteral",arguments)},exports.booleanLiteralTypeAnnotation=function(value){return _builder.default.apply("BooleanLiteralTypeAnnotation",arguments)},exports.booleanTypeAnnotation=function(){return _builder.default.apply("BooleanTypeAnnotation",arguments)},exports.breakStatement=function(label){return _builder.default.apply("BreakStatement",arguments)},exports.callExpression=function(callee,_arguments){return _builder.default.apply("CallExpression",arguments)},exports.catchClause=function(param,body){return _builder.default.apply("CatchClause",arguments)},exports.classBody=function(body){return _builder.default.apply("ClassBody",arguments)},exports.classDeclaration=function(id,superClass,body,decorators){return _builder.default.apply("ClassDeclaration",arguments)},exports.classExpression=function(id,superClass,body,decorators){return _builder.default.apply("ClassExpression",arguments)},exports.classImplements=function(id,typeParameters){return _builder.default.apply("ClassImplements",arguments)},exports.classMethod=function(kind,key,params,body,computed,_static,generator,async){return _builder.default.apply("ClassMethod",arguments)},exports.classPrivateMethod=function(kind,key,params,body,_static){return _builder.default.apply("ClassPrivateMethod",arguments)},exports.classPrivateProperty=function(key,value,decorators,_static){return _builder.default.apply("ClassPrivateProperty",arguments)},exports.classProperty=function(key,value,typeAnnotation,decorators,computed,_static){return _builder.default.apply("ClassProperty",arguments)},exports.conditionalExpression=function(test,consequent,alternate){return _builder.default.apply("ConditionalExpression",arguments)},exports.continueStatement=function(label){return _builder.default.apply("ContinueStatement",arguments)},exports.debuggerStatement=function(){return _builder.default.apply("DebuggerStatement",arguments)},exports.decimalLiteral=function(value){return _builder.default.apply("DecimalLiteral",arguments)},exports.declareClass=function(id,typeParameters,_extends,body){return _builder.default.apply("DeclareClass",arguments)},exports.declareExportAllDeclaration=function(source){return _builder.default.apply("DeclareExportAllDeclaration",arguments)},exports.declareExportDeclaration=function(declaration,specifiers,source){return _builder.default.apply("DeclareExportDeclaration",arguments)},exports.declareFunction=function(id){return _builder.default.apply("DeclareFunction",arguments)},exports.declareInterface=function(id,typeParameters,_extends,body){return _builder.default.apply("DeclareInterface",arguments)},exports.declareModule=function(id,body,kind){return _builder.default.apply("DeclareModule",arguments)},exports.declareModuleExports=function(typeAnnotation){return _builder.default.apply("DeclareModuleExports",arguments)},exports.declareOpaqueType=function(id,typeParameters,supertype){return _builder.default.apply("DeclareOpaqueType",arguments)},exports.declareTypeAlias=function(id,typeParameters,right){return _builder.default.apply("DeclareTypeAlias",arguments)},exports.declareVariable=function(id){return _builder.default.apply("DeclareVariable",arguments)},exports.declaredPredicate=function(value){return _builder.default.apply("DeclaredPredicate",arguments)},exports.decorator=function(expression){return _builder.default.apply("Decorator",arguments)},exports.directive=function(value){return _builder.default.apply("Directive",arguments)},exports.directiveLiteral=function(value){return _builder.default.apply("DirectiveLiteral",arguments)},exports.doExpression=function(body,async){return _builder.default.apply("DoExpression",arguments)},exports.doWhileStatement=function(test,body){return _builder.default.apply("DoWhileStatement",arguments)},exports.emptyStatement=function(){return _builder.default.apply("EmptyStatement",arguments)},exports.emptyTypeAnnotation=function(){return _builder.default.apply("EmptyTypeAnnotation",arguments)},exports.enumBooleanBody=function(members){return _builder.default.apply("EnumBooleanBody",arguments)},exports.enumBooleanMember=function(id){return _builder.default.apply("EnumBooleanMember",arguments)},exports.enumDeclaration=function(id,body){return _builder.default.apply("EnumDeclaration",arguments)},exports.enumDefaultedMember=function(id){return _builder.default.apply("EnumDefaultedMember",arguments)},exports.enumNumberBody=function(members){return _builder.default.apply("EnumNumberBody",arguments)},exports.enumNumberMember=function(id,init){return _builder.default.apply("EnumNumberMember",arguments)},exports.enumStringBody=function(members){return _builder.default.apply("EnumStringBody",arguments)},exports.enumStringMember=function(id,init){return _builder.default.apply("EnumStringMember",arguments)},exports.enumSymbolBody=function(members){return _builder.default.apply("EnumSymbolBody",arguments)},exports.existsTypeAnnotation=function(){return _builder.default.apply("ExistsTypeAnnotation",arguments)},exports.exportAllDeclaration=function(source){return _builder.default.apply("ExportAllDeclaration",arguments)},exports.exportDefaultDeclaration=function(declaration){return _builder.default.apply("ExportDefaultDeclaration",arguments)},exports.exportDefaultSpecifier=function(exported){return _builder.default.apply("ExportDefaultSpecifier",arguments)},exports.exportNamedDeclaration=function(declaration,specifiers,source){return _builder.default.apply("ExportNamedDeclaration",arguments)},exports.exportNamespaceSpecifier=function(exported){return _builder.default.apply("ExportNamespaceSpecifier",arguments)},exports.exportSpecifier=function(local,exported){return _builder.default.apply("ExportSpecifier",arguments)},exports.expressionStatement=function(expression){return _builder.default.apply("ExpressionStatement",arguments)},exports.file=function(program,comments,tokens){return _builder.default.apply("File",arguments)},exports.forInStatement=function(left,right,body){return _builder.default.apply("ForInStatement",arguments)},exports.forOfStatement=function(left,right,body,_await){return _builder.default.apply("ForOfStatement",arguments)},exports.forStatement=function(init,test,update,body){return _builder.default.apply("ForStatement",arguments)},exports.functionDeclaration=function(id,params,body,generator,async){return _builder.default.apply("FunctionDeclaration",arguments)},exports.functionExpression=function(id,params,body,generator,async){return _builder.default.apply("FunctionExpression",arguments)},exports.functionTypeAnnotation=function(typeParameters,params,rest,returnType){return _builder.default.apply("FunctionTypeAnnotation",arguments)},exports.functionTypeParam=function(name,typeAnnotation){return _builder.default.apply("FunctionTypeParam",arguments)},exports.genericTypeAnnotation=function(id,typeParameters){return _builder.default.apply("GenericTypeAnnotation",arguments)},exports.identifier=function(name){return _builder.default.apply("Identifier",arguments)},exports.ifStatement=function(test,consequent,alternate){return _builder.default.apply("IfStatement",arguments)},exports.import=function(){return _builder.default.apply("Import",arguments)},exports.importAttribute=function(key,value){return _builder.default.apply("ImportAttribute",arguments)},exports.importDeclaration=function(specifiers,source){return _builder.default.apply("ImportDeclaration",arguments)},exports.importDefaultSpecifier=function(local){return _builder.default.apply("ImportDefaultSpecifier",arguments)},exports.importNamespaceSpecifier=function(local){return _builder.default.apply("ImportNamespaceSpecifier",arguments)},exports.importSpecifier=function(local,imported){return _builder.default.apply("ImportSpecifier",arguments)},exports.indexedAccessType=function(objectType,indexType){return _builder.default.apply("IndexedAccessType",arguments)},exports.inferredPredicate=function(){return _builder.default.apply("InferredPredicate",arguments)},exports.interfaceDeclaration=function(id,typeParameters,_extends,body){return _builder.default.apply("InterfaceDeclaration",arguments)},exports.interfaceExtends=function(id,typeParameters){return _builder.default.apply("InterfaceExtends",arguments)},exports.interfaceTypeAnnotation=function(_extends,body){return _builder.default.apply("InterfaceTypeAnnotation",arguments)},exports.interpreterDirective=function(value){return _builder.default.apply("InterpreterDirective",arguments)},exports.intersectionTypeAnnotation=function(types){return _builder.default.apply("IntersectionTypeAnnotation",arguments)},exports.jSXAttribute=exports.jsxAttribute=function(name,value){return _builder.default.apply("JSXAttribute",arguments)},exports.jSXClosingElement=exports.jsxClosingElement=function(name){return _builder.default.apply("JSXClosingElement",arguments)},exports.jSXClosingFragment=exports.jsxClosingFragment=function(){return _builder.default.apply("JSXClosingFragment",arguments)},exports.jSXElement=exports.jsxElement=function(openingElement,closingElement,children,selfClosing){return _builder.default.apply("JSXElement",arguments)},exports.jSXEmptyExpression=exports.jsxEmptyExpression=function(){return _builder.default.apply("JSXEmptyExpression",arguments)},exports.jSXExpressionContainer=exports.jsxExpressionContainer=function(expression){return _builder.default.apply("JSXExpressionContainer",arguments)},exports.jSXFragment=exports.jsxFragment=function(openingFragment,closingFragment,children){return _builder.default.apply("JSXFragment",arguments)},exports.jSXIdentifier=exports.jsxIdentifier=function(name){return _builder.default.apply("JSXIdentifier",arguments)},exports.jSXMemberExpression=exports.jsxMemberExpression=function(object,property){return _builder.default.apply("JSXMemberExpression",arguments)},exports.jSXNamespacedName=exports.jsxNamespacedName=function(namespace,name){return _builder.default.apply("JSXNamespacedName",arguments)},exports.jSXOpeningElement=exports.jsxOpeningElement=function(name,attributes,selfClosing){return _builder.default.apply("JSXOpeningElement",arguments)},exports.jSXOpeningFragment=exports.jsxOpeningFragment=function(){return _builder.default.apply("JSXOpeningFragment",arguments)},exports.jSXSpreadAttribute=exports.jsxSpreadAttribute=function(argument){return _builder.default.apply("JSXSpreadAttribute",arguments)},exports.jSXSpreadChild=exports.jsxSpreadChild=function(expression){return _builder.default.apply("JSXSpreadChild",arguments)},exports.jSXText=exports.jsxText=function(value){return _builder.default.apply("JSXText",arguments)},exports.labeledStatement=function(label,body){return _builder.default.apply("LabeledStatement",arguments)},exports.logicalExpression=function(operator,left,right){return _builder.default.apply("LogicalExpression",arguments)},exports.memberExpression=function(object,property,computed,optional){return _builder.default.apply("MemberExpression",arguments)},exports.metaProperty=function(meta,property){return _builder.default.apply("MetaProperty",arguments)},exports.mixedTypeAnnotation=function(){return _builder.default.apply("MixedTypeAnnotation",arguments)},exports.moduleExpression=function(body){return _builder.default.apply("ModuleExpression",arguments)},exports.newExpression=function(callee,_arguments){return _builder.default.apply("NewExpression",arguments)},exports.noop=function(){return _builder.default.apply("Noop",arguments)},exports.nullLiteral=function(){return _builder.default.apply("NullLiteral",arguments)},exports.nullLiteralTypeAnnotation=function(){return _builder.default.apply("NullLiteralTypeAnnotation",arguments)},exports.nullableTypeAnnotation=function(typeAnnotation){return _builder.default.apply("NullableTypeAnnotation",arguments)},exports.numberLiteral=function(value){return console.trace("The node type NumberLiteral has been renamed to NumericLiteral"),_builder.default.apply("NumberLiteral",arguments)},exports.numberLiteralTypeAnnotation=function(value){return _builder.default.apply("NumberLiteralTypeAnnotation",arguments)},exports.numberTypeAnnotation=function(){return _builder.default.apply("NumberTypeAnnotation",arguments)},exports.numericLiteral=function(value){return _builder.default.apply("NumericLiteral",arguments)},exports.objectExpression=function(properties){return _builder.default.apply("ObjectExpression",arguments)},exports.objectMethod=function(kind,key,params,body,computed,generator,async){return _builder.default.apply("ObjectMethod",arguments)},exports.objectPattern=function(properties){return _builder.default.apply("ObjectPattern",arguments)},exports.objectProperty=function(key,value,computed,shorthand,decorators){return _builder.default.apply("ObjectProperty",arguments)},exports.objectTypeAnnotation=function(properties,indexers,callProperties,internalSlots,exact){return _builder.default.apply("ObjectTypeAnnotation",arguments)},exports.objectTypeCallProperty=function(value){return _builder.default.apply("ObjectTypeCallProperty",arguments)},exports.objectTypeIndexer=function(id,key,value,variance){return _builder.default.apply("ObjectTypeIndexer",arguments)},exports.objectTypeInternalSlot=function(id,value,optional,_static,method){return _builder.default.apply("ObjectTypeInternalSlot",arguments)},exports.objectTypeProperty=function(key,value,variance){return _builder.default.apply("ObjectTypeProperty",arguments)},exports.objectTypeSpreadProperty=function(argument){return _builder.default.apply("ObjectTypeSpreadProperty",arguments)},exports.opaqueType=function(id,typeParameters,supertype,impltype){return _builder.default.apply("OpaqueType",arguments)},exports.optionalCallExpression=function(callee,_arguments,optional){return _builder.default.apply("OptionalCallExpression",arguments)},exports.optionalIndexedAccessType=function(objectType,indexType){return _builder.default.apply("OptionalIndexedAccessType",arguments)},exports.optionalMemberExpression=function(object,property,computed,optional){return _builder.default.apply("OptionalMemberExpression",arguments)},exports.parenthesizedExpression=function(expression){return _builder.default.apply("ParenthesizedExpression",arguments)},exports.pipelineBareFunction=function(callee){return _builder.default.apply("PipelineBareFunction",arguments)},exports.pipelinePrimaryTopicReference=function(){return _builder.default.apply("PipelinePrimaryTopicReference",arguments)},exports.pipelineTopicExpression=function(expression){return _builder.default.apply("PipelineTopicExpression",arguments)},exports.placeholder=function(expectedNode,name){return _builder.default.apply("Placeholder",arguments)},exports.privateName=function(id){return _builder.default.apply("PrivateName",arguments)},exports.program=function(body,directives,sourceType,interpreter){return _builder.default.apply("Program",arguments)},exports.qualifiedTypeIdentifier=function(id,qualification){return _builder.default.apply("QualifiedTypeIdentifier",arguments)},exports.recordExpression=function(properties){return _builder.default.apply("RecordExpression",arguments)},exports.regExpLiteral=function(pattern,flags){return _builder.default.apply("RegExpLiteral",arguments)},exports.regexLiteral=function(pattern,flags){return console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"),_builder.default.apply("RegexLiteral",arguments)},exports.restElement=function(argument){return _builder.default.apply("RestElement",arguments)},exports.restProperty=function(argument){return console.trace("The node type RestProperty has been renamed to RestElement"),_builder.default.apply("RestProperty",arguments)},exports.returnStatement=function(argument){return _builder.default.apply("ReturnStatement",arguments)},exports.sequenceExpression=function(expressions){return _builder.default.apply("SequenceExpression",arguments)},exports.spreadElement=function(argument){return _builder.default.apply("SpreadElement",arguments)},exports.spreadProperty=function(argument){return console.trace("The node type SpreadProperty has been renamed to SpreadElement"),_builder.default.apply("SpreadProperty",arguments)},exports.staticBlock=function(body){return _builder.default.apply("StaticBlock",arguments)},exports.stringLiteral=function(value){return _builder.default.apply("StringLiteral",arguments)},exports.stringLiteralTypeAnnotation=function(value){return _builder.default.apply("StringLiteralTypeAnnotation",arguments)},exports.stringTypeAnnotation=function(){return _builder.default.apply("StringTypeAnnotation",arguments)},exports.super=function(){return _builder.default.apply("Super",arguments)},exports.switchCase=function(test,consequent){return _builder.default.apply("SwitchCase",arguments)},exports.switchStatement=function(discriminant,cases){return _builder.default.apply("SwitchStatement",arguments)},exports.symbolTypeAnnotation=function(){return _builder.default.apply("SymbolTypeAnnotation",arguments)},exports.taggedTemplateExpression=function(tag,quasi){return _builder.default.apply("TaggedTemplateExpression",arguments)},exports.templateElement=function(value,tail){return _builder.default.apply("TemplateElement",arguments)},exports.templateLiteral=function(quasis,expressions){return _builder.default.apply("TemplateLiteral",arguments)},exports.thisExpression=function(){return _builder.default.apply("ThisExpression",arguments)},exports.thisTypeAnnotation=function(){return _builder.default.apply("ThisTypeAnnotation",arguments)},exports.throwStatement=function(argument){return _builder.default.apply("ThrowStatement",arguments)},exports.topicReference=function(){return _builder.default.apply("TopicReference",arguments)},exports.tryStatement=function(block,handler,finalizer){return _builder.default.apply("TryStatement",arguments)},exports.tSAnyKeyword=exports.tsAnyKeyword=function(){return _builder.default.apply("TSAnyKeyword",arguments)},exports.tSArrayType=exports.tsArrayType=function(elementType){return _builder.default.apply("TSArrayType",arguments)},exports.tSAsExpression=exports.tsAsExpression=function(expression,typeAnnotation){return _builder.default.apply("TSAsExpression",arguments)},exports.tSBigIntKeyword=exports.tsBigIntKeyword=function(){return _builder.default.apply("TSBigIntKeyword",arguments)},exports.tSBooleanKeyword=exports.tsBooleanKeyword=function(){return _builder.default.apply("TSBooleanKeyword",arguments)},exports.tSCallSignatureDeclaration=exports.tsCallSignatureDeclaration=function(typeParameters,parameters,typeAnnotation){return _builder.default.apply("TSCallSignatureDeclaration",arguments)},exports.tSConditionalType=exports.tsConditionalType=function(checkType,extendsType,trueType,falseType){return _builder.default.apply("TSConditionalType",arguments)},exports.tSConstructSignatureDeclaration=exports.tsConstructSignatureDeclaration=function(typeParameters,parameters,typeAnnotation){return _builder.default.apply("TSConstructSignatureDeclaration",arguments)},exports.tSConstructorType=exports.tsConstructorType=function(typeParameters,parameters,typeAnnotation){return _builder.default.apply("TSConstructorType",arguments)},exports.tSDeclareFunction=exports.tsDeclareFunction=function(id,typeParameters,params,returnType){return _builder.default.apply("TSDeclareFunction",arguments)},exports.tSDeclareMethod=exports.tsDeclareMethod=function(decorators,key,typeParameters,params,returnType){return _builder.default.apply("TSDeclareMethod",arguments)},exports.tSEnumDeclaration=exports.tsEnumDeclaration=function(id,members){return _builder.default.apply("TSEnumDeclaration",arguments)},exports.tSEnumMember=exports.tsEnumMember=function(id,initializer){return _builder.default.apply("TSEnumMember",arguments)},exports.tSExportAssignment=exports.tsExportAssignment=function(expression){return _builder.default.apply("TSExportAssignment",arguments)},exports.tSExpressionWithTypeArguments=exports.tsExpressionWithTypeArguments=function(expression,typeParameters){return _builder.default.apply("TSExpressionWithTypeArguments",arguments)},exports.tSExternalModuleReference=exports.tsExternalModuleReference=function(expression){return _builder.default.apply("TSExternalModuleReference",arguments)},exports.tSFunctionType=exports.tsFunctionType=function(typeParameters,parameters,typeAnnotation){return _builder.default.apply("TSFunctionType",arguments)},exports.tSImportEqualsDeclaration=exports.tsImportEqualsDeclaration=function(id,moduleReference){return _builder.default.apply("TSImportEqualsDeclaration",arguments)},exports.tSImportType=exports.tsImportType=function(argument,qualifier,typeParameters){return _builder.default.apply("TSImportType",arguments)},exports.tSIndexSignature=exports.tsIndexSignature=function(parameters,typeAnnotation){return _builder.default.apply("TSIndexSignature",arguments)},exports.tSIndexedAccessType=exports.tsIndexedAccessType=function(objectType,indexType){return _builder.default.apply("TSIndexedAccessType",arguments)},exports.tSInferType=exports.tsInferType=function(typeParameter){return _builder.default.apply("TSInferType",arguments)},exports.tSInterfaceBody=exports.tsInterfaceBody=function(body){return _builder.default.apply("TSInterfaceBody",arguments)},exports.tSInterfaceDeclaration=exports.tsInterfaceDeclaration=function(id,typeParameters,_extends,body){return _builder.default.apply("TSInterfaceDeclaration",arguments)},exports.tSIntersectionType=exports.tsIntersectionType=function(types){return _builder.default.apply("TSIntersectionType",arguments)},exports.tSIntrinsicKeyword=exports.tsIntrinsicKeyword=function(){return _builder.default.apply("TSIntrinsicKeyword",arguments)},exports.tSLiteralType=exports.tsLiteralType=function(literal){return _builder.default.apply("TSLiteralType",arguments)},exports.tSMappedType=exports.tsMappedType=function(typeParameter,typeAnnotation,nameType){return _builder.default.apply("TSMappedType",arguments)},exports.tSMethodSignature=exports.tsMethodSignature=function(key,typeParameters,parameters,typeAnnotation){return _builder.default.apply("TSMethodSignature",arguments)},exports.tSModuleBlock=exports.tsModuleBlock=function(body){return _builder.default.apply("TSModuleBlock",arguments)},exports.tSModuleDeclaration=exports.tsModuleDeclaration=function(id,body){return _builder.default.apply("TSModuleDeclaration",arguments)},exports.tSNamedTupleMember=exports.tsNamedTupleMember=function(label,elementType,optional){return _builder.default.apply("TSNamedTupleMember",arguments)},exports.tSNamespaceExportDeclaration=exports.tsNamespaceExportDeclaration=function(id){return _builder.default.apply("TSNamespaceExportDeclaration",arguments)},exports.tSNeverKeyword=exports.tsNeverKeyword=function(){return _builder.default.apply("TSNeverKeyword",arguments)},exports.tSNonNullExpression=exports.tsNonNullExpression=function(expression){return _builder.default.apply("TSNonNullExpression",arguments)},exports.tSNullKeyword=exports.tsNullKeyword=function(){return _builder.default.apply("TSNullKeyword",arguments)},exports.tSNumberKeyword=exports.tsNumberKeyword=function(){return _builder.default.apply("TSNumberKeyword",arguments)},exports.tSObjectKeyword=exports.tsObjectKeyword=function(){return _builder.default.apply("TSObjectKeyword",arguments)},exports.tSOptionalType=exports.tsOptionalType=function(typeAnnotation){return _builder.default.apply("TSOptionalType",arguments)},exports.tSParameterProperty=exports.tsParameterProperty=function(parameter){return _builder.default.apply("TSParameterProperty",arguments)},exports.tSParenthesizedType=exports.tsParenthesizedType=function(typeAnnotation){return _builder.default.apply("TSParenthesizedType",arguments)},exports.tSPropertySignature=exports.tsPropertySignature=function(key,typeAnnotation,initializer){return _builder.default.apply("TSPropertySignature",arguments)},exports.tSQualifiedName=exports.tsQualifiedName=function(left,right){return _builder.default.apply("TSQualifiedName",arguments)},exports.tSRestType=exports.tsRestType=function(typeAnnotation){return _builder.default.apply("TSRestType",arguments)},exports.tSStringKeyword=exports.tsStringKeyword=function(){return _builder.default.apply("TSStringKeyword",arguments)},exports.tSSymbolKeyword=exports.tsSymbolKeyword=function(){return _builder.default.apply("TSSymbolKeyword",arguments)},exports.tSThisType=exports.tsThisType=function(){return _builder.default.apply("TSThisType",arguments)},exports.tSTupleType=exports.tsTupleType=function(elementTypes){return _builder.default.apply("TSTupleType",arguments)},exports.tSTypeAliasDeclaration=exports.tsTypeAliasDeclaration=function(id,typeParameters,typeAnnotation){return _builder.default.apply("TSTypeAliasDeclaration",arguments)},exports.tSTypeAnnotation=exports.tsTypeAnnotation=function(typeAnnotation){return _builder.default.apply("TSTypeAnnotation",arguments)},exports.tSTypeAssertion=exports.tsTypeAssertion=function(typeAnnotation,expression){return _builder.default.apply("TSTypeAssertion",arguments)},exports.tSTypeLiteral=exports.tsTypeLiteral=function(members){return _builder.default.apply("TSTypeLiteral",arguments)},exports.tSTypeOperator=exports.tsTypeOperator=function(typeAnnotation){return _builder.default.apply("TSTypeOperator",arguments)},exports.tSTypeParameter=exports.tsTypeParameter=function(constraint,_default,name){return _builder.default.apply("TSTypeParameter",arguments)},exports.tSTypeParameterDeclaration=exports.tsTypeParameterDeclaration=function(params){return _builder.default.apply("TSTypeParameterDeclaration",arguments)},exports.tSTypeParameterInstantiation=exports.tsTypeParameterInstantiation=function(params){return _builder.default.apply("TSTypeParameterInstantiation",arguments)},exports.tSTypePredicate=exports.tsTypePredicate=function(parameterName,typeAnnotation,asserts){return _builder.default.apply("TSTypePredicate",arguments)},exports.tSTypeQuery=exports.tsTypeQuery=function(exprName){return _builder.default.apply("TSTypeQuery",arguments)},exports.tSTypeReference=exports.tsTypeReference=function(typeName,typeParameters){return _builder.default.apply("TSTypeReference",arguments)},exports.tSUndefinedKeyword=exports.tsUndefinedKeyword=function(){return _builder.default.apply("TSUndefinedKeyword",arguments)},exports.tSUnionType=exports.tsUnionType=function(types){return _builder.default.apply("TSUnionType",arguments)},exports.tSUnknownKeyword=exports.tsUnknownKeyword=function(){return _builder.default.apply("TSUnknownKeyword",arguments)},exports.tSVoidKeyword=exports.tsVoidKeyword=function(){return _builder.default.apply("TSVoidKeyword",arguments)},exports.tupleExpression=function(elements){return _builder.default.apply("TupleExpression",arguments)},exports.tupleTypeAnnotation=function(types){return _builder.default.apply("TupleTypeAnnotation",arguments)},exports.typeAlias=function(id,typeParameters,right){return _builder.default.apply("TypeAlias",arguments)},exports.typeAnnotation=function(typeAnnotation){return _builder.default.apply("TypeAnnotation",arguments)},exports.typeCastExpression=function(expression,typeAnnotation){return _builder.default.apply("TypeCastExpression",arguments)},exports.typeParameter=function(bound,_default,variance){return _builder.default.apply("TypeParameter",arguments)},exports.typeParameterDeclaration=function(params){return _builder.default.apply("TypeParameterDeclaration",arguments)},exports.typeParameterInstantiation=function(params){return _builder.default.apply("TypeParameterInstantiation",arguments)},exports.typeofTypeAnnotation=function(argument){return _builder.default.apply("TypeofTypeAnnotation",arguments)},exports.unaryExpression=function(operator,argument,prefix){return _builder.default.apply("UnaryExpression",arguments)},exports.unionTypeAnnotation=function(types){return _builder.default.apply("UnionTypeAnnotation",arguments)},exports.updateExpression=function(operator,argument,prefix){return _builder.default.apply("UpdateExpression",arguments)},exports.v8IntrinsicIdentifier=function(name){return _builder.default.apply("V8IntrinsicIdentifier",arguments)},exports.variableDeclaration=function(kind,declarations){return _builder.default.apply("VariableDeclaration",arguments)},exports.variableDeclarator=function(id,init){return _builder.default.apply("VariableDeclarator",arguments)},exports.variance=function(kind){return _builder.default.apply("Variance",arguments)},exports.voidTypeAnnotation=function(){return _builder.default.apply("VoidTypeAnnotation",arguments)},exports.whileStatement=function(test,body){return _builder.default.apply("WhileStatement",arguments)},exports.withStatement=function(object,body){return _builder.default.apply("WithStatement",arguments)},exports.yieldExpression=function(argument,delegate){return _builder.default.apply("YieldExpression",arguments)};var _builder=__webpack_require__("./node_modules/@babel/types/lib/builders/builder.js");},"./node_modules/@babel/types/lib/builders/generated/uppercase.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"AnyTypeAnnotation",{enumerable:!0,get:function(){return _index.anyTypeAnnotation}}),Object.defineProperty(exports,"ArgumentPlaceholder",{enumerable:!0,get:function(){return _index.argumentPlaceholder}}),Object.defineProperty(exports,"ArrayExpression",{enumerable:!0,get:function(){return _index.arrayExpression}}),Object.defineProperty(exports,"ArrayPattern",{enumerable:!0,get:function(){return _index.arrayPattern}}),Object.defineProperty(exports,"ArrayTypeAnnotation",{enumerable:!0,get:function(){return _index.arrayTypeAnnotation}}),Object.defineProperty(exports,"ArrowFunctionExpression",{enumerable:!0,get:function(){return _index.arrowFunctionExpression}}),Object.defineProperty(exports,"AssignmentExpression",{enumerable:!0,get:function(){return _index.assignmentExpression}}),Object.defineProperty(exports,"AssignmentPattern",{enumerable:!0,get:function(){return _index.assignmentPattern}}),Object.defineProperty(exports,"AwaitExpression",{enumerable:!0,get:function(){return _index.awaitExpression}}),Object.defineProperty(exports,"BigIntLiteral",{enumerable:!0,get:function(){return _index.bigIntLiteral}}),Object.defineProperty(exports,"BinaryExpression",{enumerable:!0,get:function(){return _index.binaryExpression}}),Object.defineProperty(exports,"BindExpression",{enumerable:!0,get:function(){return _index.bindExpression}}),Object.defineProperty(exports,"BlockStatement",{enumerable:!0,get:function(){return _index.blockStatement}}),Object.defineProperty(exports,"BooleanLiteral",{enumerable:!0,get:function(){return _index.booleanLiteral}}),Object.defineProperty(exports,"BooleanLiteralTypeAnnotation",{enumerable:!0,get:function(){return _index.booleanLiteralTypeAnnotation}}),Object.defineProperty(exports,"BooleanTypeAnnotation",{enumerable:!0,get:function(){return _index.booleanTypeAnnotation}}),Object.defineProperty(exports,"BreakStatement",{enumerable:!0,get:function(){return _index.breakStatement}}),Object.defineProperty(exports,"CallExpression",{enumerable:!0,get:function(){return _index.callExpression}}),Object.defineProperty(exports,"CatchClause",{enumerable:!0,get:function(){return _index.catchClause}}),Object.defineProperty(exports,"ClassBody",{enumerable:!0,get:function(){return _index.classBody}}),Object.defineProperty(exports,"ClassDeclaration",{enumerable:!0,get:function(){return _index.classDeclaration}}),Object.defineProperty(exports,"ClassExpression",{enumerable:!0,get:function(){return _index.classExpression}}),Object.defineProperty(exports,"ClassImplements",{enumerable:!0,get:function(){return _index.classImplements}}),Object.defineProperty(exports,"ClassMethod",{enumerable:!0,get:function(){return _index.classMethod}}),Object.defineProperty(exports,"ClassPrivateMethod",{enumerable:!0,get:function(){return _index.classPrivateMethod}}),Object.defineProperty(exports,"ClassPrivateProperty",{enumerable:!0,get:function(){return _index.classPrivateProperty}}),Object.defineProperty(exports,"ClassProperty",{enumerable:!0,get:function(){return _index.classProperty}}),Object.defineProperty(exports,"ConditionalExpression",{enumerable:!0,get:function(){return _index.conditionalExpression}}),Object.defineProperty(exports,"ContinueStatement",{enumerable:!0,get:function(){return _index.continueStatement}}),Object.defineProperty(exports,"DebuggerStatement",{enumerable:!0,get:function(){return _index.debuggerStatement}}),Object.defineProperty(exports,"DecimalLiteral",{enumerable:!0,get:function(){return _index.decimalLiteral}}),Object.defineProperty(exports,"DeclareClass",{enumerable:!0,get:function(){return _index.declareClass}}),Object.defineProperty(exports,"DeclareExportAllDeclaration",{enumerable:!0,get:function(){return _index.declareExportAllDeclaration}}),Object.defineProperty(exports,"DeclareExportDeclaration",{enumerable:!0,get:function(){return _index.declareExportDeclaration}}),Object.defineProperty(exports,"DeclareFunction",{enumerable:!0,get:function(){return _index.declareFunction}}),Object.defineProperty(exports,"DeclareInterface",{enumerable:!0,get:function(){return _index.declareInterface}}),Object.defineProperty(exports,"DeclareModule",{enumerable:!0,get:function(){return _index.declareModule}}),Object.defineProperty(exports,"DeclareModuleExports",{enumerable:!0,get:function(){return _index.declareModuleExports}}),Object.defineProperty(exports,"DeclareOpaqueType",{enumerable:!0,get:function(){return _index.declareOpaqueType}}),Object.defineProperty(exports,"DeclareTypeAlias",{enumerable:!0,get:function(){return _index.declareTypeAlias}}),Object.defineProperty(exports,"DeclareVariable",{enumerable:!0,get:function(){return _index.declareVariable}}),Object.defineProperty(exports,"DeclaredPredicate",{enumerable:!0,get:function(){return _index.declaredPredicate}}),Object.defineProperty(exports,"Decorator",{enumerable:!0,get:function(){return _index.decorator}}),Object.defineProperty(exports,"Directive",{enumerable:!0,get:function(){return _index.directive}}),Object.defineProperty(exports,"DirectiveLiteral",{enumerable:!0,get:function(){return _index.directiveLiteral}}),Object.defineProperty(exports,"DoExpression",{enumerable:!0,get:function(){return _index.doExpression}}),Object.defineProperty(exports,"DoWhileStatement",{enumerable:!0,get:function(){return _index.doWhileStatement}}),Object.defineProperty(exports,"EmptyStatement",{enumerable:!0,get:function(){return _index.emptyStatement}}),Object.defineProperty(exports,"EmptyTypeAnnotation",{enumerable:!0,get:function(){return _index.emptyTypeAnnotation}}),Object.defineProperty(exports,"EnumBooleanBody",{enumerable:!0,get:function(){return _index.enumBooleanBody}}),Object.defineProperty(exports,"EnumBooleanMember",{enumerable:!0,get:function(){return _index.enumBooleanMember}}),Object.defineProperty(exports,"EnumDeclaration",{enumerable:!0,get:function(){return _index.enumDeclaration}}),Object.defineProperty(exports,"EnumDefaultedMember",{enumerable:!0,get:function(){return _index.enumDefaultedMember}}),Object.defineProperty(exports,"EnumNumberBody",{enumerable:!0,get:function(){return _index.enumNumberBody}}),Object.defineProperty(exports,"EnumNumberMember",{enumerable:!0,get:function(){return _index.enumNumberMember}}),Object.defineProperty(exports,"EnumStringBody",{enumerable:!0,get:function(){return _index.enumStringBody}}),Object.defineProperty(exports,"EnumStringMember",{enumerable:!0,get:function(){return _index.enumStringMember}}),Object.defineProperty(exports,"EnumSymbolBody",{enumerable:!0,get:function(){return _index.enumSymbolBody}}),Object.defineProperty(exports,"ExistsTypeAnnotation",{enumerable:!0,get:function(){return _index.existsTypeAnnotation}}),Object.defineProperty(exports,"ExportAllDeclaration",{enumerable:!0,get:function(){return _index.exportAllDeclaration}}),Object.defineProperty(exports,"ExportDefaultDeclaration",{enumerable:!0,get:function(){return _index.exportDefaultDeclaration}}),Object.defineProperty(exports,"ExportDefaultSpecifier",{enumerable:!0,get:function(){return _index.exportDefaultSpecifier}}),Object.defineProperty(exports,"ExportNamedDeclaration",{enumerable:!0,get:function(){return _index.exportNamedDeclaration}}),Object.defineProperty(exports,"ExportNamespaceSpecifier",{enumerable:!0,get:function(){return _index.exportNamespaceSpecifier}}),Object.defineProperty(exports,"ExportSpecifier",{enumerable:!0,get:function(){return _index.exportSpecifier}}),Object.defineProperty(exports,"ExpressionStatement",{enumerable:!0,get:function(){return _index.expressionStatement}}),Object.defineProperty(exports,"File",{enumerable:!0,get:function(){return _index.file}}),Object.defineProperty(exports,"ForInStatement",{enumerable:!0,get:function(){return _index.forInStatement}}),Object.defineProperty(exports,"ForOfStatement",{enumerable:!0,get:function(){return _index.forOfStatement}}),Object.defineProperty(exports,"ForStatement",{enumerable:!0,get:function(){return _index.forStatement}}),Object.defineProperty(exports,"FunctionDeclaration",{enumerable:!0,get:function(){return _index.functionDeclaration}}),Object.defineProperty(exports,"FunctionExpression",{enumerable:!0,get:function(){return _index.functionExpression}}),Object.defineProperty(exports,"FunctionTypeAnnotation",{enumerable:!0,get:function(){return _index.functionTypeAnnotation}}),Object.defineProperty(exports,"FunctionTypeParam",{enumerable:!0,get:function(){return _index.functionTypeParam}}),Object.defineProperty(exports,"GenericTypeAnnotation",{enumerable:!0,get:function(){return _index.genericTypeAnnotation}}),Object.defineProperty(exports,"Identifier",{enumerable:!0,get:function(){return _index.identifier}}),Object.defineProperty(exports,"IfStatement",{enumerable:!0,get:function(){return _index.ifStatement}}),Object.defineProperty(exports,"Import",{enumerable:!0,get:function(){return _index.import}}),Object.defineProperty(exports,"ImportAttribute",{enumerable:!0,get:function(){return _index.importAttribute}}),Object.defineProperty(exports,"ImportDeclaration",{enumerable:!0,get:function(){return _index.importDeclaration}}),Object.defineProperty(exports,"ImportDefaultSpecifier",{enumerable:!0,get:function(){return _index.importDefaultSpecifier}}),Object.defineProperty(exports,"ImportNamespaceSpecifier",{enumerable:!0,get:function(){return _index.importNamespaceSpecifier}}),Object.defineProperty(exports,"ImportSpecifier",{enumerable:!0,get:function(){return _index.importSpecifier}}),Object.defineProperty(exports,"IndexedAccessType",{enumerable:!0,get:function(){return _index.indexedAccessType}}),Object.defineProperty(exports,"InferredPredicate",{enumerable:!0,get:function(){return _index.inferredPredicate}}),Object.defineProperty(exports,"InterfaceDeclaration",{enumerable:!0,get:function(){return _index.interfaceDeclaration}}),Object.defineProperty(exports,"InterfaceExtends",{enumerable:!0,get:function(){return _index.interfaceExtends}}),Object.defineProperty(exports,"InterfaceTypeAnnotation",{enumerable:!0,get:function(){return _index.interfaceTypeAnnotation}}),Object.defineProperty(exports,"InterpreterDirective",{enumerable:!0,get:function(){return _index.interpreterDirective}}),Object.defineProperty(exports,"IntersectionTypeAnnotation",{enumerable:!0,get:function(){return _index.intersectionTypeAnnotation}}),Object.defineProperty(exports,"JSXAttribute",{enumerable:!0,get:function(){return _index.jsxAttribute}}),Object.defineProperty(exports,"JSXClosingElement",{enumerable:!0,get:function(){return _index.jsxClosingElement}}),Object.defineProperty(exports,"JSXClosingFragment",{enumerable:!0,get:function(){return _index.jsxClosingFragment}}),Object.defineProperty(exports,"JSXElement",{enumerable:!0,get:function(){return _index.jsxElement}}),Object.defineProperty(exports,"JSXEmptyExpression",{enumerable:!0,get:function(){return _index.jsxEmptyExpression}}),Object.defineProperty(exports,"JSXExpressionContainer",{enumerable:!0,get:function(){return _index.jsxExpressionContainer}}),Object.defineProperty(exports,"JSXFragment",{enumerable:!0,get:function(){return _index.jsxFragment}}),Object.defineProperty(exports,"JSXIdentifier",{enumerable:!0,get:function(){return _index.jsxIdentifier}}),Object.defineProperty(exports,"JSXMemberExpression",{enumerable:!0,get:function(){return _index.jsxMemberExpression}}),Object.defineProperty(exports,"JSXNamespacedName",{enumerable:!0,get:function(){return _index.jsxNamespacedName}}),Object.defineProperty(exports,"JSXOpeningElement",{enumerable:!0,get:function(){return _index.jsxOpeningElement}}),Object.defineProperty(exports,"JSXOpeningFragment",{enumerable:!0,get:function(){return _index.jsxOpeningFragment}}),Object.defineProperty(exports,"JSXSpreadAttribute",{enumerable:!0,get:function(){return _index.jsxSpreadAttribute}}),Object.defineProperty(exports,"JSXSpreadChild",{enumerable:!0,get:function(){return _index.jsxSpreadChild}}),Object.defineProperty(exports,"JSXText",{enumerable:!0,get:function(){return _index.jsxText}}),Object.defineProperty(exports,"LabeledStatement",{enumerable:!0,get:function(){return _index.labeledStatement}}),Object.defineProperty(exports,"LogicalExpression",{enumerable:!0,get:function(){return _index.logicalExpression}}),Object.defineProperty(exports,"MemberExpression",{enumerable:!0,get:function(){return _index.memberExpression}}),Object.defineProperty(exports,"MetaProperty",{enumerable:!0,get:function(){return _index.metaProperty}}),Object.defineProperty(exports,"MixedTypeAnnotation",{enumerable:!0,get:function(){return _index.mixedTypeAnnotation}}),Object.defineProperty(exports,"ModuleExpression",{enumerable:!0,get:function(){return _index.moduleExpression}}),Object.defineProperty(exports,"NewExpression",{enumerable:!0,get:function(){return _index.newExpression}}),Object.defineProperty(exports,"Noop",{enumerable:!0,get:function(){return _index.noop}}),Object.defineProperty(exports,"NullLiteral",{enumerable:!0,get:function(){return _index.nullLiteral}}),Object.defineProperty(exports,"NullLiteralTypeAnnotation",{enumerable:!0,get:function(){return _index.nullLiteralTypeAnnotation}}),Object.defineProperty(exports,"NullableTypeAnnotation",{enumerable:!0,get:function(){return _index.nullableTypeAnnotation}}),Object.defineProperty(exports,"NumberLiteral",{enumerable:!0,get:function(){return _index.numberLiteral}}),Object.defineProperty(exports,"NumberLiteralTypeAnnotation",{enumerable:!0,get:function(){return _index.numberLiteralTypeAnnotation}}),Object.defineProperty(exports,"NumberTypeAnnotation",{enumerable:!0,get:function(){return _index.numberTypeAnnotation}}),Object.defineProperty(exports,"NumericLiteral",{enumerable:!0,get:function(){return _index.numericLiteral}}),Object.defineProperty(exports,"ObjectExpression",{enumerable:!0,get:function(){return _index.objectExpression}}),Object.defineProperty(exports,"ObjectMethod",{enumerable:!0,get:function(){return _index.objectMethod}}),Object.defineProperty(exports,"ObjectPattern",{enumerable:!0,get:function(){return _index.objectPattern}}),Object.defineProperty(exports,"ObjectProperty",{enumerable:!0,get:function(){return _index.objectProperty}}),Object.defineProperty(exports,"ObjectTypeAnnotation",{enumerable:!0,get:function(){return _index.objectTypeAnnotation}}),Object.defineProperty(exports,"ObjectTypeCallProperty",{enumerable:!0,get:function(){return _index.objectTypeCallProperty}}),Object.defineProperty(exports,"ObjectTypeIndexer",{enumerable:!0,get:function(){return _index.objectTypeIndexer}}),Object.defineProperty(exports,"ObjectTypeInternalSlot",{enumerable:!0,get:function(){return _index.objectTypeInternalSlot}}),Object.defineProperty(exports,"ObjectTypeProperty",{enumerable:!0,get:function(){return _index.objectTypeProperty}}),Object.defineProperty(exports,"ObjectTypeSpreadProperty",{enumerable:!0,get:function(){return _index.objectTypeSpreadProperty}}),Object.defineProperty(exports,"OpaqueType",{enumerable:!0,get:function(){return _index.opaqueType}}),Object.defineProperty(exports,"OptionalCallExpression",{enumerable:!0,get:function(){return _index.optionalCallExpression}}),Object.defineProperty(exports,"OptionalIndexedAccessType",{enumerable:!0,get:function(){return _index.optionalIndexedAccessType}}),Object.defineProperty(exports,"OptionalMemberExpression",{enumerable:!0,get:function(){return _index.optionalMemberExpression}}),Object.defineProperty(exports,"ParenthesizedExpression",{enumerable:!0,get:function(){return _index.parenthesizedExpression}}),Object.defineProperty(exports,"PipelineBareFunction",{enumerable:!0,get:function(){return _index.pipelineBareFunction}}),Object.defineProperty(exports,"PipelinePrimaryTopicReference",{enumerable:!0,get:function(){return _index.pipelinePrimaryTopicReference}}),Object.defineProperty(exports,"PipelineTopicExpression",{enumerable:!0,get:function(){return _index.pipelineTopicExpression}}),Object.defineProperty(exports,"Placeholder",{enumerable:!0,get:function(){return _index.placeholder}}),Object.defineProperty(exports,"PrivateName",{enumerable:!0,get:function(){return _index.privateName}}),Object.defineProperty(exports,"Program",{enumerable:!0,get:function(){return _index.program}}),Object.defineProperty(exports,"QualifiedTypeIdentifier",{enumerable:!0,get:function(){return _index.qualifiedTypeIdentifier}}),Object.defineProperty(exports,"RecordExpression",{enumerable:!0,get:function(){return _index.recordExpression}}),Object.defineProperty(exports,"RegExpLiteral",{enumerable:!0,get:function(){return _index.regExpLiteral}}),Object.defineProperty(exports,"RegexLiteral",{enumerable:!0,get:function(){return _index.regexLiteral}}),Object.defineProperty(exports,"RestElement",{enumerable:!0,get:function(){return _index.restElement}}),Object.defineProperty(exports,"RestProperty",{enumerable:!0,get:function(){return _index.restProperty}}),Object.defineProperty(exports,"ReturnStatement",{enumerable:!0,get:function(){return _index.returnStatement}}),Object.defineProperty(exports,"SequenceExpression",{enumerable:!0,get:function(){return _index.sequenceExpression}}),Object.defineProperty(exports,"SpreadElement",{enumerable:!0,get:function(){return _index.spreadElement}}),Object.defineProperty(exports,"SpreadProperty",{enumerable:!0,get:function(){return _index.spreadProperty}}),Object.defineProperty(exports,"StaticBlock",{enumerable:!0,get:function(){return _index.staticBlock}}),Object.defineProperty(exports,"StringLiteral",{enumerable:!0,get:function(){return _index.stringLiteral}}),Object.defineProperty(exports,"StringLiteralTypeAnnotation",{enumerable:!0,get:function(){return _index.stringLiteralTypeAnnotation}}),Object.defineProperty(exports,"StringTypeAnnotation",{enumerable:!0,get:function(){return _index.stringTypeAnnotation}}),Object.defineProperty(exports,"Super",{enumerable:!0,get:function(){return _index.super}}),Object.defineProperty(exports,"SwitchCase",{enumerable:!0,get:function(){return _index.switchCase}}),Object.defineProperty(exports,"SwitchStatement",{enumerable:!0,get:function(){return _index.switchStatement}}),Object.defineProperty(exports,"SymbolTypeAnnotation",{enumerable:!0,get:function(){return _index.symbolTypeAnnotation}}),Object.defineProperty(exports,"TSAnyKeyword",{enumerable:!0,get:function(){return _index.tsAnyKeyword}}),Object.defineProperty(exports,"TSArrayType",{enumerable:!0,get:function(){return _index.tsArrayType}}),Object.defineProperty(exports,"TSAsExpression",{enumerable:!0,get:function(){return _index.tsAsExpression}}),Object.defineProperty(exports,"TSBigIntKeyword",{enumerable:!0,get:function(){return _index.tsBigIntKeyword}}),Object.defineProperty(exports,"TSBooleanKeyword",{enumerable:!0,get:function(){return _index.tsBooleanKeyword}}),Object.defineProperty(exports,"TSCallSignatureDeclaration",{enumerable:!0,get:function(){return _index.tsCallSignatureDeclaration}}),Object.defineProperty(exports,"TSConditionalType",{enumerable:!0,get:function(){return _index.tsConditionalType}}),Object.defineProperty(exports,"TSConstructSignatureDeclaration",{enumerable:!0,get:function(){return _index.tsConstructSignatureDeclaration}}),Object.defineProperty(exports,"TSConstructorType",{enumerable:!0,get:function(){return _index.tsConstructorType}}),Object.defineProperty(exports,"TSDeclareFunction",{enumerable:!0,get:function(){return _index.tsDeclareFunction}}),Object.defineProperty(exports,"TSDeclareMethod",{enumerable:!0,get:function(){return _index.tsDeclareMethod}}),Object.defineProperty(exports,"TSEnumDeclaration",{enumerable:!0,get:function(){return _index.tsEnumDeclaration}}),Object.defineProperty(exports,"TSEnumMember",{enumerable:!0,get:function(){return _index.tsEnumMember}}),Object.defineProperty(exports,"TSExportAssignment",{enumerable:!0,get:function(){return _index.tsExportAssignment}}),Object.defineProperty(exports,"TSExpressionWithTypeArguments",{enumerable:!0,get:function(){return _index.tsExpressionWithTypeArguments}}),Object.defineProperty(exports,"TSExternalModuleReference",{enumerable:!0,get:function(){return _index.tsExternalModuleReference}}),Object.defineProperty(exports,"TSFunctionType",{enumerable:!0,get:function(){return _index.tsFunctionType}}),Object.defineProperty(exports,"TSImportEqualsDeclaration",{enumerable:!0,get:function(){return _index.tsImportEqualsDeclaration}}),Object.defineProperty(exports,"TSImportType",{enumerable:!0,get:function(){return _index.tsImportType}}),Object.defineProperty(exports,"TSIndexSignature",{enumerable:!0,get:function(){return _index.tsIndexSignature}}),Object.defineProperty(exports,"TSIndexedAccessType",{enumerable:!0,get:function(){return _index.tsIndexedAccessType}}),Object.defineProperty(exports,"TSInferType",{enumerable:!0,get:function(){return _index.tsInferType}}),Object.defineProperty(exports,"TSInterfaceBody",{enumerable:!0,get:function(){return _index.tsInterfaceBody}}),Object.defineProperty(exports,"TSInterfaceDeclaration",{enumerable:!0,get:function(){return _index.tsInterfaceDeclaration}}),Object.defineProperty(exports,"TSIntersectionType",{enumerable:!0,get:function(){return _index.tsIntersectionType}}),Object.defineProperty(exports,"TSIntrinsicKeyword",{enumerable:!0,get:function(){return _index.tsIntrinsicKeyword}}),Object.defineProperty(exports,"TSLiteralType",{enumerable:!0,get:function(){return _index.tsLiteralType}}),Object.defineProperty(exports,"TSMappedType",{enumerable:!0,get:function(){return _index.tsMappedType}}),Object.defineProperty(exports,"TSMethodSignature",{enumerable:!0,get:function(){return _index.tsMethodSignature}}),Object.defineProperty(exports,"TSModuleBlock",{enumerable:!0,get:function(){return _index.tsModuleBlock}}),Object.defineProperty(exports,"TSModuleDeclaration",{enumerable:!0,get:function(){return _index.tsModuleDeclaration}}),Object.defineProperty(exports,"TSNamedTupleMember",{enumerable:!0,get:function(){return _index.tsNamedTupleMember}}),Object.defineProperty(exports,"TSNamespaceExportDeclaration",{enumerable:!0,get:function(){return _index.tsNamespaceExportDeclaration}}),Object.defineProperty(exports,"TSNeverKeyword",{enumerable:!0,get:function(){return _index.tsNeverKeyword}}),Object.defineProperty(exports,"TSNonNullExpression",{enumerable:!0,get:function(){return _index.tsNonNullExpression}}),Object.defineProperty(exports,"TSNullKeyword",{enumerable:!0,get:function(){return _index.tsNullKeyword}}),Object.defineProperty(exports,"TSNumberKeyword",{enumerable:!0,get:function(){return _index.tsNumberKeyword}}),Object.defineProperty(exports,"TSObjectKeyword",{enumerable:!0,get:function(){return _index.tsObjectKeyword}}),Object.defineProperty(exports,"TSOptionalType",{enumerable:!0,get:function(){return _index.tsOptionalType}}),Object.defineProperty(exports,"TSParameterProperty",{enumerable:!0,get:function(){return _index.tsParameterProperty}}),Object.defineProperty(exports,"TSParenthesizedType",{enumerable:!0,get:function(){return _index.tsParenthesizedType}}),Object.defineProperty(exports,"TSPropertySignature",{enumerable:!0,get:function(){return _index.tsPropertySignature}}),Object.defineProperty(exports,"TSQualifiedName",{enumerable:!0,get:function(){return _index.tsQualifiedName}}),Object.defineProperty(exports,"TSRestType",{enumerable:!0,get:function(){return _index.tsRestType}}),Object.defineProperty(exports,"TSStringKeyword",{enumerable:!0,get:function(){return _index.tsStringKeyword}}),Object.defineProperty(exports,"TSSymbolKeyword",{enumerable:!0,get:function(){return _index.tsSymbolKeyword}}),Object.defineProperty(exports,"TSThisType",{enumerable:!0,get:function(){return _index.tsThisType}}),Object.defineProperty(exports,"TSTupleType",{enumerable:!0,get:function(){return _index.tsTupleType}}),Object.defineProperty(exports,"TSTypeAliasDeclaration",{enumerable:!0,get:function(){return _index.tsTypeAliasDeclaration}}),Object.defineProperty(exports,"TSTypeAnnotation",{enumerable:!0,get:function(){return _index.tsTypeAnnotation}}),Object.defineProperty(exports,"TSTypeAssertion",{enumerable:!0,get:function(){return _index.tsTypeAssertion}}),Object.defineProperty(exports,"TSTypeLiteral",{enumerable:!0,get:function(){return _index.tsTypeLiteral}}),Object.defineProperty(exports,"TSTypeOperator",{enumerable:!0,get:function(){return _index.tsTypeOperator}}),Object.defineProperty(exports,"TSTypeParameter",{enumerable:!0,get:function(){return _index.tsTypeParameter}}),Object.defineProperty(exports,"TSTypeParameterDeclaration",{enumerable:!0,get:function(){return _index.tsTypeParameterDeclaration}}),Object.defineProperty(exports,"TSTypeParameterInstantiation",{enumerable:!0,get:function(){return _index.tsTypeParameterInstantiation}}),Object.defineProperty(exports,"TSTypePredicate",{enumerable:!0,get:function(){return _index.tsTypePredicate}}),Object.defineProperty(exports,"TSTypeQuery",{enumerable:!0,get:function(){return _index.tsTypeQuery}}),Object.defineProperty(exports,"TSTypeReference",{enumerable:!0,get:function(){return _index.tsTypeReference}}),Object.defineProperty(exports,"TSUndefinedKeyword",{enumerable:!0,get:function(){return _index.tsUndefinedKeyword}}),Object.defineProperty(exports,"TSUnionType",{enumerable:!0,get:function(){return _index.tsUnionType}}),Object.defineProperty(exports,"TSUnknownKeyword",{enumerable:!0,get:function(){return _index.tsUnknownKeyword}}),Object.defineProperty(exports,"TSVoidKeyword",{enumerable:!0,get:function(){return _index.tsVoidKeyword}}),Object.defineProperty(exports,"TaggedTemplateExpression",{enumerable:!0,get:function(){return _index.taggedTemplateExpression}}),Object.defineProperty(exports,"TemplateElement",{enumerable:!0,get:function(){return _index.templateElement}}),Object.defineProperty(exports,"TemplateLiteral",{enumerable:!0,get:function(){return _index.templateLiteral}}),Object.defineProperty(exports,"ThisExpression",{enumerable:!0,get:function(){return _index.thisExpression}}),Object.defineProperty(exports,"ThisTypeAnnotation",{enumerable:!0,get:function(){return _index.thisTypeAnnotation}}),Object.defineProperty(exports,"ThrowStatement",{enumerable:!0,get:function(){return _index.throwStatement}}),Object.defineProperty(exports,"TopicReference",{enumerable:!0,get:function(){return _index.topicReference}}),Object.defineProperty(exports,"TryStatement",{enumerable:!0,get:function(){return _index.tryStatement}}),Object.defineProperty(exports,"TupleExpression",{enumerable:!0,get:function(){return _index.tupleExpression}}),Object.defineProperty(exports,"TupleTypeAnnotation",{enumerable:!0,get:function(){return _index.tupleTypeAnnotation}}),Object.defineProperty(exports,"TypeAlias",{enumerable:!0,get:function(){return _index.typeAlias}}),Object.defineProperty(exports,"TypeAnnotation",{enumerable:!0,get:function(){return _index.typeAnnotation}}),Object.defineProperty(exports,"TypeCastExpression",{enumerable:!0,get:function(){return _index.typeCastExpression}}),Object.defineProperty(exports,"TypeParameter",{enumerable:!0,get:function(){return _index.typeParameter}}),Object.defineProperty(exports,"TypeParameterDeclaration",{enumerable:!0,get:function(){return _index.typeParameterDeclaration}}),Object.defineProperty(exports,"TypeParameterInstantiation",{enumerable:!0,get:function(){return _index.typeParameterInstantiation}}),Object.defineProperty(exports,"TypeofTypeAnnotation",{enumerable:!0,get:function(){return _index.typeofTypeAnnotation}}),Object.defineProperty(exports,"UnaryExpression",{enumerable:!0,get:function(){return _index.unaryExpression}}),Object.defineProperty(exports,"UnionTypeAnnotation",{enumerable:!0,get:function(){return _index.unionTypeAnnotation}}),Object.defineProperty(exports,"UpdateExpression",{enumerable:!0,get:function(){return _index.updateExpression}}),Object.defineProperty(exports,"V8IntrinsicIdentifier",{enumerable:!0,get:function(){return _index.v8IntrinsicIdentifier}}),Object.defineProperty(exports,"VariableDeclaration",{enumerable:!0,get:function(){return _index.variableDeclaration}}),Object.defineProperty(exports,"VariableDeclarator",{enumerable:!0,get:function(){return _index.variableDeclarator}}),Object.defineProperty(exports,"Variance",{enumerable:!0,get:function(){return _index.variance}}),Object.defineProperty(exports,"VoidTypeAnnotation",{enumerable:!0,get:function(){return _index.voidTypeAnnotation}}),Object.defineProperty(exports,"WhileStatement",{enumerable:!0,get:function(){return _index.whileStatement}}),Object.defineProperty(exports,"WithStatement",{enumerable:!0,get:function(){return _index.withStatement}}),Object.defineProperty(exports,"YieldExpression",{enumerable:!0,get:function(){return _index.yieldExpression}});var _index=__webpack_require__("./node_modules/@babel/types/lib/builders/generated/index.js");},"./node_modules/@babel/types/lib/builders/react/buildChildren.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node){const elements=[];for(let i=0;i<node.children.length;i++){let child=node.children[i];(0, _generated.isJSXText)(child)?(0, _cleanJSXElementLiteralChild.default)(child,elements):((0, _generated.isJSXExpressionContainer)(child)&&(child=child.expression),(0, _generated.isJSXEmptyExpression)(child)||elements.push(child));}return elements};var _generated=__webpack_require__("./node_modules/@babel/types/lib/validators/generated/index.js"),_cleanJSXElementLiteralChild=__webpack_require__("./node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js");},"./node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(typeAnnotations){const types=typeAnnotations.map((type=>type.typeAnnotation)),flattened=(0, _removeTypeDuplicates.default)(types);return 1===flattened.length?flattened[0]:(0, _generated.tsUnionType)(flattened)};var _generated=__webpack_require__("./node_modules/@babel/types/lib/builders/generated/index.js"),_removeTypeDuplicates=__webpack_require__("./node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js");},"./node_modules/@babel/types/lib/clone/clone.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node){return (0, _cloneNode.default)(node,!1)};var _cloneNode=__webpack_require__("./node_modules/@babel/types/lib/clone/cloneNode.js");},"./node_modules/@babel/types/lib/clone/cloneDeep.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node){return (0, _cloneNode.default)(node)};var _cloneNode=__webpack_require__("./node_modules/@babel/types/lib/clone/cloneNode.js");},"./node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node){return (0, _cloneNode.default)(node,!0,!0)};var _cloneNode=__webpack_require__("./node_modules/@babel/types/lib/clone/cloneNode.js");},"./node_modules/@babel/types/lib/clone/cloneNode.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=cloneNode;var _definitions=__webpack_require__("./node_modules/@babel/types/lib/definitions/index.js"),_generated=__webpack_require__("./node_modules/@babel/types/lib/validators/generated/index.js");const has=Function.call.bind(Object.prototype.hasOwnProperty);function cloneIfNode(obj,deep,withoutLoc){return obj&&"string"==typeof obj.type?cloneNode(obj,deep,withoutLoc):obj}function cloneIfNodeOrArray(obj,deep,withoutLoc){return Array.isArray(obj)?obj.map((node=>cloneIfNode(node,deep,withoutLoc))):cloneIfNode(obj,deep,withoutLoc)}function cloneNode(node,deep=!0,withoutLoc=!1){if(!node)return node;const{type}=node,newNode={type:node.type};if((0, _generated.isIdentifier)(node))newNode.name=node.name,has(node,"optional")&&"boolean"==typeof node.optional&&(newNode.optional=node.optional),has(node,"typeAnnotation")&&(newNode.typeAnnotation=deep?cloneIfNodeOrArray(node.typeAnnotation,!0,withoutLoc):node.typeAnnotation);else {if(!has(_definitions.NODE_FIELDS,type))throw new Error(`Unknown node type: "${type}"`);for(const field of Object.keys(_definitions.NODE_FIELDS[type]))has(node,field)&&(newNode[field]=deep?(0, _generated.isFile)(node)&&"comments"===field?maybeCloneComments(node.comments,deep,withoutLoc):cloneIfNodeOrArray(node[field],!0,withoutLoc):node[field]);}return has(node,"loc")&&(newNode.loc=withoutLoc?null:node.loc),has(node,"leadingComments")&&(newNode.leadingComments=maybeCloneComments(node.leadingComments,deep,withoutLoc)),has(node,"innerComments")&&(newNode.innerComments=maybeCloneComments(node.innerComments,deep,withoutLoc)),has(node,"trailingComments")&&(newNode.trailingComments=maybeCloneComments(node.trailingComments,deep,withoutLoc)),has(node,"extra")&&(newNode.extra=Object.assign({},node.extra)),newNode}function maybeCloneComments(comments,deep,withoutLoc){return comments&&deep?comments.map((({type,value,loc})=>withoutLoc?{type,value,loc:null}:{type,value,loc})):comments}},"./node_modules/@babel/types/lib/clone/cloneWithoutLoc.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node){return (0, _cloneNode.default)(node,!1,!0)};var _cloneNode=__webpack_require__("./node_modules/@babel/types/lib/clone/cloneNode.js");},"./node_modules/@babel/types/lib/comments/addComment.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node,type,content,line){return (0, _addComments.default)(node,type,[{type:line?"CommentLine":"CommentBlock",value:content}])};var _addComments=__webpack_require__("./node_modules/@babel/types/lib/comments/addComments.js");},"./node_modules/@babel/types/lib/comments/addComments.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node,type,comments){if(!comments||!node)return node;const key=`${type}Comments`;node[key]?"leading"===type?node[key]=comments.concat(node[key]):node[key].push(...comments):node[key]=comments;return node};},"./node_modules/@babel/types/lib/comments/inheritInnerComments.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(child,parent){(0, _inherit.default)("innerComments",child,parent);};var _inherit=__webpack_require__("./node_modules/@babel/types/lib/utils/inherit.js");},"./node_modules/@babel/types/lib/comments/inheritLeadingComments.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(child,parent){(0, _inherit.default)("leadingComments",child,parent);};var _inherit=__webpack_require__("./node_modules/@babel/types/lib/utils/inherit.js");},"./node_modules/@babel/types/lib/comments/inheritTrailingComments.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(child,parent){(0, _inherit.default)("trailingComments",child,parent);};var _inherit=__webpack_require__("./node_modules/@babel/types/lib/utils/inherit.js");},"./node_modules/@babel/types/lib/comments/inheritsComments.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(child,parent){return (0, _inheritTrailingComments.default)(child,parent),(0, _inheritLeadingComments.default)(child,parent),(0, _inheritInnerComments.default)(child,parent),child};var _inheritTrailingComments=__webpack_require__("./node_modules/@babel/types/lib/comments/inheritTrailingComments.js"),_inheritLeadingComments=__webpack_require__("./node_modules/@babel/types/lib/comments/inheritLeadingComments.js"),_inheritInnerComments=__webpack_require__("./node_modules/@babel/types/lib/comments/inheritInnerComments.js");},"./node_modules/@babel/types/lib/comments/removeComments.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node){return _constants.COMMENT_KEYS.forEach((key=>{node[key]=null;})),node};var _constants=__webpack_require__("./node_modules/@babel/types/lib/constants/index.js");},"./node_modules/@babel/types/lib/constants/generated/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.WHILE_TYPES=exports.USERWHITESPACABLE_TYPES=exports.UNARYLIKE_TYPES=exports.TYPESCRIPT_TYPES=exports.TSTYPE_TYPES=exports.TSTYPEELEMENT_TYPES=exports.TSENTITYNAME_TYPES=exports.TSBASETYPE_TYPES=exports.TERMINATORLESS_TYPES=exports.STATEMENT_TYPES=exports.STANDARDIZED_TYPES=exports.SCOPABLE_TYPES=exports.PUREISH_TYPES=exports.PROPERTY_TYPES=exports.PRIVATE_TYPES=exports.PATTERN_TYPES=exports.PATTERNLIKE_TYPES=exports.OBJECTMEMBER_TYPES=exports.MODULESPECIFIER_TYPES=exports.MODULEDECLARATION_TYPES=exports.MISCELLANEOUS_TYPES=exports.METHOD_TYPES=exports.LVAL_TYPES=exports.LOOP_TYPES=exports.LITERAL_TYPES=exports.JSX_TYPES=exports.IMMUTABLE_TYPES=exports.FUNCTION_TYPES=exports.FUNCTIONPARENT_TYPES=exports.FOR_TYPES=exports.FORXSTATEMENT_TYPES=exports.FLOW_TYPES=exports.FLOWTYPE_TYPES=exports.FLOWPREDICATE_TYPES=exports.FLOWDECLARATION_TYPES=exports.FLOWBASEANNOTATION_TYPES=exports.EXPRESSION_TYPES=exports.EXPRESSIONWRAPPER_TYPES=exports.EXPORTDECLARATION_TYPES=exports.ENUMMEMBER_TYPES=exports.ENUMBODY_TYPES=exports.DECLARATION_TYPES=exports.CONDITIONAL_TYPES=exports.COMPLETIONSTATEMENT_TYPES=exports.CLASS_TYPES=exports.BLOCK_TYPES=exports.BLOCKPARENT_TYPES=exports.BINARY_TYPES=void 0;var _definitions=__webpack_require__("./node_modules/@babel/types/lib/definitions/index.js");const STANDARDIZED_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Standardized;exports.STANDARDIZED_TYPES=STANDARDIZED_TYPES;const EXPRESSION_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Expression;exports.EXPRESSION_TYPES=EXPRESSION_TYPES;const BINARY_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Binary;exports.BINARY_TYPES=BINARY_TYPES;const SCOPABLE_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Scopable;exports.SCOPABLE_TYPES=SCOPABLE_TYPES;const BLOCKPARENT_TYPES=_definitions.FLIPPED_ALIAS_KEYS.BlockParent;exports.BLOCKPARENT_TYPES=BLOCKPARENT_TYPES;const BLOCK_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Block;exports.BLOCK_TYPES=BLOCK_TYPES;const STATEMENT_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Statement;exports.STATEMENT_TYPES=STATEMENT_TYPES;const TERMINATORLESS_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Terminatorless;exports.TERMINATORLESS_TYPES=TERMINATORLESS_TYPES;const COMPLETIONSTATEMENT_TYPES=_definitions.FLIPPED_ALIAS_KEYS.CompletionStatement;exports.COMPLETIONSTATEMENT_TYPES=COMPLETIONSTATEMENT_TYPES;const CONDITIONAL_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Conditional;exports.CONDITIONAL_TYPES=CONDITIONAL_TYPES;const LOOP_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Loop;exports.LOOP_TYPES=LOOP_TYPES;const WHILE_TYPES=_definitions.FLIPPED_ALIAS_KEYS.While;exports.WHILE_TYPES=WHILE_TYPES;const EXPRESSIONWRAPPER_TYPES=_definitions.FLIPPED_ALIAS_KEYS.ExpressionWrapper;exports.EXPRESSIONWRAPPER_TYPES=EXPRESSIONWRAPPER_TYPES;const FOR_TYPES=_definitions.FLIPPED_ALIAS_KEYS.For;exports.FOR_TYPES=FOR_TYPES;const FORXSTATEMENT_TYPES=_definitions.FLIPPED_ALIAS_KEYS.ForXStatement;exports.FORXSTATEMENT_TYPES=FORXSTATEMENT_TYPES;const FUNCTION_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Function;exports.FUNCTION_TYPES=FUNCTION_TYPES;const FUNCTIONPARENT_TYPES=_definitions.FLIPPED_ALIAS_KEYS.FunctionParent;exports.FUNCTIONPARENT_TYPES=FUNCTIONPARENT_TYPES;const PUREISH_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Pureish;exports.PUREISH_TYPES=PUREISH_TYPES;const DECLARATION_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Declaration;exports.DECLARATION_TYPES=DECLARATION_TYPES;const PATTERNLIKE_TYPES=_definitions.FLIPPED_ALIAS_KEYS.PatternLike;exports.PATTERNLIKE_TYPES=PATTERNLIKE_TYPES;const LVAL_TYPES=_definitions.FLIPPED_ALIAS_KEYS.LVal;exports.LVAL_TYPES=LVAL_TYPES;const TSENTITYNAME_TYPES=_definitions.FLIPPED_ALIAS_KEYS.TSEntityName;exports.TSENTITYNAME_TYPES=TSENTITYNAME_TYPES;const LITERAL_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Literal;exports.LITERAL_TYPES=LITERAL_TYPES;const IMMUTABLE_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Immutable;exports.IMMUTABLE_TYPES=IMMUTABLE_TYPES;const USERWHITESPACABLE_TYPES=_definitions.FLIPPED_ALIAS_KEYS.UserWhitespacable;exports.USERWHITESPACABLE_TYPES=USERWHITESPACABLE_TYPES;const METHOD_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Method;exports.METHOD_TYPES=METHOD_TYPES;const OBJECTMEMBER_TYPES=_definitions.FLIPPED_ALIAS_KEYS.ObjectMember;exports.OBJECTMEMBER_TYPES=OBJECTMEMBER_TYPES;const PROPERTY_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Property;exports.PROPERTY_TYPES=PROPERTY_TYPES;const UNARYLIKE_TYPES=_definitions.FLIPPED_ALIAS_KEYS.UnaryLike;exports.UNARYLIKE_TYPES=UNARYLIKE_TYPES;const PATTERN_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Pattern;exports.PATTERN_TYPES=PATTERN_TYPES;const CLASS_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Class;exports.CLASS_TYPES=CLASS_TYPES;const MODULEDECLARATION_TYPES=_definitions.FLIPPED_ALIAS_KEYS.ModuleDeclaration;exports.MODULEDECLARATION_TYPES=MODULEDECLARATION_TYPES;const EXPORTDECLARATION_TYPES=_definitions.FLIPPED_ALIAS_KEYS.ExportDeclaration;exports.EXPORTDECLARATION_TYPES=EXPORTDECLARATION_TYPES;const MODULESPECIFIER_TYPES=_definitions.FLIPPED_ALIAS_KEYS.ModuleSpecifier;exports.MODULESPECIFIER_TYPES=MODULESPECIFIER_TYPES;const PRIVATE_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Private;exports.PRIVATE_TYPES=PRIVATE_TYPES;const FLOW_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Flow;exports.FLOW_TYPES=FLOW_TYPES;const FLOWTYPE_TYPES=_definitions.FLIPPED_ALIAS_KEYS.FlowType;exports.FLOWTYPE_TYPES=FLOWTYPE_TYPES;const FLOWBASEANNOTATION_TYPES=_definitions.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;exports.FLOWBASEANNOTATION_TYPES=FLOWBASEANNOTATION_TYPES;const FLOWDECLARATION_TYPES=_definitions.FLIPPED_ALIAS_KEYS.FlowDeclaration;exports.FLOWDECLARATION_TYPES=FLOWDECLARATION_TYPES;const FLOWPREDICATE_TYPES=_definitions.FLIPPED_ALIAS_KEYS.FlowPredicate;exports.FLOWPREDICATE_TYPES=FLOWPREDICATE_TYPES;const ENUMBODY_TYPES=_definitions.FLIPPED_ALIAS_KEYS.EnumBody;exports.ENUMBODY_TYPES=ENUMBODY_TYPES;const ENUMMEMBER_TYPES=_definitions.FLIPPED_ALIAS_KEYS.EnumMember;exports.ENUMMEMBER_TYPES=ENUMMEMBER_TYPES;const JSX_TYPES=_definitions.FLIPPED_ALIAS_KEYS.JSX;exports.JSX_TYPES=JSX_TYPES;const MISCELLANEOUS_TYPES=_definitions.FLIPPED_ALIAS_KEYS.Miscellaneous;exports.MISCELLANEOUS_TYPES=MISCELLANEOUS_TYPES;const TYPESCRIPT_TYPES=_definitions.FLIPPED_ALIAS_KEYS.TypeScript;exports.TYPESCRIPT_TYPES=TYPESCRIPT_TYPES;const TSTYPEELEMENT_TYPES=_definitions.FLIPPED_ALIAS_KEYS.TSTypeElement;exports.TSTYPEELEMENT_TYPES=TSTYPEELEMENT_TYPES;const TSTYPE_TYPES=_definitions.FLIPPED_ALIAS_KEYS.TSType;exports.TSTYPE_TYPES=TSTYPE_TYPES;const TSBASETYPE_TYPES=_definitions.FLIPPED_ALIAS_KEYS.TSBaseType;exports.TSBASETYPE_TYPES=TSBASETYPE_TYPES;},"./node_modules/@babel/types/lib/constants/index.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.UPDATE_OPERATORS=exports.UNARY_OPERATORS=exports.STRING_UNARY_OPERATORS=exports.STATEMENT_OR_BLOCK_KEYS=exports.NUMBER_UNARY_OPERATORS=exports.NUMBER_BINARY_OPERATORS=exports.NOT_LOCAL_BINDING=exports.LOGICAL_OPERATORS=exports.INHERIT_KEYS=exports.FOR_INIT_KEYS=exports.FLATTENABLE_KEYS=exports.EQUALITY_BINARY_OPERATORS=exports.COMPARISON_BINARY_OPERATORS=exports.COMMENT_KEYS=exports.BOOLEAN_UNARY_OPERATORS=exports.BOOLEAN_NUMBER_BINARY_OPERATORS=exports.BOOLEAN_BINARY_OPERATORS=exports.BLOCK_SCOPED_SYMBOL=exports.BINARY_OPERATORS=exports.ASSIGNMENT_OPERATORS=void 0;exports.STATEMENT_OR_BLOCK_KEYS=["consequent","body","alternate"];exports.FLATTENABLE_KEYS=["body","expressions"];exports.FOR_INIT_KEYS=["left","init"];exports.COMMENT_KEYS=["leadingComments","trailingComments","innerComments"];const LOGICAL_OPERATORS=["||","&&","??"];exports.LOGICAL_OPERATORS=LOGICAL_OPERATORS;exports.UPDATE_OPERATORS=["++","--"];const BOOLEAN_NUMBER_BINARY_OPERATORS=[">","<",">=","<="];exports.BOOLEAN_NUMBER_BINARY_OPERATORS=BOOLEAN_NUMBER_BINARY_OPERATORS;const EQUALITY_BINARY_OPERATORS=["==","===","!=","!=="];exports.EQUALITY_BINARY_OPERATORS=EQUALITY_BINARY_OPERATORS;const COMPARISON_BINARY_OPERATORS=[...EQUALITY_BINARY_OPERATORS,"in","instanceof"];exports.COMPARISON_BINARY_OPERATORS=COMPARISON_BINARY_OPERATORS;const BOOLEAN_BINARY_OPERATORS=[...COMPARISON_BINARY_OPERATORS,...BOOLEAN_NUMBER_BINARY_OPERATORS];exports.BOOLEAN_BINARY_OPERATORS=BOOLEAN_BINARY_OPERATORS;const NUMBER_BINARY_OPERATORS=["-","/","%","*","**","&","|",">>",">>>","<<","^"];exports.NUMBER_BINARY_OPERATORS=NUMBER_BINARY_OPERATORS;const BINARY_OPERATORS=["+",...NUMBER_BINARY_OPERATORS,...BOOLEAN_BINARY_OPERATORS];exports.BINARY_OPERATORS=BINARY_OPERATORS;const ASSIGNMENT_OPERATORS=["=","+=",...NUMBER_BINARY_OPERATORS.map((op=>op+"=")),...LOGICAL_OPERATORS.map((op=>op+"="))];exports.ASSIGNMENT_OPERATORS=ASSIGNMENT_OPERATORS;const BOOLEAN_UNARY_OPERATORS=["delete","!"];exports.BOOLEAN_UNARY_OPERATORS=BOOLEAN_UNARY_OPERATORS;const NUMBER_UNARY_OPERATORS=["+","-","~"];exports.NUMBER_UNARY_OPERATORS=NUMBER_UNARY_OPERATORS;const STRING_UNARY_OPERATORS=["typeof"];exports.STRING_UNARY_OPERATORS=STRING_UNARY_OPERATORS;const UNARY_OPERATORS=["void","throw",...BOOLEAN_UNARY_OPERATORS,...NUMBER_UNARY_OPERATORS,...STRING_UNARY_OPERATORS];exports.UNARY_OPERATORS=UNARY_OPERATORS;exports.INHERIT_KEYS={optional:["typeAnnotation","typeParameters","returnType"],force:["start","loc","end"]};const BLOCK_SCOPED_SYMBOL=Symbol.for("var used to be block scoped");exports.BLOCK_SCOPED_SYMBOL=BLOCK_SCOPED_SYMBOL;const NOT_LOCAL_BINDING=Symbol.for("should not be considered a local binding");exports.NOT_LOCAL_BINDING=NOT_LOCAL_BINDING;},"./node_modules/@babel/types/lib/converters/ensureBlock.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node,key="body"){return node[key]=(0, _toBlock.default)(node[key],node)};var _toBlock=__webpack_require__("./node_modules/@babel/types/lib/converters/toBlock.js");},"./node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function gatherSequenceExpressions(nodes,scope,declars){const exprs=[];let ensureLastUndefined=!0;for(const node of nodes)if((0, _generated.isEmptyStatement)(node)||(ensureLastUndefined=!1),(0, _generated.isExpression)(node))exprs.push(node);else if((0, _generated.isExpressionStatement)(node))exprs.push(node.expression);else if((0, _generated.isVariableDeclaration)(node)){if("var"!==node.kind)return;for(const declar of node.declarations){const bindings=(0, _getBindingIdentifiers.default)(declar);for(const key of Object.keys(bindings))declars.push({kind:node.kind,id:(0, _cloneNode.default)(bindings[key])});declar.init&&exprs.push((0, _generated2.assignmentExpression)("=",declar.id,declar.init));}ensureLastUndefined=!0;}else if((0, _generated.isIfStatement)(node)){const consequent=node.consequent?gatherSequenceExpressions([node.consequent],scope,declars):scope.buildUndefinedNode(),alternate=node.alternate?gatherSequenceExpressions([node.alternate],scope,declars):scope.buildUndefinedNode();if(!consequent||!alternate)return;exprs.push((0, _generated2.conditionalExpression)(node.test,consequent,alternate));}else if((0, _generated.isBlockStatement)(node)){const body=gatherSequenceExpressions(node.body,scope,declars);if(!body)return;exprs.push(body);}else {if(!(0, _generated.isEmptyStatement)(node))return;0===nodes.indexOf(node)&&(ensureLastUndefined=!0);}ensureLastUndefined&&exprs.push(scope.buildUndefinedNode());return 1===exprs.length?exprs[0]:(0, _generated2.sequenceExpression)(exprs)};var _getBindingIdentifiers=__webpack_require__("./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"),_generated=__webpack_require__("./node_modules/@babel/types/lib/validators/generated/index.js"),_generated2=__webpack_require__("./node_modules/@babel/types/lib/builders/generated/index.js"),_cloneNode=__webpack_require__("./node_modules/@babel/types/lib/clone/cloneNode.js");},"./node_modules/@babel/types/lib/converters/toBindingIdentifierName.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(name){"eval"!==(name=(0, _toIdentifier.default)(name))&&"arguments"!==name||(name="_"+name);return name};var _toIdentifier=__webpack_require__("./node_modules/@babel/types/lib/converters/toIdentifier.js");},"./node_modules/@babel/types/lib/converters/toBlock.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node,parent){if((0, _generated.isBlockStatement)(node))return node;let blockNodes=[];(0, _generated.isEmptyStatement)(node)?blockNodes=[]:((0, _generated.isStatement)(node)||(node=(0, _generated.isFunction)(parent)?(0, _generated2.returnStatement)(node):(0, _generated2.expressionStatement)(node)),blockNodes=[node]);return (0, _generated2.blockStatement)(blockNodes)};var _generated=__webpack_require__("./node_modules/@babel/types/lib/validators/generated/index.js"),_generated2=__webpack_require__("./node_modules/@babel/types/lib/builders/generated/index.js");},"./node_modules/@babel/types/lib/converters/toComputedKey.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node,key=node.key||node.property){!node.computed&&(0, _generated.isIdentifier)(key)&&(key=(0, _generated2.stringLiteral)(key.name));return key};var _generated=__webpack_require__("./node_modules/@babel/types/lib/validators/generated/index.js"),_generated2=__webpack_require__("./node_modules/@babel/types/lib/builders/generated/index.js");},"./node_modules/@babel/types/lib/converters/toExpression.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _generated=__webpack_require__("./node_modules/@babel/types/lib/validators/generated/index.js"),_default=function(node){(0, _generated.isExpressionStatement)(node)&&(node=node.expression);if((0, _generated.isExpression)(node))return node;(0, _generated.isClass)(node)?node.type="ClassExpression":(0, _generated.isFunction)(node)&&(node.type="FunctionExpression");if(!(0, _generated.isExpression)(node))throw new Error(`cannot turn ${node.type} to an expression`);return node};exports.default=_default;},"./node_modules/@babel/types/lib/converters/toIdentifier.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(input){input+="";let name="";for(const c of input)name+=(0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0))?c:"-";name=name.replace(/^[-0-9]+/,""),name=name.replace(/[-\s]+(.)?/g,(function(match,c){return c?c.toUpperCase():""})),(0, _isValidIdentifier.default)(name)||(name=`_${name}`);return name||"_"};var _isValidIdentifier=__webpack_require__("./node_modules/@babel/types/lib/validators/isValidIdentifier.js"),_helperValidatorIdentifier=__webpack_require__("./node_modules/@babel/helper-validator-identifier/lib/index.js");},"./node_modules/@babel/types/lib/converters/toKeyAlias.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=toKeyAlias;var _generated=__webpack_require__("./node_modules/@babel/types/lib/validators/generated/index.js"),_cloneNode=__webpack_require__("./node_modules/@babel/types/lib/clone/cloneNode.js"),_removePropertiesDeep=__webpack_require__("./node_modules/@babel/types/lib/modifications/removePropertiesDeep.js");function toKeyAlias(node,key=node.key){let alias;return "method"===node.kind?toKeyAlias.increment()+"":(alias=(0, _generated.isIdentifier)(key)?key.name:(0, _generated.isStringLiteral)(key)?JSON.stringify(key.value):JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key))),node.computed&&(alias=`[${alias}]`),node.static&&(alias=`static:${alias}`),alias)}toKeyAlias.uid=0,toKeyAlias.increment=function(){return toKeyAlias.uid>=Number.MAX_SAFE_INTEGER?toKeyAlias.uid=0:toKeyAlias.uid++};},"./node_modules/@babel/types/lib/converters/toSequenceExpression.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(nodes,scope){if(null==nodes||!nodes.length)return;const declars=[],result=(0, _gatherSequenceExpressions.default)(nodes,scope,declars);if(!result)return;for(const declar of declars)scope.push(declar);return result};var _gatherSequenceExpressions=__webpack_require__("./node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js");},"./node_modules/@babel/types/lib/converters/toStatement.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _generated=__webpack_require__("./node_modules/@babel/types/lib/validators/generated/index.js"),_generated2=__webpack_require__("./node_modules/@babel/types/lib/builders/generated/index.js"),_default=function(node,ignore){if((0, _generated.isStatement)(node))return node;let newType,mustHaveId=!1;if((0, _generated.isClass)(node))mustHaveId=!0,newType="ClassDeclaration";else if((0, _generated.isFunction)(node))mustHaveId=!0,newType="FunctionDeclaration";else if((0, _generated.isAssignmentExpression)(node))return (0, _generated2.expressionStatement)(node);mustHaveId&&!node.id&&(newType=!1);if(!newType){if(ignore)return !1;throw new Error(`cannot turn ${node.type} to a statement`)}return node.type=newType,node};exports.default=_default;},"./node_modules/@babel/types/lib/converters/valueToNode.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _isValidIdentifier=__webpack_require__("./node_modules/@babel/types/lib/validators/isValidIdentifier.js"),_generated=__webpack_require__("./node_modules/@babel/types/lib/builders/generated/index.js"),_default=function valueToNode(value){if(void 0===value)return (0, _generated.identifier)("undefined");if(!0===value||!1===value)return (0, _generated.booleanLiteral)(value);if(null===value)return (0, _generated.nullLiteral)();if("string"==typeof value)return (0, _generated.stringLiteral)(value);if("number"==typeof value){let result;if(Number.isFinite(value))result=(0, _generated.numericLiteral)(Math.abs(value));else {let numerator;numerator=Number.isNaN(value)?(0, _generated.numericLiteral)(0):(0, _generated.numericLiteral)(1),result=(0, _generated.binaryExpression)("/",numerator,(0, _generated.numericLiteral)(0));}return (value<0||Object.is(value,-0))&&(result=(0, _generated.unaryExpression)("-",result)),result}if(function(value){return "[object RegExp]"===objectToString(value)}(value)){const pattern=value.source,flags=value.toString().match(/\/([a-z]+|)$/)[1];return (0, _generated.regExpLiteral)(pattern,flags)}if(Array.isArray(value))return (0, _generated.arrayExpression)(value.map(valueToNode));if(function(value){if("object"!=typeof value||null===value||"[object Object]"!==Object.prototype.toString.call(value))return !1;const proto=Object.getPrototypeOf(value);return null===proto||null===Object.getPrototypeOf(proto)}(value)){const props=[];for(const key of Object.keys(value)){let nodeKey;nodeKey=(0, _isValidIdentifier.default)(key)?(0, _generated.identifier)(key):(0, _generated.stringLiteral)(key),props.push((0, _generated.objectProperty)(nodeKey,valueToNode(value[key])));}return (0, _generated.objectExpression)(props)}throw new Error("don't know how to turn this value into a node")};exports.default=_default;const objectToString=Function.call.bind(Object.prototype.toString);},"./node_modules/@babel/types/lib/definitions/core.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.patternLikeCommon=exports.functionTypeAnnotationCommon=exports.functionDeclarationCommon=exports.functionCommon=exports.classMethodOrPropertyCommon=exports.classMethodOrDeclareMethodCommon=void 0;var _is=__webpack_require__("./node_modules/@babel/types/lib/validators/is.js"),_isValidIdentifier=__webpack_require__("./node_modules/@babel/types/lib/validators/isValidIdentifier.js"),_helperValidatorIdentifier=__webpack_require__("./node_modules/@babel/helper-validator-identifier/lib/index.js"),_constants=__webpack_require__("./node_modules/@babel/types/lib/constants/index.js"),_utils=__webpack_require__("./node_modules/@babel/types/lib/definitions/utils.js");const defineType=(0, _utils.defineAliasedType)("Standardized");defineType("ArrayExpression",{fields:{elements:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null","Expression","SpreadElement"))),default:process.env.BABEL_TYPES_8_BREAKING?void 0:[]}},visitor:["elements"],aliases:["Expression"]}),defineType("AssignmentExpression",{fields:{operator:{validate:function(){if(!process.env.BABEL_TYPES_8_BREAKING)return (0, _utils.assertValueType)("string");const identifier=(0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS),pattern=(0, _utils.assertOneOf)("=");return function(node,key,val){((0, _is.default)("Pattern",node.left)?pattern:identifier)(node,key,val);}}()},left:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.assertNodeType)("Identifier","MemberExpression","ArrayPattern","ObjectPattern"):(0, _utils.assertNodeType)("LVal")},right:{validate:(0, _utils.assertNodeType)("Expression")}},builder:["operator","left","right"],visitor:["left","right"],aliases:["Expression"]}),defineType("BinaryExpression",{builder:["operator","left","right"],fields:{operator:{validate:(0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)},left:{validate:function(){const expression=(0, _utils.assertNodeType)("Expression"),inOp=(0, _utils.assertNodeType)("Expression","PrivateName"),validator=function(node,key,val){("in"===node.operator?inOp:expression)(node,key,val);};return validator.oneOfNodeTypes=["Expression","PrivateName"],validator}()},right:{validate:(0, _utils.assertNodeType)("Expression")}},visitor:["left","right"],aliases:["Binary","Expression"]}),defineType("InterpreterDirective",{builder:["value"],fields:{value:{validate:(0, _utils.assertValueType)("string")}}}),defineType("Directive",{visitor:["value"],fields:{value:{validate:(0, _utils.assertNodeType)("DirectiveLiteral")}}}),defineType("DirectiveLiteral",{builder:["value"],fields:{value:{validate:(0, _utils.assertValueType)("string")}}}),defineType("BlockStatement",{builder:["body","directives"],visitor:["directives","body"],fields:{directives:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),default:[]},body:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))}},aliases:["Scopable","BlockParent","Block","Statement"]}),defineType("BreakStatement",{visitor:["label"],fields:{label:{validate:(0, _utils.assertNodeType)("Identifier"),optional:!0}},aliases:["Statement","Terminatorless","CompletionStatement"]}),defineType("CallExpression",{visitor:["callee","arguments","typeParameters","typeArguments"],builder:["callee","arguments"],aliases:["Expression"],fields:Object.assign({callee:{validate:(0, _utils.assertNodeType)("Expression","V8IntrinsicIdentifier")},arguments:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Expression","SpreadElement","JSXNamespacedName","ArgumentPlaceholder")))}},process.env.BABEL_TYPES_8_BREAKING?{}:{optional:{validate:(0, _utils.assertOneOf)(!0,!1),optional:!0}},{typeArguments:{validate:(0, _utils.assertNodeType)("TypeParameterInstantiation"),optional:!0},typeParameters:{validate:(0, _utils.assertNodeType)("TSTypeParameterInstantiation"),optional:!0}})}),defineType("CatchClause",{visitor:["param","body"],fields:{param:{validate:(0, _utils.assertNodeType)("Identifier","ArrayPattern","ObjectPattern"),optional:!0},body:{validate:(0, _utils.assertNodeType)("BlockStatement")}},aliases:["Scopable","BlockParent"]}),defineType("ConditionalExpression",{visitor:["test","consequent","alternate"],fields:{test:{validate:(0, _utils.assertNodeType)("Expression")},consequent:{validate:(0, _utils.assertNodeType)("Expression")},alternate:{validate:(0, _utils.assertNodeType)("Expression")}},aliases:["Expression","Conditional"]}),defineType("ContinueStatement",{visitor:["label"],fields:{label:{validate:(0, _utils.assertNodeType)("Identifier"),optional:!0}},aliases:["Statement","Terminatorless","CompletionStatement"]}),defineType("DebuggerStatement",{aliases:["Statement"]}),defineType("DoWhileStatement",{visitor:["test","body"],fields:{test:{validate:(0, _utils.assertNodeType)("Expression")},body:{validate:(0, _utils.assertNodeType)("Statement")}},aliases:["Statement","BlockParent","Loop","While","Scopable"]}),defineType("EmptyStatement",{aliases:["Statement"]}),defineType("ExpressionStatement",{visitor:["expression"],fields:{expression:{validate:(0, _utils.assertNodeType)("Expression")}},aliases:["Statement","ExpressionWrapper"]}),defineType("File",{builder:["program","comments","tokens"],visitor:["program"],fields:{program:{validate:(0, _utils.assertNodeType)("Program")},comments:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock","CommentLine")):Object.assign((()=>{}),{each:{oneOfNodeTypes:["CommentBlock","CommentLine"]}}),optional:!0},tokens:{validate:(0, _utils.assertEach)(Object.assign((()=>{}),{type:"any"})),optional:!0}}}),defineType("ForInStatement",{visitor:["left","right","body"],aliases:["Scopable","Statement","For","BlockParent","Loop","ForXStatement"],fields:{left:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.assertNodeType)("VariableDeclaration","Identifier","MemberExpression","ArrayPattern","ObjectPattern"):(0, _utils.assertNodeType)("VariableDeclaration","LVal")},right:{validate:(0, _utils.assertNodeType)("Expression")},body:{validate:(0, _utils.assertNodeType)("Statement")}}}),defineType("ForStatement",{visitor:["init","test","update","body"],aliases:["Scopable","Statement","For","BlockParent","Loop"],fields:{init:{validate:(0, _utils.assertNodeType)("VariableDeclaration","Expression"),optional:!0},test:{validate:(0, _utils.assertNodeType)("Expression"),optional:!0},update:{validate:(0, _utils.assertNodeType)("Expression"),optional:!0},body:{validate:(0, _utils.assertNodeType)("Statement")}}});const functionCommon={params:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier","Pattern","RestElement")))},generator:{default:!1},async:{default:!1}};exports.functionCommon=functionCommon;const functionTypeAnnotationCommon={returnType:{validate:(0, _utils.assertNodeType)("TypeAnnotation","TSTypeAnnotation","Noop"),optional:!0},typeParameters:{validate:(0, _utils.assertNodeType)("TypeParameterDeclaration","TSTypeParameterDeclaration","Noop"),optional:!0}};exports.functionTypeAnnotationCommon=functionTypeAnnotationCommon;const functionDeclarationCommon=Object.assign({},functionCommon,{declare:{validate:(0, _utils.assertValueType)("boolean"),optional:!0},id:{validate:(0, _utils.assertNodeType)("Identifier"),optional:!0}});exports.functionDeclarationCommon=functionDeclarationCommon,defineType("FunctionDeclaration",{builder:["id","params","body","generator","async"],visitor:["id","params","body","returnType","typeParameters"],fields:Object.assign({},functionDeclarationCommon,functionTypeAnnotationCommon,{body:{validate:(0, _utils.assertNodeType)("BlockStatement")}}),aliases:["Scopable","Function","BlockParent","FunctionParent","Statement","Pureish","Declaration"],validate:function(){if(!process.env.BABEL_TYPES_8_BREAKING)return ()=>{};const identifier=(0, _utils.assertNodeType)("Identifier");return function(parent,key,node){(0, _is.default)("ExportDefaultDeclaration",parent)||identifier(node,"id",node.id);}}()}),defineType("FunctionExpression",{inherits:"FunctionDeclaration",aliases:["Scopable","Function","BlockParent","FunctionParent","Expression","Pureish"],fields:Object.assign({},functionCommon,functionTypeAnnotationCommon,{id:{validate:(0, _utils.assertNodeType)("Identifier"),optional:!0},body:{validate:(0, _utils.assertNodeType)("BlockStatement")}})});const patternLikeCommon={typeAnnotation:{validate:(0, _utils.assertNodeType)("TypeAnnotation","TSTypeAnnotation","Noop"),optional:!0},decorators:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))}};exports.patternLikeCommon=patternLikeCommon,defineType("Identifier",{builder:["name"],visitor:["typeAnnotation","decorators"],aliases:["Expression","PatternLike","LVal","TSEntityName"],fields:Object.assign({},patternLikeCommon,{name:{validate:(0, _utils.chain)((0, _utils.assertValueType)("string"),Object.assign((function(node,key,val){if(process.env.BABEL_TYPES_8_BREAKING&&!(0, _isValidIdentifier.default)(val,!1))throw new TypeError(`"${val}" is not a valid identifier name`)}),{type:"string"}))},optional:{validate:(0, _utils.assertValueType)("boolean"),optional:!0}}),validate(parent,key,node){if(!process.env.BABEL_TYPES_8_BREAKING)return;const match=/\.(\w+)$/.exec(key);if(!match)return;const[,parentKey]=match,nonComp={computed:!1};if("property"===parentKey){if((0, _is.default)("MemberExpression",parent,nonComp))return;if((0, _is.default)("OptionalMemberExpression",parent,nonComp))return}else if("key"===parentKey){if((0, _is.default)("Property",parent,nonComp))return;if((0, _is.default)("Method",parent,nonComp))return}else if("exported"===parentKey){if((0, _is.default)("ExportSpecifier",parent))return}else if("imported"===parentKey){if((0, _is.default)("ImportSpecifier",parent,{imported:node}))return}else if("meta"===parentKey&&(0, _is.default)("MetaProperty",parent,{meta:node}))return;if(((0, _helperValidatorIdentifier.isKeyword)(node.name)||(0, _helperValidatorIdentifier.isReservedWord)(node.name,!1))&&"this"!==node.name)throw new TypeError(`"${node.name}" is not a valid identifier`)}}),defineType("IfStatement",{visitor:["test","consequent","alternate"],aliases:["Statement","Conditional"],fields:{test:{validate:(0, _utils.assertNodeType)("Expression")},consequent:{validate:(0, _utils.assertNodeType)("Statement")},alternate:{optional:!0,validate:(0, _utils.assertNodeType)("Statement")}}}),defineType("LabeledStatement",{visitor:["label","body"],aliases:["Statement"],fields:{label:{validate:(0, _utils.assertNodeType)("Identifier")},body:{validate:(0, _utils.assertNodeType)("Statement")}}}),defineType("StringLiteral",{builder:["value"],fields:{value:{validate:(0, _utils.assertValueType)("string")}},aliases:["Expression","Pureish","Literal","Immutable"]}),defineType("NumericLiteral",{builder:["value"],deprecatedAlias:"NumberLiteral",fields:{value:{validate:(0, _utils.assertValueType)("number")}},aliases:["Expression","Pureish","Literal","Immutable"]}),defineType("NullLiteral",{aliases:["Expression","Pureish","Literal","Immutable"]}),defineType("BooleanLiteral",{builder:["value"],fields:{value:{validate:(0, _utils.assertValueType)("boolean")}},aliases:["Expression","Pureish","Literal","Immutable"]}),defineType("RegExpLiteral",{builder:["pattern","flags"],deprecatedAlias:"RegexLiteral",aliases:["Expression","Pureish","Literal"],fields:{pattern:{validate:(0, _utils.assertValueType)("string")},flags:{validate:(0, _utils.chain)((0, _utils.assertValueType)("string"),Object.assign((function(node,key,val){if(!process.env.BABEL_TYPES_8_BREAKING)return;const invalid=/[^gimsuy]/.exec(val);if(invalid)throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`)}),{type:"string"})),default:""}}}),defineType("LogicalExpression",{builder:["operator","left","right"],visitor:["left","right"],aliases:["Binary","Expression"],fields:{operator:{validate:(0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)},left:{validate:(0, _utils.assertNodeType)("Expression")},right:{validate:(0, _utils.assertNodeType)("Expression")}}}),defineType("MemberExpression",{builder:["object","property","computed",...process.env.BABEL_TYPES_8_BREAKING?[]:["optional"]],visitor:["object","property"],aliases:["Expression","LVal"],fields:Object.assign({object:{validate:(0, _utils.assertNodeType)("Expression")},property:{validate:function(){const normal=(0, _utils.assertNodeType)("Identifier","PrivateName"),computed=(0, _utils.assertNodeType)("Expression"),validator=function(node,key,val){(node.computed?computed:normal)(node,key,val);};return validator.oneOfNodeTypes=["Expression","Identifier","PrivateName"],validator}()},computed:{default:!1}},process.env.BABEL_TYPES_8_BREAKING?{}:{optional:{validate:(0, _utils.assertOneOf)(!0,!1),optional:!0}})}),defineType("NewExpression",{inherits:"CallExpression"}),defineType("Program",{visitor:["directives","body"],builder:["body","directives","sourceType","interpreter"],fields:{sourceFile:{validate:(0, _utils.assertValueType)("string")},sourceType:{validate:(0, _utils.assertOneOf)("script","module"),default:"script"},interpreter:{validate:(0, _utils.assertNodeType)("InterpreterDirective"),default:null,optional:!0},directives:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),default:[]},body:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))}},aliases:["Scopable","BlockParent","Block"]}),defineType("ObjectExpression",{visitor:["properties"],aliases:["Expression"],fields:{properties:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod","ObjectProperty","SpreadElement")))}}}),defineType("ObjectMethod",{builder:["kind","key","params","body","computed","generator","async"],fields:Object.assign({},functionCommon,functionTypeAnnotationCommon,{kind:Object.assign({validate:(0, _utils.assertOneOf)("method","get","set")},process.env.BABEL_TYPES_8_BREAKING?{}:{default:"method"}),computed:{default:!1},key:{validate:function(){const normal=(0, _utils.assertNodeType)("Identifier","StringLiteral","NumericLiteral"),computed=(0, _utils.assertNodeType)("Expression"),validator=function(node,key,val){(node.computed?computed:normal)(node,key,val);};return validator.oneOfNodeTypes=["Expression","Identifier","StringLiteral","NumericLiteral"],validator}()},decorators:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),optional:!0},body:{validate:(0, _utils.assertNodeType)("BlockStatement")}}),visitor:["key","params","body","decorators","returnType","typeParameters"],aliases:["UserWhitespacable","Function","Scopable","BlockParent","FunctionParent","Method","ObjectMember"]}),defineType("ObjectProperty",{builder:["key","value","computed","shorthand",...process.env.BABEL_TYPES_8_BREAKING?[]:["decorators"]],fields:{computed:{default:!1},key:{validate:function(){const normal=(0, _utils.assertNodeType)("Identifier","StringLiteral","NumericLiteral"),computed=(0, _utils.assertNodeType)("Expression"),validator=function(node,key,val){(node.computed?computed:normal)(node,key,val);};return validator.oneOfNodeTypes=["Expression","Identifier","StringLiteral","NumericLiteral"],validator}()},value:{validate:(0, _utils.assertNodeType)("Expression","PatternLike")},shorthand:{validate:(0, _utils.chain)((0, _utils.assertValueType)("boolean"),Object.assign((function(node,key,val){if(process.env.BABEL_TYPES_8_BREAKING&&val&&node.computed)throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true")}),{type:"boolean"}),(function(node,key,val){if(process.env.BABEL_TYPES_8_BREAKING&&val&&!(0, _is.default)("Identifier",node.key))throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier")})),default:!1},decorators:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),optional:!0}},visitor:["key","value","decorators"],aliases:["UserWhitespacable","Property","ObjectMember"],validate:function(){const pattern=(0, _utils.assertNodeType)("Identifier","Pattern"),expression=(0, _utils.assertNodeType)("Expression");return function(parent,key,node){if(!process.env.BABEL_TYPES_8_BREAKING)return;((0, _is.default)("ObjectPattern",parent)?pattern:expression)(node,"value",node.value);}}()}),defineType("RestElement",{visitor:["argument","typeAnnotation"],builder:["argument"],aliases:["LVal","PatternLike"],deprecatedAlias:"RestProperty",fields:Object.assign({},patternLikeCommon,{argument:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.assertNodeType)("Identifier","ArrayPattern","ObjectPattern","MemberExpression"):(0, _utils.assertNodeType)("LVal")},optional:{validate:(0, _utils.assertValueType)("boolean"),optional:!0}}),validate(parent,key){if(!process.env.BABEL_TYPES_8_BREAKING)return;const match=/(\w+)\[(\d+)\]/.exec(key);if(!match)throw new Error("Internal Babel error: malformed key.");const[,listKey,index]=match;if(parent[listKey].length>index+1)throw new TypeError(`RestElement must be last element of ${listKey}`)}}),defineType("ReturnStatement",{visitor:["argument"],aliases:["Statement","Terminatorless","CompletionStatement"],fields:{argument:{validate:(0, _utils.assertNodeType)("Expression"),optional:!0}}}),defineType("SequenceExpression",{visitor:["expressions"],fields:{expressions:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))}},aliases:["Expression"]}),defineType("ParenthesizedExpression",{visitor:["expression"],aliases:["Expression","ExpressionWrapper"],fields:{expression:{validate:(0, _utils.assertNodeType)("Expression")}}}),defineType("SwitchCase",{visitor:["test","consequent"],fields:{test:{validate:(0, _utils.assertNodeType)("Expression"),optional:!0},consequent:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))}}}),defineType("SwitchStatement",{visitor:["discriminant","cases"],aliases:["Statement","BlockParent","Scopable"],fields:{discriminant:{validate:(0, _utils.assertNodeType)("Expression")},cases:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))}}}),defineType("ThisExpression",{aliases:["Expression"]}),defineType("ThrowStatement",{visitor:["argument"],aliases:["Statement","Terminatorless","CompletionStatement"],fields:{argument:{validate:(0, _utils.assertNodeType)("Expression")}}}),defineType("TryStatement",{visitor:["block","handler","finalizer"],aliases:["Statement"],fields:{block:{validate:(0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"),Object.assign((function(node){if(process.env.BABEL_TYPES_8_BREAKING&&!node.handler&&!node.finalizer)throw new TypeError("TryStatement expects either a handler or finalizer, or both")}),{oneOfNodeTypes:["BlockStatement"]}))},handler:{optional:!0,validate:(0, _utils.assertNodeType)("CatchClause")},finalizer:{optional:!0,validate:(0, _utils.assertNodeType)("BlockStatement")}}}),defineType("UnaryExpression",{builder:["operator","argument","prefix"],fields:{prefix:{default:!0},argument:{validate:(0, _utils.assertNodeType)("Expression")},operator:{validate:(0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)}},visitor:["argument"],aliases:["UnaryLike","Expression"]}),defineType("UpdateExpression",{builder:["operator","argument","prefix"],fields:{prefix:{default:!1},argument:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.assertNodeType)("Identifier","MemberExpression"):(0, _utils.assertNodeType)("Expression")},operator:{validate:(0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)}},visitor:["argument"],aliases:["Expression"]}),defineType("VariableDeclaration",{builder:["kind","declarations"],visitor:["declarations"],aliases:["Statement","Declaration"],fields:{declare:{validate:(0, _utils.assertValueType)("boolean"),optional:!0},kind:{validate:(0, _utils.assertOneOf)("var","let","const")},declarations:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))}},validate(parent,key,node){if(process.env.BABEL_TYPES_8_BREAKING&&(0, _is.default)("ForXStatement",parent,{left:node})&&1!==node.declarations.length)throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`)}}),defineType("VariableDeclarator",{visitor:["id","init"],fields:{id:{validate:function(){if(!process.env.BABEL_TYPES_8_BREAKING)return (0, _utils.assertNodeType)("LVal");const normal=(0, _utils.assertNodeType)("Identifier","ArrayPattern","ObjectPattern"),without=(0, _utils.assertNodeType)("Identifier");return function(node,key,val){(node.init?normal:without)(node,key,val);}}()},definite:{optional:!0,validate:(0, _utils.assertValueType)("boolean")},init:{optional:!0,validate:(0, _utils.assertNodeType)("Expression")}}}),defineType("WhileStatement",{visitor:["test","body"],aliases:["Statement","BlockParent","Loop","While","Scopable"],fields:{test:{validate:(0, _utils.assertNodeType)("Expression")},body:{validate:(0, _utils.assertNodeType)("Statement")}}}),defineType("WithStatement",{visitor:["object","body"],aliases:["Statement"],fields:{object:{validate:(0, _utils.assertNodeType)("Expression")},body:{validate:(0, _utils.assertNodeType)("Statement")}}}),defineType("AssignmentPattern",{visitor:["left","right","decorators"],builder:["left","right"],aliases:["Pattern","PatternLike","LVal"],fields:Object.assign({},patternLikeCommon,{left:{validate:(0, _utils.assertNodeType)("Identifier","ObjectPattern","ArrayPattern","MemberExpression")},right:{validate:(0, _utils.assertNodeType)("Expression")},decorators:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),optional:!0}})}),defineType("ArrayPattern",{visitor:["elements","typeAnnotation"],builder:["elements"],aliases:["Pattern","PatternLike","LVal"],fields:Object.assign({},patternLikeCommon,{elements:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null","PatternLike")))},decorators:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),optional:!0},optional:{validate:(0, _utils.assertValueType)("boolean"),optional:!0}})}),defineType("ArrowFunctionExpression",{builder:["params","body","async"],visitor:["params","body","returnType","typeParameters"],aliases:["Scopable","Function","BlockParent","FunctionParent","Expression","Pureish"],fields:Object.assign({},functionCommon,functionTypeAnnotationCommon,{expression:{validate:(0, _utils.assertValueType)("boolean")},body:{validate:(0, _utils.assertNodeType)("BlockStatement","Expression")}})}),defineType("ClassBody",{visitor:["body"],fields:{body:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod","ClassPrivateMethod","ClassProperty","ClassPrivateProperty","TSDeclareMethod","TSIndexSignature")))}}}),defineType("ClassExpression",{builder:["id","superClass","body","decorators"],visitor:["id","body","superClass","mixins","typeParameters","superTypeParameters","implements","decorators"],aliases:["Scopable","Class","Expression"],fields:{id:{validate:(0, _utils.assertNodeType)("Identifier"),optional:!0},typeParameters:{validate:(0, _utils.assertNodeType)("TypeParameterDeclaration","TSTypeParameterDeclaration","Noop"),optional:!0},body:{validate:(0, _utils.assertNodeType)("ClassBody")},superClass:{optional:!0,validate:(0, _utils.assertNodeType)("Expression")},superTypeParameters:{validate:(0, _utils.assertNodeType)("TypeParameterInstantiation","TSTypeParameterInstantiation"),optional:!0},implements:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments","ClassImplements"))),optional:!0},decorators:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),optional:!0},mixins:{validate:(0, _utils.assertNodeType)("InterfaceExtends"),optional:!0}}}),defineType("ClassDeclaration",{inherits:"ClassExpression",aliases:["Scopable","Class","Statement","Declaration"],fields:{id:{validate:(0, _utils.assertNodeType)("Identifier")},typeParameters:{validate:(0, _utils.assertNodeType)("TypeParameterDeclaration","TSTypeParameterDeclaration","Noop"),optional:!0},body:{validate:(0, _utils.assertNodeType)("ClassBody")},superClass:{optional:!0,validate:(0, _utils.assertNodeType)("Expression")},superTypeParameters:{validate:(0, _utils.assertNodeType)("TypeParameterInstantiation","TSTypeParameterInstantiation"),optional:!0},implements:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments","ClassImplements"))),optional:!0},decorators:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),optional:!0},mixins:{validate:(0, _utils.assertNodeType)("InterfaceExtends"),optional:!0},declare:{validate:(0, _utils.assertValueType)("boolean"),optional:!0},abstract:{validate:(0, _utils.assertValueType)("boolean"),optional:!0}},validate:function(){const identifier=(0, _utils.assertNodeType)("Identifier");return function(parent,key,node){process.env.BABEL_TYPES_8_BREAKING&&((0, _is.default)("ExportDefaultDeclaration",parent)||identifier(node,"id",node.id));}}()}),defineType("ExportAllDeclaration",{visitor:["source"],aliases:["Statement","Declaration","ModuleDeclaration","ExportDeclaration"],fields:{source:{validate:(0, _utils.assertNodeType)("StringLiteral")},exportKind:(0, _utils.validateOptional)((0, _utils.assertOneOf)("type","value")),assertions:{optional:!0,validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))}}}),defineType("ExportDefaultDeclaration",{visitor:["declaration"],aliases:["Statement","Declaration","ModuleDeclaration","ExportDeclaration"],fields:{declaration:{validate:(0, _utils.assertNodeType)("FunctionDeclaration","TSDeclareFunction","ClassDeclaration","Expression")},exportKind:(0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))}}),defineType("ExportNamedDeclaration",{visitor:["declaration","specifiers","source"],aliases:["Statement","Declaration","ModuleDeclaration","ExportDeclaration"],fields:{declaration:{optional:!0,validate:(0, _utils.chain)((0, _utils.assertNodeType)("Declaration"),Object.assign((function(node,key,val){if(process.env.BABEL_TYPES_8_BREAKING&&val&&node.specifiers.length)throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration")}),{oneOfNodeTypes:["Declaration"]}),(function(node,key,val){if(process.env.BABEL_TYPES_8_BREAKING&&val&&node.source)throw new TypeError("Cannot export a declaration from a source")}))},assertions:{optional:!0,validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))},specifiers:{default:[],validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)(function(){const sourced=(0, _utils.assertNodeType)("ExportSpecifier","ExportDefaultSpecifier","ExportNamespaceSpecifier"),sourceless=(0, _utils.assertNodeType)("ExportSpecifier");return process.env.BABEL_TYPES_8_BREAKING?function(node,key,val){(node.source?sourced:sourceless)(node,key,val);}:sourced}()))},source:{validate:(0, _utils.assertNodeType)("StringLiteral"),optional:!0},exportKind:(0, _utils.validateOptional)((0, _utils.assertOneOf)("type","value"))}}),defineType("ExportSpecifier",{visitor:["local","exported"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0, _utils.assertNodeType)("Identifier")},exported:{validate:(0, _utils.assertNodeType)("Identifier","StringLiteral")},exportKind:{validate:(0, _utils.assertOneOf)("type","value"),optional:!0}}}),defineType("ForOfStatement",{visitor:["left","right","body"],builder:["left","right","body","await"],aliases:["Scopable","Statement","For","BlockParent","Loop","ForXStatement"],fields:{left:{validate:function(){if(!process.env.BABEL_TYPES_8_BREAKING)return (0, _utils.assertNodeType)("VariableDeclaration","LVal");const declaration=(0, _utils.assertNodeType)("VariableDeclaration"),lval=(0, _utils.assertNodeType)("Identifier","MemberExpression","ArrayPattern","ObjectPattern");return function(node,key,val){(0, _is.default)("VariableDeclaration",val)?declaration(node,key,val):lval(node,key,val);}}()},right:{validate:(0, _utils.assertNodeType)("Expression")},body:{validate:(0, _utils.assertNodeType)("Statement")},await:{default:!1}}}),defineType("ImportDeclaration",{visitor:["specifiers","source"],aliases:["Statement","Declaration","ModuleDeclaration"],fields:{assertions:{optional:!0,validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))},specifiers:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier")))},source:{validate:(0, _utils.assertNodeType)("StringLiteral")},importKind:{validate:(0, _utils.assertOneOf)("type","typeof","value"),optional:!0}}}),defineType("ImportDefaultSpecifier",{visitor:["local"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0, _utils.assertNodeType)("Identifier")}}}),defineType("ImportNamespaceSpecifier",{visitor:["local"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0, _utils.assertNodeType)("Identifier")}}}),defineType("ImportSpecifier",{visitor:["local","imported"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0, _utils.assertNodeType)("Identifier")},imported:{validate:(0, _utils.assertNodeType)("Identifier","StringLiteral")},importKind:{validate:(0, _utils.assertOneOf)("type","typeof","value"),optional:!0}}}),defineType("MetaProperty",{visitor:["meta","property"],aliases:["Expression"],fields:{meta:{validate:(0, _utils.chain)((0, _utils.assertNodeType)("Identifier"),Object.assign((function(node,key,val){if(!process.env.BABEL_TYPES_8_BREAKING)return;let property;switch(val.name){case"function":property="sent";break;case"new":property="target";break;case"import":property="meta";}if(!(0, _is.default)("Identifier",node.property,{name:property}))throw new TypeError("Unrecognised MetaProperty")}),{oneOfNodeTypes:["Identifier"]}))},property:{validate:(0, _utils.assertNodeType)("Identifier")}}});const classMethodOrPropertyCommon={abstract:{validate:(0, _utils.assertValueType)("boolean"),optional:!0},accessibility:{validate:(0, _utils.assertOneOf)("public","private","protected"),optional:!0},static:{default:!1},override:{default:!1},computed:{default:!1},optional:{validate:(0, _utils.assertValueType)("boolean"),optional:!0},key:{validate:(0, _utils.chain)(function(){const normal=(0, _utils.assertNodeType)("Identifier","StringLiteral","NumericLiteral"),computed=(0, _utils.assertNodeType)("Expression");return function(node,key,val){(node.computed?computed:normal)(node,key,val);}}(),(0, _utils.assertNodeType)("Identifier","StringLiteral","NumericLiteral","Expression"))}};exports.classMethodOrPropertyCommon=classMethodOrPropertyCommon;const classMethodOrDeclareMethodCommon=Object.assign({},functionCommon,classMethodOrPropertyCommon,{params:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier","Pattern","RestElement","TSParameterProperty")))},kind:{validate:(0, _utils.assertOneOf)("get","set","method","constructor"),default:"method"},access:{validate:(0, _utils.chain)((0, _utils.assertValueType)("string"),(0, _utils.assertOneOf)("public","private","protected")),optional:!0},decorators:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),optional:!0}});exports.classMethodOrDeclareMethodCommon=classMethodOrDeclareMethodCommon,defineType("ClassMethod",{aliases:["Function","Scopable","BlockParent","FunctionParent","Method"],builder:["kind","key","params","body","computed","static","generator","async"],visitor:["key","params","body","decorators","returnType","typeParameters"],fields:Object.assign({},classMethodOrDeclareMethodCommon,functionTypeAnnotationCommon,{body:{validate:(0, _utils.assertNodeType)("BlockStatement")}})}),defineType("ObjectPattern",{visitor:["properties","typeAnnotation","decorators"],builder:["properties"],aliases:["Pattern","PatternLike","LVal"],fields:Object.assign({},patternLikeCommon,{properties:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement","ObjectProperty")))}})}),defineType("SpreadElement",{visitor:["argument"],aliases:["UnaryLike"],deprecatedAlias:"SpreadProperty",fields:{argument:{validate:(0, _utils.assertNodeType)("Expression")}}}),defineType("Super",{aliases:["Expression"]}),defineType("TaggedTemplateExpression",{visitor:["tag","quasi","typeParameters"],builder:["tag","quasi"],aliases:["Expression"],fields:{tag:{validate:(0, _utils.assertNodeType)("Expression")},quasi:{validate:(0, _utils.assertNodeType)("TemplateLiteral")},typeParameters:{validate:(0, _utils.assertNodeType)("TypeParameterInstantiation","TSTypeParameterInstantiation"),optional:!0}}}),defineType("TemplateElement",{builder:["value","tail"],fields:{value:{validate:(0, _utils.assertShape)({raw:{validate:(0, _utils.assertValueType)("string")},cooked:{validate:(0, _utils.assertValueType)("string"),optional:!0}})},tail:{default:!1}}}),defineType("TemplateLiteral",{visitor:["quasis","expressions"],aliases:["Expression","Literal"],fields:{quasis:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))},expressions:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Expression","TSType")),(function(node,key,val){if(node.quasis.length!==val.length+1)throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length+1} quasis but got ${node.quasis.length}`)}))}}}),defineType("YieldExpression",{builder:["argument","delegate"],visitor:["argument"],aliases:["Expression","Terminatorless"],fields:{delegate:{validate:(0, _utils.chain)((0, _utils.assertValueType)("boolean"),Object.assign((function(node,key,val){if(process.env.BABEL_TYPES_8_BREAKING&&val&&!node.argument)throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument")}),{type:"boolean"})),default:!1},argument:{optional:!0,validate:(0, _utils.assertNodeType)("Expression")}}}),defineType("AwaitExpression",{builder:["argument"],visitor:["argument"],aliases:["Expression","Terminatorless"],fields:{argument:{validate:(0, _utils.assertNodeType)("Expression")}}}),defineType("Import",{aliases:["Expression"]}),defineType("BigIntLiteral",{builder:["value"],fields:{value:{validate:(0, _utils.assertValueType)("string")}},aliases:["Expression","Pureish","Literal","Immutable"]}),defineType("ExportNamespaceSpecifier",{visitor:["exported"],aliases:["ModuleSpecifier"],fields:{exported:{validate:(0, _utils.assertNodeType)("Identifier")}}}),defineType("OptionalMemberExpression",{builder:["object","property","computed","optional"],visitor:["object","property"],aliases:["Expression"],fields:{object:{validate:(0, _utils.assertNodeType)("Expression")},property:{validate:function(){const normal=(0, _utils.assertNodeType)("Identifier"),computed=(0, _utils.assertNodeType)("Expression"),validator=function(node,key,val){(node.computed?computed:normal)(node,key,val);};return validator.oneOfNodeTypes=["Expression","Identifier"],validator}()},computed:{default:!1},optional:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.chain)((0, _utils.assertValueType)("boolean"),(0, _utils.assertOptionalChainStart)()):(0, _utils.assertValueType)("boolean")}}}),defineType("OptionalCallExpression",{visitor:["callee","arguments","typeParameters","typeArguments"],builder:["callee","arguments","optional"],aliases:["Expression"],fields:{callee:{validate:(0, _utils.assertNodeType)("Expression")},arguments:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Expression","SpreadElement","JSXNamespacedName","ArgumentPlaceholder")))},optional:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.chain)((0, _utils.assertValueType)("boolean"),(0, _utils.assertOptionalChainStart)()):(0, _utils.assertValueType)("boolean")},typeArguments:{validate:(0, _utils.assertNodeType)("TypeParameterInstantiation"),optional:!0},typeParameters:{validate:(0, _utils.assertNodeType)("TSTypeParameterInstantiation"),optional:!0}}}),defineType("ClassProperty",{visitor:["key","value","typeAnnotation","decorators"],builder:["key","value","typeAnnotation","decorators","computed","static"],aliases:["Property"],fields:Object.assign({},classMethodOrPropertyCommon,{value:{validate:(0, _utils.assertNodeType)("Expression"),optional:!0},definite:{validate:(0, _utils.assertValueType)("boolean"),optional:!0},typeAnnotation:{validate:(0, _utils.assertNodeType)("TypeAnnotation","TSTypeAnnotation","Noop"),optional:!0},decorators:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),optional:!0},readonly:{validate:(0, _utils.assertValueType)("boolean"),optional:!0},declare:{validate:(0, _utils.assertValueType)("boolean"),optional:!0},variance:{validate:(0, _utils.assertNodeType)("Variance"),optional:!0}})}),defineType("ClassPrivateProperty",{visitor:["key","value","decorators","typeAnnotation"],builder:["key","value","decorators","static"],aliases:["Property","Private"],fields:{key:{validate:(0, _utils.assertNodeType)("PrivateName")},value:{validate:(0, _utils.assertNodeType)("Expression"),optional:!0},typeAnnotation:{validate:(0, _utils.assertNodeType)("TypeAnnotation","TSTypeAnnotation","Noop"),optional:!0},decorators:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),optional:!0},readonly:{validate:(0, _utils.assertValueType)("boolean"),optional:!0},definite:{validate:(0, _utils.assertValueType)("boolean"),optional:!0},variance:{validate:(0, _utils.assertNodeType)("Variance"),optional:!0}}}),defineType("ClassPrivateMethod",{builder:["kind","key","params","body","static"],visitor:["key","params","body","decorators","returnType","typeParameters"],aliases:["Function","Scopable","BlockParent","FunctionParent","Method","Private"],fields:Object.assign({},classMethodOrDeclareMethodCommon,functionTypeAnnotationCommon,{key:{validate:(0, _utils.assertNodeType)("PrivateName")},body:{validate:(0, _utils.assertNodeType)("BlockStatement")}})}),defineType("PrivateName",{visitor:["id"],aliases:["Private"],fields:{id:{validate:(0, _utils.assertNodeType)("Identifier")}}}),defineType("StaticBlock",{visitor:["body"],fields:{body:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))}},aliases:["Scopable","BlockParent","FunctionParent"]});},"./node_modules/@babel/types/lib/definitions/experimental.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{var _utils=__webpack_require__("./node_modules/@babel/types/lib/definitions/utils.js");(0, _utils.default)("ArgumentPlaceholder",{}),(0, _utils.default)("BindExpression",{visitor:["object","callee"],aliases:["Expression"],fields:process.env.BABEL_TYPES_8_BREAKING?{object:{validate:(0, _utils.assertNodeType)("Expression")},callee:{validate:(0, _utils.assertNodeType)("Expression")}}:{object:{validate:Object.assign((()=>{}),{oneOfNodeTypes:["Expression"]})},callee:{validate:Object.assign((()=>{}),{oneOfNodeTypes:["Expression"]})}}}),(0, _utils.default)("ImportAttribute",{visitor:["key","value"],fields:{key:{validate:(0, _utils.assertNodeType)("Identifier","StringLiteral")},value:{validate:(0, _utils.assertNodeType)("StringLiteral")}}}),(0, _utils.default)("Decorator",{visitor:["expression"],fields:{expression:{validate:(0, _utils.assertNodeType)("Expression")}}}),(0, _utils.default)("DoExpression",{visitor:["body"],builder:["body","async"],aliases:["Expression"],fields:{body:{validate:(0, _utils.assertNodeType)("BlockStatement")},async:{validate:(0, _utils.assertValueType)("boolean"),default:!1}}}),(0, _utils.default)("ExportDefaultSpecifier",{visitor:["exported"],aliases:["ModuleSpecifier"],fields:{exported:{validate:(0, _utils.assertNodeType)("Identifier")}}}),(0, _utils.default)("RecordExpression",{visitor:["properties"],aliases:["Expression"],fields:{properties:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty","SpreadElement")))}}}),(0, _utils.default)("TupleExpression",{fields:{elements:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Expression","SpreadElement"))),default:[]}},visitor:["elements"],aliases:["Expression"]}),(0, _utils.default)("DecimalLiteral",{builder:["value"],fields:{value:{validate:(0, _utils.assertValueType)("string")}},aliases:["Expression","Pureish","Literal","Immutable"]}),(0, _utils.default)("ModuleExpression",{visitor:["body"],fields:{body:{validate:(0, _utils.assertNodeType)("Program")}},aliases:["Expression"]}),(0, _utils.default)("TopicReference",{aliases:["Expression"]}),(0, _utils.default)("PipelineTopicExpression",{builder:["expression"],visitor:["expression"],fields:{expression:{validate:(0, _utils.assertNodeType)("Expression")}},aliases:["Expression"]}),(0, _utils.default)("PipelineBareFunction",{builder:["callee"],visitor:["callee"],fields:{callee:{validate:(0, _utils.assertNodeType)("Expression")}},aliases:["Expression"]}),(0, _utils.default)("PipelinePrimaryTopicReference",{aliases:["Expression"]});},"./node_modules/@babel/types/lib/definitions/flow.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{var _utils=__webpack_require__("./node_modules/@babel/types/lib/definitions/utils.js");const defineType=(0, _utils.defineAliasedType)("Flow"),defineInterfaceishType=(name,typeParameterType="TypeParameterDeclaration")=>{defineType(name,{builder:["id","typeParameters","extends","body"],visitor:["id","typeParameters","extends","mixins","implements","body"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0, _utils.validateType)("Identifier"),typeParameters:(0, _utils.validateOptionalType)(typeParameterType),extends:(0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),mixins:(0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),implements:(0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements")),body:(0, _utils.validateType)("ObjectTypeAnnotation")}});};defineType("AnyTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),defineType("ArrayTypeAnnotation",{visitor:["elementType"],aliases:["FlowType"],fields:{elementType:(0, _utils.validateType)("FlowType")}}),defineType("BooleanTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),defineType("BooleanLiteralTypeAnnotation",{builder:["value"],aliases:["FlowType"],fields:{value:(0, _utils.validate)((0, _utils.assertValueType)("boolean"))}}),defineType("NullLiteralTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),defineType("ClassImplements",{visitor:["id","typeParameters"],fields:{id:(0, _utils.validateType)("Identifier"),typeParameters:(0, _utils.validateOptionalType)("TypeParameterInstantiation")}}),defineInterfaceishType("DeclareClass"),defineType("DeclareFunction",{visitor:["id"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0, _utils.validateType)("Identifier"),predicate:(0, _utils.validateOptionalType)("DeclaredPredicate")}}),defineInterfaceishType("DeclareInterface"),defineType("DeclareModule",{builder:["id","body","kind"],visitor:["id","body"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0, _utils.validateType)(["Identifier","StringLiteral"]),body:(0, _utils.validateType)("BlockStatement"),kind:(0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS","ES"))}}),defineType("DeclareModuleExports",{visitor:["typeAnnotation"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{typeAnnotation:(0, _utils.validateType)("TypeAnnotation")}}),defineType("DeclareTypeAlias",{visitor:["id","typeParameters","right"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0, _utils.validateType)("Identifier"),typeParameters:(0, _utils.validateOptionalType)("TypeParameterDeclaration"),right:(0, _utils.validateType)("FlowType")}}),defineType("DeclareOpaqueType",{visitor:["id","typeParameters","supertype"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0, _utils.validateType)("Identifier"),typeParameters:(0, _utils.validateOptionalType)("TypeParameterDeclaration"),supertype:(0, _utils.validateOptionalType)("FlowType"),impltype:(0, _utils.validateOptionalType)("FlowType")}}),defineType("DeclareVariable",{visitor:["id"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0, _utils.validateType)("Identifier")}}),defineType("DeclareExportDeclaration",{visitor:["declaration","specifiers","source"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{declaration:(0, _utils.validateOptionalType)("Flow"),specifiers:(0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier","ExportNamespaceSpecifier"])),source:(0, _utils.validateOptionalType)("StringLiteral"),default:(0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))}}),defineType("DeclareExportAllDeclaration",{visitor:["source"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{source:(0, _utils.validateType)("StringLiteral"),exportKind:(0, _utils.validateOptional)((0, _utils.assertOneOf)("type","value"))}}),defineType("DeclaredPredicate",{visitor:["value"],aliases:["FlowPredicate"],fields:{value:(0, _utils.validateType)("Flow")}}),defineType("ExistsTypeAnnotation",{aliases:["FlowType"]}),defineType("FunctionTypeAnnotation",{visitor:["typeParameters","params","rest","returnType"],aliases:["FlowType"],fields:{typeParameters:(0, _utils.validateOptionalType)("TypeParameterDeclaration"),params:(0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),rest:(0, _utils.validateOptionalType)("FunctionTypeParam"),this:(0, _utils.validateOptionalType)("FunctionTypeParam"),returnType:(0, _utils.validateType)("FlowType")}}),defineType("FunctionTypeParam",{visitor:["name","typeAnnotation"],fields:{name:(0, _utils.validateOptionalType)("Identifier"),typeAnnotation:(0, _utils.validateType)("FlowType"),optional:(0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))}}),defineType("GenericTypeAnnotation",{visitor:["id","typeParameters"],aliases:["FlowType"],fields:{id:(0, _utils.validateType)(["Identifier","QualifiedTypeIdentifier"]),typeParameters:(0, _utils.validateOptionalType)("TypeParameterInstantiation")}}),defineType("InferredPredicate",{aliases:["FlowPredicate"]}),defineType("InterfaceExtends",{visitor:["id","typeParameters"],fields:{id:(0, _utils.validateType)(["Identifier","QualifiedTypeIdentifier"]),typeParameters:(0, _utils.validateOptionalType)("TypeParameterInstantiation")}}),defineInterfaceishType("InterfaceDeclaration"),defineType("InterfaceTypeAnnotation",{visitor:["extends","body"],aliases:["FlowType"],fields:{extends:(0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),body:(0, _utils.validateType)("ObjectTypeAnnotation")}}),defineType("IntersectionTypeAnnotation",{visitor:["types"],aliases:["FlowType"],fields:{types:(0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))}}),defineType("MixedTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),defineType("EmptyTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),defineType("NullableTypeAnnotation",{visitor:["typeAnnotation"],aliases:["FlowType"],fields:{typeAnnotation:(0, _utils.validateType)("FlowType")}}),defineType("NumberLiteralTypeAnnotation",{builder:["value"],aliases:["FlowType"],fields:{value:(0, _utils.validate)((0, _utils.assertValueType)("number"))}}),defineType("NumberTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),defineType("ObjectTypeAnnotation",{visitor:["properties","indexers","callProperties","internalSlots"],aliases:["FlowType"],builder:["properties","indexers","callProperties","internalSlots","exact"],fields:{properties:(0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty","ObjectTypeSpreadProperty"])),indexers:(0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeIndexer")),callProperties:(0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeCallProperty")),internalSlots:(0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeInternalSlot")),exact:{validate:(0, _utils.assertValueType)("boolean"),default:!1},inexact:(0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))}}),defineType("ObjectTypeInternalSlot",{visitor:["id","value","optional","static","method"],aliases:["UserWhitespacable"],fields:{id:(0, _utils.validateType)("Identifier"),value:(0, _utils.validateType)("FlowType"),optional:(0, _utils.validate)((0, _utils.assertValueType)("boolean")),static:(0, _utils.validate)((0, _utils.assertValueType)("boolean")),method:(0, _utils.validate)((0, _utils.assertValueType)("boolean"))}}),defineType("ObjectTypeCallProperty",{visitor:["value"],aliases:["UserWhitespacable"],fields:{value:(0, _utils.validateType)("FlowType"),static:(0, _utils.validate)((0, _utils.assertValueType)("boolean"))}}),defineType("ObjectTypeIndexer",{visitor:["id","key","value","variance"],aliases:["UserWhitespacable"],fields:{id:(0, _utils.validateOptionalType)("Identifier"),key:(0, _utils.validateType)("FlowType"),value:(0, _utils.validateType)("FlowType"),static:(0, _utils.validate)((0, _utils.assertValueType)("boolean")),variance:(0, _utils.validateOptionalType)("Variance")}}),defineType("ObjectTypeProperty",{visitor:["key","value","variance"],aliases:["UserWhitespacable"],fields:{key:(0, _utils.validateType)(["Identifier","StringLiteral"]),value:(0, _utils.validateType)("FlowType"),kind:(0, _utils.validate)((0, _utils.assertOneOf)("init","get","set")),static:(0, _utils.validate)((0, _utils.assertValueType)("boolean")),proto:(0, _utils.validate)((0, _utils.assertValueType)("boolean")),optional:(0, _utils.validate)((0, _utils.assertValueType)("boolean")),variance:(0, _utils.validateOptionalType)("Variance"),method:(0, _utils.validate)((0, _utils.assertValueType)("boolean"))}}),defineType("ObjectTypeSpreadProperty",{visitor:["argument"],aliases:["UserWhitespacable"],fields:{argument:(0, _utils.validateType)("FlowType")}}),defineType("OpaqueType",{visitor:["id","typeParameters","supertype","impltype"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0, _utils.validateType)("Identifier"),typeParameters:(0, _utils.validateOptionalType)("TypeParameterDeclaration"),supertype:(0, _utils.validateOptionalType)("FlowType"),impltype:(0, _utils.validateType)("FlowType")}}),defineType("QualifiedTypeIdentifier",{visitor:["id","qualification"],fields:{id:(0, _utils.validateType)("Identifier"),qualification:(0, _utils.validateType)(["Identifier","QualifiedTypeIdentifier"])}}),defineType("StringLiteralTypeAnnotation",{builder:["value"],aliases:["FlowType"],fields:{value:(0, _utils.validate)((0, _utils.assertValueType)("string"))}}),defineType("StringTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),defineType("SymbolTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),defineType("ThisTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),defineType("TupleTypeAnnotation",{visitor:["types"],aliases:["FlowType"],fields:{types:(0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))}}),defineType("TypeofTypeAnnotation",{visitor:["argument"],aliases:["FlowType"],fields:{argument:(0, _utils.validateType)("FlowType")}}),defineType("TypeAlias",{visitor:["id","typeParameters","right"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0, _utils.validateType)("Identifier"),typeParameters:(0, _utils.validateOptionalType)("TypeParameterDeclaration"),right:(0, _utils.validateType)("FlowType")}}),defineType("TypeAnnotation",{visitor:["typeAnnotation"],fields:{typeAnnotation:(0, _utils.validateType)("FlowType")}}),defineType("TypeCastExpression",{visitor:["expression","typeAnnotation"],aliases:["ExpressionWrapper","Expression"],fields:{expression:(0, _utils.validateType)("Expression"),typeAnnotation:(0, _utils.validateType)("TypeAnnotation")}}),defineType("TypeParameter",{visitor:["bound","default","variance"],fields:{name:(0, _utils.validate)((0, _utils.assertValueType)("string")),bound:(0, _utils.validateOptionalType)("TypeAnnotation"),default:(0, _utils.validateOptionalType)("FlowType"),variance:(0, _utils.validateOptionalType)("Variance")}}),defineType("TypeParameterDeclaration",{visitor:["params"],fields:{params:(0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))}}),defineType("TypeParameterInstantiation",{visitor:["params"],fields:{params:(0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))}}),defineType("UnionTypeAnnotation",{visitor:["types"],aliases:["FlowType"],fields:{types:(0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))}}),defineType("Variance",{builder:["kind"],fields:{kind:(0, _utils.validate)((0, _utils.assertOneOf)("minus","plus"))}}),defineType("VoidTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),defineType("EnumDeclaration",{aliases:["Statement","Declaration"],visitor:["id","body"],fields:{id:(0, _utils.validateType)("Identifier"),body:(0, _utils.validateType)(["EnumBooleanBody","EnumNumberBody","EnumStringBody","EnumSymbolBody"])}}),defineType("EnumBooleanBody",{aliases:["EnumBody"],visitor:["members"],fields:{explicitType:(0, _utils.validate)((0, _utils.assertValueType)("boolean")),members:(0, _utils.validateArrayOfType)("EnumBooleanMember"),hasUnknownMembers:(0, _utils.validate)((0, _utils.assertValueType)("boolean"))}}),defineType("EnumNumberBody",{aliases:["EnumBody"],visitor:["members"],fields:{explicitType:(0, _utils.validate)((0, _utils.assertValueType)("boolean")),members:(0, _utils.validateArrayOfType)("EnumNumberMember"),hasUnknownMembers:(0, _utils.validate)((0, _utils.assertValueType)("boolean"))}}),defineType("EnumStringBody",{aliases:["EnumBody"],visitor:["members"],fields:{explicitType:(0, _utils.validate)((0, _utils.assertValueType)("boolean")),members:(0, _utils.validateArrayOfType)(["EnumStringMember","EnumDefaultedMember"]),hasUnknownMembers:(0, _utils.validate)((0, _utils.assertValueType)("boolean"))}}),defineType("EnumSymbolBody",{aliases:["EnumBody"],visitor:["members"],fields:{members:(0, _utils.validateArrayOfType)("EnumDefaultedMember"),hasUnknownMembers:(0, _utils.validate)((0, _utils.assertValueType)("boolean"))}}),defineType("EnumBooleanMember",{aliases:["EnumMember"],visitor:["id"],fields:{id:(0, _utils.validateType)("Identifier"),init:(0, _utils.validateType)("BooleanLiteral")}}),defineType("EnumNumberMember",{aliases:["EnumMember"],visitor:["id","init"],fields:{id:(0, _utils.validateType)("Identifier"),init:(0, _utils.validateType)("NumericLiteral")}}),defineType("EnumStringMember",{aliases:["EnumMember"],visitor:["id","init"],fields:{id:(0, _utils.validateType)("Identifier"),init:(0, _utils.validateType)("StringLiteral")}}),defineType("EnumDefaultedMember",{aliases:["EnumMember"],visitor:["id"],fields:{id:(0, _utils.validateType)("Identifier")}}),defineType("IndexedAccessType",{visitor:["objectType","indexType"],aliases:["FlowType"],fields:{objectType:(0, _utils.validateType)("FlowType"),indexType:(0, _utils.validateType)("FlowType")}}),defineType("OptionalIndexedAccessType",{visitor:["objectType","indexType"],aliases:["FlowType"],fields:{objectType:(0, _utils.validateType)("FlowType"),indexType:(0, _utils.validateType)("FlowType"),optional:(0, _utils.validate)((0, _utils.assertValueType)("boolean"))}});},"./node_modules/@babel/types/lib/definitions/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"ALIAS_KEYS",{enumerable:!0,get:function(){return _utils.ALIAS_KEYS}}),Object.defineProperty(exports,"BUILDER_KEYS",{enumerable:!0,get:function(){return _utils.BUILDER_KEYS}}),Object.defineProperty(exports,"DEPRECATED_KEYS",{enumerable:!0,get:function(){return _utils.DEPRECATED_KEYS}}),Object.defineProperty(exports,"FLIPPED_ALIAS_KEYS",{enumerable:!0,get:function(){return _utils.FLIPPED_ALIAS_KEYS}}),Object.defineProperty(exports,"NODE_FIELDS",{enumerable:!0,get:function(){return _utils.NODE_FIELDS}}),Object.defineProperty(exports,"NODE_PARENT_VALIDATIONS",{enumerable:!0,get:function(){return _utils.NODE_PARENT_VALIDATIONS}}),Object.defineProperty(exports,"PLACEHOLDERS",{enumerable:!0,get:function(){return _placeholders.PLACEHOLDERS}}),Object.defineProperty(exports,"PLACEHOLDERS_ALIAS",{enumerable:!0,get:function(){return _placeholders.PLACEHOLDERS_ALIAS}}),Object.defineProperty(exports,"PLACEHOLDERS_FLIPPED_ALIAS",{enumerable:!0,get:function(){return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS}}),exports.TYPES=void 0,Object.defineProperty(exports,"VISITOR_KEYS",{enumerable:!0,get:function(){return _utils.VISITOR_KEYS}});var _toFastProperties=__webpack_require__("./node_modules/to-fast-properties/index.js");__webpack_require__("./node_modules/@babel/types/lib/definitions/core.js"),__webpack_require__("./node_modules/@babel/types/lib/definitions/flow.js"),__webpack_require__("./node_modules/@babel/types/lib/definitions/jsx.js"),__webpack_require__("./node_modules/@babel/types/lib/definitions/misc.js"),__webpack_require__("./node_modules/@babel/types/lib/definitions/experimental.js"),__webpack_require__("./node_modules/@babel/types/lib/definitions/typescript.js");var _utils=__webpack_require__("./node_modules/@babel/types/lib/definitions/utils.js"),_placeholders=__webpack_require__("./node_modules/@babel/types/lib/definitions/placeholders.js");_toFastProperties(_utils.VISITOR_KEYS),_toFastProperties(_utils.ALIAS_KEYS),_toFastProperties(_utils.FLIPPED_ALIAS_KEYS),_toFastProperties(_utils.NODE_FIELDS),_toFastProperties(_utils.BUILDER_KEYS),_toFastProperties(_utils.DEPRECATED_KEYS),_toFastProperties(_placeholders.PLACEHOLDERS_ALIAS),_toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);const TYPES=[].concat(Object.keys(_utils.VISITOR_KEYS),Object.keys(_utils.FLIPPED_ALIAS_KEYS),Object.keys(_utils.DEPRECATED_KEYS));exports.TYPES=TYPES;},"./node_modules/@babel/types/lib/definitions/jsx.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{var _utils=__webpack_require__("./node_modules/@babel/types/lib/definitions/utils.js");const defineType=(0, _utils.defineAliasedType)("JSX");defineType("JSXAttribute",{visitor:["name","value"],aliases:["Immutable"],fields:{name:{validate:(0, _utils.assertNodeType)("JSXIdentifier","JSXNamespacedName")},value:{optional:!0,validate:(0, _utils.assertNodeType)("JSXElement","JSXFragment","StringLiteral","JSXExpressionContainer")}}}),defineType("JSXClosingElement",{visitor:["name"],aliases:["Immutable"],fields:{name:{validate:(0, _utils.assertNodeType)("JSXIdentifier","JSXMemberExpression","JSXNamespacedName")}}}),defineType("JSXElement",{builder:["openingElement","closingElement","children","selfClosing"],visitor:["openingElement","children","closingElement"],aliases:["Immutable","Expression"],fields:{openingElement:{validate:(0, _utils.assertNodeType)("JSXOpeningElement")},closingElement:{optional:!0,validate:(0, _utils.assertNodeType)("JSXClosingElement")},children:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText","JSXExpressionContainer","JSXSpreadChild","JSXElement","JSXFragment")))},selfClosing:{validate:(0, _utils.assertValueType)("boolean"),optional:!0}}}),defineType("JSXEmptyExpression",{}),defineType("JSXExpressionContainer",{visitor:["expression"],aliases:["Immutable"],fields:{expression:{validate:(0, _utils.assertNodeType)("Expression","JSXEmptyExpression")}}}),defineType("JSXSpreadChild",{visitor:["expression"],aliases:["Immutable"],fields:{expression:{validate:(0, _utils.assertNodeType)("Expression")}}}),defineType("JSXIdentifier",{builder:["name"],fields:{name:{validate:(0, _utils.assertValueType)("string")}}}),defineType("JSXMemberExpression",{visitor:["object","property"],fields:{object:{validate:(0, _utils.assertNodeType)("JSXMemberExpression","JSXIdentifier")},property:{validate:(0, _utils.assertNodeType)("JSXIdentifier")}}}),defineType("JSXNamespacedName",{visitor:["namespace","name"],fields:{namespace:{validate:(0, _utils.assertNodeType)("JSXIdentifier")},name:{validate:(0, _utils.assertNodeType)("JSXIdentifier")}}}),defineType("JSXOpeningElement",{builder:["name","attributes","selfClosing"],visitor:["name","attributes"],aliases:["Immutable"],fields:{name:{validate:(0, _utils.assertNodeType)("JSXIdentifier","JSXMemberExpression","JSXNamespacedName")},selfClosing:{default:!1},attributes:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute","JSXSpreadAttribute")))},typeParameters:{validate:(0, _utils.assertNodeType)("TypeParameterInstantiation","TSTypeParameterInstantiation"),optional:!0}}}),defineType("JSXSpreadAttribute",{visitor:["argument"],fields:{argument:{validate:(0, _utils.assertNodeType)("Expression")}}}),defineType("JSXText",{aliases:["Immutable"],builder:["value"],fields:{value:{validate:(0, _utils.assertValueType)("string")}}}),defineType("JSXFragment",{builder:["openingFragment","closingFragment","children"],visitor:["openingFragment","children","closingFragment"],aliases:["Immutable","Expression"],fields:{openingFragment:{validate:(0, _utils.assertNodeType)("JSXOpeningFragment")},closingFragment:{validate:(0, _utils.assertNodeType)("JSXClosingFragment")},children:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText","JSXExpressionContainer","JSXSpreadChild","JSXElement","JSXFragment")))}}}),defineType("JSXOpeningFragment",{aliases:["Immutable"]}),defineType("JSXClosingFragment",{aliases:["Immutable"]});},"./node_modules/@babel/types/lib/definitions/misc.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{var _utils=__webpack_require__("./node_modules/@babel/types/lib/definitions/utils.js"),_placeholders=__webpack_require__("./node_modules/@babel/types/lib/definitions/placeholders.js");const defineType=(0, _utils.defineAliasedType)("Miscellaneous");defineType("Noop",{visitor:[]}),defineType("Placeholder",{visitor:[],builder:["expectedNode","name"],fields:{name:{validate:(0, _utils.assertNodeType)("Identifier")},expectedNode:{validate:(0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)}}}),defineType("V8IntrinsicIdentifier",{builder:["name"],fields:{name:{validate:(0, _utils.assertValueType)("string")}}});},"./node_modules/@babel/types/lib/definitions/placeholders.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.PLACEHOLDERS_FLIPPED_ALIAS=exports.PLACEHOLDERS_ALIAS=exports.PLACEHOLDERS=void 0;var _utils=__webpack_require__("./node_modules/@babel/types/lib/definitions/utils.js");const PLACEHOLDERS=["Identifier","StringLiteral","Expression","Statement","Declaration","BlockStatement","ClassBody","Pattern"];exports.PLACEHOLDERS=PLACEHOLDERS;const PLACEHOLDERS_ALIAS={Declaration:["Statement"],Pattern:["PatternLike","LVal"]};exports.PLACEHOLDERS_ALIAS=PLACEHOLDERS_ALIAS;for(const type of PLACEHOLDERS){const alias=_utils.ALIAS_KEYS[type];null!=alias&&alias.length&&(PLACEHOLDERS_ALIAS[type]=alias);}const PLACEHOLDERS_FLIPPED_ALIAS={};exports.PLACEHOLDERS_FLIPPED_ALIAS=PLACEHOLDERS_FLIPPED_ALIAS,Object.keys(PLACEHOLDERS_ALIAS).forEach((type=>{PLACEHOLDERS_ALIAS[type].forEach((alias=>{Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS,alias)||(PLACEHOLDERS_FLIPPED_ALIAS[alias]=[]),PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);}));}));},"./node_modules/@babel/types/lib/definitions/typescript.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{var _utils=__webpack_require__("./node_modules/@babel/types/lib/definitions/utils.js"),_core=__webpack_require__("./node_modules/@babel/types/lib/definitions/core.js"),_is=__webpack_require__("./node_modules/@babel/types/lib/validators/is.js");const defineType=(0, _utils.defineAliasedType)("TypeScript"),bool=(0, _utils.assertValueType)("boolean"),tSFunctionTypeAnnotationCommon={returnType:{validate:(0, _utils.assertNodeType)("TSTypeAnnotation","Noop"),optional:!0},typeParameters:{validate:(0, _utils.assertNodeType)("TSTypeParameterDeclaration","Noop"),optional:!0}};defineType("TSParameterProperty",{aliases:["LVal"],visitor:["parameter"],fields:{accessibility:{validate:(0, _utils.assertOneOf)("public","private","protected"),optional:!0},readonly:{validate:(0, _utils.assertValueType)("boolean"),optional:!0},parameter:{validate:(0, _utils.assertNodeType)("Identifier","AssignmentPattern")},override:{validate:(0, _utils.assertValueType)("boolean"),optional:!0},decorators:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),optional:!0}}}),defineType("TSDeclareFunction",{aliases:["Statement","Declaration"],visitor:["id","typeParameters","params","returnType"],fields:Object.assign({},_core.functionDeclarationCommon,tSFunctionTypeAnnotationCommon)}),defineType("TSDeclareMethod",{visitor:["decorators","key","typeParameters","params","returnType"],fields:Object.assign({},_core.classMethodOrDeclareMethodCommon,tSFunctionTypeAnnotationCommon)}),defineType("TSQualifiedName",{aliases:["TSEntityName"],visitor:["left","right"],fields:{left:(0, _utils.validateType)("TSEntityName"),right:(0, _utils.validateType)("Identifier")}});const signatureDeclarationCommon={typeParameters:(0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),parameters:(0, _utils.validateArrayOfType)(["Identifier","RestElement"]),typeAnnotation:(0, _utils.validateOptionalType)("TSTypeAnnotation")},callConstructSignatureDeclaration={aliases:["TSTypeElement"],visitor:["typeParameters","parameters","typeAnnotation"],fields:signatureDeclarationCommon};defineType("TSCallSignatureDeclaration",callConstructSignatureDeclaration),defineType("TSConstructSignatureDeclaration",callConstructSignatureDeclaration);const namedTypeElementCommon={key:(0, _utils.validateType)("Expression"),computed:(0, _utils.validate)(bool),optional:(0, _utils.validateOptional)(bool)};defineType("TSPropertySignature",{aliases:["TSTypeElement"],visitor:["key","typeAnnotation","initializer"],fields:Object.assign({},namedTypeElementCommon,{readonly:(0, _utils.validateOptional)(bool),typeAnnotation:(0, _utils.validateOptionalType)("TSTypeAnnotation"),initializer:(0, _utils.validateOptionalType)("Expression"),kind:{validate:(0, _utils.assertOneOf)("get","set")}})}),defineType("TSMethodSignature",{aliases:["TSTypeElement"],visitor:["key","typeParameters","parameters","typeAnnotation"],fields:Object.assign({},signatureDeclarationCommon,namedTypeElementCommon,{kind:{validate:(0, _utils.assertOneOf)("method","get","set")}})}),defineType("TSIndexSignature",{aliases:["TSTypeElement"],visitor:["parameters","typeAnnotation"],fields:{readonly:(0, _utils.validateOptional)(bool),static:(0, _utils.validateOptional)(bool),parameters:(0, _utils.validateArrayOfType)("Identifier"),typeAnnotation:(0, _utils.validateOptionalType)("TSTypeAnnotation")}});const tsKeywordTypes=["TSAnyKeyword","TSBooleanKeyword","TSBigIntKeyword","TSIntrinsicKeyword","TSNeverKeyword","TSNullKeyword","TSNumberKeyword","TSObjectKeyword","TSStringKeyword","TSSymbolKeyword","TSUndefinedKeyword","TSUnknownKeyword","TSVoidKeyword"];for(const type of tsKeywordTypes)defineType(type,{aliases:["TSType","TSBaseType"],visitor:[],fields:{}});defineType("TSThisType",{aliases:["TSType","TSBaseType"],visitor:[],fields:{}});const fnOrCtrBase={aliases:["TSType"],visitor:["typeParameters","parameters","typeAnnotation"]};defineType("TSFunctionType",Object.assign({},fnOrCtrBase,{fields:signatureDeclarationCommon})),defineType("TSConstructorType",Object.assign({},fnOrCtrBase,{fields:Object.assign({},signatureDeclarationCommon,{abstract:(0, _utils.validateOptional)(bool)})})),defineType("TSTypeReference",{aliases:["TSType"],visitor:["typeName","typeParameters"],fields:{typeName:(0, _utils.validateType)("TSEntityName"),typeParameters:(0, _utils.validateOptionalType)("TSTypeParameterInstantiation")}}),defineType("TSTypePredicate",{aliases:["TSType"],visitor:["parameterName","typeAnnotation"],builder:["parameterName","typeAnnotation","asserts"],fields:{parameterName:(0, _utils.validateType)(["Identifier","TSThisType"]),typeAnnotation:(0, _utils.validateOptionalType)("TSTypeAnnotation"),asserts:(0, _utils.validateOptional)(bool)}}),defineType("TSTypeQuery",{aliases:["TSType"],visitor:["exprName"],fields:{exprName:(0, _utils.validateType)(["TSEntityName","TSImportType"])}}),defineType("TSTypeLiteral",{aliases:["TSType"],visitor:["members"],fields:{members:(0, _utils.validateArrayOfType)("TSTypeElement")}}),defineType("TSArrayType",{aliases:["TSType"],visitor:["elementType"],fields:{elementType:(0, _utils.validateType)("TSType")}}),defineType("TSTupleType",{aliases:["TSType"],visitor:["elementTypes"],fields:{elementTypes:(0, _utils.validateArrayOfType)(["TSType","TSNamedTupleMember"])}}),defineType("TSOptionalType",{aliases:["TSType"],visitor:["typeAnnotation"],fields:{typeAnnotation:(0, _utils.validateType)("TSType")}}),defineType("TSRestType",{aliases:["TSType"],visitor:["typeAnnotation"],fields:{typeAnnotation:(0, _utils.validateType)("TSType")}}),defineType("TSNamedTupleMember",{visitor:["label","elementType"],builder:["label","elementType","optional"],fields:{label:(0, _utils.validateType)("Identifier"),optional:{validate:bool,default:!1},elementType:(0, _utils.validateType)("TSType")}});const unionOrIntersection={aliases:["TSType"],visitor:["types"],fields:{types:(0, _utils.validateArrayOfType)("TSType")}};defineType("TSUnionType",unionOrIntersection),defineType("TSIntersectionType",unionOrIntersection),defineType("TSConditionalType",{aliases:["TSType"],visitor:["checkType","extendsType","trueType","falseType"],fields:{checkType:(0, _utils.validateType)("TSType"),extendsType:(0, _utils.validateType)("TSType"),trueType:(0, _utils.validateType)("TSType"),falseType:(0, _utils.validateType)("TSType")}}),defineType("TSInferType",{aliases:["TSType"],visitor:["typeParameter"],fields:{typeParameter:(0, _utils.validateType)("TSTypeParameter")}}),defineType("TSParenthesizedType",{aliases:["TSType"],visitor:["typeAnnotation"],fields:{typeAnnotation:(0, _utils.validateType)("TSType")}}),defineType("TSTypeOperator",{aliases:["TSType"],visitor:["typeAnnotation"],fields:{operator:(0, _utils.validate)((0, _utils.assertValueType)("string")),typeAnnotation:(0, _utils.validateType)("TSType")}}),defineType("TSIndexedAccessType",{aliases:["TSType"],visitor:["objectType","indexType"],fields:{objectType:(0, _utils.validateType)("TSType"),indexType:(0, _utils.validateType)("TSType")}}),defineType("TSMappedType",{aliases:["TSType"],visitor:["typeParameter","typeAnnotation","nameType"],fields:{readonly:(0, _utils.validateOptional)(bool),typeParameter:(0, _utils.validateType)("TSTypeParameter"),optional:(0, _utils.validateOptional)(bool),typeAnnotation:(0, _utils.validateOptionalType)("TSType"),nameType:(0, _utils.validateOptionalType)("TSType")}}),defineType("TSLiteralType",{aliases:["TSType","TSBaseType"],visitor:["literal"],fields:{literal:{validate:function(){const unaryExpression=(0, _utils.assertNodeType)("NumericLiteral","BigIntLiteral"),unaryOperator=(0, _utils.assertOneOf)("-"),literal=(0, _utils.assertNodeType)("NumericLiteral","StringLiteral","BooleanLiteral","BigIntLiteral");function validator(parent,key,node){(0, _is.default)("UnaryExpression",node)?(unaryOperator(node,"operator",node.operator),unaryExpression(node,"argument",node.argument)):literal(parent,key,node);}return validator.oneOfNodeTypes=["NumericLiteral","StringLiteral","BooleanLiteral","BigIntLiteral","UnaryExpression"],validator}()}}}),defineType("TSExpressionWithTypeArguments",{aliases:["TSType"],visitor:["expression","typeParameters"],fields:{expression:(0, _utils.validateType)("TSEntityName"),typeParameters:(0, _utils.validateOptionalType)("TSTypeParameterInstantiation")}}),defineType("TSInterfaceDeclaration",{aliases:["Statement","Declaration"],visitor:["id","typeParameters","extends","body"],fields:{declare:(0, _utils.validateOptional)(bool),id:(0, _utils.validateType)("Identifier"),typeParameters:(0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),extends:(0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),body:(0, _utils.validateType)("TSInterfaceBody")}}),defineType("TSInterfaceBody",{visitor:["body"],fields:{body:(0, _utils.validateArrayOfType)("TSTypeElement")}}),defineType("TSTypeAliasDeclaration",{aliases:["Statement","Declaration"],visitor:["id","typeParameters","typeAnnotation"],fields:{declare:(0, _utils.validateOptional)(bool),id:(0, _utils.validateType)("Identifier"),typeParameters:(0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),typeAnnotation:(0, _utils.validateType)("TSType")}}),defineType("TSAsExpression",{aliases:["Expression"],visitor:["expression","typeAnnotation"],fields:{expression:(0, _utils.validateType)("Expression"),typeAnnotation:(0, _utils.validateType)("TSType")}}),defineType("TSTypeAssertion",{aliases:["Expression"],visitor:["typeAnnotation","expression"],fields:{typeAnnotation:(0, _utils.validateType)("TSType"),expression:(0, _utils.validateType)("Expression")}}),defineType("TSEnumDeclaration",{aliases:["Statement","Declaration"],visitor:["id","members"],fields:{declare:(0, _utils.validateOptional)(bool),const:(0, _utils.validateOptional)(bool),id:(0, _utils.validateType)("Identifier"),members:(0, _utils.validateArrayOfType)("TSEnumMember"),initializer:(0, _utils.validateOptionalType)("Expression")}}),defineType("TSEnumMember",{visitor:["id","initializer"],fields:{id:(0, _utils.validateType)(["Identifier","StringLiteral"]),initializer:(0, _utils.validateOptionalType)("Expression")}}),defineType("TSModuleDeclaration",{aliases:["Statement","Declaration"],visitor:["id","body"],fields:{declare:(0, _utils.validateOptional)(bool),global:(0, _utils.validateOptional)(bool),id:(0, _utils.validateType)(["Identifier","StringLiteral"]),body:(0, _utils.validateType)(["TSModuleBlock","TSModuleDeclaration"])}}),defineType("TSModuleBlock",{aliases:["Scopable","Block","BlockParent"],visitor:["body"],fields:{body:(0, _utils.validateArrayOfType)("Statement")}}),defineType("TSImportType",{aliases:["TSType"],visitor:["argument","qualifier","typeParameters"],fields:{argument:(0, _utils.validateType)("StringLiteral"),qualifier:(0, _utils.validateOptionalType)("TSEntityName"),typeParameters:(0, _utils.validateOptionalType)("TSTypeParameterInstantiation")}}),defineType("TSImportEqualsDeclaration",{aliases:["Statement"],visitor:["id","moduleReference"],fields:{isExport:(0, _utils.validate)(bool),id:(0, _utils.validateType)("Identifier"),moduleReference:(0, _utils.validateType)(["TSEntityName","TSExternalModuleReference"]),importKind:{validate:(0, _utils.assertOneOf)("type","value"),optional:!0}}}),defineType("TSExternalModuleReference",{visitor:["expression"],fields:{expression:(0, _utils.validateType)("StringLiteral")}}),defineType("TSNonNullExpression",{aliases:["Expression"],visitor:["expression"],fields:{expression:(0, _utils.validateType)("Expression")}}),defineType("TSExportAssignment",{aliases:["Statement"],visitor:["expression"],fields:{expression:(0, _utils.validateType)("Expression")}}),defineType("TSNamespaceExportDeclaration",{aliases:["Statement"],visitor:["id"],fields:{id:(0, _utils.validateType)("Identifier")}}),defineType("TSTypeAnnotation",{visitor:["typeAnnotation"],fields:{typeAnnotation:{validate:(0, _utils.assertNodeType)("TSType")}}}),defineType("TSTypeParameterInstantiation",{visitor:["params"],fields:{params:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))}}}),defineType("TSTypeParameterDeclaration",{visitor:["params"],fields:{params:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))}}}),defineType("TSTypeParameter",{builder:["constraint","default","name"],visitor:["constraint","default"],fields:{name:{validate:(0, _utils.assertValueType)("string")},constraint:{validate:(0, _utils.assertNodeType)("TSType"),optional:!0},default:{validate:(0, _utils.assertNodeType)("TSType"),optional:!0}}});},"./node_modules/@babel/types/lib/definitions/utils.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.VISITOR_KEYS=exports.NODE_PARENT_VALIDATIONS=exports.NODE_FIELDS=exports.FLIPPED_ALIAS_KEYS=exports.DEPRECATED_KEYS=exports.BUILDER_KEYS=exports.ALIAS_KEYS=void 0,exports.arrayOf=arrayOf,exports.arrayOfType=arrayOfType,exports.assertEach=assertEach,exports.assertNodeOrValueType=function(...types){function validate(node,key,val){for(const type of types)if(getType(val)===type||(0, _is.default)(type,val))return void(0, _validate.validateChild)(node,key,val);throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(null==val?void 0:val.type)}`)}return validate.oneOfNodeOrValueTypes=types,validate},exports.assertNodeType=assertNodeType,exports.assertOneOf=function(...values){function validate(node,key,val){if(values.indexOf(val)<0)throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`)}return validate.oneOf=values,validate},exports.assertOptionalChainStart=function(){return function(node){var _current;let current=node;for(;node;){const{type}=current;if("OptionalCallExpression"!==type){if("OptionalMemberExpression"!==type)break;if(current.optional)return;current=current.object;}else {if(current.optional)return;current=current.callee;}}throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${null==(_current=current)?void 0:_current.type}`)}},exports.assertShape=function(shape){function validate(node,key,val){const errors=[];for(const property of Object.keys(shape))try{(0,_validate.validateField)(node,property,val[property],shape[property]);}catch(error){if(error instanceof TypeError){errors.push(error.message);continue}throw error}if(errors.length)throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\n${errors.join("\n")}`)}return validate.shapeOf=shape,validate},exports.assertValueType=assertValueType,exports.chain=chain,exports.default=defineType,exports.defineAliasedType=function(...aliases){return (type,opts={})=>{let defined=opts.aliases;var _store$opts$inherits$;defined||(opts.inherits&&(defined=null==(_store$opts$inherits$=store[opts.inherits].aliases)?void 0:_store$opts$inherits$.slice()),null!=defined||(defined=[]),opts.aliases=defined);const additional=aliases.filter((a=>!defined.includes(a)));return defined.unshift(...additional),defineType(type,opts)}},exports.typeIs=typeIs,exports.validate=validate,exports.validateArrayOfType=function(typeName){return validate(arrayOfType(typeName))},exports.validateOptional=function(validate){return {validate,optional:!0}},exports.validateOptionalType=function(typeName){return {validate:typeIs(typeName),optional:!0}},exports.validateType=function(typeName){return validate(typeIs(typeName))};var _is=__webpack_require__("./node_modules/@babel/types/lib/validators/is.js"),_validate=__webpack_require__("./node_modules/@babel/types/lib/validators/validate.js");const VISITOR_KEYS={};exports.VISITOR_KEYS=VISITOR_KEYS;const ALIAS_KEYS={};exports.ALIAS_KEYS=ALIAS_KEYS;const FLIPPED_ALIAS_KEYS={};exports.FLIPPED_ALIAS_KEYS=FLIPPED_ALIAS_KEYS;const NODE_FIELDS={};exports.NODE_FIELDS=NODE_FIELDS;const BUILDER_KEYS={};exports.BUILDER_KEYS=BUILDER_KEYS;const DEPRECATED_KEYS={};exports.DEPRECATED_KEYS=DEPRECATED_KEYS;const NODE_PARENT_VALIDATIONS={};function getType(val){return Array.isArray(val)?"array":null===val?"null":typeof val}function validate(validate){return {validate}}function typeIs(typeName){return "string"==typeof typeName?assertNodeType(typeName):assertNodeType(...typeName)}function arrayOf(elementType){return chain(assertValueType("array"),assertEach(elementType))}function arrayOfType(typeName){return arrayOf(typeIs(typeName))}function assertEach(callback){function validator(node,key,val){if(Array.isArray(val))for(let i=0;i<val.length;i++){const subkey=`${key}[${i}]`,v=val[i];callback(node,subkey,v),process.env.BABEL_TYPES_8_BREAKING&&(0, _validate.validateChild)(node,subkey,v);}}return validator.each=callback,validator}function assertNodeType(...types){function validate(node,key,val){for(const type of types)if((0, _is.default)(type,val))return void(0, _validate.validateChild)(node,key,val);throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(null==val?void 0:val.type)}`)}return validate.oneOfNodeTypes=types,validate}function assertValueType(type){function validate(node,key,val){if(!(getType(val)===type))throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`)}return validate.type=type,validate}function chain(...fns){function validate(...args){for(const fn of fns)fn(...args);}if(validate.chainOf=fns,fns.length>=2&&"type"in fns[0]&&"array"===fns[0].type&&!("each"in fns[1]))throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');return validate}exports.NODE_PARENT_VALIDATIONS=NODE_PARENT_VALIDATIONS;const validTypeOpts=["aliases","builder","deprecatedAlias","fields","inherits","visitor","validate"],validFieldKeys=["default","optional","validate"];function defineType(type,opts={}){const inherits=opts.inherits&&store[opts.inherits]||{};let fields=opts.fields;if(!fields&&(fields={},inherits.fields)){const keys=Object.getOwnPropertyNames(inherits.fields);for(const key of keys){const field=inherits.fields[key],def=field.default;if(Array.isArray(def)?def.length>0:def&&"object"==typeof def)throw new Error("field defaults can only be primitives or empty arrays currently");fields[key]={default:Array.isArray(def)?[]:def,optional:field.optional,validate:field.validate};}}const visitor=opts.visitor||inherits.visitor||[],aliases=opts.aliases||inherits.aliases||[],builder=opts.builder||inherits.builder||opts.visitor||[];for(const k of Object.keys(opts))if(-1===validTypeOpts.indexOf(k))throw new Error(`Unknown type option "${k}" on ${type}`);opts.deprecatedAlias&&(DEPRECATED_KEYS[opts.deprecatedAlias]=type);for(const key of visitor.concat(builder))fields[key]=fields[key]||{};for(const key of Object.keys(fields)){const field=fields[key];void 0!==field.default&&-1===builder.indexOf(key)&&(field.optional=!0),void 0===field.default?field.default=null:field.validate||null==field.default||(field.validate=assertValueType(getType(field.default)));for(const k of Object.keys(field))if(-1===validFieldKeys.indexOf(k))throw new Error(`Unknown field key "${k}" on ${type}.${key}`)}VISITOR_KEYS[type]=opts.visitor=visitor,BUILDER_KEYS[type]=opts.builder=builder,NODE_FIELDS[type]=opts.fields=fields,ALIAS_KEYS[type]=opts.aliases=aliases,aliases.forEach((alias=>{FLIPPED_ALIAS_KEYS[alias]=FLIPPED_ALIAS_KEYS[alias]||[],FLIPPED_ALIAS_KEYS[alias].push(type);})),opts.validate&&(NODE_PARENT_VALIDATIONS[type]=opts.validate),store[type]=opts;}const store={};},"./node_modules/@babel/types/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0});var _exportNames={react:!0,assertNode:!0,createTypeAnnotationBasedOnTypeof:!0,createUnionTypeAnnotation:!0,createFlowUnionType:!0,createTSUnionType:!0,cloneNode:!0,clone:!0,cloneDeep:!0,cloneDeepWithoutLoc:!0,cloneWithoutLoc:!0,addComment:!0,addComments:!0,inheritInnerComments:!0,inheritLeadingComments:!0,inheritsComments:!0,inheritTrailingComments:!0,removeComments:!0,ensureBlock:!0,toBindingIdentifierName:!0,toBlock:!0,toComputedKey:!0,toExpression:!0,toIdentifier:!0,toKeyAlias:!0,toSequenceExpression:!0,toStatement:!0,valueToNode:!0,appendToMemberExpression:!0,inherits:!0,prependToMemberExpression:!0,removeProperties:!0,removePropertiesDeep:!0,removeTypeDuplicates:!0,getBindingIdentifiers:!0,getOuterBindingIdentifiers:!0,traverse:!0,traverseFast:!0,shallowEqual:!0,is:!0,isBinding:!0,isBlockScoped:!0,isImmutable:!0,isLet:!0,isNode:!0,isNodesEquivalent:!0,isPlaceholderType:!0,isReferenced:!0,isScope:!0,isSpecifierDefault:!0,isType:!0,isValidES3Identifier:!0,isValidIdentifier:!0,isVar:!0,matchesPattern:!0,validate:!0,buildMatchMemberExpression:!0};Object.defineProperty(exports,"addComment",{enumerable:!0,get:function(){return _addComment.default}}),Object.defineProperty(exports,"addComments",{enumerable:!0,get:function(){return _addComments.default}}),Object.defineProperty(exports,"appendToMemberExpression",{enumerable:!0,get:function(){return _appendToMemberExpression.default}}),Object.defineProperty(exports,"assertNode",{enumerable:!0,get:function(){return _assertNode.default}}),Object.defineProperty(exports,"buildMatchMemberExpression",{enumerable:!0,get:function(){return _buildMatchMemberExpression.default}}),Object.defineProperty(exports,"clone",{enumerable:!0,get:function(){return _clone.default}}),Object.defineProperty(exports,"cloneDeep",{enumerable:!0,get:function(){return _cloneDeep.default}}),Object.defineProperty(exports,"cloneDeepWithoutLoc",{enumerable:!0,get:function(){return _cloneDeepWithoutLoc.default}}),Object.defineProperty(exports,"cloneNode",{enumerable:!0,get:function(){return _cloneNode.default}}),Object.defineProperty(exports,"cloneWithoutLoc",{enumerable:!0,get:function(){return _cloneWithoutLoc.default}}),Object.defineProperty(exports,"createFlowUnionType",{enumerable:!0,get:function(){return _createFlowUnionType.default}}),Object.defineProperty(exports,"createTSUnionType",{enumerable:!0,get:function(){return _createTSUnionType.default}}),Object.defineProperty(exports,"createTypeAnnotationBasedOnTypeof",{enumerable:!0,get:function(){return _createTypeAnnotationBasedOnTypeof.default}}),Object.defineProperty(exports,"createUnionTypeAnnotation",{enumerable:!0,get:function(){return _createFlowUnionType.default}}),Object.defineProperty(exports,"ensureBlock",{enumerable:!0,get:function(){return _ensureBlock.default}}),Object.defineProperty(exports,"getBindingIdentifiers",{enumerable:!0,get:function(){return _getBindingIdentifiers.default}}),Object.defineProperty(exports,"getOuterBindingIdentifiers",{enumerable:!0,get:function(){return _getOuterBindingIdentifiers.default}}),Object.defineProperty(exports,"inheritInnerComments",{enumerable:!0,get:function(){return _inheritInnerComments.default}}),Object.defineProperty(exports,"inheritLeadingComments",{enumerable:!0,get:function(){return _inheritLeadingComments.default}}),Object.defineProperty(exports,"inheritTrailingComments",{enumerable:!0,get:function(){return _inheritTrailingComments.default}}),Object.defineProperty(exports,"inherits",{enumerable:!0,get:function(){return _inherits.default}}),Object.defineProperty(exports,"inheritsComments",{enumerable:!0,get:function(){return _inheritsComments.default}}),Object.defineProperty(exports,"is",{enumerable:!0,get:function(){return _is.default}}),Object.defineProperty(exports,"isBinding",{enumerable:!0,get:function(){return _isBinding.default}}),Object.defineProperty(exports,"isBlockScoped",{enumerable:!0,get:function(){return _isBlockScoped.default}}),Object.defineProperty(exports,"isImmutable",{enumerable:!0,get:function(){return _isImmutable.default}}),Object.defineProperty(exports,"isLet",{enumerable:!0,get:function(){return _isLet.default}}),Object.defineProperty(exports,"isNode",{enumerable:!0,get:function(){return _isNode.default}}),Object.defineProperty(exports,"isNodesEquivalent",{enumerable:!0,get:function(){return _isNodesEquivalent.default}}),Object.defineProperty(exports,"isPlaceholderType",{enumerable:!0,get:function(){return _isPlaceholderType.default}}),Object.defineProperty(exports,"isReferenced",{enumerable:!0,get:function(){return _isReferenced.default}}),Object.defineProperty(exports,"isScope",{enumerable:!0,get:function(){return _isScope.default}}),Object.defineProperty(exports,"isSpecifierDefault",{enumerable:!0,get:function(){return _isSpecifierDefault.default}}),Object.defineProperty(exports,"isType",{enumerable:!0,get:function(){return _isType.default}}),Object.defineProperty(exports,"isValidES3Identifier",{enumerable:!0,get:function(){return _isValidES3Identifier.default}}),Object.defineProperty(exports,"isValidIdentifier",{enumerable:!0,get:function(){return _isValidIdentifier.default}}),Object.defineProperty(exports,"isVar",{enumerable:!0,get:function(){return _isVar.default}}),Object.defineProperty(exports,"matchesPattern",{enumerable:!0,get:function(){return _matchesPattern.default}}),Object.defineProperty(exports,"prependToMemberExpression",{enumerable:!0,get:function(){return _prependToMemberExpression.default}}),exports.react=void 0,Object.defineProperty(exports,"removeComments",{enumerable:!0,get:function(){return _removeComments.default}}),Object.defineProperty(exports,"removeProperties",{enumerable:!0,get:function(){return _removeProperties.default}}),Object.defineProperty(exports,"removePropertiesDeep",{enumerable:!0,get:function(){return _removePropertiesDeep.default}}),Object.defineProperty(exports,"removeTypeDuplicates",{enumerable:!0,get:function(){return _removeTypeDuplicates.default}}),Object.defineProperty(exports,"shallowEqual",{enumerable:!0,get:function(){return _shallowEqual.default}}),Object.defineProperty(exports,"toBindingIdentifierName",{enumerable:!0,get:function(){return _toBindingIdentifierName.default}}),Object.defineProperty(exports,"toBlock",{enumerable:!0,get:function(){return _toBlock.default}}),Object.defineProperty(exports,"toComputedKey",{enumerable:!0,get:function(){return _toComputedKey.default}}),Object.defineProperty(exports,"toExpression",{enumerable:!0,get:function(){return _toExpression.default}}),Object.defineProperty(exports,"toIdentifier",{enumerable:!0,get:function(){return _toIdentifier.default}}),Object.defineProperty(exports,"toKeyAlias",{enumerable:!0,get:function(){return _toKeyAlias.default}}),Object.defineProperty(exports,"toSequenceExpression",{enumerable:!0,get:function(){return _toSequenceExpression.default}}),Object.defineProperty(exports,"toStatement",{enumerable:!0,get:function(){return _toStatement.default}}),Object.defineProperty(exports,"traverse",{enumerable:!0,get:function(){return _traverse.default}}),Object.defineProperty(exports,"traverseFast",{enumerable:!0,get:function(){return _traverseFast.default}}),Object.defineProperty(exports,"validate",{enumerable:!0,get:function(){return _validate.default}}),Object.defineProperty(exports,"valueToNode",{enumerable:!0,get:function(){return _valueToNode.default}});var _isReactComponent=__webpack_require__("./node_modules/@babel/types/lib/validators/react/isReactComponent.js"),_isCompatTag=__webpack_require__("./node_modules/@babel/types/lib/validators/react/isCompatTag.js"),_buildChildren=__webpack_require__("./node_modules/@babel/types/lib/builders/react/buildChildren.js"),_assertNode=__webpack_require__("./node_modules/@babel/types/lib/asserts/assertNode.js"),_generated=__webpack_require__("./node_modules/@babel/types/lib/asserts/generated/index.js");Object.keys(_generated).forEach((function(key){"default"!==key&&"__esModule"!==key&&(Object.prototype.hasOwnProperty.call(_exportNames,key)||key in exports&&exports[key]===_generated[key]||Object.defineProperty(exports,key,{enumerable:!0,get:function(){return _generated[key]}}));}));var _createTypeAnnotationBasedOnTypeof=__webpack_require__("./node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"),_createFlowUnionType=__webpack_require__("./node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"),_createTSUnionType=__webpack_require__("./node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"),_generated2=__webpack_require__("./node_modules/@babel/types/lib/builders/generated/index.js");Object.keys(_generated2).forEach((function(key){"default"!==key&&"__esModule"!==key&&(Object.prototype.hasOwnProperty.call(_exportNames,key)||key in exports&&exports[key]===_generated2[key]||Object.defineProperty(exports,key,{enumerable:!0,get:function(){return _generated2[key]}}));}));var _uppercase=__webpack_require__("./node_modules/@babel/types/lib/builders/generated/uppercase.js");Object.keys(_uppercase).forEach((function(key){"default"!==key&&"__esModule"!==key&&(Object.prototype.hasOwnProperty.call(_exportNames,key)||key in exports&&exports[key]===_uppercase[key]||Object.defineProperty(exports,key,{enumerable:!0,get:function(){return _uppercase[key]}}));}));var _cloneNode=__webpack_require__("./node_modules/@babel/types/lib/clone/cloneNode.js"),_clone=__webpack_require__("./node_modules/@babel/types/lib/clone/clone.js"),_cloneDeep=__webpack_require__("./node_modules/@babel/types/lib/clone/cloneDeep.js"),_cloneDeepWithoutLoc=__webpack_require__("./node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"),_cloneWithoutLoc=__webpack_require__("./node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"),_addComment=__webpack_require__("./node_modules/@babel/types/lib/comments/addComment.js"),_addComments=__webpack_require__("./node_modules/@babel/types/lib/comments/addComments.js"),_inheritInnerComments=__webpack_require__("./node_modules/@babel/types/lib/comments/inheritInnerComments.js"),_inheritLeadingComments=__webpack_require__("./node_modules/@babel/types/lib/comments/inheritLeadingComments.js"),_inheritsComments=__webpack_require__("./node_modules/@babel/types/lib/comments/inheritsComments.js"),_inheritTrailingComments=__webpack_require__("./node_modules/@babel/types/lib/comments/inheritTrailingComments.js"),_removeComments=__webpack_require__("./node_modules/@babel/types/lib/comments/removeComments.js"),_generated3=__webpack_require__("./node_modules/@babel/types/lib/constants/generated/index.js");Object.keys(_generated3).forEach((function(key){"default"!==key&&"__esModule"!==key&&(Object.prototype.hasOwnProperty.call(_exportNames,key)||key in exports&&exports[key]===_generated3[key]||Object.defineProperty(exports,key,{enumerable:!0,get:function(){return _generated3[key]}}));}));var _constants=__webpack_require__("./node_modules/@babel/types/lib/constants/index.js");Object.keys(_constants).forEach((function(key){"default"!==key&&"__esModule"!==key&&(Object.prototype.hasOwnProperty.call(_exportNames,key)||key in exports&&exports[key]===_constants[key]||Object.defineProperty(exports,key,{enumerable:!0,get:function(){return _constants[key]}}));}));var _ensureBlock=__webpack_require__("./node_modules/@babel/types/lib/converters/ensureBlock.js"),_toBindingIdentifierName=__webpack_require__("./node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"),_toBlock=__webpack_require__("./node_modules/@babel/types/lib/converters/toBlock.js"),_toComputedKey=__webpack_require__("./node_modules/@babel/types/lib/converters/toComputedKey.js"),_toExpression=__webpack_require__("./node_modules/@babel/types/lib/converters/toExpression.js"),_toIdentifier=__webpack_require__("./node_modules/@babel/types/lib/converters/toIdentifier.js"),_toKeyAlias=__webpack_require__("./node_modules/@babel/types/lib/converters/toKeyAlias.js"),_toSequenceExpression=__webpack_require__("./node_modules/@babel/types/lib/converters/toSequenceExpression.js"),_toStatement=__webpack_require__("./node_modules/@babel/types/lib/converters/toStatement.js"),_valueToNode=__webpack_require__("./node_modules/@babel/types/lib/converters/valueToNode.js"),_definitions=__webpack_require__("./node_modules/@babel/types/lib/definitions/index.js");Object.keys(_definitions).forEach((function(key){"default"!==key&&"__esModule"!==key&&(Object.prototype.hasOwnProperty.call(_exportNames,key)||key in exports&&exports[key]===_definitions[key]||Object.defineProperty(exports,key,{enumerable:!0,get:function(){return _definitions[key]}}));}));var _appendToMemberExpression=__webpack_require__("./node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"),_inherits=__webpack_require__("./node_modules/@babel/types/lib/modifications/inherits.js"),_prependToMemberExpression=__webpack_require__("./node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"),_removeProperties=__webpack_require__("./node_modules/@babel/types/lib/modifications/removeProperties.js"),_removePropertiesDeep=__webpack_require__("./node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"),_removeTypeDuplicates=__webpack_require__("./node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"),_getBindingIdentifiers=__webpack_require__("./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"),_getOuterBindingIdentifiers=__webpack_require__("./node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"),_traverse=__webpack_require__("./node_modules/@babel/types/lib/traverse/traverse.js");Object.keys(_traverse).forEach((function(key){"default"!==key&&"__esModule"!==key&&(Object.prototype.hasOwnProperty.call(_exportNames,key)||key in exports&&exports[key]===_traverse[key]||Object.defineProperty(exports,key,{enumerable:!0,get:function(){return _traverse[key]}}));}));var _traverseFast=__webpack_require__("./node_modules/@babel/types/lib/traverse/traverseFast.js"),_shallowEqual=__webpack_require__("./node_modules/@babel/types/lib/utils/shallowEqual.js"),_is=__webpack_require__("./node_modules/@babel/types/lib/validators/is.js"),_isBinding=__webpack_require__("./node_modules/@babel/types/lib/validators/isBinding.js"),_isBlockScoped=__webpack_require__("./node_modules/@babel/types/lib/validators/isBlockScoped.js"),_isImmutable=__webpack_require__("./node_modules/@babel/types/lib/validators/isImmutable.js"),_isLet=__webpack_require__("./node_modules/@babel/types/lib/validators/isLet.js"),_isNode=__webpack_require__("./node_modules/@babel/types/lib/validators/isNode.js"),_isNodesEquivalent=__webpack_require__("./node_modules/@babel/types/lib/validators/isNodesEquivalent.js"),_isPlaceholderType=__webpack_require__("./node_modules/@babel/types/lib/validators/isPlaceholderType.js"),_isReferenced=__webpack_require__("./node_modules/@babel/types/lib/validators/isReferenced.js"),_isScope=__webpack_require__("./node_modules/@babel/types/lib/validators/isScope.js"),_isSpecifierDefault=__webpack_require__("./node_modules/@babel/types/lib/validators/isSpecifierDefault.js"),_isType=__webpack_require__("./node_modules/@babel/types/lib/validators/isType.js"),_isValidES3Identifier=__webpack_require__("./node_modules/@babel/types/lib/validators/isValidES3Identifier.js"),_isValidIdentifier=__webpack_require__("./node_modules/@babel/types/lib/validators/isValidIdentifier.js"),_isVar=__webpack_require__("./node_modules/@babel/types/lib/validators/isVar.js"),_matchesPattern=__webpack_require__("./node_modules/@babel/types/lib/validators/matchesPattern.js"),_validate=__webpack_require__("./node_modules/@babel/types/lib/validators/validate.js"),_buildMatchMemberExpression=__webpack_require__("./node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"),_generated4=__webpack_require__("./node_modules/@babel/types/lib/validators/generated/index.js");Object.keys(_generated4).forEach((function(key){"default"!==key&&"__esModule"!==key&&(Object.prototype.hasOwnProperty.call(_exportNames,key)||key in exports&&exports[key]===_generated4[key]||Object.defineProperty(exports,key,{enumerable:!0,get:function(){return _generated4[key]}}));}));var _generated5=__webpack_require__("./node_modules/@babel/types/lib/ast-types/generated/index.js");Object.keys(_generated5).forEach((function(key){"default"!==key&&"__esModule"!==key&&(Object.prototype.hasOwnProperty.call(_exportNames,key)||key in exports&&exports[key]===_generated5[key]||Object.defineProperty(exports,key,{enumerable:!0,get:function(){return _generated5[key]}}));}));const react={isReactComponent:_isReactComponent.default,isCompatTag:_isCompatTag.default,buildChildren:_buildChildren.default};exports.react=react;},"./node_modules/@babel/types/lib/modifications/appendToMemberExpression.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(member,append,computed=!1){return member.object=(0, _generated.memberExpression)(member.object,member.property,member.computed),member.property=append,member.computed=!!computed,member};var _generated=__webpack_require__("./node_modules/@babel/types/lib/builders/generated/index.js");},"./node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function removeTypeDuplicates(nodes){const generics={},bases={},typeGroups=new Set,types=[];for(let i=0;i<nodes.length;i++){const node=nodes[i];if(node&&!(types.indexOf(node)>=0)){if((0, _generated.isAnyTypeAnnotation)(node))return [node];if((0, _generated.isFlowBaseAnnotation)(node))bases[node.type]=node;else if((0, _generated.isUnionTypeAnnotation)(node))typeGroups.has(node.types)||(nodes=nodes.concat(node.types),typeGroups.add(node.types));else if((0, _generated.isGenericTypeAnnotation)(node)){const name=getQualifiedName(node.id);if(generics[name]){let existing=generics[name];existing.typeParameters?node.typeParameters&&(existing.typeParameters.params=removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params))):existing=node.typeParameters;}else generics[name]=node;}else types.push(node);}}for(const type of Object.keys(bases))types.push(bases[type]);for(const name of Object.keys(generics))types.push(generics[name]);return types};var _generated=__webpack_require__("./node_modules/@babel/types/lib/validators/generated/index.js");function getQualifiedName(node){return (0, _generated.isIdentifier)(node)?node.name:`${node.id.name}.${getQualifiedName(node.qualification)}`}},"./node_modules/@babel/types/lib/modifications/inherits.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(child,parent){if(!child||!parent)return child;for(const key of _constants.INHERIT_KEYS.optional)null==child[key]&&(child[key]=parent[key]);for(const key of Object.keys(parent))"_"===key[0]&&"__clone"!==key&&(child[key]=parent[key]);for(const key of _constants.INHERIT_KEYS.force)child[key]=parent[key];return (0, _inheritsComments.default)(child,parent),child};var _constants=__webpack_require__("./node_modules/@babel/types/lib/constants/index.js"),_inheritsComments=__webpack_require__("./node_modules/@babel/types/lib/comments/inheritsComments.js");},"./node_modules/@babel/types/lib/modifications/prependToMemberExpression.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(member,prepend){return member.object=(0, _generated.memberExpression)(prepend,member.object),member};var _generated=__webpack_require__("./node_modules/@babel/types/lib/builders/generated/index.js");},"./node_modules/@babel/types/lib/modifications/removeProperties.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node,opts={}){const map=opts.preserveComments?CLEAR_KEYS:CLEAR_KEYS_PLUS_COMMENTS;for(const key of map)null!=node[key]&&(node[key]=void 0);for(const key of Object.keys(node))"_"===key[0]&&null!=node[key]&&(node[key]=void 0);const symbols=Object.getOwnPropertySymbols(node);for(const sym of symbols)node[sym]=null;};var _constants=__webpack_require__("./node_modules/@babel/types/lib/constants/index.js");const CLEAR_KEYS=["tokens","start","end","loc","raw","rawValue"],CLEAR_KEYS_PLUS_COMMENTS=_constants.COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);},"./node_modules/@babel/types/lib/modifications/removePropertiesDeep.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(tree,opts){return (0, _traverseFast.default)(tree,_removeProperties.default,opts),tree};var _traverseFast=__webpack_require__("./node_modules/@babel/types/lib/traverse/traverseFast.js"),_removeProperties=__webpack_require__("./node_modules/@babel/types/lib/modifications/removeProperties.js");},"./node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(nodes){const generics={},bases={},typeGroups=new Set,types=[];for(let i=0;i<nodes.length;i++){const node=nodes[i];if(node&&!(types.indexOf(node)>=0)){if((0, _generated.isTSAnyKeyword)(node))return [node];(0, _generated.isTSBaseType)(node)?bases[node.type]=node:(0, _generated.isTSUnionType)(node)?typeGroups.has(node.types)||(nodes.push(...node.types),typeGroups.add(node.types)):types.push(node);}}for(const type of Object.keys(bases))types.push(bases[type]);for(const name of Object.keys(generics))types.push(generics[name]);return types};var _generated=__webpack_require__("./node_modules/@babel/types/lib/validators/generated/index.js");},"./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=getBindingIdentifiers;var _generated=__webpack_require__("./node_modules/@babel/types/lib/validators/generated/index.js");function getBindingIdentifiers(node,duplicates,outerOnly){let search=[].concat(node);const ids=Object.create(null);for(;search.length;){const id=search.shift();if(!id)continue;const keys=getBindingIdentifiers.keys[id.type];if((0, _generated.isIdentifier)(id))if(duplicates){(ids[id.name]=ids[id.name]||[]).push(id);}else ids[id.name]=id;else if(!(0, _generated.isExportDeclaration)(id)||(0, _generated.isExportAllDeclaration)(id)){if(outerOnly){if((0, _generated.isFunctionDeclaration)(id)){search.push(id.id);continue}if((0, _generated.isFunctionExpression)(id))continue}if(keys)for(let i=0;i<keys.length;i++){const key=keys[i];id[key]&&(search=search.concat(id[key]));}}else (0, _generated.isDeclaration)(id.declaration)&&search.push(id.declaration);}return ids}getBindingIdentifiers.keys={DeclareClass:["id"],DeclareFunction:["id"],DeclareModule:["id"],DeclareVariable:["id"],DeclareInterface:["id"],DeclareTypeAlias:["id"],DeclareOpaqueType:["id"],InterfaceDeclaration:["id"],TypeAlias:["id"],OpaqueType:["id"],CatchClause:["param"],LabeledStatement:["label"],UnaryExpression:["argument"],AssignmentExpression:["left"],ImportSpecifier:["local"],ImportNamespaceSpecifier:["local"],ImportDefaultSpecifier:["local"],ImportDeclaration:["specifiers"],ExportSpecifier:["exported"],ExportNamespaceSpecifier:["exported"],ExportDefaultSpecifier:["exported"],FunctionDeclaration:["id","params"],FunctionExpression:["id","params"],ArrowFunctionExpression:["params"],ObjectMethod:["params"],ClassMethod:["params"],ClassPrivateMethod:["params"],ForInStatement:["left"],ForOfStatement:["left"],ClassDeclaration:["id"],ClassExpression:["id"],RestElement:["argument"],UpdateExpression:["argument"],ObjectProperty:["value"],AssignmentPattern:["left"],ArrayPattern:["elements"],ObjectPattern:["properties"],VariableDeclaration:["declarations"],VariableDeclarator:["id"]};},"./node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _getBindingIdentifiers=__webpack_require__("./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"),_default=function(node,duplicates){return (0, _getBindingIdentifiers.default)(node,duplicates,!0)};exports.default=_default;},"./node_modules/@babel/types/lib/traverse/traverse.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node,handlers,state){"function"==typeof handlers&&(handlers={enter:handlers});const{enter,exit}=handlers;traverseSimpleImpl(node,enter,exit,state,[]);};var _definitions=__webpack_require__("./node_modules/@babel/types/lib/definitions/index.js");function traverseSimpleImpl(node,enter,exit,state,ancestors){const keys=_definitions.VISITOR_KEYS[node.type];if(keys){enter&&enter(node,ancestors,state);for(const key of keys){const subNode=node[key];if(Array.isArray(subNode))for(let i=0;i<subNode.length;i++){const child=subNode[i];child&&(ancestors.push({node,key,index:i}),traverseSimpleImpl(child,enter,exit,state,ancestors),ancestors.pop());}else subNode&&(ancestors.push({node,key}),traverseSimpleImpl(subNode,enter,exit,state,ancestors),ancestors.pop());}exit&&exit(node,ancestors,state);}}},"./node_modules/@babel/types/lib/traverse/traverseFast.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function traverseFast(node,enter,opts){if(!node)return;const keys=_definitions.VISITOR_KEYS[node.type];if(!keys)return;enter(node,opts=opts||{});for(const key of keys){const subNode=node[key];if(Array.isArray(subNode))for(const node of subNode)traverseFast(node,enter,opts);else traverseFast(subNode,enter,opts);}};var _definitions=__webpack_require__("./node_modules/@babel/types/lib/definitions/index.js");},"./node_modules/@babel/types/lib/utils/inherit.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(key,child,parent){child&&parent&&(child[key]=Array.from(new Set([].concat(child[key],parent[key]).filter(Boolean))));};},"./node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(child,args){const lines=child.value.split(/\r\n|\n|\r/);let lastNonEmptyLine=0;for(let i=0;i<lines.length;i++)lines[i].match(/[^ \t]/)&&(lastNonEmptyLine=i);let str="";for(let i=0;i<lines.length;i++){const line=lines[i],isFirstLine=0===i,isLastLine=i===lines.length-1,isLastNonEmptyLine=i===lastNonEmptyLine;let trimmedLine=line.replace(/\t/g," ");isFirstLine||(trimmedLine=trimmedLine.replace(/^[ ]+/,"")),isLastLine||(trimmedLine=trimmedLine.replace(/[ ]+$/,"")),trimmedLine&&(isLastNonEmptyLine||(trimmedLine+=" "),str+=trimmedLine);}str&&args.push((0, _generated.stringLiteral)(str));};var _generated=__webpack_require__("./node_modules/@babel/types/lib/builders/generated/index.js");},"./node_modules/@babel/types/lib/utils/shallowEqual.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(actual,expected){const keys=Object.keys(expected);for(const key of keys)if(actual[key]!==expected[key])return !1;return !0};},"./node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(match,allowPartial){const parts=match.split(".");return member=>(0, _matchesPattern.default)(member,parts,allowPartial)};var _matchesPattern=__webpack_require__("./node_modules/@babel/types/lib/validators/matchesPattern.js");},"./node_modules/@babel/types/lib/validators/generated/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.isAnyTypeAnnotation=function(node,opts){if(!node)return !1;if("AnyTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isArgumentPlaceholder=function(node,opts){if(!node)return !1;if("ArgumentPlaceholder"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isArrayExpression=function(node,opts){if(!node)return !1;if("ArrayExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isArrayPattern=function(node,opts){if(!node)return !1;if("ArrayPattern"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isArrayTypeAnnotation=function(node,opts){if(!node)return !1;if("ArrayTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isArrowFunctionExpression=function(node,opts){if(!node)return !1;if("ArrowFunctionExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isAssignmentExpression=function(node,opts){if(!node)return !1;if("AssignmentExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isAssignmentPattern=function(node,opts){if(!node)return !1;if("AssignmentPattern"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isAwaitExpression=function(node,opts){if(!node)return !1;if("AwaitExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isBigIntLiteral=function(node,opts){if(!node)return !1;if("BigIntLiteral"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isBinary=function(node,opts){if(!node)return !1;const nodeType=node.type;if("BinaryExpression"===nodeType||"LogicalExpression"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isBinaryExpression=function(node,opts){if(!node)return !1;if("BinaryExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isBindExpression=function(node,opts){if(!node)return !1;if("BindExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isBlock=function(node,opts){if(!node)return !1;const nodeType=node.type;if("BlockStatement"===nodeType||"Program"===nodeType||"TSModuleBlock"===nodeType||"Placeholder"===nodeType&&"BlockStatement"===node.expectedNode)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isBlockParent=function(node,opts){if(!node)return !1;const nodeType=node.type;if("BlockStatement"===nodeType||"CatchClause"===nodeType||"DoWhileStatement"===nodeType||"ForInStatement"===nodeType||"ForStatement"===nodeType||"FunctionDeclaration"===nodeType||"FunctionExpression"===nodeType||"Program"===nodeType||"ObjectMethod"===nodeType||"SwitchStatement"===nodeType||"WhileStatement"===nodeType||"ArrowFunctionExpression"===nodeType||"ForOfStatement"===nodeType||"ClassMethod"===nodeType||"ClassPrivateMethod"===nodeType||"StaticBlock"===nodeType||"TSModuleBlock"===nodeType||"Placeholder"===nodeType&&"BlockStatement"===node.expectedNode)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isBlockStatement=function(node,opts){if(!node)return !1;if("BlockStatement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isBooleanLiteral=function(node,opts){if(!node)return !1;if("BooleanLiteral"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isBooleanLiteralTypeAnnotation=function(node,opts){if(!node)return !1;if("BooleanLiteralTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isBooleanTypeAnnotation=function(node,opts){if(!node)return !1;if("BooleanTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isBreakStatement=function(node,opts){if(!node)return !1;if("BreakStatement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isCallExpression=function(node,opts){if(!node)return !1;if("CallExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isCatchClause=function(node,opts){if(!node)return !1;if("CatchClause"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isClass=function(node,opts){if(!node)return !1;const nodeType=node.type;if("ClassExpression"===nodeType||"ClassDeclaration"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isClassBody=function(node,opts){if(!node)return !1;if("ClassBody"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isClassDeclaration=function(node,opts){if(!node)return !1;if("ClassDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isClassExpression=function(node,opts){if(!node)return !1;if("ClassExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isClassImplements=function(node,opts){if(!node)return !1;if("ClassImplements"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isClassMethod=function(node,opts){if(!node)return !1;if("ClassMethod"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isClassPrivateMethod=function(node,opts){if(!node)return !1;if("ClassPrivateMethod"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isClassPrivateProperty=function(node,opts){if(!node)return !1;if("ClassPrivateProperty"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isClassProperty=function(node,opts){if(!node)return !1;if("ClassProperty"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isCompletionStatement=function(node,opts){if(!node)return !1;const nodeType=node.type;if("BreakStatement"===nodeType||"ContinueStatement"===nodeType||"ReturnStatement"===nodeType||"ThrowStatement"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isConditional=function(node,opts){if(!node)return !1;const nodeType=node.type;if("ConditionalExpression"===nodeType||"IfStatement"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isConditionalExpression=function(node,opts){if(!node)return !1;if("ConditionalExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isContinueStatement=function(node,opts){if(!node)return !1;if("ContinueStatement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isDebuggerStatement=function(node,opts){if(!node)return !1;if("DebuggerStatement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isDecimalLiteral=function(node,opts){if(!node)return !1;if("DecimalLiteral"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isDeclaration=function(node,opts){if(!node)return !1;const nodeType=node.type;if("FunctionDeclaration"===nodeType||"VariableDeclaration"===nodeType||"ClassDeclaration"===nodeType||"ExportAllDeclaration"===nodeType||"ExportDefaultDeclaration"===nodeType||"ExportNamedDeclaration"===nodeType||"ImportDeclaration"===nodeType||"DeclareClass"===nodeType||"DeclareFunction"===nodeType||"DeclareInterface"===nodeType||"DeclareModule"===nodeType||"DeclareModuleExports"===nodeType||"DeclareTypeAlias"===nodeType||"DeclareOpaqueType"===nodeType||"DeclareVariable"===nodeType||"DeclareExportDeclaration"===nodeType||"DeclareExportAllDeclaration"===nodeType||"InterfaceDeclaration"===nodeType||"OpaqueType"===nodeType||"TypeAlias"===nodeType||"EnumDeclaration"===nodeType||"TSDeclareFunction"===nodeType||"TSInterfaceDeclaration"===nodeType||"TSTypeAliasDeclaration"===nodeType||"TSEnumDeclaration"===nodeType||"TSModuleDeclaration"===nodeType||"Placeholder"===nodeType&&"Declaration"===node.expectedNode)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isDeclareClass=function(node,opts){if(!node)return !1;if("DeclareClass"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isDeclareExportAllDeclaration=function(node,opts){if(!node)return !1;if("DeclareExportAllDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isDeclareExportDeclaration=function(node,opts){if(!node)return !1;if("DeclareExportDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isDeclareFunction=function(node,opts){if(!node)return !1;if("DeclareFunction"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isDeclareInterface=function(node,opts){if(!node)return !1;if("DeclareInterface"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isDeclareModule=function(node,opts){if(!node)return !1;if("DeclareModule"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isDeclareModuleExports=function(node,opts){if(!node)return !1;if("DeclareModuleExports"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isDeclareOpaqueType=function(node,opts){if(!node)return !1;if("DeclareOpaqueType"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isDeclareTypeAlias=function(node,opts){if(!node)return !1;if("DeclareTypeAlias"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isDeclareVariable=function(node,opts){if(!node)return !1;if("DeclareVariable"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isDeclaredPredicate=function(node,opts){if(!node)return !1;if("DeclaredPredicate"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isDecorator=function(node,opts){if(!node)return !1;if("Decorator"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isDirective=function(node,opts){if(!node)return !1;if("Directive"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isDirectiveLiteral=function(node,opts){if(!node)return !1;if("DirectiveLiteral"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isDoExpression=function(node,opts){if(!node)return !1;if("DoExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isDoWhileStatement=function(node,opts){if(!node)return !1;if("DoWhileStatement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isEmptyStatement=function(node,opts){if(!node)return !1;if("EmptyStatement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isEmptyTypeAnnotation=function(node,opts){if(!node)return !1;if("EmptyTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isEnumBody=function(node,opts){if(!node)return !1;const nodeType=node.type;if("EnumBooleanBody"===nodeType||"EnumNumberBody"===nodeType||"EnumStringBody"===nodeType||"EnumSymbolBody"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isEnumBooleanBody=function(node,opts){if(!node)return !1;if("EnumBooleanBody"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isEnumBooleanMember=function(node,opts){if(!node)return !1;if("EnumBooleanMember"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isEnumDeclaration=function(node,opts){if(!node)return !1;if("EnumDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isEnumDefaultedMember=function(node,opts){if(!node)return !1;if("EnumDefaultedMember"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isEnumMember=function(node,opts){if(!node)return !1;const nodeType=node.type;if("EnumBooleanMember"===nodeType||"EnumNumberMember"===nodeType||"EnumStringMember"===nodeType||"EnumDefaultedMember"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isEnumNumberBody=function(node,opts){if(!node)return !1;if("EnumNumberBody"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isEnumNumberMember=function(node,opts){if(!node)return !1;if("EnumNumberMember"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isEnumStringBody=function(node,opts){if(!node)return !1;if("EnumStringBody"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isEnumStringMember=function(node,opts){if(!node)return !1;if("EnumStringMember"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isEnumSymbolBody=function(node,opts){if(!node)return !1;if("EnumSymbolBody"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isExistsTypeAnnotation=function(node,opts){if(!node)return !1;if("ExistsTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isExportAllDeclaration=function(node,opts){if(!node)return !1;if("ExportAllDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isExportDeclaration=function(node,opts){if(!node)return !1;const nodeType=node.type;if("ExportAllDeclaration"===nodeType||"ExportDefaultDeclaration"===nodeType||"ExportNamedDeclaration"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isExportDefaultDeclaration=function(node,opts){if(!node)return !1;if("ExportDefaultDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isExportDefaultSpecifier=function(node,opts){if(!node)return !1;if("ExportDefaultSpecifier"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isExportNamedDeclaration=function(node,opts){if(!node)return !1;if("ExportNamedDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isExportNamespaceSpecifier=function(node,opts){if(!node)return !1;if("ExportNamespaceSpecifier"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isExportSpecifier=function(node,opts){if(!node)return !1;if("ExportSpecifier"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isExpression=function(node,opts){if(!node)return !1;const nodeType=node.type;if("ArrayExpression"===nodeType||"AssignmentExpression"===nodeType||"BinaryExpression"===nodeType||"CallExpression"===nodeType||"ConditionalExpression"===nodeType||"FunctionExpression"===nodeType||"Identifier"===nodeType||"StringLiteral"===nodeType||"NumericLiteral"===nodeType||"NullLiteral"===nodeType||"BooleanLiteral"===nodeType||"RegExpLiteral"===nodeType||"LogicalExpression"===nodeType||"MemberExpression"===nodeType||"NewExpression"===nodeType||"ObjectExpression"===nodeType||"SequenceExpression"===nodeType||"ParenthesizedExpression"===nodeType||"ThisExpression"===nodeType||"UnaryExpression"===nodeType||"UpdateExpression"===nodeType||"ArrowFunctionExpression"===nodeType||"ClassExpression"===nodeType||"MetaProperty"===nodeType||"Super"===nodeType||"TaggedTemplateExpression"===nodeType||"TemplateLiteral"===nodeType||"YieldExpression"===nodeType||"AwaitExpression"===nodeType||"Import"===nodeType||"BigIntLiteral"===nodeType||"OptionalMemberExpression"===nodeType||"OptionalCallExpression"===nodeType||"TypeCastExpression"===nodeType||"JSXElement"===nodeType||"JSXFragment"===nodeType||"BindExpression"===nodeType||"DoExpression"===nodeType||"RecordExpression"===nodeType||"TupleExpression"===nodeType||"DecimalLiteral"===nodeType||"ModuleExpression"===nodeType||"TopicReference"===nodeType||"PipelineTopicExpression"===nodeType||"PipelineBareFunction"===nodeType||"PipelinePrimaryTopicReference"===nodeType||"TSAsExpression"===nodeType||"TSTypeAssertion"===nodeType||"TSNonNullExpression"===nodeType||"Placeholder"===nodeType&&("Expression"===node.expectedNode||"Identifier"===node.expectedNode||"StringLiteral"===node.expectedNode))return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isExpressionStatement=function(node,opts){if(!node)return !1;if("ExpressionStatement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isExpressionWrapper=function(node,opts){if(!node)return !1;const nodeType=node.type;if("ExpressionStatement"===nodeType||"ParenthesizedExpression"===nodeType||"TypeCastExpression"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isFile=function(node,opts){if(!node)return !1;if("File"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isFlow=function(node,opts){if(!node)return !1;const nodeType=node.type;if("AnyTypeAnnotation"===nodeType||"ArrayTypeAnnotation"===nodeType||"BooleanTypeAnnotation"===nodeType||"BooleanLiteralTypeAnnotation"===nodeType||"NullLiteralTypeAnnotation"===nodeType||"ClassImplements"===nodeType||"DeclareClass"===nodeType||"DeclareFunction"===nodeType||"DeclareInterface"===nodeType||"DeclareModule"===nodeType||"DeclareModuleExports"===nodeType||"DeclareTypeAlias"===nodeType||"DeclareOpaqueType"===nodeType||"DeclareVariable"===nodeType||"DeclareExportDeclaration"===nodeType||"DeclareExportAllDeclaration"===nodeType||"DeclaredPredicate"===nodeType||"ExistsTypeAnnotation"===nodeType||"FunctionTypeAnnotation"===nodeType||"FunctionTypeParam"===nodeType||"GenericTypeAnnotation"===nodeType||"InferredPredicate"===nodeType||"InterfaceExtends"===nodeType||"InterfaceDeclaration"===nodeType||"InterfaceTypeAnnotation"===nodeType||"IntersectionTypeAnnotation"===nodeType||"MixedTypeAnnotation"===nodeType||"EmptyTypeAnnotation"===nodeType||"NullableTypeAnnotation"===nodeType||"NumberLiteralTypeAnnotation"===nodeType||"NumberTypeAnnotation"===nodeType||"ObjectTypeAnnotation"===nodeType||"ObjectTypeInternalSlot"===nodeType||"ObjectTypeCallProperty"===nodeType||"ObjectTypeIndexer"===nodeType||"ObjectTypeProperty"===nodeType||"ObjectTypeSpreadProperty"===nodeType||"OpaqueType"===nodeType||"QualifiedTypeIdentifier"===nodeType||"StringLiteralTypeAnnotation"===nodeType||"StringTypeAnnotation"===nodeType||"SymbolTypeAnnotation"===nodeType||"ThisTypeAnnotation"===nodeType||"TupleTypeAnnotation"===nodeType||"TypeofTypeAnnotation"===nodeType||"TypeAlias"===nodeType||"TypeAnnotation"===nodeType||"TypeCastExpression"===nodeType||"TypeParameter"===nodeType||"TypeParameterDeclaration"===nodeType||"TypeParameterInstantiation"===nodeType||"UnionTypeAnnotation"===nodeType||"Variance"===nodeType||"VoidTypeAnnotation"===nodeType||"EnumDeclaration"===nodeType||"EnumBooleanBody"===nodeType||"EnumNumberBody"===nodeType||"EnumStringBody"===nodeType||"EnumSymbolBody"===nodeType||"EnumBooleanMember"===nodeType||"EnumNumberMember"===nodeType||"EnumStringMember"===nodeType||"EnumDefaultedMember"===nodeType||"IndexedAccessType"===nodeType||"OptionalIndexedAccessType"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isFlowBaseAnnotation=function(node,opts){if(!node)return !1;const nodeType=node.type;if("AnyTypeAnnotation"===nodeType||"BooleanTypeAnnotation"===nodeType||"NullLiteralTypeAnnotation"===nodeType||"MixedTypeAnnotation"===nodeType||"EmptyTypeAnnotation"===nodeType||"NumberTypeAnnotation"===nodeType||"StringTypeAnnotation"===nodeType||"SymbolTypeAnnotation"===nodeType||"ThisTypeAnnotation"===nodeType||"VoidTypeAnnotation"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isFlowDeclaration=function(node,opts){if(!node)return !1;const nodeType=node.type;if("DeclareClass"===nodeType||"DeclareFunction"===nodeType||"DeclareInterface"===nodeType||"DeclareModule"===nodeType||"DeclareModuleExports"===nodeType||"DeclareTypeAlias"===nodeType||"DeclareOpaqueType"===nodeType||"DeclareVariable"===nodeType||"DeclareExportDeclaration"===nodeType||"DeclareExportAllDeclaration"===nodeType||"InterfaceDeclaration"===nodeType||"OpaqueType"===nodeType||"TypeAlias"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isFlowPredicate=function(node,opts){if(!node)return !1;const nodeType=node.type;if("DeclaredPredicate"===nodeType||"InferredPredicate"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isFlowType=function(node,opts){if(!node)return !1;const nodeType=node.type;if("AnyTypeAnnotation"===nodeType||"ArrayTypeAnnotation"===nodeType||"BooleanTypeAnnotation"===nodeType||"BooleanLiteralTypeAnnotation"===nodeType||"NullLiteralTypeAnnotation"===nodeType||"ExistsTypeAnnotation"===nodeType||"FunctionTypeAnnotation"===nodeType||"GenericTypeAnnotation"===nodeType||"InterfaceTypeAnnotation"===nodeType||"IntersectionTypeAnnotation"===nodeType||"MixedTypeAnnotation"===nodeType||"EmptyTypeAnnotation"===nodeType||"NullableTypeAnnotation"===nodeType||"NumberLiteralTypeAnnotation"===nodeType||"NumberTypeAnnotation"===nodeType||"ObjectTypeAnnotation"===nodeType||"StringLiteralTypeAnnotation"===nodeType||"StringTypeAnnotation"===nodeType||"SymbolTypeAnnotation"===nodeType||"ThisTypeAnnotation"===nodeType||"TupleTypeAnnotation"===nodeType||"TypeofTypeAnnotation"===nodeType||"UnionTypeAnnotation"===nodeType||"VoidTypeAnnotation"===nodeType||"IndexedAccessType"===nodeType||"OptionalIndexedAccessType"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isFor=function(node,opts){if(!node)return !1;const nodeType=node.type;if("ForInStatement"===nodeType||"ForStatement"===nodeType||"ForOfStatement"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isForInStatement=function(node,opts){if(!node)return !1;if("ForInStatement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isForOfStatement=function(node,opts){if(!node)return !1;if("ForOfStatement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isForStatement=function(node,opts){if(!node)return !1;if("ForStatement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isForXStatement=function(node,opts){if(!node)return !1;const nodeType=node.type;if("ForInStatement"===nodeType||"ForOfStatement"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isFunction=function(node,opts){if(!node)return !1;const nodeType=node.type;if("FunctionDeclaration"===nodeType||"FunctionExpression"===nodeType||"ObjectMethod"===nodeType||"ArrowFunctionExpression"===nodeType||"ClassMethod"===nodeType||"ClassPrivateMethod"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isFunctionDeclaration=function(node,opts){if(!node)return !1;if("FunctionDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isFunctionExpression=function(node,opts){if(!node)return !1;if("FunctionExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isFunctionParent=function(node,opts){if(!node)return !1;const nodeType=node.type;if("FunctionDeclaration"===nodeType||"FunctionExpression"===nodeType||"ObjectMethod"===nodeType||"ArrowFunctionExpression"===nodeType||"ClassMethod"===nodeType||"ClassPrivateMethod"===nodeType||"StaticBlock"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isFunctionTypeAnnotation=function(node,opts){if(!node)return !1;if("FunctionTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isFunctionTypeParam=function(node,opts){if(!node)return !1;if("FunctionTypeParam"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isGenericTypeAnnotation=function(node,opts){if(!node)return !1;if("GenericTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isIdentifier=function(node,opts){if(!node)return !1;if("Identifier"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isIfStatement=function(node,opts){if(!node)return !1;if("IfStatement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isImmutable=function(node,opts){if(!node)return !1;const nodeType=node.type;if("StringLiteral"===nodeType||"NumericLiteral"===nodeType||"NullLiteral"===nodeType||"BooleanLiteral"===nodeType||"BigIntLiteral"===nodeType||"JSXAttribute"===nodeType||"JSXClosingElement"===nodeType||"JSXElement"===nodeType||"JSXExpressionContainer"===nodeType||"JSXSpreadChild"===nodeType||"JSXOpeningElement"===nodeType||"JSXText"===nodeType||"JSXFragment"===nodeType||"JSXOpeningFragment"===nodeType||"JSXClosingFragment"===nodeType||"DecimalLiteral"===nodeType||"Placeholder"===nodeType&&"StringLiteral"===node.expectedNode)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isImport=function(node,opts){if(!node)return !1;if("Import"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isImportAttribute=function(node,opts){if(!node)return !1;if("ImportAttribute"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isImportDeclaration=function(node,opts){if(!node)return !1;if("ImportDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isImportDefaultSpecifier=function(node,opts){if(!node)return !1;if("ImportDefaultSpecifier"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isImportNamespaceSpecifier=function(node,opts){if(!node)return !1;if("ImportNamespaceSpecifier"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isImportSpecifier=function(node,opts){if(!node)return !1;if("ImportSpecifier"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isIndexedAccessType=function(node,opts){if(!node)return !1;if("IndexedAccessType"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isInferredPredicate=function(node,opts){if(!node)return !1;if("InferredPredicate"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isInterfaceDeclaration=function(node,opts){if(!node)return !1;if("InterfaceDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isInterfaceExtends=function(node,opts){if(!node)return !1;if("InterfaceExtends"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isInterfaceTypeAnnotation=function(node,opts){if(!node)return !1;if("InterfaceTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isInterpreterDirective=function(node,opts){if(!node)return !1;if("InterpreterDirective"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isIntersectionTypeAnnotation=function(node,opts){if(!node)return !1;if("IntersectionTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isJSX=function(node,opts){if(!node)return !1;const nodeType=node.type;if("JSXAttribute"===nodeType||"JSXClosingElement"===nodeType||"JSXElement"===nodeType||"JSXEmptyExpression"===nodeType||"JSXExpressionContainer"===nodeType||"JSXSpreadChild"===nodeType||"JSXIdentifier"===nodeType||"JSXMemberExpression"===nodeType||"JSXNamespacedName"===nodeType||"JSXOpeningElement"===nodeType||"JSXSpreadAttribute"===nodeType||"JSXText"===nodeType||"JSXFragment"===nodeType||"JSXOpeningFragment"===nodeType||"JSXClosingFragment"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isJSXAttribute=function(node,opts){if(!node)return !1;if("JSXAttribute"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isJSXClosingElement=function(node,opts){if(!node)return !1;if("JSXClosingElement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isJSXClosingFragment=function(node,opts){if(!node)return !1;if("JSXClosingFragment"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isJSXElement=function(node,opts){if(!node)return !1;if("JSXElement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isJSXEmptyExpression=function(node,opts){if(!node)return !1;if("JSXEmptyExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isJSXExpressionContainer=function(node,opts){if(!node)return !1;if("JSXExpressionContainer"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isJSXFragment=function(node,opts){if(!node)return !1;if("JSXFragment"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isJSXIdentifier=function(node,opts){if(!node)return !1;if("JSXIdentifier"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isJSXMemberExpression=function(node,opts){if(!node)return !1;if("JSXMemberExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isJSXNamespacedName=function(node,opts){if(!node)return !1;if("JSXNamespacedName"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isJSXOpeningElement=function(node,opts){if(!node)return !1;if("JSXOpeningElement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isJSXOpeningFragment=function(node,opts){if(!node)return !1;if("JSXOpeningFragment"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isJSXSpreadAttribute=function(node,opts){if(!node)return !1;if("JSXSpreadAttribute"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isJSXSpreadChild=function(node,opts){if(!node)return !1;if("JSXSpreadChild"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isJSXText=function(node,opts){if(!node)return !1;if("JSXText"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isLVal=function(node,opts){if(!node)return !1;const nodeType=node.type;if("Identifier"===nodeType||"MemberExpression"===nodeType||"RestElement"===nodeType||"AssignmentPattern"===nodeType||"ArrayPattern"===nodeType||"ObjectPattern"===nodeType||"TSParameterProperty"===nodeType||"Placeholder"===nodeType&&("Pattern"===node.expectedNode||"Identifier"===node.expectedNode))return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isLabeledStatement=function(node,opts){if(!node)return !1;if("LabeledStatement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isLiteral=function(node,opts){if(!node)return !1;const nodeType=node.type;if("StringLiteral"===nodeType||"NumericLiteral"===nodeType||"NullLiteral"===nodeType||"BooleanLiteral"===nodeType||"RegExpLiteral"===nodeType||"TemplateLiteral"===nodeType||"BigIntLiteral"===nodeType||"DecimalLiteral"===nodeType||"Placeholder"===nodeType&&"StringLiteral"===node.expectedNode)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isLogicalExpression=function(node,opts){if(!node)return !1;if("LogicalExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isLoop=function(node,opts){if(!node)return !1;const nodeType=node.type;if("DoWhileStatement"===nodeType||"ForInStatement"===nodeType||"ForStatement"===nodeType||"WhileStatement"===nodeType||"ForOfStatement"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isMemberExpression=function(node,opts){if(!node)return !1;if("MemberExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isMetaProperty=function(node,opts){if(!node)return !1;if("MetaProperty"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isMethod=function(node,opts){if(!node)return !1;const nodeType=node.type;if("ObjectMethod"===nodeType||"ClassMethod"===nodeType||"ClassPrivateMethod"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isMiscellaneous=function(node,opts){if(!node)return !1;const nodeType=node.type;if("Noop"===nodeType||"Placeholder"===nodeType||"V8IntrinsicIdentifier"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isMixedTypeAnnotation=function(node,opts){if(!node)return !1;if("MixedTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isModuleDeclaration=function(node,opts){if(!node)return !1;const nodeType=node.type;if("ExportAllDeclaration"===nodeType||"ExportDefaultDeclaration"===nodeType||"ExportNamedDeclaration"===nodeType||"ImportDeclaration"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isModuleExpression=function(node,opts){if(!node)return !1;if("ModuleExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isModuleSpecifier=function(node,opts){if(!node)return !1;const nodeType=node.type;if("ExportSpecifier"===nodeType||"ImportDefaultSpecifier"===nodeType||"ImportNamespaceSpecifier"===nodeType||"ImportSpecifier"===nodeType||"ExportNamespaceSpecifier"===nodeType||"ExportDefaultSpecifier"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isNewExpression=function(node,opts){if(!node)return !1;if("NewExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isNoop=function(node,opts){if(!node)return !1;if("Noop"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isNullLiteral=function(node,opts){if(!node)return !1;if("NullLiteral"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isNullLiteralTypeAnnotation=function(node,opts){if(!node)return !1;if("NullLiteralTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isNullableTypeAnnotation=function(node,opts){if(!node)return !1;if("NullableTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isNumberLiteral=function(node,opts){if(console.trace("The node type NumberLiteral has been renamed to NumericLiteral"),!node)return !1;if("NumberLiteral"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isNumberLiteralTypeAnnotation=function(node,opts){if(!node)return !1;if("NumberLiteralTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isNumberTypeAnnotation=function(node,opts){if(!node)return !1;if("NumberTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isNumericLiteral=function(node,opts){if(!node)return !1;if("NumericLiteral"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isObjectExpression=function(node,opts){if(!node)return !1;if("ObjectExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isObjectMember=function(node,opts){if(!node)return !1;const nodeType=node.type;if("ObjectMethod"===nodeType||"ObjectProperty"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isObjectMethod=function(node,opts){if(!node)return !1;if("ObjectMethod"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isObjectPattern=function(node,opts){if(!node)return !1;if("ObjectPattern"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isObjectProperty=function(node,opts){if(!node)return !1;if("ObjectProperty"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isObjectTypeAnnotation=function(node,opts){if(!node)return !1;if("ObjectTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isObjectTypeCallProperty=function(node,opts){if(!node)return !1;if("ObjectTypeCallProperty"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isObjectTypeIndexer=function(node,opts){if(!node)return !1;if("ObjectTypeIndexer"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isObjectTypeInternalSlot=function(node,opts){if(!node)return !1;if("ObjectTypeInternalSlot"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isObjectTypeProperty=function(node,opts){if(!node)return !1;if("ObjectTypeProperty"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isObjectTypeSpreadProperty=function(node,opts){if(!node)return !1;if("ObjectTypeSpreadProperty"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isOpaqueType=function(node,opts){if(!node)return !1;if("OpaqueType"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isOptionalCallExpression=function(node,opts){if(!node)return !1;if("OptionalCallExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isOptionalIndexedAccessType=function(node,opts){if(!node)return !1;if("OptionalIndexedAccessType"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isOptionalMemberExpression=function(node,opts){if(!node)return !1;if("OptionalMemberExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isParenthesizedExpression=function(node,opts){if(!node)return !1;if("ParenthesizedExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isPattern=function(node,opts){if(!node)return !1;const nodeType=node.type;if("AssignmentPattern"===nodeType||"ArrayPattern"===nodeType||"ObjectPattern"===nodeType||"Placeholder"===nodeType&&"Pattern"===node.expectedNode)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isPatternLike=function(node,opts){if(!node)return !1;const nodeType=node.type;if("Identifier"===nodeType||"RestElement"===nodeType||"AssignmentPattern"===nodeType||"ArrayPattern"===nodeType||"ObjectPattern"===nodeType||"Placeholder"===nodeType&&("Pattern"===node.expectedNode||"Identifier"===node.expectedNode))return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isPipelineBareFunction=function(node,opts){if(!node)return !1;if("PipelineBareFunction"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isPipelinePrimaryTopicReference=function(node,opts){if(!node)return !1;if("PipelinePrimaryTopicReference"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isPipelineTopicExpression=function(node,opts){if(!node)return !1;if("PipelineTopicExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isPlaceholder=function(node,opts){if(!node)return !1;if("Placeholder"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isPrivate=function(node,opts){if(!node)return !1;const nodeType=node.type;if("ClassPrivateProperty"===nodeType||"ClassPrivateMethod"===nodeType||"PrivateName"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isPrivateName=function(node,opts){if(!node)return !1;if("PrivateName"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isProgram=function(node,opts){if(!node)return !1;if("Program"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isProperty=function(node,opts){if(!node)return !1;const nodeType=node.type;if("ObjectProperty"===nodeType||"ClassProperty"===nodeType||"ClassPrivateProperty"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isPureish=function(node,opts){if(!node)return !1;const nodeType=node.type;if("FunctionDeclaration"===nodeType||"FunctionExpression"===nodeType||"StringLiteral"===nodeType||"NumericLiteral"===nodeType||"NullLiteral"===nodeType||"BooleanLiteral"===nodeType||"RegExpLiteral"===nodeType||"ArrowFunctionExpression"===nodeType||"BigIntLiteral"===nodeType||"DecimalLiteral"===nodeType||"Placeholder"===nodeType&&"StringLiteral"===node.expectedNode)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isQualifiedTypeIdentifier=function(node,opts){if(!node)return !1;if("QualifiedTypeIdentifier"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isRecordExpression=function(node,opts){if(!node)return !1;if("RecordExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isRegExpLiteral=function(node,opts){if(!node)return !1;if("RegExpLiteral"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isRegexLiteral=function(node,opts){if(console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"),!node)return !1;if("RegexLiteral"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isRestElement=function(node,opts){if(!node)return !1;if("RestElement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isRestProperty=function(node,opts){if(console.trace("The node type RestProperty has been renamed to RestElement"),!node)return !1;if("RestProperty"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isReturnStatement=function(node,opts){if(!node)return !1;if("ReturnStatement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isScopable=function(node,opts){if(!node)return !1;const nodeType=node.type;if("BlockStatement"===nodeType||"CatchClause"===nodeType||"DoWhileStatement"===nodeType||"ForInStatement"===nodeType||"ForStatement"===nodeType||"FunctionDeclaration"===nodeType||"FunctionExpression"===nodeType||"Program"===nodeType||"ObjectMethod"===nodeType||"SwitchStatement"===nodeType||"WhileStatement"===nodeType||"ArrowFunctionExpression"===nodeType||"ClassExpression"===nodeType||"ClassDeclaration"===nodeType||"ForOfStatement"===nodeType||"ClassMethod"===nodeType||"ClassPrivateMethod"===nodeType||"StaticBlock"===nodeType||"TSModuleBlock"===nodeType||"Placeholder"===nodeType&&"BlockStatement"===node.expectedNode)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isSequenceExpression=function(node,opts){if(!node)return !1;if("SequenceExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isSpreadElement=function(node,opts){if(!node)return !1;if("SpreadElement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isSpreadProperty=function(node,opts){if(console.trace("The node type SpreadProperty has been renamed to SpreadElement"),!node)return !1;if("SpreadProperty"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isStandardized=function(node,opts){if(!node)return !1;const nodeType=node.type;if("ArrayExpression"===nodeType||"AssignmentExpression"===nodeType||"BinaryExpression"===nodeType||"InterpreterDirective"===nodeType||"Directive"===nodeType||"DirectiveLiteral"===nodeType||"BlockStatement"===nodeType||"BreakStatement"===nodeType||"CallExpression"===nodeType||"CatchClause"===nodeType||"ConditionalExpression"===nodeType||"ContinueStatement"===nodeType||"DebuggerStatement"===nodeType||"DoWhileStatement"===nodeType||"EmptyStatement"===nodeType||"ExpressionStatement"===nodeType||"File"===nodeType||"ForInStatement"===nodeType||"ForStatement"===nodeType||"FunctionDeclaration"===nodeType||"FunctionExpression"===nodeType||"Identifier"===nodeType||"IfStatement"===nodeType||"LabeledStatement"===nodeType||"StringLiteral"===nodeType||"NumericLiteral"===nodeType||"NullLiteral"===nodeType||"BooleanLiteral"===nodeType||"RegExpLiteral"===nodeType||"LogicalExpression"===nodeType||"MemberExpression"===nodeType||"NewExpression"===nodeType||"Program"===nodeType||"ObjectExpression"===nodeType||"ObjectMethod"===nodeType||"ObjectProperty"===nodeType||"RestElement"===nodeType||"ReturnStatement"===nodeType||"SequenceExpression"===nodeType||"ParenthesizedExpression"===nodeType||"SwitchCase"===nodeType||"SwitchStatement"===nodeType||"ThisExpression"===nodeType||"ThrowStatement"===nodeType||"TryStatement"===nodeType||"UnaryExpression"===nodeType||"UpdateExpression"===nodeType||"VariableDeclaration"===nodeType||"VariableDeclarator"===nodeType||"WhileStatement"===nodeType||"WithStatement"===nodeType||"AssignmentPattern"===nodeType||"ArrayPattern"===nodeType||"ArrowFunctionExpression"===nodeType||"ClassBody"===nodeType||"ClassExpression"===nodeType||"ClassDeclaration"===nodeType||"ExportAllDeclaration"===nodeType||"ExportDefaultDeclaration"===nodeType||"ExportNamedDeclaration"===nodeType||"ExportSpecifier"===nodeType||"ForOfStatement"===nodeType||"ImportDeclaration"===nodeType||"ImportDefaultSpecifier"===nodeType||"ImportNamespaceSpecifier"===nodeType||"ImportSpecifier"===nodeType||"MetaProperty"===nodeType||"ClassMethod"===nodeType||"ObjectPattern"===nodeType||"SpreadElement"===nodeType||"Super"===nodeType||"TaggedTemplateExpression"===nodeType||"TemplateElement"===nodeType||"TemplateLiteral"===nodeType||"YieldExpression"===nodeType||"AwaitExpression"===nodeType||"Import"===nodeType||"BigIntLiteral"===nodeType||"ExportNamespaceSpecifier"===nodeType||"OptionalMemberExpression"===nodeType||"OptionalCallExpression"===nodeType||"ClassProperty"===nodeType||"ClassPrivateProperty"===nodeType||"ClassPrivateMethod"===nodeType||"PrivateName"===nodeType||"StaticBlock"===nodeType||"Placeholder"===nodeType&&("Identifier"===node.expectedNode||"StringLiteral"===node.expectedNode||"BlockStatement"===node.expectedNode||"ClassBody"===node.expectedNode))return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isStatement=function(node,opts){if(!node)return !1;const nodeType=node.type;if("BlockStatement"===nodeType||"BreakStatement"===nodeType||"ContinueStatement"===nodeType||"DebuggerStatement"===nodeType||"DoWhileStatement"===nodeType||"EmptyStatement"===nodeType||"ExpressionStatement"===nodeType||"ForInStatement"===nodeType||"ForStatement"===nodeType||"FunctionDeclaration"===nodeType||"IfStatement"===nodeType||"LabeledStatement"===nodeType||"ReturnStatement"===nodeType||"SwitchStatement"===nodeType||"ThrowStatement"===nodeType||"TryStatement"===nodeType||"VariableDeclaration"===nodeType||"WhileStatement"===nodeType||"WithStatement"===nodeType||"ClassDeclaration"===nodeType||"ExportAllDeclaration"===nodeType||"ExportDefaultDeclaration"===nodeType||"ExportNamedDeclaration"===nodeType||"ForOfStatement"===nodeType||"ImportDeclaration"===nodeType||"DeclareClass"===nodeType||"DeclareFunction"===nodeType||"DeclareInterface"===nodeType||"DeclareModule"===nodeType||"DeclareModuleExports"===nodeType||"DeclareTypeAlias"===nodeType||"DeclareOpaqueType"===nodeType||"DeclareVariable"===nodeType||"DeclareExportDeclaration"===nodeType||"DeclareExportAllDeclaration"===nodeType||"InterfaceDeclaration"===nodeType||"OpaqueType"===nodeType||"TypeAlias"===nodeType||"EnumDeclaration"===nodeType||"TSDeclareFunction"===nodeType||"TSInterfaceDeclaration"===nodeType||"TSTypeAliasDeclaration"===nodeType||"TSEnumDeclaration"===nodeType||"TSModuleDeclaration"===nodeType||"TSImportEqualsDeclaration"===nodeType||"TSExportAssignment"===nodeType||"TSNamespaceExportDeclaration"===nodeType||"Placeholder"===nodeType&&("Statement"===node.expectedNode||"Declaration"===node.expectedNode||"BlockStatement"===node.expectedNode))return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isStaticBlock=function(node,opts){if(!node)return !1;if("StaticBlock"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isStringLiteral=function(node,opts){if(!node)return !1;if("StringLiteral"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isStringLiteralTypeAnnotation=function(node,opts){if(!node)return !1;if("StringLiteralTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isStringTypeAnnotation=function(node,opts){if(!node)return !1;if("StringTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isSuper=function(node,opts){if(!node)return !1;if("Super"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isSwitchCase=function(node,opts){if(!node)return !1;if("SwitchCase"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isSwitchStatement=function(node,opts){if(!node)return !1;if("SwitchStatement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isSymbolTypeAnnotation=function(node,opts){if(!node)return !1;if("SymbolTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSAnyKeyword=function(node,opts){if(!node)return !1;if("TSAnyKeyword"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSArrayType=function(node,opts){if(!node)return !1;if("TSArrayType"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSAsExpression=function(node,opts){if(!node)return !1;if("TSAsExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSBaseType=function(node,opts){if(!node)return !1;const nodeType=node.type;if("TSAnyKeyword"===nodeType||"TSBooleanKeyword"===nodeType||"TSBigIntKeyword"===nodeType||"TSIntrinsicKeyword"===nodeType||"TSNeverKeyword"===nodeType||"TSNullKeyword"===nodeType||"TSNumberKeyword"===nodeType||"TSObjectKeyword"===nodeType||"TSStringKeyword"===nodeType||"TSSymbolKeyword"===nodeType||"TSUndefinedKeyword"===nodeType||"TSUnknownKeyword"===nodeType||"TSVoidKeyword"===nodeType||"TSThisType"===nodeType||"TSLiteralType"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSBigIntKeyword=function(node,opts){if(!node)return !1;if("TSBigIntKeyword"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSBooleanKeyword=function(node,opts){if(!node)return !1;if("TSBooleanKeyword"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSCallSignatureDeclaration=function(node,opts){if(!node)return !1;if("TSCallSignatureDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSConditionalType=function(node,opts){if(!node)return !1;if("TSConditionalType"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSConstructSignatureDeclaration=function(node,opts){if(!node)return !1;if("TSConstructSignatureDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSConstructorType=function(node,opts){if(!node)return !1;if("TSConstructorType"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSDeclareFunction=function(node,opts){if(!node)return !1;if("TSDeclareFunction"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSDeclareMethod=function(node,opts){if(!node)return !1;if("TSDeclareMethod"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSEntityName=function(node,opts){if(!node)return !1;const nodeType=node.type;if("Identifier"===nodeType||"TSQualifiedName"===nodeType||"Placeholder"===nodeType&&"Identifier"===node.expectedNode)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSEnumDeclaration=function(node,opts){if(!node)return !1;if("TSEnumDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSEnumMember=function(node,opts){if(!node)return !1;if("TSEnumMember"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSExportAssignment=function(node,opts){if(!node)return !1;if("TSExportAssignment"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSExpressionWithTypeArguments=function(node,opts){if(!node)return !1;if("TSExpressionWithTypeArguments"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSExternalModuleReference=function(node,opts){if(!node)return !1;if("TSExternalModuleReference"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSFunctionType=function(node,opts){if(!node)return !1;if("TSFunctionType"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSImportEqualsDeclaration=function(node,opts){if(!node)return !1;if("TSImportEqualsDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSImportType=function(node,opts){if(!node)return !1;if("TSImportType"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSIndexSignature=function(node,opts){if(!node)return !1;if("TSIndexSignature"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSIndexedAccessType=function(node,opts){if(!node)return !1;if("TSIndexedAccessType"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSInferType=function(node,opts){if(!node)return !1;if("TSInferType"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSInterfaceBody=function(node,opts){if(!node)return !1;if("TSInterfaceBody"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSInterfaceDeclaration=function(node,opts){if(!node)return !1;if("TSInterfaceDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSIntersectionType=function(node,opts){if(!node)return !1;if("TSIntersectionType"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSIntrinsicKeyword=function(node,opts){if(!node)return !1;if("TSIntrinsicKeyword"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSLiteralType=function(node,opts){if(!node)return !1;if("TSLiteralType"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSMappedType=function(node,opts){if(!node)return !1;if("TSMappedType"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSMethodSignature=function(node,opts){if(!node)return !1;if("TSMethodSignature"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSModuleBlock=function(node,opts){if(!node)return !1;if("TSModuleBlock"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSModuleDeclaration=function(node,opts){if(!node)return !1;if("TSModuleDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSNamedTupleMember=function(node,opts){if(!node)return !1;if("TSNamedTupleMember"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSNamespaceExportDeclaration=function(node,opts){if(!node)return !1;if("TSNamespaceExportDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSNeverKeyword=function(node,opts){if(!node)return !1;if("TSNeverKeyword"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSNonNullExpression=function(node,opts){if(!node)return !1;if("TSNonNullExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSNullKeyword=function(node,opts){if(!node)return !1;if("TSNullKeyword"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSNumberKeyword=function(node,opts){if(!node)return !1;if("TSNumberKeyword"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSObjectKeyword=function(node,opts){if(!node)return !1;if("TSObjectKeyword"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSOptionalType=function(node,opts){if(!node)return !1;if("TSOptionalType"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSParameterProperty=function(node,opts){if(!node)return !1;if("TSParameterProperty"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSParenthesizedType=function(node,opts){if(!node)return !1;if("TSParenthesizedType"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSPropertySignature=function(node,opts){if(!node)return !1;if("TSPropertySignature"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSQualifiedName=function(node,opts){if(!node)return !1;if("TSQualifiedName"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSRestType=function(node,opts){if(!node)return !1;if("TSRestType"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSStringKeyword=function(node,opts){if(!node)return !1;if("TSStringKeyword"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSSymbolKeyword=function(node,opts){if(!node)return !1;if("TSSymbolKeyword"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSThisType=function(node,opts){if(!node)return !1;if("TSThisType"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSTupleType=function(node,opts){if(!node)return !1;if("TSTupleType"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSType=function(node,opts){if(!node)return !1;const nodeType=node.type;if("TSAnyKeyword"===nodeType||"TSBooleanKeyword"===nodeType||"TSBigIntKeyword"===nodeType||"TSIntrinsicKeyword"===nodeType||"TSNeverKeyword"===nodeType||"TSNullKeyword"===nodeType||"TSNumberKeyword"===nodeType||"TSObjectKeyword"===nodeType||"TSStringKeyword"===nodeType||"TSSymbolKeyword"===nodeType||"TSUndefinedKeyword"===nodeType||"TSUnknownKeyword"===nodeType||"TSVoidKeyword"===nodeType||"TSThisType"===nodeType||"TSFunctionType"===nodeType||"TSConstructorType"===nodeType||"TSTypeReference"===nodeType||"TSTypePredicate"===nodeType||"TSTypeQuery"===nodeType||"TSTypeLiteral"===nodeType||"TSArrayType"===nodeType||"TSTupleType"===nodeType||"TSOptionalType"===nodeType||"TSRestType"===nodeType||"TSUnionType"===nodeType||"TSIntersectionType"===nodeType||"TSConditionalType"===nodeType||"TSInferType"===nodeType||"TSParenthesizedType"===nodeType||"TSTypeOperator"===nodeType||"TSIndexedAccessType"===nodeType||"TSMappedType"===nodeType||"TSLiteralType"===nodeType||"TSExpressionWithTypeArguments"===nodeType||"TSImportType"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSTypeAliasDeclaration=function(node,opts){if(!node)return !1;if("TSTypeAliasDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSTypeAnnotation=function(node,opts){if(!node)return !1;if("TSTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSTypeAssertion=function(node,opts){if(!node)return !1;if("TSTypeAssertion"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSTypeElement=function(node,opts){if(!node)return !1;const nodeType=node.type;if("TSCallSignatureDeclaration"===nodeType||"TSConstructSignatureDeclaration"===nodeType||"TSPropertySignature"===nodeType||"TSMethodSignature"===nodeType||"TSIndexSignature"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSTypeLiteral=function(node,opts){if(!node)return !1;if("TSTypeLiteral"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSTypeOperator=function(node,opts){if(!node)return !1;if("TSTypeOperator"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSTypeParameter=function(node,opts){if(!node)return !1;if("TSTypeParameter"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSTypeParameterDeclaration=function(node,opts){if(!node)return !1;if("TSTypeParameterDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSTypeParameterInstantiation=function(node,opts){if(!node)return !1;if("TSTypeParameterInstantiation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSTypePredicate=function(node,opts){if(!node)return !1;if("TSTypePredicate"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSTypeQuery=function(node,opts){if(!node)return !1;if("TSTypeQuery"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSTypeReference=function(node,opts){if(!node)return !1;if("TSTypeReference"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSUndefinedKeyword=function(node,opts){if(!node)return !1;if("TSUndefinedKeyword"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSUnionType=function(node,opts){if(!node)return !1;if("TSUnionType"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSUnknownKeyword=function(node,opts){if(!node)return !1;if("TSUnknownKeyword"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTSVoidKeyword=function(node,opts){if(!node)return !1;if("TSVoidKeyword"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTaggedTemplateExpression=function(node,opts){if(!node)return !1;if("TaggedTemplateExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTemplateElement=function(node,opts){if(!node)return !1;if("TemplateElement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTemplateLiteral=function(node,opts){if(!node)return !1;if("TemplateLiteral"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTerminatorless=function(node,opts){if(!node)return !1;const nodeType=node.type;if("BreakStatement"===nodeType||"ContinueStatement"===nodeType||"ReturnStatement"===nodeType||"ThrowStatement"===nodeType||"YieldExpression"===nodeType||"AwaitExpression"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isThisExpression=function(node,opts){if(!node)return !1;if("ThisExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isThisTypeAnnotation=function(node,opts){if(!node)return !1;if("ThisTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isThrowStatement=function(node,opts){if(!node)return !1;if("ThrowStatement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTopicReference=function(node,opts){if(!node)return !1;if("TopicReference"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTryStatement=function(node,opts){if(!node)return !1;if("TryStatement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTupleExpression=function(node,opts){if(!node)return !1;if("TupleExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTupleTypeAnnotation=function(node,opts){if(!node)return !1;if("TupleTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTypeAlias=function(node,opts){if(!node)return !1;if("TypeAlias"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTypeAnnotation=function(node,opts){if(!node)return !1;if("TypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTypeCastExpression=function(node,opts){if(!node)return !1;if("TypeCastExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTypeParameter=function(node,opts){if(!node)return !1;if("TypeParameter"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTypeParameterDeclaration=function(node,opts){if(!node)return !1;if("TypeParameterDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTypeParameterInstantiation=function(node,opts){if(!node)return !1;if("TypeParameterInstantiation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTypeScript=function(node,opts){if(!node)return !1;const nodeType=node.type;if("TSParameterProperty"===nodeType||"TSDeclareFunction"===nodeType||"TSDeclareMethod"===nodeType||"TSQualifiedName"===nodeType||"TSCallSignatureDeclaration"===nodeType||"TSConstructSignatureDeclaration"===nodeType||"TSPropertySignature"===nodeType||"TSMethodSignature"===nodeType||"TSIndexSignature"===nodeType||"TSAnyKeyword"===nodeType||"TSBooleanKeyword"===nodeType||"TSBigIntKeyword"===nodeType||"TSIntrinsicKeyword"===nodeType||"TSNeverKeyword"===nodeType||"TSNullKeyword"===nodeType||"TSNumberKeyword"===nodeType||"TSObjectKeyword"===nodeType||"TSStringKeyword"===nodeType||"TSSymbolKeyword"===nodeType||"TSUndefinedKeyword"===nodeType||"TSUnknownKeyword"===nodeType||"TSVoidKeyword"===nodeType||"TSThisType"===nodeType||"TSFunctionType"===nodeType||"TSConstructorType"===nodeType||"TSTypeReference"===nodeType||"TSTypePredicate"===nodeType||"TSTypeQuery"===nodeType||"TSTypeLiteral"===nodeType||"TSArrayType"===nodeType||"TSTupleType"===nodeType||"TSOptionalType"===nodeType||"TSRestType"===nodeType||"TSNamedTupleMember"===nodeType||"TSUnionType"===nodeType||"TSIntersectionType"===nodeType||"TSConditionalType"===nodeType||"TSInferType"===nodeType||"TSParenthesizedType"===nodeType||"TSTypeOperator"===nodeType||"TSIndexedAccessType"===nodeType||"TSMappedType"===nodeType||"TSLiteralType"===nodeType||"TSExpressionWithTypeArguments"===nodeType||"TSInterfaceDeclaration"===nodeType||"TSInterfaceBody"===nodeType||"TSTypeAliasDeclaration"===nodeType||"TSAsExpression"===nodeType||"TSTypeAssertion"===nodeType||"TSEnumDeclaration"===nodeType||"TSEnumMember"===nodeType||"TSModuleDeclaration"===nodeType||"TSModuleBlock"===nodeType||"TSImportType"===nodeType||"TSImportEqualsDeclaration"===nodeType||"TSExternalModuleReference"===nodeType||"TSNonNullExpression"===nodeType||"TSExportAssignment"===nodeType||"TSNamespaceExportDeclaration"===nodeType||"TSTypeAnnotation"===nodeType||"TSTypeParameterInstantiation"===nodeType||"TSTypeParameterDeclaration"===nodeType||"TSTypeParameter"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isTypeofTypeAnnotation=function(node,opts){if(!node)return !1;if("TypeofTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isUnaryExpression=function(node,opts){if(!node)return !1;if("UnaryExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isUnaryLike=function(node,opts){if(!node)return !1;const nodeType=node.type;if("UnaryExpression"===nodeType||"SpreadElement"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isUnionTypeAnnotation=function(node,opts){if(!node)return !1;if("UnionTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isUpdateExpression=function(node,opts){if(!node)return !1;if("UpdateExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isUserWhitespacable=function(node,opts){if(!node)return !1;const nodeType=node.type;if("ObjectMethod"===nodeType||"ObjectProperty"===nodeType||"ObjectTypeInternalSlot"===nodeType||"ObjectTypeCallProperty"===nodeType||"ObjectTypeIndexer"===nodeType||"ObjectTypeProperty"===nodeType||"ObjectTypeSpreadProperty"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isV8IntrinsicIdentifier=function(node,opts){if(!node)return !1;if("V8IntrinsicIdentifier"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isVariableDeclaration=function(node,opts){if(!node)return !1;if("VariableDeclaration"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isVariableDeclarator=function(node,opts){if(!node)return !1;if("VariableDeclarator"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isVariance=function(node,opts){if(!node)return !1;if("Variance"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isVoidTypeAnnotation=function(node,opts){if(!node)return !1;if("VoidTypeAnnotation"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isWhile=function(node,opts){if(!node)return !1;const nodeType=node.type;if("DoWhileStatement"===nodeType||"WhileStatement"===nodeType)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isWhileStatement=function(node,opts){if(!node)return !1;if("WhileStatement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isWithStatement=function(node,opts){if(!node)return !1;if("WithStatement"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1},exports.isYieldExpression=function(node,opts){if(!node)return !1;if("YieldExpression"===node.type)return void 0===opts||(0, _shallowEqual.default)(node,opts);return !1};var _shallowEqual=__webpack_require__("./node_modules/@babel/types/lib/utils/shallowEqual.js");},"./node_modules/@babel/types/lib/validators/is.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(type,node,opts){if(!node)return !1;if(!(0, _isType.default)(node.type,type))return !opts&&"Placeholder"===node.type&&type in _definitions.FLIPPED_ALIAS_KEYS&&(0, _isPlaceholderType.default)(node.expectedNode,type);return void 0===opts||(0, _shallowEqual.default)(node,opts)};var _shallowEqual=__webpack_require__("./node_modules/@babel/types/lib/utils/shallowEqual.js"),_isType=__webpack_require__("./node_modules/@babel/types/lib/validators/isType.js"),_isPlaceholderType=__webpack_require__("./node_modules/@babel/types/lib/validators/isPlaceholderType.js"),_definitions=__webpack_require__("./node_modules/@babel/types/lib/definitions/index.js");},"./node_modules/@babel/types/lib/validators/isBinding.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node,parent,grandparent){if(grandparent&&"Identifier"===node.type&&"ObjectProperty"===parent.type&&"ObjectExpression"===grandparent.type)return !1;const keys=_getBindingIdentifiers.default.keys[parent.type];if(keys)for(let i=0;i<keys.length;i++){const key=keys[i],val=parent[key];if(Array.isArray(val)){if(val.indexOf(node)>=0)return !0}else if(val===node)return !0}return !1};var _getBindingIdentifiers=__webpack_require__("./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js");},"./node_modules/@babel/types/lib/validators/isBlockScoped.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node){return (0, _generated.isFunctionDeclaration)(node)||(0, _generated.isClassDeclaration)(node)||(0, _isLet.default)(node)};var _generated=__webpack_require__("./node_modules/@babel/types/lib/validators/generated/index.js"),_isLet=__webpack_require__("./node_modules/@babel/types/lib/validators/isLet.js");},"./node_modules/@babel/types/lib/validators/isImmutable.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node){if((0, _isType.default)(node.type,"Immutable"))return !0;if((0, _generated.isIdentifier)(node))return "undefined"===node.name;return !1};var _isType=__webpack_require__("./node_modules/@babel/types/lib/validators/isType.js"),_generated=__webpack_require__("./node_modules/@babel/types/lib/validators/generated/index.js");},"./node_modules/@babel/types/lib/validators/isLet.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node){return (0, _generated.isVariableDeclaration)(node)&&("var"!==node.kind||node[_constants.BLOCK_SCOPED_SYMBOL])};var _generated=__webpack_require__("./node_modules/@babel/types/lib/validators/generated/index.js"),_constants=__webpack_require__("./node_modules/@babel/types/lib/constants/index.js");},"./node_modules/@babel/types/lib/validators/isNode.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node){return !(!node||!_definitions.VISITOR_KEYS[node.type])};var _definitions=__webpack_require__("./node_modules/@babel/types/lib/definitions/index.js");},"./node_modules/@babel/types/lib/validators/isNodesEquivalent.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function isNodesEquivalent(a,b){if("object"!=typeof a||"object"!=typeof b||null==a||null==b)return a===b;if(a.type!==b.type)return !1;const fields=Object.keys(_definitions.NODE_FIELDS[a.type]||a.type),visitorKeys=_definitions.VISITOR_KEYS[a.type];for(const field of fields){if(typeof a[field]!=typeof b[field])return !1;if(null!=a[field]||null!=b[field]){if(null==a[field]||null==b[field])return !1;if(Array.isArray(a[field])){if(!Array.isArray(b[field]))return !1;if(a[field].length!==b[field].length)return !1;for(let i=0;i<a[field].length;i++)if(!isNodesEquivalent(a[field][i],b[field][i]))return !1}else if("object"!=typeof a[field]||null!=visitorKeys&&visitorKeys.includes(field)){if(!isNodesEquivalent(a[field],b[field]))return !1}else for(const key of Object.keys(a[field]))if(a[field][key]!==b[field][key])return !1}}return !0};var _definitions=__webpack_require__("./node_modules/@babel/types/lib/definitions/index.js");},"./node_modules/@babel/types/lib/validators/isPlaceholderType.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(placeholderType,targetType){if(placeholderType===targetType)return !0;const aliases=_definitions.PLACEHOLDERS_ALIAS[placeholderType];if(aliases)for(const alias of aliases)if(targetType===alias)return !0;return !1};var _definitions=__webpack_require__("./node_modules/@babel/types/lib/definitions/index.js");},"./node_modules/@babel/types/lib/validators/isReferenced.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node,parent,grandparent){switch(parent.type){case"MemberExpression":case"OptionalMemberExpression":return parent.property===node?!!parent.computed:parent.object===node;case"JSXMemberExpression":return parent.object===node;case"VariableDeclarator":return parent.init===node;case"ArrowFunctionExpression":return parent.body===node;case"PrivateName":case"LabeledStatement":case"CatchClause":case"RestElement":case"BreakStatement":case"ContinueStatement":case"FunctionDeclaration":case"FunctionExpression":case"ExportNamespaceSpecifier":case"ExportDefaultSpecifier":case"ImportDefaultSpecifier":case"ImportNamespaceSpecifier":case"ImportSpecifier":case"ImportAttribute":case"JSXAttribute":case"ObjectPattern":case"ArrayPattern":case"MetaProperty":return !1;case"ClassMethod":case"ClassPrivateMethod":case"ObjectMethod":return parent.key===node&&!!parent.computed;case"ObjectProperty":return parent.key===node?!!parent.computed:!grandparent||"ObjectPattern"!==grandparent.type;case"ClassProperty":case"TSPropertySignature":return parent.key!==node||!!parent.computed;case"ClassPrivateProperty":case"ObjectTypeProperty":return parent.key!==node;case"ClassDeclaration":case"ClassExpression":return parent.superClass===node;case"AssignmentExpression":case"AssignmentPattern":return parent.right===node;case"ExportSpecifier":return (null==grandparent||!grandparent.source)&&parent.local===node;case"TSEnumMember":return parent.id!==node}return !0};},"./node_modules/@babel/types/lib/validators/isScope.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node,parent){if((0, _generated.isBlockStatement)(node)&&((0, _generated.isFunction)(parent)||(0, _generated.isCatchClause)(parent)))return !1;if((0, _generated.isPattern)(node)&&((0, _generated.isFunction)(parent)||(0, _generated.isCatchClause)(parent)))return !0;return (0, _generated.isScopable)(node)};var _generated=__webpack_require__("./node_modules/@babel/types/lib/validators/generated/index.js");},"./node_modules/@babel/types/lib/validators/isSpecifierDefault.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(specifier){return (0, _generated.isImportDefaultSpecifier)(specifier)||(0, _generated.isIdentifier)(specifier.imported||specifier.exported,{name:"default"})};var _generated=__webpack_require__("./node_modules/@babel/types/lib/validators/generated/index.js");},"./node_modules/@babel/types/lib/validators/isType.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(nodeType,targetType){if(nodeType===targetType)return !0;if(_definitions.ALIAS_KEYS[targetType])return !1;const aliases=_definitions.FLIPPED_ALIAS_KEYS[targetType];if(aliases){if(aliases[0]===nodeType)return !0;for(const alias of aliases)if(nodeType===alias)return !0}return !1};var _definitions=__webpack_require__("./node_modules/@babel/types/lib/definitions/index.js");},"./node_modules/@babel/types/lib/validators/isValidES3Identifier.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(name){return (0, _isValidIdentifier.default)(name)&&!RESERVED_WORDS_ES3_ONLY.has(name)};var _isValidIdentifier=__webpack_require__("./node_modules/@babel/types/lib/validators/isValidIdentifier.js");const RESERVED_WORDS_ES3_ONLY=new Set(["abstract","boolean","byte","char","double","enum","final","float","goto","implements","int","interface","long","native","package","private","protected","public","short","static","synchronized","throws","transient","volatile"]);},"./node_modules/@babel/types/lib/validators/isValidIdentifier.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(name,reserved=!0){if("string"!=typeof name)return !1;if(reserved&&((0, _helperValidatorIdentifier.isKeyword)(name)||(0, _helperValidatorIdentifier.isStrictReservedWord)(name,!0)))return !1;return (0, _helperValidatorIdentifier.isIdentifierName)(name)};var _helperValidatorIdentifier=__webpack_require__("./node_modules/@babel/helper-validator-identifier/lib/index.js");},"./node_modules/@babel/types/lib/validators/isVar.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node){return (0, _generated.isVariableDeclaration)(node,{kind:"var"})&&!node[_constants.BLOCK_SCOPED_SYMBOL]};var _generated=__webpack_require__("./node_modules/@babel/types/lib/validators/generated/index.js"),_constants=__webpack_require__("./node_modules/@babel/types/lib/constants/index.js");},"./node_modules/@babel/types/lib/validators/matchesPattern.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(member,match,allowPartial){if(!(0, _generated.isMemberExpression)(member))return !1;const parts=Array.isArray(match)?match:match.split("."),nodes=[];let node;for(node=member;(0, _generated.isMemberExpression)(node);node=node.object)nodes.push(node.property);if(nodes.push(node),nodes.length<parts.length)return !1;if(!allowPartial&&nodes.length>parts.length)return !1;for(let i=0,j=nodes.length-1;i<parts.length;i++,j--){const node=nodes[j];let value;if((0, _generated.isIdentifier)(node))value=node.name;else if((0, _generated.isStringLiteral)(node))value=node.value;else {if(!(0, _generated.isThisExpression)(node))return !1;value="this";}if(parts[i]!==value)return !1}return !0};var _generated=__webpack_require__("./node_modules/@babel/types/lib/validators/generated/index.js");},"./node_modules/@babel/types/lib/validators/react/isCompatTag.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(tagName){return !!tagName&&/^[a-z]/.test(tagName)};},"./node_modules/@babel/types/lib/validators/react/isReactComponent.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _default=(0, __webpack_require__("./node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js").default)("React.Component");exports.default=_default;},"./node_modules/@babel/types/lib/validators/validate.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(node,key,val){if(!node)return;const fields=_definitions.NODE_FIELDS[node.type];if(!fields)return;const field=fields[key];validateField(node,key,val,field),validateChild(node,key,val);},exports.validateChild=validateChild,exports.validateField=validateField;var _definitions=__webpack_require__("./node_modules/@babel/types/lib/definitions/index.js");function validateField(node,key,val,field){null!=field&&field.validate&&(field.optional&&null==val||field.validate(node,key,val));}function validateChild(node,key,val){if(null==val)return;const validate=_definitions.NODE_PARENT_VALIDATIONS[val.type];validate&&validate(node,key,val);}},"./node_modules/babel-plugin-dynamic-import-node/lib/index.js":(module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(api){var transformImport=(0, _utils.createDynamicImportTransform)(api);return {manipulateOptions:function(opts,parserOpts){parserOpts.plugins.push("dynamicImport");},visitor:{Import:function(path){transformImport(this,path);}}}};var _utils=__webpack_require__("./node_modules/babel-plugin-dynamic-import-node/lib/utils.js");module.exports=exports.default;},"./node_modules/babel-plugin-dynamic-import-node/lib/utils.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0});var _slicedToArray=function(arr,i){if(Array.isArray(arr))return arr;if(Symbol.iterator in Object(arr))return function(arr,i){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _s,_i=arr[Symbol.iterator]();!(_n=(_s=_i.next()).done)&&(_arr.push(_s.value),!i||_arr.length!==i);_n=!0);}catch(err){_d=!0,_e=err;}finally{try{!_n&&_i.return&&_i.return();}finally{if(_d)throw _e}}return _arr}(arr,i);throw new TypeError("Invalid attempt to destructure non-iterable instance")};function getImportSource(t,callNode){var importArguments=callNode.arguments,importPath=_slicedToArray(importArguments,1)[0];return t.isStringLiteral(importPath)||t.isTemplateLiteral(importPath)?(t.removeComments(importPath),importPath):t.templateLiteral([t.templateElement({raw:"",cooked:""}),t.templateElement({raw:"",cooked:""},!0)],importArguments)}exports.getImportSource=getImportSource,exports.createDynamicImportTransform=function(_ref){var template=_ref.template,t=_ref.types,builders={static:{interop:template("Promise.resolve().then(() => INTEROP(require(SOURCE)))"),noInterop:template("Promise.resolve().then(() => require(SOURCE))")},dynamic:{interop:template("Promise.resolve(SOURCE).then(s => INTEROP(require(s)))"),noInterop:template("Promise.resolve(SOURCE).then(s => require(s))")}},visited="function"==typeof WeakSet&&new WeakSet;return function(context,path){if(visited){if(visited.has(path))return;visited.add(path);}var node,SOURCE=getImportSource(t,path.parent),builder=(node=SOURCE,t.isStringLiteral(node)||t.isTemplateLiteral(node)&&0===node.expressions.length?builders.static:builders.dynamic),newImport=context.opts.noInterop?builder.noInterop({SOURCE}):builder.interop({SOURCE,INTEROP:context.addHelper("interopRequireWildcard")});path.parentPath.replaceWith(newImport);}};},"./node_modules/babel-plugin-dynamic-import-node/utils.js":(module,__unused_webpack_exports,__webpack_require__)=>{module.exports=__webpack_require__("./node_modules/babel-plugin-dynamic-import-node/lib/utils.js");},"./node_modules/babel-plugin-parameter-decorator/lib/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{var _path=__webpack_require__("path");function isInType(path){switch(path.parent.type){case"TSTypeReference":case"TSQualifiedName":case"TSExpressionWithTypeArguments":case"TSTypeQuery":return !0;default:return !1}}module.exports=function(_ref){var types=_ref.types,decoratorExpressionForConstructor=function(decorator,param){return function(className){var resultantDecorator=types.callExpression(decorator.expression,[types.Identifier(className),types.Identifier("undefined"),types.NumericLiteral(param.key)]),resultantDecoratorWithFallback=types.logicalExpression("||",resultantDecorator,types.Identifier(className)),assignment=types.assignmentExpression("=",types.Identifier(className),resultantDecoratorWithFallback);return types.expressionStatement(assignment)}},decoratorExpressionForMethod=function(decorator,param){return function(className,functionName){var resultantDecorator=types.callExpression(decorator.expression,[types.Identifier("".concat(className,".prototype")),types.StringLiteral(functionName),types.NumericLiteral(param.key)]);return types.expressionStatement(resultantDecorator)}};return {visitor:{Program:function(path,state){var extension=(0, _path.extname)(state.file.opts.filename);".ts"!==extension&&".tsx"!==extension||function(){var decorators=Object.create(null);path.node.body.filter((function(it){var type=it.type,declaration=it.declaration;switch(type){case"ClassDeclaration":return !0;case"ExportNamedDeclaration":case"ExportDefaultDeclaration":return declaration&&"ClassDeclaration"===declaration.type;default:return !1}})).map((function(it){return "ClassDeclaration"===it.type?it:it.declaration})).forEach((function(clazz){clazz.body.body.forEach((function(body){(body.params||[]).forEach((function(param){(param.decorators||[]).forEach((function(decorator){decorator.expression.callee?decorators[decorator.expression.callee.name]=decorator:decorators[decorator.expression.name]=decorator;}));}));}));}));var _iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _step,_iterator=path.get("body")[Symbol.iterator]();!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=!0){var stmt=_step.value;if("ImportDeclaration"===stmt.node.type){if(0===stmt.node.specifiers.length)continue;var _iteratorNormalCompletion2=!0,_didIteratorError2=!1,_iteratorError2=void 0;try{for(var _step2,_loop=function(){var specifier=_step2.value,binding=stmt.scope.getBinding(specifier.local.name);binding.referencePaths.length?binding.referencePaths.reduce((function(prev,next){return prev||isInType(next)}),!1)&&Object.keys(decorators).forEach((function(k){var decorator=decorators[k];(decorator.expression.arguments||[]).forEach((function(arg){arg.name===specifier.local.name&&binding.referencePaths.push({parent:decorator.expression});}));})):decorators[specifier.local.name]&&binding.referencePaths.push({parent:decorators[specifier.local.name]});},_iterator2=stmt.node.specifiers[Symbol.iterator]();!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=!0)_loop();}catch(err){_didIteratorError2=!0,_iteratorError2=err;}finally{try{_iteratorNormalCompletion2||null==_iterator2.return||_iterator2.return();}finally{if(_didIteratorError2)throw _iteratorError2}}}}}catch(err){_didIteratorError=!0,_iteratorError=err;}finally{try{_iteratorNormalCompletion||null==_iterator.return||_iterator.return();}finally{if(_didIteratorError)throw _iteratorError}}}();},Function:function(path){var functionName="";path.node.id?functionName=path.node.id.name:path.node.key&&(functionName=path.node.key.name),(path.get("params")||[]).slice().forEach((function(param){var decorators=param.node.decorators||[],transformable=decorators.length;if(decorators.slice().forEach((function(decorator){if("ClassMethod"===path.type){var classIdentifier,parentNode=path.parentPath.parentPath,classDeclaration=path.findParent((function(p){return "ClassDeclaration"===p.type}));if(classDeclaration?classIdentifier=classDeclaration.node.id.name:(parentNode.insertAfter(null),classIdentifier=function(path){var assignment=path.findParent((function(p){return "AssignmentExpression"===p.node.type}));return "SequenceExpression"===assignment.node.right.type?assignment.node.right.expressions[1].name:"ClassExpression"===assignment.node.right.type?assignment.node.left.name:null}(path)),"constructor"===functionName){var expression=decoratorExpressionForConstructor(decorator,param)(classIdentifier);parentNode.insertAfter(expression);}else {var _expression=decoratorExpressionForMethod(decorator,param)(classIdentifier,functionName);parentNode.insertAfter(_expression);}}else {var className=path.findParent((function(p){return "VariableDeclarator"===p.node.type})).node.id.name;if(functionName===className){var _expression2=decoratorExpressionForConstructor(decorator,param)(className);if("body"===path.parentKey)path.insertAfter(_expression2);else path.findParent((function(p){return "body"===p.parentKey})).insertAfter(_expression2);}else {var classParent=path.findParent((function(p){return "CallExpression"===p.node.type})),_expression3=decoratorExpressionForMethod(decorator,param)(className,functionName);classParent.insertAfter(_expression3);}}})),transformable){var replacement=function(path){switch(path.node.type){case"ObjectPattern":return types.ObjectPattern(path.node.properties);case"AssignmentPattern":return types.AssignmentPattern(path.node.left,path.node.right);case"TSParameterProperty":return types.Identifier(path.node.parameter.name);default:return types.Identifier(path.node.name)}}(param);param.replaceWith(replacement);}}));}}}};},"./node_modules/convert-source-map/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{var fs=__webpack_require__("fs"),path=__webpack_require__("path"),SafeBuffer=__webpack_require__("./node_modules/safe-buffer/index.js");function Converter(sm,opts){var base64;(opts=opts||{}).isFileComment&&(sm=function(sm,dir){var r=exports.mapFileCommentRegex.exec(sm),filename=r[1]||r[2],filepath=path.resolve(dir,filename);try{return fs.readFileSync(filepath,"utf8")}catch(e){throw new Error("An error occurred while trying to read the map file at "+filepath+"\n"+e)}}(sm,opts.commentFileDir)),opts.hasComment&&(sm=function(sm){return sm.split(",").pop()}(sm)),opts.isEncoded&&(base64=sm,sm=(SafeBuffer.Buffer.from(base64,"base64")||"").toString()),(opts.isJSON||opts.isEncoded)&&(sm=JSON.parse(sm)),this.sourcemap=sm;}Object.defineProperty(exports,"commentRegex",{get:function(){return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/gm}}),Object.defineProperty(exports,"mapFileCommentRegex",{get:function(){return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/gm}}),Converter.prototype.toJSON=function(space){return JSON.stringify(this.sourcemap,null,space)},Converter.prototype.toBase64=function(){var json=this.toJSON();return (SafeBuffer.Buffer.from(json,"utf8")||"").toString("base64")},Converter.prototype.toComment=function(options){var data="sourceMappingURL=data:application/json;charset=utf-8;base64,"+this.toBase64();return options&&options.multiline?"/*# "+data+" */":"//# "+data},Converter.prototype.toObject=function(){return JSON.parse(this.toJSON())},Converter.prototype.addProperty=function(key,value){if(this.sourcemap.hasOwnProperty(key))throw new Error('property "'+key+'" already exists on the sourcemap, use set property instead');return this.setProperty(key,value)},Converter.prototype.setProperty=function(key,value){return this.sourcemap[key]=value,this},Converter.prototype.getProperty=function(key){return this.sourcemap[key]},exports.fromObject=function(obj){return new Converter(obj)},exports.fromJSON=function(json){return new Converter(json,{isJSON:!0})},exports.fromBase64=function(base64){return new Converter(base64,{isEncoded:!0})},exports.fromComment=function(comment){return new Converter(comment=comment.replace(/^\/\*/g,"//").replace(/\*\/$/g,""),{isEncoded:!0,hasComment:!0})},exports.fromMapFileComment=function(comment,dir){return new Converter(comment,{commentFileDir:dir,isFileComment:!0,isJSON:!0})},exports.fromSource=function(content){var m=content.match(exports.commentRegex);return m?exports.fromComment(m.pop()):null},exports.fromMapFileSource=function(content,dir){var m=content.match(exports.mapFileCommentRegex);return m?exports.fromMapFileComment(m.pop(),dir):null},exports.removeComments=function(src){return src.replace(exports.commentRegex,"")},exports.removeMapFileComments=function(src){return src.replace(exports.mapFileCommentRegex,"")},exports.generateMapFileComment=function(file,options){var data="sourceMappingURL="+file;return options&&options.multiline?"/*# "+data+" */":"//# "+data};},"./node_modules/debug/src/browser.js":(module,exports,__webpack_require__)=>{exports.formatArgs=function(args){if(args[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+args[0]+(this.useColors?"%c ":" ")+"+"+module.exports.humanize(this.diff),!this.useColors)return;const c="color: "+this.color;args.splice(1,0,c,"color: inherit");let index=0,lastC=0;args[0].replace(/%[a-zA-Z%]/g,(match=>{"%%"!==match&&(index++,"%c"===match&&(lastC=index));})),args.splice(lastC,0,c);},exports.save=function(namespaces){try{namespaces?exports.storage.setItem("debug",namespaces):exports.storage.removeItem("debug");}catch(error){}},exports.load=function(){let r;try{r=exports.storage.getItem("debug");}catch(error){}!r&&"undefined"!=typeof process&&"env"in process&&(r=process.env.DEBUG);return r},exports.useColors=function(){if("undefined"!=typeof window&&window.process&&("renderer"===window.process.type||window.process.__nwjs))return !0;if("undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return !1;return "undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},exports.storage=function(){try{return localStorage}catch(error){}}(),exports.destroy=(()=>{let warned=!1;return ()=>{warned||(warned=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));}})(),exports.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],exports.log=console.debug||console.log||(()=>{}),module.exports=__webpack_require__("./node_modules/debug/src/common.js")(exports);const{formatters}=module.exports;formatters.j=function(v){try{return JSON.stringify(v)}catch(error){return "[UnexpectedJSONParseError]: "+error.message}};},"./node_modules/debug/src/common.js":(module,__unused_webpack_exports,__webpack_require__)=>{module.exports=function(env){function createDebug(namespace){let prevTime,namespacesCache,enabledCache,enableOverride=null;function debug(...args){if(!debug.enabled)return;const self=debug,curr=Number(new Date),ms=curr-(prevTime||curr);self.diff=ms,self.prev=prevTime,self.curr=curr,prevTime=curr,args[0]=createDebug.coerce(args[0]),"string"!=typeof args[0]&&args.unshift("%O");let index=0;args[0]=args[0].replace(/%([a-zA-Z%])/g,((match,format)=>{if("%%"===match)return "%";index++;const formatter=createDebug.formatters[format];if("function"==typeof formatter){const val=args[index];match=formatter.call(self,val),args.splice(index,1),index--;}return match})),createDebug.formatArgs.call(self,args);(self.log||createDebug.log).apply(self,args);}return debug.namespace=namespace,debug.useColors=createDebug.useColors(),debug.color=createDebug.selectColor(namespace),debug.extend=extend,debug.destroy=createDebug.destroy,Object.defineProperty(debug,"enabled",{enumerable:!0,configurable:!1,get:()=>null!==enableOverride?enableOverride:(namespacesCache!==createDebug.namespaces&&(namespacesCache=createDebug.namespaces,enabledCache=createDebug.enabled(namespace)),enabledCache),set:v=>{enableOverride=v;}}),"function"==typeof createDebug.init&&createDebug.init(debug),debug}function extend(namespace,delimiter){const newDebug=createDebug(this.namespace+(void 0===delimiter?":":delimiter)+namespace);return newDebug.log=this.log,newDebug}function toNamespace(regexp){return regexp.toString().substring(2,regexp.toString().length-2).replace(/\.\*\?$/,"*")}return createDebug.debug=createDebug,createDebug.default=createDebug,createDebug.coerce=function(val){if(val instanceof Error)return val.stack||val.message;return val},createDebug.disable=function(){const namespaces=[...createDebug.names.map(toNamespace),...createDebug.skips.map(toNamespace).map((namespace=>"-"+namespace))].join(",");return createDebug.enable(""),namespaces},createDebug.enable=function(namespaces){let i;createDebug.save(namespaces),createDebug.namespaces=namespaces,createDebug.names=[],createDebug.skips=[];const split=("string"==typeof namespaces?namespaces:"").split(/[\s,]+/),len=split.length;for(i=0;i<len;i++)split[i]&&("-"===(namespaces=split[i].replace(/\*/g,".*?"))[0]?createDebug.skips.push(new RegExp("^"+namespaces.substr(1)+"$")):createDebug.names.push(new RegExp("^"+namespaces+"$")));},createDebug.enabled=function(name){if("*"===name[name.length-1])return !0;let i,len;for(i=0,len=createDebug.skips.length;i<len;i++)if(createDebug.skips[i].test(name))return !1;for(i=0,len=createDebug.names.length;i<len;i++)if(createDebug.names[i].test(name))return !0;return !1},createDebug.humanize=__webpack_require__("./node_modules/ms/index.js"),createDebug.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");},Object.keys(env).forEach((key=>{createDebug[key]=env[key];})),createDebug.names=[],createDebug.skips=[],createDebug.formatters={},createDebug.selectColor=function(namespace){let hash=0;for(let i=0;i<namespace.length;i++)hash=(hash<<5)-hash+namespace.charCodeAt(i),hash|=0;return createDebug.colors[Math.abs(hash)%createDebug.colors.length]},createDebug.enable(createDebug.load()),createDebug};},"./node_modules/debug/src/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"undefined"==typeof process||"renderer"===process.type||!0===process.browser||process.__nwjs?module.exports=__webpack_require__("./node_modules/debug/src/browser.js"):module.exports=__webpack_require__("./node_modules/debug/src/node.js");},"./node_modules/debug/src/node.js":(module,exports,__webpack_require__)=>{const tty=__webpack_require__("tty"),util=__webpack_require__("util");exports.init=function(debug){debug.inspectOpts={};const keys=Object.keys(exports.inspectOpts);for(let i=0;i<keys.length;i++)debug.inspectOpts[keys[i]]=exports.inspectOpts[keys[i]];},exports.log=function(...args){return process.stderr.write(util.format(...args)+"\n")},exports.formatArgs=function(args){const{namespace:name,useColors}=this;if(useColors){const c=this.color,colorCode="[3"+(c<8?c:"8;5;"+c),prefix=`  ${colorCode};1m${name} [0m`;args[0]=prefix+args[0].split("\n").join("\n"+prefix),args.push(colorCode+"m+"+module.exports.humanize(this.diff)+"[0m");}else args[0]=function(){if(exports.inspectOpts.hideDate)return "";return (new Date).toISOString()+" "}()+name+" "+args[0];},exports.save=function(namespaces){namespaces?process.env.DEBUG=namespaces:delete process.env.DEBUG;},exports.load=function(){return process.env.DEBUG},exports.useColors=function(){return "colors"in exports.inspectOpts?Boolean(exports.inspectOpts.colors):tty.isatty(process.stderr.fd)},exports.destroy=util.deprecate((()=>{}),"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."),exports.colors=[6,2,3,4,5,1];try{const supportsColor=__webpack_require__("./node_modules/supports-color/index.js");supportsColor&&(supportsColor.stderr||supportsColor).level>=2&&(exports.colors=[20,21,26,27,32,33,38,39,40,41,42,43,44,45,56,57,62,63,68,69,74,75,76,77,78,79,80,81,92,93,98,99,112,113,128,129,134,135,148,149,160,161,162,163,164,165,166,167,168,169,170,171,172,173,178,179,184,185,196,197,198,199,200,201,202,203,204,205,206,207,208,209,214,215,220,221]);}catch(error){}exports.inspectOpts=Object.keys(process.env).filter((key=>/^debug_/i.test(key))).reduce(((obj,key)=>{const prop=key.substring(6).toLowerCase().replace(/_([a-z])/g,((_,k)=>k.toUpperCase()));let val=process.env[key];return val=!!/^(yes|on|true|enabled)$/i.test(val)||!/^(no|off|false|disabled)$/i.test(val)&&("null"===val?null:Number(val)),obj[prop]=val,obj}),{}),module.exports=__webpack_require__("./node_modules/debug/src/common.js")(exports);const{formatters}=module.exports;formatters.o=function(v){return this.inspectOpts.colors=this.useColors,util.inspect(v,this.inspectOpts).split("\n").map((str=>str.trim())).join(" ")},formatters.O=function(v){return this.inspectOpts.colors=this.useColors,util.inspect(v,this.inspectOpts)};},"./node_modules/gensync/index.js":module=>{const GENSYNC_START=Symbol.for("gensync:v1:start"),GENSYNC_SUSPEND=Symbol.for("gensync:v1:suspend");function assertTypeof(type,name,value,allowUndefined){if(typeof value===type||allowUndefined&&void 0===value)return;let msg;throw msg=allowUndefined?`Expected opts.${name} to be either a ${type}, or undefined.`:`Expected opts.${name} to be a ${type}.`,makeError(msg,"GENSYNC_OPTIONS_ERROR")}function makeError(msg,code){return Object.assign(new Error(msg),{code})}function buildOperation({name,arity,sync,async}){return setFunctionMetadata(name,arity,(function*(...args){const resume=yield GENSYNC_START;if(!resume){return sync.call(this,args)}let result;try{async.call(this,args,(value=>{result||(result={value},resume());}),(err=>{result||(result={err},resume());}));}catch(err){result={err},resume();}if(yield GENSYNC_SUSPEND,result.hasOwnProperty("err"))throw result.err;return result.value}))}function evaluateSync(gen){let value;for(;!({value}=gen.next()).done;)assertStart(value,gen);return value}function evaluateAsync(gen,resolve,reject){!function step(){try{let value;for(;!({value}=gen.next()).done;){assertStart(value,gen);let sync=!0,didSyncResume=!1;const out=gen.next((()=>{sync?didSyncResume=!0:step();}));if(sync=!1,assertSuspend(out,gen),!didSyncResume)return}return resolve(value)}catch(err){return reject(err)}}();}function assertStart(value,gen){value!==GENSYNC_START&&throwError(gen,makeError(`Got unexpected yielded value in gensync generator: ${JSON.stringify(value)}. Did you perhaps mean to use 'yield*' instead of 'yield'?`,"GENSYNC_EXPECTED_START"));}function assertSuspend({value,done},gen){(done||value!==GENSYNC_SUSPEND)&&throwError(gen,makeError(done?"Unexpected generator completion. If you get this, it is probably a gensync bug.":`Expected GENSYNC_SUSPEND, got ${JSON.stringify(value)}. If you get this, it is probably a gensync bug.`,"GENSYNC_EXPECTED_SUSPEND"));}function throwError(gen,err){throw gen.throw&&gen.throw(err),err}function setFunctionMetadata(name,arity,fn){if("string"==typeof name){const nameDesc=Object.getOwnPropertyDescriptor(fn,"name");nameDesc&&!nameDesc.configurable||Object.defineProperty(fn,"name",Object.assign(nameDesc||{},{configurable:!0,value:name}));}if("number"==typeof arity){const lengthDesc=Object.getOwnPropertyDescriptor(fn,"length");lengthDesc&&!lengthDesc.configurable||Object.defineProperty(fn,"length",Object.assign(lengthDesc||{},{configurable:!0,value:arity}));}return fn}module.exports=Object.assign((function(optsOrFn){let genFn=optsOrFn;return genFn="function"!=typeof optsOrFn?function({name,arity,sync,async,errback}){if(assertTypeof("string","name",name,!0),assertTypeof("number","arity",arity,!0),assertTypeof("function","sync",sync),assertTypeof("function","async",async,!0),assertTypeof("function","errback",errback,!0),async&&errback)throw makeError("Expected one of either opts.async or opts.errback, but got _both_.","GENSYNC_OPTIONS_ERROR");if("string"!=typeof name){let fnName;errback&&errback.name&&"errback"!==errback.name&&(fnName=errback.name),async&&async.name&&"async"!==async.name&&(fnName=async.name.replace(/Async$/,"")),sync&&sync.name&&"sync"!==sync.name&&(fnName=sync.name.replace(/Sync$/,"")),"string"==typeof fnName&&(name=fnName);}"number"!=typeof arity&&(arity=sync.length);return buildOperation({name,arity,sync:function(args){return sync.apply(this,args)},async:function(args,resolve,reject){async?async.apply(this,args).then(resolve,reject):errback?errback.call(this,...args,((err,value)=>{null==err?resolve(value):reject(err);})):resolve(sync.apply(this,args));}})}(optsOrFn):function(genFn){return setFunctionMetadata(genFn.name,genFn.length,(function(...args){return genFn.apply(this,args)}))}(optsOrFn),Object.assign(genFn,function(genFn){return {sync:function(...args){return evaluateSync(genFn.apply(this,args))},async:function(...args){return new Promise(((resolve,reject)=>{evaluateAsync(genFn.apply(this,args),resolve,reject);}))},errback:function(...args){const cb=args.pop();if("function"!=typeof cb)throw makeError("Asynchronous function called without callback","GENSYNC_ERRBACK_NO_CALLBACK");let gen;try{gen=genFn.apply(this,args);}catch(err){return void cb(err)}evaluateAsync(gen,(val=>cb(void 0,val)),(err=>cb(err)));}}}(genFn))}),{all:buildOperation({name:"all",arity:1,sync:function(args){return Array.from(args[0]).map((item=>evaluateSync(item)))},async:function(args,resolve,reject){const items=Array.from(args[0]);if(0===items.length)return void Promise.resolve().then((()=>resolve([])));let count=0;const results=items.map((()=>{}));items.forEach(((item,i)=>{evaluateAsync(item,(val=>{results[i]=val,count+=1,count===results.length&&resolve(results);}),reject);}));}}),race:buildOperation({name:"race",arity:1,sync:function(args){const items=Array.from(args[0]);if(0===items.length)throw makeError("Must race at least 1 item","GENSYNC_RACE_NONEMPTY");return evaluateSync(items[0])},async:function(args,resolve,reject){const items=Array.from(args[0]);if(0===items.length)throw makeError("Must race at least 1 item","GENSYNC_RACE_NONEMPTY");for(const item of items)evaluateAsync(item,resolve,reject);}})});},"./node_modules/jsesc/jsesc.js":module=>{const object={},hasOwnProperty=object.hasOwnProperty,forOwn=(object,callback)=>{for(const key in object)hasOwnProperty.call(object,key)&&callback(key,object[key]);},toString=object.toString,isArray=Array.isArray,isBuffer=Buffer.isBuffer,singleEscapes={'"':'\\"',"'":"\\'","\\":"\\\\","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t"},regexSingleEscape=/["'\\\b\f\n\r\t]/,regexDigit=/[0-9]/,regexWhitelist=/[ !#-&\(-\[\]-_a-~]/,jsesc=(argument,options)=>{const increaseIndentation=()=>{oldIndent=indent,++options.indentLevel,indent=options.indent.repeat(options.indentLevel);},defaults={escapeEverything:!1,minimal:!1,isScriptContext:!1,quotes:"single",wrap:!1,es6:!1,json:!1,compact:!0,lowercaseHex:!1,numbers:"decimal",indent:"\t",indentLevel:0,__inline1__:!1,__inline2__:!1},json=options&&options.json;var destination,source;json&&(defaults.quotes="double",defaults.wrap=!0),destination=defaults,options=(source=options)?(forOwn(source,((key,value)=>{destination[key]=value;})),destination):destination,"single"!=options.quotes&&"double"!=options.quotes&&"backtick"!=options.quotes&&(options.quotes="single");const quote="double"==options.quotes?'"':"backtick"==options.quotes?"`":"'",compact=options.compact,lowercaseHex=options.lowercaseHex;let indent=options.indent.repeat(options.indentLevel),oldIndent="";const inline1=options.__inline1__,inline2=options.__inline2__,newLine=compact?"":"\n";let result,isEmpty=!0;const useBinNumbers="binary"==options.numbers,useOctNumbers="octal"==options.numbers,useDecNumbers="decimal"==options.numbers,useHexNumbers="hexadecimal"==options.numbers;if(json&&argument&&"function"==typeof argument.toJSON&&(argument=argument.toJSON()),!(value=>"string"==typeof value||"[object String]"==toString.call(value))(argument)){if((value=>"[object Map]"==toString.call(value))(argument))return 0==argument.size?"new Map()":(compact||(options.__inline1__=!0,options.__inline2__=!1),"new Map("+jsesc(Array.from(argument),options)+")");if((value=>"[object Set]"==toString.call(value))(argument))return 0==argument.size?"new Set()":"new Set("+jsesc(Array.from(argument),options)+")";if(isBuffer(argument))return 0==argument.length?"Buffer.from([])":"Buffer.from("+jsesc(Array.from(argument),options)+")";if(isArray(argument))return result=[],options.wrap=!0,inline1&&(options.__inline1__=!1,options.__inline2__=!0),inline2||increaseIndentation(),((array,callback)=>{const length=array.length;let index=-1;for(;++index<length;)callback(array[index]);})(argument,(value=>{isEmpty=!1,inline2&&(options.__inline2__=!1),result.push((compact||inline2?"":indent)+jsesc(value,options));})),isEmpty?"[]":inline2?"["+result.join(", ")+"]":"["+newLine+result.join(","+newLine)+newLine+(compact?"":oldIndent)+"]";if(!(value=>"number"==typeof value||"[object Number]"==toString.call(value))(argument))return (value=>"[object Object]"==toString.call(value))(argument)?(result=[],options.wrap=!0,increaseIndentation(),forOwn(argument,((key,value)=>{isEmpty=!1,result.push((compact?"":indent)+jsesc(key,options)+":"+(compact?"":" ")+jsesc(value,options));})),isEmpty?"{}":"{"+newLine+result.join(","+newLine)+newLine+(compact?"":oldIndent)+"}"):json?JSON.stringify(argument)||"null":String(argument);if(json)return JSON.stringify(argument);if(useDecNumbers)return String(argument);if(useHexNumbers){let hexadecimal=argument.toString(16);return lowercaseHex||(hexadecimal=hexadecimal.toUpperCase()),"0x"+hexadecimal}if(useBinNumbers)return "0b"+argument.toString(2);if(useOctNumbers)return "0o"+argument.toString(8)}const string=argument;let index=-1;const length=string.length;for(result="";++index<length;){const character=string.charAt(index);if(options.es6){const first=string.charCodeAt(index);if(first>=55296&&first<=56319&&length>index+1){const second=string.charCodeAt(index+1);if(second>=56320&&second<=57343){let hexadecimal=(1024*(first-55296)+second-56320+65536).toString(16);lowercaseHex||(hexadecimal=hexadecimal.toUpperCase()),result+="\\u{"+hexadecimal+"}",++index;continue}}}if(!options.escapeEverything){if(regexWhitelist.test(character)){result+=character;continue}if('"'==character){result+=quote==character?'\\"':character;continue}if("`"==character){result+=quote==character?"\\`":character;continue}if("'"==character){result+=quote==character?"\\'":character;continue}}if("\0"==character&&!json&&!regexDigit.test(string.charAt(index+1))){result+="\\0";continue}if(regexSingleEscape.test(character)){result+=singleEscapes[character];continue}const charCode=character.charCodeAt(0);if(options.minimal&&8232!=charCode&&8233!=charCode){result+=character;continue}let hexadecimal=charCode.toString(16);lowercaseHex||(hexadecimal=hexadecimal.toUpperCase());const longhand=hexadecimal.length>2||json,escaped="\\"+(longhand?"u":"x")+("0000"+hexadecimal).slice(longhand?-4:-2);result+=escaped;}return options.wrap&&(result=quote+result+quote),"`"==quote&&(result=result.replace(/\$\{/g,"\\${")),options.isScriptContext?result.replace(/<\/(script|style)/gi,"<\\/$1").replace(/<!--/g,json?"\\u003C!--":"\\x3C!--"):result};jsesc.version="2.5.2",module.exports=jsesc;},"./node_modules/ms/index.js":module=>{var s=1e3,m=60*s,h=60*m,d=24*h,w=7*d,y=365.25*d;function plural(ms,msAbs,n,name){var isPlural=msAbs>=1.5*n;return Math.round(ms/n)+" "+name+(isPlural?"s":"")}module.exports=function(val,options){options=options||{};var type=typeof val;if("string"===type&&val.length>0)return function(str){if((str=String(str)).length>100)return;var match=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);if(!match)return;var n=parseFloat(match[1]);switch((match[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return n*y;case"weeks":case"week":case"w":return n*w;case"days":case"day":case"d":return n*d;case"hours":case"hour":case"hrs":case"hr":case"h":return n*h;case"minutes":case"minute":case"mins":case"min":case"m":return n*m;case"seconds":case"second":case"secs":case"sec":case"s":return n*s;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return n;default:return}}(val);if("number"===type&&isFinite(val))return options.long?function(ms){var msAbs=Math.abs(ms);if(msAbs>=d)return plural(ms,msAbs,d,"day");if(msAbs>=h)return plural(ms,msAbs,h,"hour");if(msAbs>=m)return plural(ms,msAbs,m,"minute");if(msAbs>=s)return plural(ms,msAbs,s,"second");return ms+" ms"}(val):function(ms){var msAbs=Math.abs(ms);if(msAbs>=d)return Math.round(ms/d)+"d";if(msAbs>=h)return Math.round(ms/h)+"h";if(msAbs>=m)return Math.round(ms/m)+"m";if(msAbs>=s)return Math.round(ms/s)+"s";return ms+"ms"}(val);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(val))};},"./node_modules/safe-buffer/index.js":(module,exports,__webpack_require__)=>{var buffer=__webpack_require__("buffer"),Buffer=buffer.Buffer;function copyProps(src,dst){for(var key in src)dst[key]=src[key];}function SafeBuffer(arg,encodingOrOffset,length){return Buffer(arg,encodingOrOffset,length)}Buffer.from&&Buffer.alloc&&Buffer.allocUnsafe&&Buffer.allocUnsafeSlow?module.exports=buffer:(copyProps(buffer,exports),exports.Buffer=SafeBuffer),copyProps(Buffer,SafeBuffer),SafeBuffer.from=function(arg,encodingOrOffset,length){if("number"==typeof arg)throw new TypeError("Argument must not be a number");return Buffer(arg,encodingOrOffset,length)},SafeBuffer.alloc=function(size,fill,encoding){if("number"!=typeof size)throw new TypeError("Argument must be a number");var buf=Buffer(size);return void 0!==fill?"string"==typeof encoding?buf.fill(fill,encoding):buf.fill(fill):buf.fill(0),buf},SafeBuffer.allocUnsafe=function(size){if("number"!=typeof size)throw new TypeError("Argument must be a number");return Buffer(size)},SafeBuffer.allocUnsafeSlow=function(size){if("number"!=typeof size)throw new TypeError("Argument must be a number");return buffer.SlowBuffer(size)};},"./node_modules/supports-color/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{const os=__webpack_require__("os"),hasFlag=__webpack_require__("./node_modules/supports-color/node_modules/has-flag/index.js"),env=process.env;let forceColor;function getSupportLevel(stream){const level=function(stream){if(!1===forceColor)return 0;if(hasFlag("color=16m")||hasFlag("color=full")||hasFlag("color=truecolor"))return 3;if(hasFlag("color=256"))return 2;if(stream&&!stream.isTTY&&!0!==forceColor)return 0;const min=forceColor?1:0;if("win32"===process.platform){const osRelease=os.release().split(".");return Number(process.versions.node.split(".")[0])>=8&&Number(osRelease[0])>=10&&Number(osRelease[2])>=10586?Number(osRelease[2])>=14931?3:2:1}if("CI"in env)return ["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI"].some((sign=>sign in env))||"codeship"===env.CI_NAME?1:min;if("TEAMCITY_VERSION"in env)return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION)?1:0;if("truecolor"===env.COLORTERM)return 3;if("TERM_PROGRAM"in env){const version=parseInt((env.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(env.TERM_PROGRAM){case"iTerm.app":return version>=3?3:2;case"Apple_Terminal":return 2}}return /-256(color)?$/i.test(env.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)||"COLORTERM"in env?1:(env.TERM,min)}(stream);return function(level){return 0!==level&&{level,hasBasic:!0,has256:level>=2,has16m:level>=3}}(level)}hasFlag("no-color")||hasFlag("no-colors")||hasFlag("color=false")?forceColor=!1:(hasFlag("color")||hasFlag("colors")||hasFlag("color=true")||hasFlag("color=always"))&&(forceColor=!0),"FORCE_COLOR"in env&&(forceColor=0===env.FORCE_COLOR.length||0!==parseInt(env.FORCE_COLOR,10)),module.exports={supportsColor:getSupportLevel,stdout:getSupportLevel(process.stdout),stderr:getSupportLevel(process.stderr)};},"./node_modules/supports-color/node_modules/has-flag/index.js":module=>{module.exports=(flag,argv)=>{argv=argv||process.argv;const prefix=flag.startsWith("-")?"":1===flag.length?"-":"--",pos=argv.indexOf(prefix+flag),terminatorPos=argv.indexOf("--");return -1!==pos&&(-1===terminatorPos||pos<terminatorPos)};},"./node_modules/to-fast-properties/index.js":module=>{let fastProto=null;function FastObject(o){if(null!==fastProto&&(fastProto.property,1)){const result=fastProto;return fastProto=FastObject.prototype=null,result}return fastProto=FastObject.prototype=null==o?Object.create(null):o,new FastObject}FastObject(),module.exports=function(o){return FastObject(o)};},"./node_modules/tslib/tslib.es6.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{__extends:()=>__extends,__assign:()=>__assign,__rest:()=>__rest,__decorate:()=>__decorate,__param:()=>__param,__metadata:()=>__metadata,__awaiter:()=>__awaiter,__generator:()=>__generator,__createBinding:()=>__createBinding,__exportStar:()=>__exportStar,__values:()=>__values,__read:()=>__read,__spread:()=>__spread,__spreadArrays:()=>__spreadArrays,__spreadArray:()=>__spreadArray,__await:()=>__await,__asyncGenerator:()=>__asyncGenerator,__asyncDelegator:()=>__asyncDelegator,__asyncValues:()=>__asyncValues,__makeTemplateObject:()=>__makeTemplateObject,__importStar:()=>__importStar,__importDefault:()=>__importDefault,__classPrivateFieldGet:()=>__classPrivateFieldGet,__classPrivateFieldSet:()=>__classPrivateFieldSet});var extendStatics=function(d,b){return extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)Object.prototype.hasOwnProperty.call(b,p)&&(d[p]=b[p]);},extendStatics(d,b)};function __extends(d,b){if("function"!=typeof b&&null!==b)throw new TypeError("Class extends value "+String(b)+" is not a constructor or null");function __(){this.constructor=d;}extendStatics(d,b),d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __);}var __assign=function(){return __assign=Object.assign||function(t){for(var s,i=1,n=arguments.length;i<n;i++)for(var p in s=arguments[i])Object.prototype.hasOwnProperty.call(s,p)&&(t[p]=s[p]);return t},__assign.apply(this,arguments)};function __rest(s,e){var t={};for(var p in s)Object.prototype.hasOwnProperty.call(s,p)&&e.indexOf(p)<0&&(t[p]=s[p]);if(null!=s&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(p=Object.getOwnPropertySymbols(s);i<p.length;i++)e.indexOf(p[i])<0&&Object.prototype.propertyIsEnumerable.call(s,p[i])&&(t[p[i]]=s[p[i]]);}return t}function __decorate(decorators,target,key,desc){var d,c=arguments.length,r=c<3?target:null===desc?desc=Object.getOwnPropertyDescriptor(target,key):desc;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)r=Reflect.decorate(decorators,target,key,desc);else for(var i=decorators.length-1;i>=0;i--)(d=decorators[i])&&(r=(c<3?d(r):c>3?d(target,key,r):d(target,key))||r);return c>3&&r&&Object.defineProperty(target,key,r),r}function __param(paramIndex,decorator){return function(target,key){decorator(target,key,paramIndex);}}function __metadata(metadataKey,metadataValue){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(metadataKey,metadataValue)}function __awaiter(thisArg,_arguments,P,generator){return new(P||(P=Promise))((function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator.throw(value));}catch(e){reject(e);}}function step(result){var value;result.done?resolve(result.value):(value=result.value,value instanceof P?value:new P((function(resolve){resolve(value);}))).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());}))}function __generator(thisArg,body){var f,y,t,g,_={label:0,sent:function(){if(1&t[0])throw t[1];return t[1]},trys:[],ops:[]};return g={next:verb(0),throw:verb(1),return:verb(2)},"function"==typeof Symbol&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return function(op){if(f)throw new TypeError("Generator is already executing.");for(;_;)try{if(f=1,y&&(t=2&op[0]?y.return:op[0]?y.throw||((t=y.return)&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;switch(y=0,t&&(op=[2&op[0],t.value]),op[0]){case 0:case 1:t=op;break;case 4:return _.label++,{value:op[1],done:!1};case 5:_.label++,y=op[1],op=[0];continue;case 7:op=_.ops.pop(),_.trys.pop();continue;default:if(!(t=_.trys,(t=t.length>0&&t[t.length-1])||6!==op[0]&&2!==op[0])){_=0;continue}if(3===op[0]&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(6===op[0]&&_.label<t[1]){_.label=t[1],t=op;break}if(t&&_.label<t[2]){_.label=t[2],_.ops.push(op);break}t[2]&&_.ops.pop(),_.trys.pop();continue}op=body.call(thisArg,_);}catch(e){op=[6,e],y=0;}finally{f=t=0;}if(5&op[0])throw op[1];return {value:op[0]?op[1]:void 0,done:!0}}([n,v])}}}var __createBinding=Object.create?function(o,m,k,k2){void 0===k2&&(k2=k),Object.defineProperty(o,k2,{enumerable:!0,get:function(){return m[k]}});}:function(o,m,k,k2){void 0===k2&&(k2=k),o[k2]=m[k];};function __exportStar(m,o){for(var p in m)"default"===p||Object.prototype.hasOwnProperty.call(o,p)||__createBinding(o,m,p);}function __values(o){var s="function"==typeof Symbol&&Symbol.iterator,m=s&&o[s],i=0;if(m)return m.call(o);if(o&&"number"==typeof o.length)return {next:function(){return o&&i>=o.length&&(o=void 0),{value:o&&o[i++],done:!o}}};throw new TypeError(s?"Object is not iterable.":"Symbol.iterator is not defined.")}function __read(o,n){var m="function"==typeof Symbol&&o[Symbol.iterator];if(!m)return o;var r,e,i=m.call(o),ar=[];try{for(;(void 0===n||n-- >0)&&!(r=i.next()).done;)ar.push(r.value);}catch(error){e={error};}finally{try{r&&!r.done&&(m=i.return)&&m.call(i);}finally{if(e)throw e.error}}return ar}function __spread(){for(var ar=[],i=0;i<arguments.length;i++)ar=ar.concat(__read(arguments[i]));return ar}function __spreadArrays(){for(var s=0,i=0,il=arguments.length;i<il;i++)s+=arguments[i].length;var r=Array(s),k=0;for(i=0;i<il;i++)for(var a=arguments[i],j=0,jl=a.length;j<jl;j++,k++)r[k]=a[j];return r}function __spreadArray(to,from,pack){if(pack||2===arguments.length)for(var ar,i=0,l=from.length;i<l;i++)!ar&&i in from||(ar||(ar=Array.prototype.slice.call(from,0,i)),ar[i]=from[i]);return to.concat(ar||Array.prototype.slice.call(from))}function __await(v){return this instanceof __await?(this.v=v,this):new __await(v)}function __asyncGenerator(thisArg,_arguments,generator){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var i,g=generator.apply(thisArg,_arguments||[]),q=[];return i={},verb("next"),verb("throw"),verb("return"),i[Symbol.asyncIterator]=function(){return this},i;function verb(n){g[n]&&(i[n]=function(v){return new Promise((function(a,b){q.push([n,v,a,b])>1||resume(n,v);}))});}function resume(n,v){try{(r=g[n](v)).value instanceof __await?Promise.resolve(r.value.v).then(fulfill,reject):settle(q[0][2],r);}catch(e){settle(q[0][3],e);}var r;}function fulfill(value){resume("next",value);}function reject(value){resume("throw",value);}function settle(f,v){f(v),q.shift(),q.length&&resume(q[0][0],q[0][1]);}}function __asyncDelegator(o){var i,p;return i={},verb("next"),verb("throw",(function(e){throw e})),verb("return"),i[Symbol.iterator]=function(){return this},i;function verb(n,f){i[n]=o[n]?function(v){return (p=!p)?{value:__await(o[n](v)),done:"return"===n}:f?f(v):v}:f;}}function __asyncValues(o){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var i,m=o[Symbol.asyncIterator];return m?m.call(o):(o=__values(o),i={},verb("next"),verb("throw"),verb("return"),i[Symbol.asyncIterator]=function(){return this},i);function verb(n){i[n]=o[n]&&function(v){return new Promise((function(resolve,reject){(function(resolve,reject,d,v){Promise.resolve(v).then((function(v){resolve({value:v,done:d});}),reject);})(resolve,reject,(v=o[n](v)).done,v.value);}))};}}function __makeTemplateObject(cooked,raw){return Object.defineProperty?Object.defineProperty(cooked,"raw",{value:raw}):cooked.raw=raw,cooked}var __setModuleDefault=Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:!0,value:v});}:function(o,v){o.default=v;};function __importStar(mod){if(mod&&mod.__esModule)return mod;var result={};if(null!=mod)for(var k in mod)"default"!==k&&Object.prototype.hasOwnProperty.call(mod,k)&&__createBinding(result,mod,k);return __setModuleDefault(result,mod),result}function __importDefault(mod){return mod&&mod.__esModule?mod:{default:mod}}function __classPrivateFieldGet(receiver,state,kind,f){if("a"===kind&&!f)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof state?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return "m"===kind?f:"a"===kind?f.call(receiver):f?f.value:state.get(receiver)}function __classPrivateFieldSet(receiver,state,value,kind,f){if("m"===kind)throw new TypeError("Private method is not writable");if("a"===kind&&!f)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof state?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return "a"===kind?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value}},"./stubs/babel_codeframe.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{function codeFrameColumns(){return ""}__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{codeFrameColumns:()=>codeFrameColumns});},"./stubs/helper_compilation_targets.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{function getTargets(){return {}}__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{default:()=>getTargets});},assert:module=>{module.exports=require$$8__default["default"];},buffer:module=>{module.exports=require$$1__default$1["default"];},fs:module=>{module.exports=fs__default["default"];},module:module=>{module.exports=require$$2__default["default"];},os:module=>{module.exports=require$$5__default["default"];},path:module=>{module.exports=require$$0__default$1["default"];},tty:module=>{module.exports=require$$0__default$2["default"];},url:module=>{module.exports=require$$7__default["default"];},util:module=>{module.exports=require$$1__default["default"];},v8:module=>{module.exports=require$$9__default["default"];},"./node_modules/babel-plugin-transform-import-meta/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0});var tslib=__webpack_require__("./node_modules/tslib/tslib.es6.js");function _interopDefaultLegacy(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var templateObject_1,ast=_interopDefaultLegacy(__webpack_require__("./node_modules/@babel/template/lib/index.js")).default.ast;exports.default=function(){return {name:"transform-import-meta",visitor:{Program:function(path){var metas=[];if(path.traverse({MemberExpression:function(memberExpPath){var node=memberExpPath.node;"MetaProperty"===node.object.type&&"import"===node.object.meta.name&&"meta"===node.object.property.name&&"Identifier"===node.property.type&&"url"===node.property.name&&metas.push(memberExpPath);}}),0!==metas.length)for(var _i=0,metas_1=metas;_i<metas_1.length;_i++){metas_1[_i].replaceWith(ast(templateObject_1||(templateObject_1=tslib.__makeTemplateObject(["require('url').pathToFileURL(__filename).toString()"],["require('url').pathToFileURL(__filename).toString()"]))));}}}}};},"./node_modules/json5/dist/index.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{default:()=>__WEBPACK_DEFAULT_EXPORT__});var unicode={Space_Separator:/[\u1680\u2000-\u200A\u202F\u205F\u3000]/,ID_Start:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/,ID_Continue:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/},util={isSpaceSeparator:c=>"string"==typeof c&&unicode.Space_Separator.test(c),isIdStartChar:c=>"string"==typeof c&&(c>="a"&&c<="z"||c>="A"&&c<="Z"||"$"===c||"_"===c||unicode.ID_Start.test(c)),isIdContinueChar:c=>"string"==typeof c&&(c>="a"&&c<="z"||c>="A"&&c<="Z"||c>="0"&&c<="9"||"$"===c||"_"===c||"‌"===c||"‍"===c||unicode.ID_Continue.test(c)),isDigit:c=>"string"==typeof c&&/[0-9]/.test(c),isHexDigit:c=>"string"==typeof c&&/[0-9A-Fa-f]/.test(c)};let source,parseState,stack,pos,line,column,token,key,root;function internalize(holder,name,reviver){const value=holder[name];if(null!=value&&"object"==typeof value)for(const key in value){const replacement=internalize(value,key,reviver);void 0===replacement?delete value[key]:value[key]=replacement;}return reviver.call(holder,name,value)}let lexState,buffer,doubleQuote,sign,c;function lex(){for(lexState="default",buffer="",doubleQuote=!1,sign=1;;){c=peek();const token=lexStates[lexState]();if(token)return token}}function peek(){if(source[pos])return String.fromCodePoint(source.codePointAt(pos))}function read(){const c=peek();return "\n"===c?(line++,column=0):c?column+=c.length:column++,c&&(pos+=c.length),c}const lexStates={default(){switch(c){case"\t":case"\v":case"\f":case" ":case" ":case"\ufeff":case"\n":case"\r":case"\u2028":case"\u2029":return void read();case"/":return read(),void(lexState="comment");case void 0:return read(),newToken("eof")}if(!util.isSpaceSeparator(c))return lexStates[parseState]();read();},comment(){switch(c){case"*":return read(),void(lexState="multiLineComment");case"/":return read(),void(lexState="singleLineComment")}throw invalidChar(read())},multiLineComment(){switch(c){case"*":return read(),void(lexState="multiLineCommentAsterisk");case void 0:throw invalidChar(read())}read();},multiLineCommentAsterisk(){switch(c){case"*":return void read();case"/":return read(),void(lexState="default");case void 0:throw invalidChar(read())}read(),lexState="multiLineComment";},singleLineComment(){switch(c){case"\n":case"\r":case"\u2028":case"\u2029":return read(),void(lexState="default");case void 0:return read(),newToken("eof")}read();},value(){switch(c){case"{":case"[":return newToken("punctuator",read());case"n":return read(),literal("ull"),newToken("null",null);case"t":return read(),literal("rue"),newToken("boolean",!0);case"f":return read(),literal("alse"),newToken("boolean",!1);case"-":case"+":return "-"===read()&&(sign=-1),void(lexState="sign");case".":return buffer=read(),void(lexState="decimalPointLeading");case"0":return buffer=read(),void(lexState="zero");case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":return buffer=read(),void(lexState="decimalInteger");case"I":return read(),literal("nfinity"),newToken("numeric",1/0);case"N":return read(),literal("aN"),newToken("numeric",NaN);case'"':case"'":return doubleQuote='"'===read(),buffer="",void(lexState="string")}throw invalidChar(read())},identifierNameStartEscape(){if("u"!==c)throw invalidChar(read());read();const u=unicodeEscape();switch(u){case"$":case"_":break;default:if(!util.isIdStartChar(u))throw invalidIdentifier()}buffer+=u,lexState="identifierName";},identifierName(){switch(c){case"$":case"_":case"‌":case"‍":return void(buffer+=read());case"\\":return read(),void(lexState="identifierNameEscape")}if(!util.isIdContinueChar(c))return newToken("identifier",buffer);buffer+=read();},identifierNameEscape(){if("u"!==c)throw invalidChar(read());read();const u=unicodeEscape();switch(u){case"$":case"_":case"‌":case"‍":break;default:if(!util.isIdContinueChar(u))throw invalidIdentifier()}buffer+=u,lexState="identifierName";},sign(){switch(c){case".":return buffer=read(),void(lexState="decimalPointLeading");case"0":return buffer=read(),void(lexState="zero");case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":return buffer=read(),void(lexState="decimalInteger");case"I":return read(),literal("nfinity"),newToken("numeric",sign*(1/0));case"N":return read(),literal("aN"),newToken("numeric",NaN)}throw invalidChar(read())},zero(){switch(c){case".":return buffer+=read(),void(lexState="decimalPoint");case"e":case"E":return buffer+=read(),void(lexState="decimalExponent");case"x":case"X":return buffer+=read(),void(lexState="hexadecimal")}return newToken("numeric",0*sign)},decimalInteger(){switch(c){case".":return buffer+=read(),void(lexState="decimalPoint");case"e":case"E":return buffer+=read(),void(lexState="decimalExponent")}if(!util.isDigit(c))return newToken("numeric",sign*Number(buffer));buffer+=read();},decimalPointLeading(){if(util.isDigit(c))return buffer+=read(),void(lexState="decimalFraction");throw invalidChar(read())},decimalPoint(){switch(c){case"e":case"E":return buffer+=read(),void(lexState="decimalExponent")}return util.isDigit(c)?(buffer+=read(),void(lexState="decimalFraction")):newToken("numeric",sign*Number(buffer))},decimalFraction(){switch(c){case"e":case"E":return buffer+=read(),void(lexState="decimalExponent")}if(!util.isDigit(c))return newToken("numeric",sign*Number(buffer));buffer+=read();},decimalExponent(){switch(c){case"+":case"-":return buffer+=read(),void(lexState="decimalExponentSign")}if(util.isDigit(c))return buffer+=read(),void(lexState="decimalExponentInteger");throw invalidChar(read())},decimalExponentSign(){if(util.isDigit(c))return buffer+=read(),void(lexState="decimalExponentInteger");throw invalidChar(read())},decimalExponentInteger(){if(!util.isDigit(c))return newToken("numeric",sign*Number(buffer));buffer+=read();},hexadecimal(){if(util.isHexDigit(c))return buffer+=read(),void(lexState="hexadecimalInteger");throw invalidChar(read())},hexadecimalInteger(){if(!util.isHexDigit(c))return newToken("numeric",sign*Number(buffer));buffer+=read();},string(){switch(c){case"\\":return read(),void(buffer+=function(){switch(peek()){case"b":return read(),"\b";case"f":return read(),"\f";case"n":return read(),"\n";case"r":return read(),"\r";case"t":return read(),"\t";case"v":return read(),"\v";case"0":if(read(),util.isDigit(peek()))throw invalidChar(read());return "\0";case"x":return read(),function(){let buffer="",c=peek();if(!util.isHexDigit(c))throw invalidChar(read());if(buffer+=read(),c=peek(),!util.isHexDigit(c))throw invalidChar(read());return buffer+=read(),String.fromCodePoint(parseInt(buffer,16))}();case"u":return read(),unicodeEscape();case"\n":case"\u2028":case"\u2029":return read(),"";case"\r":return read(),"\n"===peek()&&read(),"";case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":case void 0:throw invalidChar(read())}return read()}());case'"':return doubleQuote?(read(),newToken("string",buffer)):void(buffer+=read());case"'":return doubleQuote?void(buffer+=read()):(read(),newToken("string",buffer));case"\n":case"\r":throw invalidChar(read());case"\u2028":case"\u2029":!function(c){console.warn(`JSON5: '${formatChar(c)}' in strings is not valid ECMAScript; consider escaping`);}(c);break;case void 0:throw invalidChar(read())}buffer+=read();},start(){switch(c){case"{":case"[":return newToken("punctuator",read())}lexState="value";},beforePropertyName(){switch(c){case"$":case"_":return buffer=read(),void(lexState="identifierName");case"\\":return read(),void(lexState="identifierNameStartEscape");case"}":return newToken("punctuator",read());case'"':case"'":return doubleQuote='"'===read(),void(lexState="string")}if(util.isIdStartChar(c))return buffer+=read(),void(lexState="identifierName");throw invalidChar(read())},afterPropertyName(){if(":"===c)return newToken("punctuator",read());throw invalidChar(read())},beforePropertyValue(){lexState="value";},afterPropertyValue(){switch(c){case",":case"}":return newToken("punctuator",read())}throw invalidChar(read())},beforeArrayValue(){if("]"===c)return newToken("punctuator",read());lexState="value";},afterArrayValue(){switch(c){case",":case"]":return newToken("punctuator",read())}throw invalidChar(read())},end(){throw invalidChar(read())}};function newToken(type,value){return {type,value,line,column}}function literal(s){for(const c of s){if(peek()!==c)throw invalidChar(read());read();}}function unicodeEscape(){let buffer="",count=4;for(;count-- >0;){const c=peek();if(!util.isHexDigit(c))throw invalidChar(read());buffer+=read();}return String.fromCodePoint(parseInt(buffer,16))}const parseStates={start(){if("eof"===token.type)throw invalidEOF();push();},beforePropertyName(){switch(token.type){case"identifier":case"string":return key=token.value,void(parseState="afterPropertyName");case"punctuator":return void pop();case"eof":throw invalidEOF()}},afterPropertyName(){if("eof"===token.type)throw invalidEOF();parseState="beforePropertyValue";},beforePropertyValue(){if("eof"===token.type)throw invalidEOF();push();},beforeArrayValue(){if("eof"===token.type)throw invalidEOF();"punctuator"!==token.type||"]"!==token.value?push():pop();},afterPropertyValue(){if("eof"===token.type)throw invalidEOF();switch(token.value){case",":return void(parseState="beforePropertyName");case"}":pop();}},afterArrayValue(){if("eof"===token.type)throw invalidEOF();switch(token.value){case",":return void(parseState="beforeArrayValue");case"]":pop();}},end(){}};function push(){let value;switch(token.type){case"punctuator":switch(token.value){case"{":value={};break;case"[":value=[];}break;case"null":case"boolean":case"numeric":case"string":value=token.value;}if(void 0===root)root=value;else {const parent=stack[stack.length-1];Array.isArray(parent)?parent.push(value):parent[key]=value;}if(null!==value&&"object"==typeof value)stack.push(value),parseState=Array.isArray(value)?"beforeArrayValue":"beforePropertyName";else {const current=stack[stack.length-1];parseState=null==current?"end":Array.isArray(current)?"afterArrayValue":"afterPropertyValue";}}function pop(){stack.pop();const current=stack[stack.length-1];parseState=null==current?"end":Array.isArray(current)?"afterArrayValue":"afterPropertyValue";}function invalidChar(c){return syntaxError(void 0===c?`JSON5: invalid end of input at ${line}:${column}`:`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)}function invalidEOF(){return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)}function invalidIdentifier(){return column-=5,syntaxError(`JSON5: invalid identifier character at ${line}:${column}`)}function formatChar(c){const replacements={"'":"\\'",'"':'\\"',"\\":"\\\\","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\v":"\\v","\0":"\\0","\u2028":"\\u2028","\u2029":"\\u2029"};if(replacements[c])return replacements[c];if(c<" "){const hexString=c.charCodeAt(0).toString(16);return "\\x"+("00"+hexString).substring(hexString.length)}return c}function syntaxError(message){const err=new SyntaxError(message);return err.lineNumber=line,err.columnNumber=column,err}const JSON5={parse:function(text,reviver){source=String(text),parseState="start",stack=[],pos=0,line=1,column=0,token=void 0,key=void 0,root=void 0;do{token=lex(),parseStates[parseState]();}while("eof"!==token.type);return "function"==typeof reviver?internalize({"":root},"",reviver):root},stringify:function(value,replacer,space){const stack=[];let propertyList,replacerFunc,quote,indent="",gap="";if(null==replacer||"object"!=typeof replacer||Array.isArray(replacer)||(space=replacer.space,quote=replacer.quote,replacer=replacer.replacer),"function"==typeof replacer)replacerFunc=replacer;else if(Array.isArray(replacer)){propertyList=[];for(const v of replacer){let item;"string"==typeof v?item=v:("number"==typeof v||v instanceof String||v instanceof Number)&&(item=String(v)),void 0!==item&&propertyList.indexOf(item)<0&&propertyList.push(item);}}return space instanceof Number?space=Number(space):space instanceof String&&(space=String(space)),"number"==typeof space?space>0&&(space=Math.min(10,Math.floor(space)),gap="          ".substr(0,space)):"string"==typeof space&&(gap=space.substr(0,10)),serializeProperty("",{"":value});function serializeProperty(key,holder){let value=holder[key];switch(null!=value&&("function"==typeof value.toJSON5?value=value.toJSON5(key):"function"==typeof value.toJSON&&(value=value.toJSON(key))),replacerFunc&&(value=replacerFunc.call(holder,key,value)),value instanceof Number?value=Number(value):value instanceof String?value=String(value):value instanceof Boolean&&(value=value.valueOf()),value){case null:return "null";case!0:return "true";case!1:return "false"}return "string"==typeof value?quoteString(value):"number"==typeof value?String(value):"object"==typeof value?Array.isArray(value)?function(value){if(stack.indexOf(value)>=0)throw TypeError("Converting circular structure to JSON5");stack.push(value);let stepback=indent;indent+=gap;let final,partial=[];for(let i=0;i<value.length;i++){const propertyString=serializeProperty(String(i),value);partial.push(void 0!==propertyString?propertyString:"null");}if(0===partial.length)final="[]";else if(""===gap){final="["+partial.join(",")+"]";}else {let separator=",\n"+indent,properties=partial.join(separator);final="[\n"+indent+properties+",\n"+stepback+"]";}return stack.pop(),indent=stepback,final}(value):function(value){if(stack.indexOf(value)>=0)throw TypeError("Converting circular structure to JSON5");stack.push(value);let stepback=indent;indent+=gap;let final,keys=propertyList||Object.keys(value),partial=[];for(const key of keys){const propertyString=serializeProperty(key,value);if(void 0!==propertyString){let member=serializeKey(key)+":";""!==gap&&(member+=" "),member+=propertyString,partial.push(member);}}if(0===partial.length)final="{}";else {let properties;if(""===gap)properties=partial.join(","),final="{"+properties+"}";else {let separator=",\n"+indent;properties=partial.join(separator),final="{\n"+indent+properties+",\n"+stepback+"}";}}return stack.pop(),indent=stepback,final}(value):void 0}function quoteString(value){const quotes={"'":.1,'"':.2},replacements={"'":"\\'",'"':'\\"',"\\":"\\\\","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\v":"\\v","\0":"\\0","\u2028":"\\u2028","\u2029":"\\u2029"};let product="";for(let i=0;i<value.length;i++){const c=value[i];switch(c){case"'":case'"':quotes[c]++,product+=c;continue;case"\0":if(util.isDigit(value[i+1])){product+="\\x00";continue}}if(replacements[c])product+=replacements[c];else if(c<" "){let hexString=c.charCodeAt(0).toString(16);product+="\\x"+("00"+hexString).substring(hexString.length);}else product+=c;}const quoteChar=quote||Object.keys(quotes).reduce(((a,b)=>quotes[a]<quotes[b]?a:b));return product=product.replace(new RegExp(quoteChar,"g"),replacements[quoteChar]),quoteChar+product+quoteChar}function serializeKey(key){if(0===key.length)return quoteString(key);const firstChar=String.fromCodePoint(key.codePointAt(0));if(!util.isIdStartChar(firstChar))return quoteString(key);for(let i=firstChar.length;i<key.length;i++)if(!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i))))return quoteString(key);return key}}};const __WEBPACK_DEFAULT_EXPORT__=JSON5;},"./node_modules/@babel/traverse/node_modules/globals/globals.json":module=>{module.exports=JSON.parse('{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}');}},__webpack_module_cache__={};function __webpack_require__(moduleId){var cachedModule=__webpack_module_cache__[moduleId];if(void 0!==cachedModule)return cachedModule.exports;var module=__webpack_module_cache__[moduleId]={exports:{}};return __webpack_modules__[moduleId](module,module.exports,__webpack_require__),module.exports}__webpack_require__.d=(exports,definition)=>{for(var key in definition)__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)&&Object.defineProperty(exports,key,{enumerable:!0,get:definition[key]});},__webpack_require__.o=(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop),__webpack_require__.r=exports=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(exports,"__esModule",{value:!0});};var __webpack_exports__={};(()=>{__webpack_require__.d(__webpack_exports__,{default:()=>transform});var _babel_core__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@babel/core/lib/index.js");function transform(opts){var _a,_b,_c,_d,_e,_f;const _opts=Object.assign(Object.assign({babelrc:!1,configFile:!1,compact:!1,retainLines:"boolean"!=typeof opts.retainLines||opts.retainLines,filename:"",cwd:"/"},opts.babel),{plugins:[[__webpack_require__("./node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js"),{allowTopLevelThis:!0}],[__webpack_require__("./node_modules/babel-plugin-dynamic-import-node/lib/index.js"),{noInterop:!0}],[__webpack_require__("./node_modules/babel-plugin-transform-import-meta/lib/index.js")],[__webpack_require__("./node_modules/@babel/plugin-syntax-class-properties/lib/index.js")]]});opts.ts&&(_opts.plugins.push([__webpack_require__("./node_modules/@babel/plugin-transform-typescript/lib/index.js"),{allowDeclareFields:!0}]),_opts.plugins.unshift([__webpack_require__("./node_modules/@babel/plugin-proposal-decorators/lib/index.js"),{legacy:!0}]),_opts.plugins.push(__webpack_require__("./node_modules/babel-plugin-parameter-decorator/lib/index.js"))),opts.legacy&&(_opts.plugins.push(__webpack_require__("./node_modules/@babel/plugin-proposal-nullish-coalescing-operator/lib/index.js")),_opts.plugins.push(__webpack_require__("./node_modules/@babel/plugin-proposal-optional-chaining/lib/index.js"))),opts.babel&&Array.isArray(opts.babel.plugins)&&(null===(_a=_opts.plugins)||void 0===_a||_a.push(...opts.babel.plugins));try{return {code:(null===(_b=(0,_babel_core__WEBPACK_IMPORTED_MODULE_0__.transformSync)(opts.source,_opts))||void 0===_b?void 0:_b.code)||""}}catch(err){return {error:err,code:"exports.__JITI_ERROR__ = "+JSON.stringify({filename:opts.filename,line:(null===(_c=err.loc)||void 0===_c?void 0:_c.line)||0,column:(null===(_d=err.loc)||void 0===_d?void 0:_d.column)||0,code:null===(_e=err.code)||void 0===_e?void 0:_e.replace("BABEL_","").replace("PARSE_ERROR","ParseError"),message:null===(_f=err.message)||void 0===_f?void 0:_f.replace("/: ","").replace(/\(.+\)\s*$/,"")})}}}})(),module.exports=__webpack_exports__.default;})();
}(babel));

function onError (err) {
  throw err /* ↓ Check stack trace ↓ */
}

var lib$d = function (filename, opts) {
  const jiti = jiti$1.exports;

  opts = { onError, ...opts };

  if (!opts.transform) {
    opts.transform = babel.exports;
  }

  return jiti(filename, opts)
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics$4 = function(d, b) {
    extendStatics$4 = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics$4(d, b);
};

function __extends$6(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics$4(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign$4 = function() {
    __assign$4 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$4.apply(this, arguments);
};

function __spreadArray$6(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

var Console = /** @class */ (function () {
    function Console() {
    }
    Console.log = function () {
        var message = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            message[_i] = arguments[_i];
        }
        // eslint-disable-next-line no-console
        console.log.apply(console, message);
    };
    Console.error = function () {
        var message = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            message[_i] = arguments[_i];
        }
        // eslint-disable-next-line no-console
        console.error.apply(console, message);
    };
    Console.time = function (label) {
        // eslint-disable-next-line no-console
        console.time(label);
    };
    Console.timeEnd = function (label) {
        // eslint-disable-next-line no-console
        console.timeEnd(label);
    };
    return Console;
}());
function toArray$5(v) {
    if (Array.isArray(v))
        return v;
    return [v];
}
function hash$2(str) {
    str = str.replace(/\r/g, '');
    var hash = 5381;
    var i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return (hash >>> 0).toString(36);
}
function indent$3(code, tab) {
    if (tab === void 0) { tab = 2; }
    var spaces = Array(tab).fill(' ').join('');
    return code
        .split('\n')
        .map(function (line) { return spaces + line; })
        .join('\n');
}
function wrapit$3(code, start, end, tab, minify) {
    if (start === void 0) { start = '{'; }
    if (end === void 0) { end = '}'; }
    if (tab === void 0) { tab = 2; }
    if (minify === void 0) { minify = false; }
    if (minify)
        return "".concat(start).concat(code).concat(end);
    return "".concat(start, "\n").concat(indent$3(code, tab), "\n").concat(end);
}
function isNumber$3(amount, start, end, type) {
    if (start === void 0) { start = -Infinity; }
    if (end === void 0) { end = Infinity; }
    if (type === void 0) { type = 'int'; }
    var isInt = /^-?\d+$/.test(amount);
    if (type === 'int') {
        if (!isInt)
            return false;
    }
    else {
        var isFloat = /^-?\d+\.\d+$/.test(amount);
        if (!(isInt || isFloat))
            return false;
    }
    var num = parseFloat(amount);
    return num >= start && num <= end;
}
function isFraction(amount) {
    return /^\d+\/\d+$/.test(amount);
}
function isSize(amount) {
    return /^-?(\d+(\.\d+)?)+(rem|em|px|rpx|vh|vw|ch|ex|cm|mm|in|pt|pc)$/.test(amount);
}
function isSpace$1(str) {
    return /^\s*$/.test(str);
}
function roundUp(num, precision) {
    if (precision === void 0) { precision = 0; }
    precision = Math.pow(10, precision);
    return Math.round(num * precision) / precision;
}
function fracToPercent(amount) {
    var matches = amount.match(/[^/]+/g);
    if (!matches || matches.length < 2)
        return;
    var a = +matches[0];
    var b = +matches[1];
    return roundUp((a / b) * 100, 6) + '%';
}
function hex2RGB$1(hex) {
    var RGB_HEX = /^#?(?:([\da-f]{3})[\da-f]?|([\da-f]{6})(?:[\da-f]{2})?)$/i;
    var _a = String(hex).match(RGB_HEX) || [], short = _a[1], long = _a[2];
    if (long) {
        var value = Number.parseInt(long, 16);
        return [value >> 16, (value >> 8) & 0xff, value & 0xff];
    }
    else if (short) {
        return Array.from(short, function (s) { return Number.parseInt(s, 16); }).map(function (n) { return (n << 4) | n; });
    }
}
function camelToDash$3(str) {
    // Use exact the same regex as Post CSS
    return str.replace(/([A-Z])/g, '-$1').replace(/^ms-/, '-ms-').toLowerCase();
}
function dashToCamel(str) {
    if (!/-/.test(str))
        return str;
    return str.toLowerCase().replace(/-(.)/g, function (_, group) { return group.toUpperCase(); });
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getNestedValue(obj, key) {
    var topKey = key.match(/^[^.[]+/);
    if (!topKey)
        return;
    var topValue = obj[topKey[0]];
    if (!topValue)
        return;
    var index = topKey[0].length;
    while (index < key.length) {
        var square = key.slice(index).match(/\[[^\s\]]+?\]/);
        var dot = key.slice(index).match(/\.[^.[]+$|\.[^.[]+(?=\.)/);
        if ((!square && !dot) || ((square === null || square === void 0 ? void 0 : square.index) === undefined && (dot === null || dot === void 0 ? void 0 : dot.index) === undefined))
            return topValue;
        if (typeof topValue !== 'object')
            return;
        if (dot && dot.index !== undefined && ((square === null || square === void 0 ? void 0 : square.index) === undefined || dot.index < square.index)) {
            var arg = dot[0].slice(1);
            topValue = topValue[arg];
            index += dot.index + dot[0].length;
        }
        else if (square && square.index !== undefined) {
            var arg = square[0].slice(1, -1).trim().replace(/^['"]+|['"]+$/g, '');
            topValue = topValue[arg];
            index += square.index + square[0].length;
        }
    }
    return topValue;
}
function negateValue(value) {
    if (/(^0\w)|(^-)|(^0$)/.test(value))
        return value;
    return '-' + value;
}
function searchFrom$3(text, target, startIndex, endIndex) {
    if (startIndex === void 0) { startIndex = 0; }
    // search from partial of string
    var subText = text.substring(startIndex, endIndex);
    var relativeIndex = subText.search(target);
    return relativeIndex === -1 ? -1 : startIndex + relativeIndex;
}
function connectList$3(a, b, append) {
    if (append === void 0) { append = true; }
    return append ? __spreadArray$6(__spreadArray$6([], (a !== null && a !== void 0 ? a : []), true), (b !== null && b !== void 0 ? b : []), true) : __spreadArray$6(__spreadArray$6([], (b !== null && b !== void 0 ? b : []), true), (a !== null && a !== void 0 ? a : []), true);
}
function toType(value, type) {
    switch (type) {
        case 'object':
            return value && typeof value === 'object' ? value : {};
        case 'string':
            if (typeof value === 'string')
                return value;
            break;
        case 'number':
            if (typeof value === 'number')
                return value;
            break;
    }
}
function deepCopy$3(source) {
    return Array.isArray(source)
        ? source.map(function (item) { return deepCopy$3(item); })
        : source instanceof Date
            ? new Date(source.getTime())
            : source && typeof source === 'object'
                ? Object.getOwnPropertyNames(source).reduce(function (o, prop) {
                    var descriptor = Object.getOwnPropertyDescriptor(source, prop);
                    if (descriptor) {
                        Object.defineProperty(o, prop, descriptor);
                        if (source && typeof source === 'object') {
                            o[prop] = deepCopy$3(source[prop]);
                        }
                    }
                    return o;
                }, Object.create(Object.getPrototypeOf(source)))
                : source;
}
function isTagName$3(name) {
    return ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embd', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'svg', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr'].includes(name);
}
function flatColors$2(colors, head) {
    var flatten = {};
    for (var _i = 0, _a = Object.entries(colors); _i < _a.length; _i++) {
        var _b = _a[_i], key = _b[0], value = _b[1];
        if (typeof value === 'string' || typeof value === 'function') {
            flatten[(head && key === 'DEFAULT') ? head : head ? "".concat(head, "-").concat(key) : key] = value;
        }
        else {
            flatten = __assign$4(__assign$4({}, flatten), flatColors$2(value, head ? "".concat(head, "-").concat(key) : key));
        }
    }
    return flatten;
}
function testRegexr(text, expressions) {
    for (var _i = 0, expressions_1 = expressions; _i < expressions_1.length; _i++) {
        var exp = expressions_1[_i];
        if (exp.test(text))
            return true;
    }
    return false;
}
function searchPropEnd$3(text, startIndex) {
    if (startIndex === void 0) { startIndex = 0; }
    var index = startIndex;
    var output = -1;
    var openSingleQuote = false;
    var openDoubleQuote = false;
    var openBracket = false;
    var isEscaped = false;
    while (index < text.length) {
        switch (text.charAt(index)) {
            case '\\':
                isEscaped = !isEscaped;
                break;
            case '\'':
                if (!openDoubleQuote && !openBracket && !isEscaped)
                    openSingleQuote = !openSingleQuote;
                isEscaped = false;
                break;
            case '"':
                if (!openSingleQuote && !openBracket && !isEscaped)
                    openDoubleQuote = !openDoubleQuote;
                isEscaped = false;
                break;
            case '(':
                if (!openBracket && !openSingleQuote && !openDoubleQuote && !isEscaped)
                    openBracket = true;
                isEscaped = false;
                break;
            case ')':
                if (openBracket && !isEscaped)
                    openBracket = false;
                isEscaped = false;
                break;
            case ';':
                if (!isEscaped && !openSingleQuote && !openDoubleQuote && !openBracket)
                    output = index;
                isEscaped = false;
                break;
            default:
                isEscaped = false;
                break;
        }
        if (output !== -1)
            break;
        index++;
    }
    return output;
}
function searchNotEscape(text, chars) {
    if (chars === void 0) { chars = ['{']; }
    if (!Array.isArray(chars))
        chars = [chars];
    var i = 0;
    while (i < text.length) {
        if (chars.includes(text.charAt(i)) && text.charAt(i - 1) !== '\\') {
            return i;
        }
        i++;
    }
    return -1;
}
function splitSelectors(selectors) {
    var splitted = [];
    var parens = 0;
    var angulars = 0;
    var soFar = '';
    for (var i = 0, len = selectors.length; i < len; i++) {
        var char = selectors[i];
        if (char === '(') {
            parens += 1;
        }
        else if (char === ')') {
            parens -= 1;
        }
        else if (char === '[') {
            angulars += 1;
        }
        else if (char === ']') {
            angulars -= 1;
        }
        else if (char === ',') {
            if (!parens && !angulars) {
                splitted.push(soFar.trim());
                soFar = '';
                continue;
            }
        }
        soFar += char;
    }
    splitted.push(soFar.trim());
    return splitted;
}
function guessClassName(selector) {
    var _a;
    if (selector.indexOf(',') >= 0) {
        var splittedSelectors = splitSelectors(selector);
        if (splittedSelectors.length !== 1)
            return splittedSelectors.map(function (i) { return guessClassName(i); });
    }
    // not classes, contains attribute selectors, nested selectors - treat as static
    if (selector.charAt(0) !== '.' || searchNotEscape(selector, ['[', '>', '+', '~']) >= 0 || selector.trim().indexOf(' ') >= 0 || searchNotEscape(selector.slice(1), '.') >= 0)
        return { selector: selector, isClass: false };
    var pseudo = searchNotEscape(selector, ':');
    var className = (((_a = selector.match(/^\.([\w-]|(\\\W))+/)) === null || _a === void 0 ? void 0 : _a[0].slice(1)) || '').replace(/\\/g, '');
    if (pseudo === -1)
        return { selector: className, isClass: true };
    return { selector: className, isClass: true, pseudo: selector.slice(pseudo) };
}
function increaseWithUnit(target, delta) {
    var _a;
    if (typeof target === 'number')
        return target + delta;
    var value = ((_a = target.match(/^-?[0-9]+\.?[0-9]*/)) === null || _a === void 0 ? void 0 : _a[0]) || '';
    var unit = target.slice(value.length);
    var result = (parseFloat(value) + delta);
    if (Number.isNaN(result))
        return target;
    return result + unit;
}
function splitColorGroup(color) {
    var sep = color.indexOf('/');
    if (sep === -1)
        return [color, undefined];
    return [color.slice(0, sep), color.slice(sep + 1)];
}

var Property$3 = /** @class */ (function () {
    function Property(name, value, comment, important) {
        if (important === void 0) { important = false; }
        this.meta = { type: 'utilities', group: 'plugin', order: 0, offset: 0, corePlugin: false };
        this.name = name;
        this.value = value;
        this.comment = comment;
        this.important = important;
    }
    Property._singleParse = function (css) {
        css = css.trim();
        if (!css)
            return;
        if (css.charAt(0) === '@')
            return InlineAtRule$3.parse(css);
        var split = css.search(':');
        var end = searchPropEnd$3(css);
        if (split === -1)
            return;
        var important = false;
        var prop = css.substring(split + 1, end === -1 ? undefined : end).trim();
        if (/!important;?$/.test(prop)) {
            important = true;
            prop = prop.replace(/!important/, '').trimRight();
        }
        return new Property(css.substring(0, split).trim(), prop, undefined, important);
    };
    Property.parse = function (css) {
        if (!/;\s*$/.test(css))
            css += ';'; // Fix for the situation where the last semicolon is omitted
        var properties = [];
        var index = 0;
        var end = searchPropEnd$3(css, index);
        while (end !== -1) {
            var parsed = this._singleParse(css.substring(searchFrom$3(css, /\S/, index), end + 1));
            if (parsed)
                properties.push(parsed);
            index = end + 1;
            end = searchPropEnd$3(css, index);
        }
        var count = properties.length;
        if (count > 1)
            return properties;
        if (count === 1)
            return properties[0];
    };
    Property.prototype.clone = function () {
        return deepCopy$3(this);
    };
    Property.prototype.toStyle = function (selector) {
        var style = new Style$3(selector, this, this.important);
        style.meta = this.meta;
        return style;
    };
    Property.prototype.build = function (minify) {
        var _this = this;
        if (minify === void 0) { minify = false; }
        var createProperty = function (name, value) {
            if (minify) {
                return "".concat(name, ":").concat(value).concat(_this.important ? '!important' : '', ";");
            }
            else {
                var p = "".concat(name, ": ").concat(value).concat(_this.important ? ' !important' : '', ";");
                return _this.comment ? p + " /* ".concat(_this.comment, " */") : p;
            }
        };
        if (!this.value)
            return '';
        return typeof this.name === 'string'
            ? createProperty(this.name, this.value)
            : this.name
                .map(function (i) { return createProperty(i, _this.value); })
                .join(minify ? '' : '\n');
    };
    Property.prototype.updateMeta = function (type, group, order, offset, corePlugin) {
        if (offset === void 0) { offset = 0; }
        if (corePlugin === void 0) { corePlugin = false; }
        this.meta = {
            type: type,
            group: group,
            order: order,
            offset: offset,
            corePlugin: corePlugin,
        };
        return this;
    };
    return Property;
}());
var InlineAtRule$3 = /** @class */ (function (_super) {
    __extends$6(InlineAtRule, _super);
    function InlineAtRule(name, value, important) {
        if (important === void 0) { important = false; }
        var _this = _super.call(this, name, value, undefined, important) || this;
        _this.name = name;
        return _this;
    }
    InlineAtRule.parse = function (css) {
        var _a;
        var matchName = css.match(/@[^\s;{}]+/);
        if (matchName) {
            var name_1 = matchName[0].substring(1);
            var important = false;
            var expression = matchName.index !== undefined
                ? (_a = css
                    .substring(matchName.index + name_1.length + 1)
                    .match(/(?:(['"]).*?\1|[^;])*/)) === null || _a === void 0 ? void 0 : _a[0].trim()
                : undefined;
            if (expression && /!important;?$/.test(expression)) {
                important = true;
                expression = expression.replace(/!important/, '').trimRight();
            }
            return new InlineAtRule(name_1, expression === '' ? undefined : expression, important);
        }
    };
    InlineAtRule.prototype.build = function () {
        return this.value
            ? "@".concat(this.name, " ").concat(this.value).concat(this.important ? ' !important' : '', ";")
            : "@".concat(this.name).concat(this.important ? ' !important' : '', ";");
    };
    return InlineAtRule;
}(Property$3));
var Style$3 = /** @class */ (function () {
    function Style(selector, property, important) {
        if (important === void 0) { important = false; }
        this.meta = { type: 'components', group: 'plugin', order: 0, offset: 0, corePlugin: false };
        this.selector = selector;
        this.important = important;
        this.property = toArray$5(property || []);
    }
    Object.defineProperty(Style.prototype, "rule", {
        get: function () {
            var _this = this;
            var _a, _b, _c;
            var selectors = ((_a = this.selector) !== null && _a !== void 0 ? _a : '').trim().split(/\s*,\s*/g);
            this._parentSelectors && (selectors = selectors.map(function (i) { var _a; return "".concat((_a = _this._parentSelectors) === null || _a === void 0 ? void 0 : _a.join(' '), " ").concat(i); }));
            ((_b = this._wrapSelectors) !== null && _b !== void 0 ? _b : []).forEach(function (func) { return (selectors = selectors.map(function (i) { return func(i); })); });
            this._pseudoClasses && (selectors = selectors.map(function (i) { var _a; return i + ":".concat((_a = _this._pseudoClasses) === null || _a === void 0 ? void 0 : _a.join(':')); }));
            this._pseudoElements && (selectors = selectors.map(function (i) { var _a; return i + "::".concat((_a = _this._pseudoElements) === null || _a === void 0 ? void 0 : _a.join('::')); }));
            this._brotherSelectors && (selectors = selectors.map(function (i) { var _a; return i + ".".concat((_a = _this._brotherSelectors) === null || _a === void 0 ? void 0 : _a.join('.')); }));
            this._childSelectors && (selectors = selectors.map(function (i) { var _a; return i + " ".concat((_a = _this._childSelectors) === null || _a === void 0 ? void 0 : _a.join(' ')); }));
            ((_c = this._wrapRules) !== null && _c !== void 0 ? _c : []).forEach(function (func) { return (selectors = selectors.map(function (i) { return func(i); })); });
            return selectors.join(', ');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "pseudoClasses", {
        get: function () {
            return this._pseudoClasses;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "pseudoElements", {
        get: function () {
            return this._pseudoElements;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "parentSelectors", {
        get: function () {
            return this._parentSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "childSelectors", {
        get: function () {
            return this._childSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "brotherSelectors", {
        get: function () {
            return this._brotherSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapProperties", {
        get: function () {
            return this._wrapProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapSelectors", {
        get: function () {
            return this._wrapSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapRules", {
        get: function () {
            return this._wrapRules;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "simple", {
        get: function () {
            // is this style only has property and no wrap?
            return !(this.atRules || this._pseudoClasses || this._pseudoElements || this._parentSelectors || this._childSelectors || this._brotherSelectors || this._wrapProperties || this._wrapSelectors || this._wrapRules);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "isAtrule", {
        get: function () {
            return !(this.atRules === undefined || this.atRules.length === 0);
        },
        enumerable: false,
        configurable: true
    });
    Style.generate = function (parent, property, root) {
        if (!root)
            root = (parent === null || parent === void 0 ? void 0 : parent.startsWith('@'))
                ? new Style().atRule(parent)
                : new Style(parent);
        var output = [];
        var _loop_1 = function (key, value) {
            var propertyValue = value;
            if (Array.isArray(propertyValue) && propertyValue.every(function (e) { return typeof e === 'object'; })) {
                propertyValue = Object.assign.apply(Object, __spreadArray$6([{}], propertyValue, false));
            }
            if (typeof propertyValue === 'string') {
                root.add(new Property$3(camelToDash$3(key), propertyValue));
            }
            else if (Array.isArray(propertyValue)) {
                propertyValue.map(function (i) { return root === null || root === void 0 ? void 0 : root.add(new Property$3(camelToDash$3(key), i)); });
            }
            else {
                var wrap = deepCopy$3(root);
                wrap.property = [];
                var child = void 0;
                if (key.startsWith('@')) {
                    child = wrap.atRule(key, false);
                }
                else {
                    if (wrap.selector === undefined) {
                        wrap.selector = key;
                        child = wrap;
                    }
                    else {
                        if (/^[a-z]+$/.test(key) && !isTagName$3(key)) {
                            wrap.wrapProperty(function (property) { return "".concat(key, "-").concat(property); });
                            child = wrap;
                        }
                        else {
                            var _hKey_1 = function (selector, key) { return (/&/.test(key) ? key : "& ".concat(key)).replace('&', selector); };
                            wrap.wrapSelector(function (selector) {
                                return selector
                                    .trim()
                                    .split(/\s*,\s*/g)
                                    .map(function (s) {
                                    return key
                                        .split(/\s*,\s*/g)
                                        .map(function (i) { return _hKey_1(s, i); })
                                        .join(', ');
                                })
                                    .join(', ');
                            });
                            child = wrap;
                        }
                    }
                }
                output = output.concat(Style.generate(key.startsWith('@') ? undefined : key, propertyValue, child));
            }
        };
        for (var _i = 0, _a = Object.entries(property !== null && property !== void 0 ? property : {}); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            _loop_1(key, value);
        }
        if (root.property.length > 0)
            output.unshift(root);
        return output;
    };
    Style.prototype.atRule = function (atrule, append) {
        if (append === void 0) { append = true; }
        if (!atrule)
            return this;
        if (this.atRules) {
            append ? this.atRules.push(atrule) : this.atRules.unshift(atrule);
        }
        else {
            this.atRules = [atrule];
        }
        return this;
    };
    Style.prototype.pseudoClass = function (string) {
        if (this._pseudoClasses) {
            this._pseudoClasses.push(string);
        }
        else {
            this._pseudoClasses = [string];
        }
        return this;
    };
    Style.prototype.pseudoElement = function (string) {
        if (this._pseudoElements) {
            this._pseudoElements.push(string);
        }
        else {
            this._pseudoElements = [string];
        }
        return this;
    };
    Style.prototype.brother = function (string) {
        if (this._brotherSelectors) {
            this._brotherSelectors.push(string);
        }
        else {
            this._brotherSelectors = [string];
        }
        return this;
    };
    Style.prototype.parent = function (string) {
        if (this._parentSelectors) {
            this._parentSelectors.push(string);
        }
        else {
            this._parentSelectors = [string];
        }
        return this;
    };
    Style.prototype.child = function (string) {
        if (this._childSelectors) {
            this._childSelectors.push(string);
        }
        else {
            this._childSelectors = [string];
        }
        return this;
    };
    Style.prototype.wrapProperty = function (func) {
        if (this._wrapProperties) {
            this._wrapProperties.push(func);
        }
        else {
            this._wrapProperties = [func];
        }
        return this;
    };
    Style.prototype.wrapSelector = function (func) {
        if (this._wrapSelectors) {
            this._wrapSelectors.push(func);
        }
        else {
            this._wrapSelectors = [func];
        }
        return this;
    };
    Style.prototype.wrapRule = function (func) {
        if (this._wrapRules) {
            this._wrapRules.push(func);
        }
        else {
            this._wrapRules = [func];
        }
        return this;
    };
    Style.prototype.add = function (item) {
        item = toArray$5(item);
        if (this.important)
            item.forEach(function (i) { return (i.important = true); });
        this.property = __spreadArray$6(__spreadArray$6([], this.property, true), item, true);
        return this;
    };
    Style.prototype.extend = function (item, onlyProperty, append) {
        if (onlyProperty === void 0) { onlyProperty = false; }
        if (append === void 0) { append = true; }
        if (!item)
            return this;
        if (item.wrapProperties) {
            var props_1 = [];
            item.property.forEach(function (p) {
                var _a;
                var pc = new Property$3(p.name, p.value, p.comment);
                (_a = item.wrapProperties) === null || _a === void 0 ? void 0 : _a.forEach(function (wrap) {
                    pc.name = Array.isArray(pc.name)
                        ? pc.name.map(function (i) { return wrap(i); })
                        : wrap(pc.name);
                });
                if (item.important)
                    pc.important = true;
                props_1.push(pc);
            });
            this.property = connectList$3(this.property, props_1, append);
        }
        else {
            if (item.important)
                item.property.forEach(function (i) { return (i.important = true); });
            this.property = connectList$3(this.property, item.property, append);
        }
        if (onlyProperty)
            return this;
        item.selector && (this.selector = item.selector);
        this.meta = item.meta;
        item.atRules &&
            (this.atRules = connectList$3(item.atRules, this.atRules, append)); // atrule is build in reverse
        item._brotherSelectors &&
            (this._brotherSelectors = connectList$3(this._brotherSelectors, item._brotherSelectors, append));
        item._childSelectors &&
            (this._childSelectors = connectList$3(this._childSelectors, item._childSelectors, append));
        item._parentSelectors &&
            (this._parentSelectors = connectList$3(this._parentSelectors, item._parentSelectors, append));
        item._pseudoClasses &&
            (this._pseudoClasses = connectList$3(this._pseudoClasses, item._pseudoClasses, append));
        item._pseudoElements &&
            (this._pseudoElements = connectList$3(this._pseudoElements, item._pseudoElements, append));
        item._wrapRules &&
            (this._wrapRules = connectList$3(this._wrapRules, item._wrapRules, append));
        item._wrapSelectors &&
            (this._wrapSelectors = connectList$3(this._wrapSelectors, item._wrapSelectors, append));
        return this;
    };
    Style.prototype.clean = function () {
        // remove duplicated property
        var property = [];
        var cache = [];
        this.property.forEach(function (i) {
            var inline = i.build();
            if (!cache.includes(inline)) {
                cache.push(inline);
                property.push(i);
            }
        });
        this.property = property;
        return this;
    };
    Style.prototype.flat = function () {
        var properties = [];
        this.property.forEach(function (p) {
            if (Array.isArray(p.name)) {
                p.name.forEach(function (i) {
                    properties.push(new Property$3(i, p.value, p.comment));
                });
            }
            else {
                properties.push(p);
            }
        });
        this.property = properties;
        return this;
    };
    Style.prototype.clone = function (selector, property) {
        var newStyle = deepCopy$3(this);
        if (selector)
            newStyle.selector = selector;
        if (property)
            newStyle.property = Array.isArray(property) ? property : [property];
        return newStyle;
    };
    Style.prototype.sort = function () {
        // sort property
        this.property = this.property.sort(function (a, b) {
            return "".concat(a.name).substring(0, 2) > "".concat(b.name).substring(0, 2) ? 1 : -1;
        });
        return this;
    };
    Style.prototype.build = function (minify, prefixer) {
        var _this = this;
        if (minify === void 0) { minify = false; }
        if (prefixer === void 0) { prefixer = true; }
        var properties = this.property;
        if (!prefixer)
            properties = properties.filter(function (p) {
                if (p.value && /-(webkit|ms|moz|o)-/.test(p.value))
                    return false;
                if (Array.isArray(p.name)) {
                    p.name = p.name.filter(function (i) { return !/^-(webkit|ms|moz|o)-/.test(i); });
                    return true;
                }
                return !/^-(webkit|ms|moz|o)-/.test(p.name);
            });
        var result = properties.map(function (p) {
            if (_this._wrapProperties) {
                var name_2 = p.name;
                _this._wrapProperties.forEach(function (w) { return (name_2 = Array.isArray(name_2) ? name_2.map(function (n) { return w(n); }) : w(name_2)); });
                return new Property$3(name_2, p.value, p.comment, _this.important ? true : p.important).build(minify);
            }
            return _this.important ? new Property$3(p.name, p.value, p.comment, true).build(minify) : p.build(minify);
        }).join(minify ? '' : '\n');
        if (!this.selector && !this.atRules)
            return result.replace(/;}/g, '}');
        if (this.selector)
            result = (minify ? this.rule.replace(/,\s/g, ',') : this.rule + ' ') + wrapit$3(result, undefined, undefined, undefined, result !== '' ? minify : true);
        if (this.atRules) {
            for (var _i = 0, _a = this.atRules; _i < _a.length; _i++) {
                var rule = _a[_i];
                result = minify ? "".concat(rule.replace(/\s/g, '')).concat(wrapit$3(result, undefined, undefined, undefined, minify)) : "".concat(rule, " ").concat(wrapit$3(result, undefined, undefined, undefined, result !== '' ? minify : true));
            }
        }
        return minify ? result.replace(/;}/g, '}') : result;
    };
    Style.prototype.updateMeta = function (type, group, order, offset, corePlugin, respectSelector) {
        if (offset === void 0) { offset = 0; }
        if (corePlugin === void 0) { corePlugin = false; }
        if (respectSelector === void 0) { respectSelector = false; }
        this.meta = {
            type: type,
            group: group,
            order: order,
            offset: offset,
            corePlugin: corePlugin,
            respectSelector: respectSelector,
        };
        return this;
    };
    return Style;
}());
/** @class */ ((function (_super) {
    __extends$6(GlobalStyle, _super);
    function GlobalStyle(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    return GlobalStyle;
})(Style$3));
var Keyframes$1 = /** @class */ (function (_super) {
    __extends$6(Keyframes, _super);
    function Keyframes(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    // root param only for consist with style
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Keyframes.generate = function (name, children, root, prefixer) {
        if (prefixer === void 0) { prefixer = true; }
        var styles = [];
        var webkitStyles = [];
        for (var _i = 0, _a = Object.entries(children); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            var style = new Keyframes(key).atRule("@keyframes ".concat(name));
            var webkitStyle = new Keyframes(key).atRule("@-webkit-keyframes ".concat(name));
            for (var _c = 0, _d = Object.entries(value); _c < _d.length; _c++) {
                var _e = _d[_c], pkey = _e[0], pvalue = _e[1];
                var prop = pkey;
                if (pkey === 'transform') {
                    prop = prefixer ? ['-webkit-transform', 'transform'] : 'transform';
                }
                else if (['animationTimingFunction', 'animation-timing-function'].includes(pkey)) {
                    prop = prefixer ? [
                        '-webkit-animation-timing-function',
                        'animation-timing-function',
                    ] : 'animation-timing-function';
                }
                style.add(new Property$3(prop, pvalue));
                webkitStyle.add(new Property$3(prop, pvalue));
            }
            styles.push(style);
            if (prefixer)
                webkitStyles.push(webkitStyle);
        }
        return __spreadArray$6(__spreadArray$6([], styles, true), webkitStyles, true);
    };
    return Keyframes;
}(Style$3));
var Container = /** @class */ (function (_super) {
    __extends$6(Container, _super);
    function Container(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    return Container;
}(Style$3));

var minMaxWidth$2 = /(!?\(\s*min(-device-)?-width).+\(\s*max(-device)?-width/i;
var minWidth$2 = /\(\s*min(-device)?-width/i;
var maxMinWidth$2 = /(!?\(\s*max(-device)?-width).+\(\s*min(-device)?-width/i;
var maxWidth$2 = /\(\s*max(-device)?-width/i;
var isMinWidth$2 = _testQuery$2(minMaxWidth$2, maxMinWidth$2, minWidth$2);
var isMaxWidth$2 = _testQuery$2(maxMinWidth$2, minMaxWidth$2, maxWidth$2);
var minMaxHeight$2 = /(!?\(\s*min(-device)?-height).+\(\s*max(-device)?-height/i;
var minHeight$2 = /\(\s*min(-device)?-height/i;
var maxMinHeight$2 = /(!?\(\s*max(-device)?-height).+\(\s*min(-device)?-height/i;
var maxHeight$2 = /\(\s*max(-device)?-height/i;
var isMinHeight$2 = _testQuery$2(minMaxHeight$2, maxMinHeight$2, minHeight$2);
var isMaxHeight$2 = _testQuery$2(maxMinHeight$2, minMaxHeight$2, maxHeight$2);
var isPrint$2 = /print/i;
var isPrintOnly$2 = /^print\$/i;
var isAtRule$2 = /^\s*@/i;
var isMedia$2 = /^\s*@media/i;
var maxValue$2 = Number.MAX_VALUE;
function _getQueryLength$2(length) {
    var result = /(-?\d*\.?\d+)(ch|em|ex|px|rpx|rem)/.exec(length);
    if (result === null) {
        return maxValue$2;
    }
    var number = result[1];
    var unit = result[2];
    switch (unit) {
        case 'ch':
            return parseFloat(number) * 8.8984375;
        case 'em':
        case 'rem':
            return parseFloat(number) * 16;
        case 'ex':
            return parseFloat(number) * 8.296875;
        case 'px':
        case 'rpx':
            return parseFloat(number);
    }
    return +number;
}
function _testQuery$2(doubleTestTrue, doubleTestFalse, singleTest) {
    return function (query) {
        if (doubleTestTrue.test(query)) {
            return true;
        }
        else if (doubleTestFalse.test(query)) {
            return false;
        }
        return singleTest.test(query);
    };
}
function _testAtRule$2(a, b) {
    var isMediaA = isMedia$2.test(a);
    var isMediaB = isMedia$2.test(b);
    if (isMediaA && isMediaB)
        return null;
    var isAtRuleA = isAtRule$2.test(a);
    var isAtRuleB = isAtRule$2.test(b);
    if (isAtRuleA)
        return 1;
    if (isAtRuleB)
        return -1;
    return 0; // don't sort selector name, may cause overwrite bug.
}
function _testIsPrint$2(a, b) {
    var isPrintA = isPrint$2.test(a);
    var isPrintOnlyA = isPrintOnly$2.test(a);
    var isPrintB = isPrint$2.test(b);
    var isPrintOnlyB = isPrintOnly$2.test(b);
    if (isPrintA && isPrintB) {
        if (!isPrintOnlyA && isPrintOnlyB) {
            return 1;
        }
        if (isPrintOnlyA && !isPrintOnlyB) {
            return -1;
        }
        return a.localeCompare(b);
    }
    if (isPrintA) {
        return 1;
    }
    if (isPrintB) {
        return -1;
    }
    return null;
}
function sortMediaQuery$2(a, b) {
    var testAtRule = _testAtRule$2(a, b);
    if (testAtRule !== null)
        return testAtRule;
    var testIsPrint = _testIsPrint$2(a, b);
    if (testIsPrint !== null)
        return testIsPrint;
    var minA = isMinWidth$2(a) || isMinHeight$2(a);
    var maxA = isMaxWidth$2(a) || isMaxHeight$2(a);
    var minB = isMinWidth$2(b) || isMinHeight$2(b);
    var maxB = isMaxWidth$2(b) || isMaxHeight$2(b);
    if (minA && maxB) {
        return -1;
    }
    if (maxA && minB) {
        return 1;
    }
    var lengthA = _getQueryLength$2(a);
    var lengthB = _getQueryLength$2(b);
    if (lengthA === maxValue$2 && lengthB === maxValue$2) {
        return a.localeCompare(b);
    }
    else if (lengthA === maxValue$2) {
        return 1;
    }
    else if (lengthB === maxValue$2) {
        return -1;
    }
    if (lengthA > lengthB) {
        if (maxA) {
            return -1;
        }
        return 1;
    }
    if (lengthA < lengthB) {
        if (maxA) {
            return 1;
        }
        return -1;
    }
    return a.localeCompare(b);
}

function getWeights$2(a) {
    var first = a.charAt(0);
    var second = a.charAt(1);
    if (first === ':' && second === ':')
        return 59; // ::moz ...
    if (first === '#')
        return 500; // #id ...
    if (first !== '.')
        return first.charCodeAt(0); // html, body ...
    return 499;
}
function sortMeta$2(a, b) {
    var _a, _b, _c, _d;
    if (a.meta.type === 'base' && b.meta.type === 'base')
        return getWeights$2((_a = a.selector) !== null && _a !== void 0 ? _a : '') - getWeights$2((_b = b.selector) !== null && _b !== void 0 ? _b : '');
    return sortMediaQuery$2(((_c = a.meta.variants) === null || _c === void 0 ? void 0 : _c[0]) || '', ((_d = b.meta.variants) === null || _d === void 0 ? void 0 : _d[0]) || '') || (a.meta.order - b.meta.order) || (a.meta.offset - b.meta.offset) || +b.meta.corePlugin - +a.meta.corePlugin;
}
function sortGroup(a, b) {
    var _a, _b;
    return sortMediaQuery$2(((_a = a.meta.variants) === null || _a === void 0 ? void 0 : _a[0]) || '', ((_b = b.meta.variants) === null || _b === void 0 ? void 0 : _b[0]) || '') || (a.meta.order - b.meta.order);
}

function _buildAtrule$2(atrule, children, minify, prefixer) {
    if (minify === void 0) { minify = false; }
    if (prefixer === void 0) { prefixer = true; }
    return "".concat(atrule).concat(minify ? '' : ' ').concat(wrapit$3(_buildStyleList$2(children, minify, prefixer), undefined, undefined, undefined, minify));
}
function _buildStyleList$2(styleList, minify, prefixer) {
    if (minify === void 0) { minify = false; }
    if (prefixer === void 0) { prefixer = true; }
    var currentAtrule;
    var currentStyle;
    var styleStack = [];
    var output = [];
    var _loop_1 = function (style) {
        if (style.isAtrule) {
            if (currentStyle) {
                output.push(currentStyle.clean().build(minify, prefixer));
                currentStyle = undefined;
            }
            var newAtrule = style.atRules.pop();
            if (currentAtrule) {
                if (currentAtrule === newAtrule && newAtrule !== '@font-face') { // @font-face shouldn't been combined
                    styleStack.push(style);
                }
                else {
                    output.push(_buildAtrule$2(currentAtrule, styleStack, minify, prefixer));
                    currentAtrule = newAtrule;
                    styleStack = [style];
                }
            }
            else {
                currentAtrule = newAtrule;
                styleStack = [style];
            }
        }
        else {
            if (currentAtrule) {
                output.push(_buildAtrule$2(currentAtrule, styleStack, minify, prefixer));
                currentAtrule = undefined;
                styleStack = [];
            }
            if (currentStyle) {
                if (style.rule === currentStyle.rule) {
                    if (style.important)
                        style.property.forEach(function (p) { return p.important = true; });
                    if (style.wrapProperties)
                        style.property.forEach(function (p) { var _a; return (_a = style.wrapProperties) === null || _a === void 0 ? void 0 : _a.forEach(function (wrap) { return p.name = Array.isArray(p.name) ? p.name.map(function (i) { return wrap(i); }) : wrap(p.name); }); });
                    currentStyle.add(style.property);
                }
                else {
                    output.push(currentStyle.clean().build(minify, prefixer));
                    currentStyle = style;
                }
            }
            else {
                currentStyle = style;
            }
        }
    };
    for (var _i = 0, styleList_1 = styleList; _i < styleList_1.length; _i++) {
        var style = styleList_1[_i];
        _loop_1(style);
    }
    if (currentAtrule)
        output.push(_buildAtrule$2(currentAtrule, styleStack, minify, prefixer));
    if (currentStyle)
        output.push(currentStyle.clean().build(minify, prefixer));
    return output.join(minify ? '' : '\n');
}
function compileStyleSheet$2 (styleList, minify, prefixer) {
    if (minify === void 0) { minify = false; }
    if (prefixer === void 0) { prefixer = true; }
    return _buildStyleList$2(deepCopy$3(styleList), minify, prefixer);
}

var StyleSheet$2 = /** @class */ (function () {
    function StyleSheet(children) {
        this.prefixer = true;
        this.children = children || [];
    }
    StyleSheet.prototype.add = function (item) {
        if (!item)
            return this;
        if (Array.isArray(item)) {
            this.children = __spreadArray$6(__spreadArray$6([], this.children, true), item, true);
        }
        else {
            this.children.push(item);
        }
        return this;
    };
    StyleSheet.prototype.extend = function (styleSheet, append, dedup) {
        if (append === void 0) { append = true; }
        if (dedup === void 0) { dedup = false; }
        if (styleSheet) {
            var extended = styleSheet.children;
            if (dedup) {
                var hashes_1 = extended.map(function (i) { return hash$2(i.build()); });
                extended = extended.filter(function (i) { return !hashes_1.includes(hash$2(i.build())); });
            }
            this.prefixer = styleSheet.prefixer;
            this.children = append ? __spreadArray$6(__spreadArray$6([], this.children, true), extended, true) : __spreadArray$6(__spreadArray$6([], extended, true), this.children, true);
        }
        return this;
    };
    StyleSheet.prototype.combine = function () {
        var styleMap = {};
        this.children.forEach(function (style, index) {
            var _a;
            var hashValue = hash$2(style.atRules + style.meta.type + style.rule);
            if (hashValue in styleMap) {
                if ((_a = style.atRules) === null || _a === void 0 ? void 0 : _a.includes('@font-face')) {
                    // keeps multiple @font-face
                    styleMap[hashValue + index] = style;
                }
                else {
                    styleMap[hashValue] = styleMap[hashValue].extend(style, true);
                }
            }
            else {
                styleMap[hashValue] = style;
            }
        });
        this.children = Object.values(styleMap).map(function (i) { return i.clean(); });
        return this;
    };
    StyleSheet.prototype.layer = function (type) {
        var styleSheet = new StyleSheet(this.children.filter(function (i) { return i.meta.type === type; }));
        styleSheet.prefixer = this.prefixer;
        return styleSheet;
    };
    StyleSheet.prototype.split = function () {
        return {
            base: this.layer('base'),
            components: this.layer('components'),
            utilities: this.layer('utilities'),
        };
    };
    StyleSheet.prototype.clone = function () {
        return deepCopy$3(this);
    };
    StyleSheet.prototype.sort = function () {
        this.children = this.children.sort(sortMeta$2);
        return this;
    };
    StyleSheet.prototype.sortby = function (compareFn) {
        this.children = this.children.sort(compareFn);
        return this;
    };
    StyleSheet.prototype.build = function (minify) {
        if (minify === void 0) { minify = false; }
        return compileStyleSheet$2(this.children, minify, this.prefixer);
    };
    return StyleSheet;
}());

function linearGradient(value) {
    // Stupid method, will be changed in the next version...
    var map = {
        'linear-gradient(to top, var(--tw-gradient-stops))': [
            '-o-linear-gradient(bottom, var(--tw-gradient-stops))',
            '-webkit-gradient(linear, left bottom, left top, from(var(--tw-gradient-stops)))',
            'linear-gradient(to top, var(--tw-gradient-stops))',
        ],
        'linear-gradient(to top right, var(--tw-gradient-stops))': [
            '-o-linear-gradient(bottom left, var(--tw-gradient-stops))',
            '-webkit-gradient(linear, left bottom, right top, from(var(--tw-gradient-stops)))',
            'linear-gradient(to top right, var(--tw-gradient-stops))',
        ],
        'linear-gradient(to right, var(--tw-gradient-stops))': [
            '-o-linear-gradient(left, var(--tw-gradient-stops))',
            '-webkit-gradient(linear, left top, right top, from(var(--tw-gradient-stops)))',
            'linear-gradient(to right, var(--tw-gradient-stops))',
        ],
        'linear-gradient(to bottom right, var(--tw-gradient-stops))': [
            '-o-linear-gradient(top left, var(--tw-gradient-stops))',
            '-webkit-gradient(linear, left top, right bottom, from(var(--tw-gradient-stops)))',
            'linear-gradient(to bottom right, var(--tw-gradient-stops))',
        ],
        'linear-gradient(to bottom, var(--tw-gradient-stops))': [
            '-o-linear-gradient(top, var(--tw-gradient-stops))',
            '-webkit-gradient(linear, left top, left bottom, from(var(--tw-gradient-stops)))',
            'linear-gradient(to bottom, var(--tw-gradient-stops))',
        ],
        'linear-gradient(to bottom left, var(--tw-gradient-stops))': [
            '-o-linear-gradient(top right, var(--tw-gradient-stops))',
            '-webkit-gradient(linear, right top, left bottom, from(var(--tw-gradient-stops)))',
            'linear-gradient(to bottom left, var(--tw-gradient-stops))',
        ],
        'linear-gradient(to left, var(--tw-gradient-stops))': [
            '-o-linear-gradient(right, var(--tw-gradient-stops))',
            '-webkit-gradient(linear, right top, left top, from(var(--tw-gradient-stops)))',
            'linear-gradient(to left, var(--tw-gradient-stops))',
        ],
        'linear-gradient(to top left, var(--tw-gradient-stops))': [
            '-o-linear-gradient(bottom right, var(--tw-gradient-stops))',
            '-webkit-gradient(linear, right bottom, left top, from(var(--tw-gradient-stops)))',
            'linear-gradient(to top left, var(--tw-gradient-stops))',
        ],
    };
    if (Object.keys(map).includes(value))
        return map[value];
    return value;
}
function minMaxContent(value) {
    if (value === 'min-content') {
        return ['-webkit-min-content', 'min-content'];
    }
    else if (value === 'max-content') {
        return ['-webkit-max-content', 'max-content'];
    }
    return value;
}

function isString$1(value) {
    return typeof value === 'string';
}
function negative$1(scale) {
    return Object.keys(scale)
        .filter(function (key) { return scale[key] !== '0'; })
        .reduce(function (negativeScale, key) {
        var _a;
        return (__assign$4(__assign$4({}, negativeScale), (_a = {}, _a["-".concat(key)] = negateValue(scale[key]), _a)));
    }, {});
}
function breakpoints(screens) {
    if (screens === void 0) { screens = {}; }
    return Object.keys(screens)
        .filter(function (key) { return typeof screens[key] === 'string'; })
        .reduce(function (breakpoints, key) {
        var _a;
        return (__assign$4(__assign$4({}, breakpoints), (_a = {}, _a["screen-".concat(key)] = screens[key], _a)));
    }, {});
}
function generateFontSize(font) {
    if (typeof font === 'string')
        return [new Property$3('font-size', font)];
    var properties = [];
    if (font[0])
        properties.push(new Property$3('font-size', font[0]));
    if (typeof font[1] === 'string') {
        properties.push(new Property$3('line-height', font[1]));
    }
    else if (font[1]) {
        if (font[1].lineHeight)
            properties.push(new Property$3('line-height', font[1].lineHeight));
        if (font[1].letterSpacing)
            properties.push(new Property$3('letter-spacing', font[1].letterSpacing));
    }
    return properties;
}
function expandDirection(value, divide) {
    if (divide === void 0) { divide = false; }
    var map = {
        '': ['*'],
        y: ['top', 'bottom'],
        x: ['left', 'right'],
        t: divide ? ['top-left', 'top-right'] : ['top'],
        r: divide ? ['top-right', 'bottom-right'] : ['right'],
        b: divide ? ['bottom-right', 'bottom-left'] : ['bottom'],
        l: divide ? ['top-left', 'bottom-left'] : ['left'],
        tl: ['top-left'],
        tr: ['top-right'],
        br: ['bottom-right'],
        bl: ['bottom-left'],
    };
    if (value in map)
        return map[value];
}
function generatePlaceholder(selector, property, prefixer) {
    if (prefixer === void 0) { prefixer = false; }
    if (!prefixer)
        return [new Style$3(selector, property).pseudoElement('placeholder')];
    return [
        new Style$3(selector, property).pseudoElement('-webkit-input-placeholder'),
        new Style$3(selector, property).pseudoElement('-moz-placeholder'),
        new Style$3(selector, property).pseudoClass('-ms-input-placeholder'),
        new Style$3(selector, property).pseudoElement('-ms-input-placeholder'),
        new Style$3(selector, property).pseudoElement('placeholder'),
    ];
}

function generateOrientations(orientations) {
    var variants = {};
    Object.entries(orientations).forEach(function (_a) {
        var name = _a[0], orientation = _a[1];
        variants[name] = function () { return new Style$3().atRule("@media (orientation: ".concat(orientation, ")")); };
    });
    return variants;
}

var colorString$1 = {exports: {}};

var colorName$1 = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

var simpleSwizzle$1 = {exports: {}};

var isArrayish$1$1 = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

var isArrayish$2 = isArrayish$1$1;

var concat$1 = Array.prototype.concat;
var slice$3 = Array.prototype.slice;

var swizzle$1$1 = simpleSwizzle$1.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish$2(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat$1.call(results, slice$3.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle$1$1.wrap = function (fn) {
	return function () {
		return fn(swizzle$1$1(arguments));
	};
};

/* MIT license */

var colorNames$1 = colorName$1;
var swizzle$2 = simpleSwizzle$1.exports;
var hasOwnProperty$1 = Object.hasOwnProperty;

var reverseNames$1 = {};

// create a list of reverse color names
for (var name$1 in colorNames$1) {
	if (hasOwnProperty$1.call(colorNames$1, name$1)) {
		reverseNames$1[colorNames$1[name$1]] = name$1;
	}
}

var cs$1 = colorString$1.exports = {
	to: {},
	get: {}
};

cs$1.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs$1.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs$1.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs$1.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs$1.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
	var keyword = /^(\w+)$/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha, 16) / 255;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			if (match[5]) {
				rgb[3] = parseFloat(match[4]) * 0.01;
			} else {
				rgb[3] = parseFloat(match[4]);
			}
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			if (match[5]) {
				rgb[3] = parseFloat(match[4]) * 0.01;
			} else {
				rgb[3] = parseFloat(match[4]);
			}
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		if (!hasOwnProperty$1.call(colorNames$1, match[1])) {
			return null;
		}

		rgb = colorNames$1[match[1]];
		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp$1(rgb[i], 0, 255);
	}
	rgb[3] = clamp$1(rgb[3], 0, 1);

	return rgb;
};

cs$1.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var s = clamp$1(parseFloat(match[2]), 0, 100);
		var l = clamp$1(parseFloat(match[3]), 0, 100);
		var a = clamp$1(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs$1.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp$1(parseFloat(match[2]), 0, 100);
		var b = clamp$1(parseFloat(match[3]), 0, 100);
		var a = clamp$1(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs$1.to.hex = function () {
	var rgba = swizzle$2(arguments);

	return (
		'#' +
		hexDouble$1(rgba[0]) +
		hexDouble$1(rgba[1]) +
		hexDouble$1(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble$1(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs$1.to.rgb = function () {
	var rgba = swizzle$2(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs$1.to.rgb.percent = function () {
	var rgba = swizzle$2(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs$1.to.hsl = function () {
	var hsla = swizzle$2(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs$1.to.hwb = function () {
	var hwba = swizzle$2(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs$1.to.keyword = function (rgb) {
	return reverseNames$1[rgb.slice(0, 3)];
};

// helpers
function clamp$1(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble$1(num) {
	var str = Math.round(num).toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}

var colorString = colorString$1.exports;

function hsl2rgb(h, s, l) {
    l /= 100;
    if (h >= 360)
        h %= 360;
    var c = (1 - Math.abs(2 * l - 1)) * (s / 100);
    var x = c * (1 - Math.abs((h / 60) % 2 - 1));
    var m = l - c / 2;
    var r = 0;
    var g = 0;
    var b = 0;
    if (0 <= h && h < 60) {
        r = c + m;
        g = x + m;
        b = m;
    }
    else if (60 <= h && h < 120) {
        r = x + m;
        g = c + m;
        b = m;
    }
    else if (120 <= h && h < 180) {
        r = m;
        g = c + m;
        b = x + m;
    }
    else if (180 <= h && h < 240) {
        r = m;
        g = x + m;
        b = c + m;
    }
    else if (240 <= h && h < 300) {
        r = x + m;
        g = m;
        b = c + m;
    }
    else if (300 <= h && h < 360) {
        r = c + m;
        g = m;
        b = x + m;
    }
    return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255),
    ];
}
function hwb2rgb(h, w, b) {
    var rgb = hsl2rgb(h, 100, 50);
    for (var i = 0; i < 3; ++i) {
        var c = rgb[i] / 255;
        c *= 1 - w / 100 - b / 100;
        c += w / 100;
        rgb[i] = Math.round(c * 255);
    }
    return rgb;
}
function toRGBA(color) {
    var _a;
    if (/^hsla?/.test(color)) {
        var color_array = colorString.get.hsl(color);
        if (!color_array)
            return;
        return __spreadArray$6(__spreadArray$6([], hsl2rgb(color_array[0], color_array[1], color_array[2]), true), [color_array[3]], false);
    }
    else if (/^rgba?/.test(color)) {
        var color_array = colorString.get.rgb(color);
        if (!color_array)
            return;
        return color_array;
    }
    else if (color.startsWith('hwb')) {
        var color_array = colorString.get.hwb(color);
        if (!color_array)
            return;
        return __spreadArray$6(__spreadArray$6([], hwb2rgb(color_array[0], color_array[1], color_array[2]), true), [color_array[3]], false);
    }
    return (_a = colorString.get(color)) === null || _a === void 0 ? void 0 : _a.value;
}
function toColor(color_string) {
    var rgba = toRGBA(color_string);
    var color = rgba ? rgba.slice(0, 3).join(', ') : color_string;
    var opacity = rgba ? rgba[3].toString() : '1';
    return { color: color, opacity: opacity };
}

function generateScreens(screens) {
    var variants = {};
    var breakpoints = Object.entries(screens).sort(function (_a, _b) {
        var sizeA = _a[1];
        var sizeB = _b[1];
        return sortWeight(sizeA) - sortWeight(sizeB);
    });
    breakpoints.forEach(function (_a, index) {
        var name = _a[0], size = _a[1];
        if (isString$1(size)) {
            var _b = breakpoints[index + 1] || [], nextSize = _b[1];
            variants[name] = styleForBreakpoint({ min: size });
            variants["<".concat(name)] = styleForBreakpoint({ max: increaseWithUnit(size, -0.1) });
            variants["@".concat(name)] = styleForBreakpoint(nextSize ? { min: size, max: increaseWithUnit(nextSize, -0.1) } : { min: size });
            variants["-".concat(name)] = styleForBreakpoint({ max: size });
            variants["+".concat(name)] = styleForBreakpoint(nextSize ? { min: size, max: nextSize } : { min: size });
        }
        else {
            variants[name] = styleForBreakpoint(size);
        }
    });
    return variants;
}
function styleForBreakpoint(rule) {
    var mediaConditions = 'raw' in rule ? rule.raw : [
        rule.min && "(min-width: ".concat(rule.min, ")"),
        rule.max && "(max-width: ".concat(rule.max, ")"),
    ].filter(function (condition) { return condition; }).join(' and ');
    return function () { return new Style$3().atRule("@media ".concat(mediaConditions)); };
}
// NOTE: Non-size breakpoints should come first, to avoid using them in the
// +breakpoint definition.
function sortWeight(breakpoint) {
    return isString$1(breakpoint) ? parseInt(breakpoint) : Number.NEGATIVE_INFINITY;
}

function generateThemes(darkMode) {
    if (!darkMode)
        return {};
    return {
        '@dark': function () { return new Style$3().atRule('@media (prefers-color-scheme: dark)'); },
        '@light': function () { return new Style$3().atRule('@media (prefers-color-scheme: light)'); },
        '.dark': function () { return new Style$3().parent('.dark'); },
        '.light': function () { return new Style$3().parent('.light'); },
        dark: function () { return darkMode === 'media' ? new Style$3().atRule('@media (prefers-color-scheme: dark)') : new Style$3().parent('.dark'); },
        light: function () { return darkMode === 'media' ? new Style$3().atRule('@media (prefers-color-scheme: light)') : new Style$3().parent('.light'); },
    };
}

/*
 * See MDN web docs for more information
 * https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes
 */
function generateStates(variantOrder) {
    var states = {
        // Interactive links/buttons
        hover: function () { return new Style$3().pseudoClass('hover'); },
        focus: function () { return new Style$3().pseudoClass('focus'); },
        active: function () { return new Style$3().pseudoClass('active'); },
        visited: function () { return new Style$3().pseudoClass('visited'); },
        link: function () { return new Style$3().pseudoClass('link'); },
        target: function () { return new Style$3().pseudoClass('target'); },
        'focus-visible': function () { return new Style$3().pseudoClass('focus-visible'); },
        'focus-within': function () { return new Style$3().pseudoClass('focus-within'); },
        // Form element states
        checked: function () { return new Style$3().pseudoClass('checked'); },
        'not-checked': function () { return new Style$3().pseudoClass('not(:checked)'); },
        default: function () { return new Style$3().pseudoClass('default'); },
        disabled: function () { return new Style$3().pseudoClass('disabled'); },
        enabled: function () { return new Style$3().pseudoClass('enabled'); },
        indeterminate: function () { return new Style$3().pseudoClass('indeterminate'); },
        invalid: function () { return new Style$3().pseudoClass('invalid'); },
        valid: function () { return new Style$3().pseudoClass('valid'); },
        optional: function () { return new Style$3().pseudoClass('optional'); },
        required: function () { return new Style$3().pseudoClass('required'); },
        'placeholder-shown': function () { return new Style$3().pseudoClass('placeholder-shown'); },
        'read-only': function () { return new Style$3().pseudoClass('read-only'); },
        'read-write': function () { return new Style$3().pseudoClass('read-write'); },
        // Child selectors
        'not-disabled': function () { return new Style$3().pseudoClass('not(:disabled)'); },
        'first-of-type': function () { return new Style$3().pseudoClass('first-of-type'); },
        'not-first-of-type': function () { return new Style$3().pseudoClass('not(:first-of-type)'); },
        'last-of-type': function () { return new Style$3().pseudoClass('last-of-type'); },
        'not-last-of-type': function () { return new Style$3().pseudoClass('not(:last-of-type)'); },
        first: function () { return new Style$3().pseudoClass('first-child'); },
        last: function () { return new Style$3().pseudoClass('last-child'); },
        'not-first': function () { return new Style$3().pseudoClass('not(:first-child)'); },
        'not-last': function () { return new Style$3().pseudoClass('not(:last-child)'); },
        'only-child': function () { return new Style$3().pseudoClass('only-child'); },
        'not-only-child': function () { return new Style$3().pseudoClass('not(:only-child)'); },
        'only-of-type': function () { return new Style$3().pseudoClass('only-of-type'); },
        'not-only-of-type': function () { return new Style$3().pseudoClass('not(:only-of-type)'); },
        even: function () { return new Style$3().pseudoClass('nth-child(even)'); },
        odd: function () { return new Style$3().pseudoClass('nth-child(odd)'); },
        'even-of-type': function () { return new Style$3().pseudoClass('nth-of-type(even)'); },
        'odd-of-type': function () { return new Style$3().pseudoClass('nth-of-type(odd)'); },
        root: function () { return new Style$3().pseudoClass('root'); },
        empty: function () { return new Style$3().pseudoClass('empty'); },
        // Pseudo elements
        before: function () { return new Style$3().pseudoElement('before'); },
        after: function () { return new Style$3().pseudoElement('after'); },
        'first-letter': function () { return new Style$3().pseudoElement('first-letter'); },
        'first-line': function () { return new Style$3().pseudoElement('first-line'); },
        'file-selector-button': function () { return new Style$3().pseudoElement('file-selector-button'); },
        file: function () { return new Style$3().pseudoElement('file-selector-button'); },
        selection: function () { return new Style$3().wrapSelector(function (selector) { return "".concat(selector, " *::selection, ").concat(selector, "::selection"); }); },
        marker: function () { return new Style$3().wrapSelector(function (selector) { return "".concat(selector, " *::marker, ").concat(selector, "::marker"); }); },
        svg: function () { return new Style$3().child('svg'); },
        all: function () { return new Style$3().child('*'); },
        children: function () { return new Style$3().child('> *'); },
        siblings: function () { return new Style$3().child('~ *'); },
        sibling: function () { return new Style$3().child('+ *'); },
        // https://www.w3schools.com/CSS/css_pseudo_elements.asp
        // Directions
        ltr: function () { return new Style$3().wrapSelector(function (selector) { return "[dir='ltr'] ".concat(selector, ", [dir='ltr']").concat(selector); }); },
        rtl: function () { return new Style$3().wrapSelector(function (selector) { return "[dir='rtl'] ".concat(selector, ", [dir='rtl']").concat(selector); }); },
        // Group states
        // You'll need to add className="group" to an ancestor to make these work
        // https://github.com/ben-rogerson/twin.macro/blob/master/docs/group.md
        'group-hover': function () { return new Style$3().parent('.group:hover'); },
        'group-focus': function () { return new Style$3().parent('.group:focus'); },
        'group-active': function () { return new Style$3().parent('.group:active'); },
        'group-visited': function () { return new Style$3().parent('.group:visited'); },
        // Motion control
        // https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion
        'motion-safe': function () { return new Style$3().atRule('@media (prefers-reduced-motion: no-preference)'); },
        'motion-reduce': function () { return new Style$3().atRule('@media (prefers-reduced-motion: reduce)'); },
    };
    var orderedStates = {};
    variantOrder.forEach(function (v) {
        if (v in states) {
            orderedStates[v] = states[v];
        }
    });
    return orderedStates;
}

function resolveVariants(config) {
    var _a, _b, _c, _d, _e;
    return {
        orientation: generateOrientations(((_b = (_a = config.theme) === null || _a === void 0 ? void 0 : _a.orientation) !== null && _b !== void 0 ? _b : {})),
        screen: generateScreens(((_d = (_c = config.theme) === null || _c === void 0 ? void 0 : _c.screens) !== null && _d !== void 0 ? _d : {})),
        theme: generateThemes(config.darkMode),
        state: generateStates((_e = config.variantOrder) !== null && _e !== void 0 ? _e : []),
    };
}

// (Last Update: Aug 22 2020) [https://github.com/sindresorhus/modern-normalize/blob/master/modern-normalize.css]
var preflights = [
    /*! modern-normalize v1.0.0 | MIT License | https://github.com/sindresorhus/modern-normalize */
    /*
  Document
  ========
  */
    /**
  Use a better box model (opinionated).
  */
    // {
    //   keys: ['*'],
    //   global: true,
    //   selector: '*, *::before, *::after',
    //   properties: {
    //     '-webkit-box-sizing': 'border-box',
    //     'box-sizing': 'border-box'
    //   }
    // },
    // overwrite by windi
    /**
  Use a more readable tab size (opinionated).
  */
    {
        keys: ['root'],
        global: true,
        selector: ':root',
        properties: {
            '-moz-tab-size': function (theme) { return theme('tabSize.DEFAULT', '4'); },
            '-o-tab-size': function (theme) { return theme('tabSize.DEFAULT', '4'); },
            'tab-size': function (theme) { return theme('tabSize.DEFAULT', '4'); },
        },
    },
    /**
  1. Correct the line height in all browsers.
  2. Prevent adjustments of font size after orientation changes in iOS.
  */
    {
        keys: ['html'],
        global: true,
        selector: 'html',
        properties: {
            // 'line-height': '1.15', /* 1 */ overwrite by windi
            '-webkit-text-size-adjust': '100%', /* 2 */
        },
    },
    /*
  Sections
  ========
  */
    /**
  Remove the margin in all browsers.
  */
    {
        keys: ['body'],
        global: true,
        selector: 'body',
        properties: {
            'margin': '0', /* 1 */
        },
    },
    /**
  Improve consistency of default fonts in all browsers. (https://github.com/sindresorhus/modern-normalize/issues/3)
  */
    // {
    //   keys: ['body'],
    //   global: true,
    //   selector: 'body',
    //   properties: {
    //     'font-family': "system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji'"
    //   }
    // },
    // overide by windi
    /*
  Grouping content
  ================
  */
    /**
  1. Add the correct height in Firefox.
  2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
  */
    {
        keys: ['hr'],
        properties: {
            'height': '0',
            'color': 'inherit', /* 2 */
        },
    },
    /*
  Text-level semantics
  ====================
  */
    /**
  Add the correct text decoration in Chrome, Edge, and Safari.
  */
    {
        keys: ['title'],
        global: true,
        selector: 'abbr[title]',
        properties: {
            '-webkit-text-decoration': 'underline dotted',
            'text-decoration': 'underline dotted',
        },
    },
    /**
  Add the correct font weight in Edge and Safari.
  */
    {
        keys: ['b', 'strong'],
        properties: {
            'font-weight': 'bolder',
        },
    },
    /**
  1. Improve consistency of default fonts in all browsers. (https://github.com/sindresorhus/modern-normalize/issues/3)
  2. Correct the odd 'em' font sizing in all browsers.
  */
    {
        keys: ['code', 'kbd', 'samp', 'pre'],
        properties: {
            // 'font-family': "ui-monospace, SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace", /* 1 */ overwrite by windi
            'font-size': '1em', /* 2 */
        },
    },
    /**
  Add the correct font size in all browsers.
  */
    {
        keys: ['small'],
        properties: {
            'font-size': '80%',
        },
    },
    /**
  Prevent 'sub' and 'sup' elements from affecting the line height in all browsers.
  */
    {
        keys: ['sub', 'sup'],
        properties: {
            'font-size': '75%',
            'line-height': '0',
            'position': 'relative',
            'vertical-align': 'baseline',
        },
    },
    {
        keys: ['sub'],
        properties: {
            'bottom': '-0.25em',
        },
    },
    {
        keys: ['sup'],
        properties: {
            'top': '-0.5em',
        },
    },
    /*
  Tabular data
  ============
  */
    /**
  1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
  2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
  */
    {
        keys: ['table'],
        properties: {
            'text-indent': '0',
            'border-color': 'inherit', /* 2 */
        },
    },
    /*
  Forms
  =====
  */
    /**
  1. Change the font styles in all browsers.
  2. Remove the margin in Firefox and Safari.
  */
    {
        keys: ['button', 'input', 'optgroup', 'select', 'textarea'],
        properties: {
            'font-family': 'inherit',
            'font-size': '100%',
            'line-height': '1.15',
            'margin': '0', /* 2 */
        },
    },
    /**
  Remove the inheritance of text transform in Edge and Firefox.
  1. Remove the inheritance of text transform in Firefox.
  */
    {
        keys: ['button', 'select'],
        properties: {
            'text-transform': 'none', /* 1 */
        },
    },
    /**
  Correct the inability to style clickable types in iOS and Safari.
  */
    {
        keys: ['button'],
        selector: 'button, [type=\'button\'], [type=\'reset\'], [type=\'submit\']',
        properties: {
            '-webkit-appearance': 'button', /* 1 */
        },
    },
    /**
  Remove the inner border and padding in Firefox.
  */
    {
        keys: ['inner'],
        global: true,
        selector: '::moz-focus-inner',
        properties: {
            'border-style': 'none',
            'padding': '0',
        },
    },
    /**
  Restore the focus styles unset by the previous rule.
  */
    {
        keys: ['focusring'],
        global: true,
        selector: ':-moz-focusring',
        properties: {
            'outline': '1px dotted ButtonText',
        },
    },
    /**
  Remove the additional ':invalid' styles in Firefox.
  See: https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737
  */
    {
        keys: ['invalid'],
        global: true,
        selector: ':-moz-ui-invalid',
        properties: {
            'box-shadow': 'none',
        },
    },
    /**
  Remove the padding so developers are not caught out when they zero out 'fieldset' elements in all browsers.
  */
    {
        keys: ['legend'],
        properties: {
            'padding': '0',
        },
    },
    /**
  Add the correct vertical alignment in Chrome and Firefox.
  */
    {
        keys: ['progress'],
        properties: {
            'vertical-align': 'baseline',
        },
    },
    /**
  Correct the cursor style of increment and decrement buttons in Safari.
  */
    {
        keys: ['spin'],
        global: true,
        selector: '::-webkit-inner-spin-button, ::-webkit-outer-spin-button',
        properties: {
            'height': 'auto',
        },
    },
    /**
  1. Correct the odd appearance in Chrome and Safari.
  2. Correct the outline style in Safari.
  */
    {
        keys: ['search'],
        global: true,
        selector: '[type=\'search\']',
        properties: {
            '-webkit-appearance': 'textfield',
            'outline-offset': '-2px', /* 2 */
        },
    },
    /**
  Remove the inner padding in Chrome and Safari on macOS.
  */
    {
        keys: ['search'],
        global: true,
        selector: '::-webkit-search-decoration',
        properties: {
            '-webkit-appearance': 'none',
        },
    },
    /**
  1. Correct the inability to style clickable types in iOS and Safari.
  2. Change font properties to 'inherit' in Safari.
  */
    {
        keys: ['file'],
        global: true,
        selector: '::-webkit-file-upload-button',
        properties: {
            '-webkit-appearance': 'button',
            'font': 'inherit',
        },
    },
    /*
  Interactive
  ===========
  */
    /*
  Add the correct display in Chrome and Safari.
  */
    {
        keys: ['summary'],
        properties: {
            'display': 'list-item',
        },
    },
    /**
   * Manually forked from SUIT CSS Base: https://github.com/suitcss/base
   * A thin layer on top of normalize.css that provides a starting point more
   * suitable for web applications.
   */
    /**
   * Removes the default spacing and border for appropriate elements.
   */
    {
        keys: ['blockquote', 'dl', 'dd', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'figure', 'p', 'pre'],
        properties: {
            'margin': '0',
        },
    },
    {
        keys: ['button'],
        properties: {
            'background-color': 'transparent',
            'background-image': 'none'
        },
    },
    /**
   * Work around a Firefox/IE bug where the transparent `button` background
   * results in a loss of the default `button` focus styles.
   */
    {
        keys: ['fieldset'],
        properties: {
            'margin': '0',
            'padding': '0',
        },
    },
    {
        keys: ['ol', 'ul'],
        properties: {
            'list-style': 'none',
            'margin': '0',
            'padding': '0',
        },
    },
    /**
   * Tailwind custom reset styles
   */
    /**
   * 1. Use the user's configured `sans` font-family (with Tailwind's default
   *    sans-serif font stack as a fallback) as a sane default.
   * 2. Use Tailwind's default "normal" line-height so the user isn't forced
   *    to override it to ensure consistency even when using the default theme.
   */
    {
        keys: ['html'],
        global: true,
        selector: 'html',
        properties: {
            'font-family': function (theme) { return theme('fontFamily.sans', 'ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"'); },
            'line-height': '1.5', /* 2 */
        },
    },
    /**
   * Inherit font-family and line-height from `html` so users can set them as
   * a class directly on the `html` element.
   */
    {
        keys: ['body'],
        global: true,
        selector: 'body',
        properties: {
            'font-family': 'inherit',
            'line-height': 'inherit',
        },
    },
    /**
   * 1. Prevent padding and border from affecting element width.
   *
   *    We used to set this in the html element and inherit from
   *    the parent element for everything else. This caused issues
   *    in shadow-dom-enhanced elements like <details> where the content
   *    is wrapped by a div with box-sizing set to `content-box`.
   *
   *    https://github.com/mozdevs/cssremedy/issues/4
   *
   *
   * 2. Allow adding a border to an element by just adding a border-width.
   *
   *    By default, the way the browser specifies that an element should have no
   *    border is by setting it's border-style to `none` in the user-agent
   *    stylesheet.
   *
   *    In order to easily add borders to elements by just setting the `border-width`
   *    property, we change the default border-style for all elements to `solid`, and
   *    use border-width to hide them instead. This way our `border` utilities only
   *    need to set the `border-width` property instead of the entire `border`
   *    shorthand, making our border utilities much more straightforward to compose.
   *
   */
    {
        keys: ['*'],
        global: true,
        selector: '*, ::before, ::after',
        properties: {
            '-webkit-box-sizing': 'border-box',
            'box-sizing': 'border-box',
            'border-width': '0',
            'border-style': 'solid',
            'border-color': function (theme) { return theme('borderColor.DEFAULT', 'currentColor'); },
        },
    },
    /*
   * Ensure horizontal rules are visible by default
   */
    {
        keys: ['hr'],
        properties: {
            'border-top-width': '1px',
        },
    },
    /**
   * Undo the `border-style: none` reset that Normalize applies to images so that
   * our `border-{width}` utilities have the expected effect.
   *
   * The Normalize reset is unnecessary for us since we default the border-width
   * to 0 on all elements.
   *
   */
    {
        keys: ['img'],
        properties: {
            'border-style': 'solid',
        },
    },
    {
        keys: ['textarea'],
        properties: {
            'resize': 'vertical',
        },
    },
    // input::placeholder,
    // textarea::placeholder {
    //   color: theme('colors.gray.400', #a1a1aa);
    // }
    // support prefixer
    {
        keys: ['input'],
        selector: 'input::placeholder',
        properties: {
            'opacity': '1',
            'color': function (theme) { return theme('colors.gray.400', '#a1a1aa'); },
        },
    },
    {
        keys: ['input'],
        selector: 'input::webkit-input-placeholder',
        properties: {
            'opacity': '1',
            'color': function (theme) { return theme('colors.gray.400', '#a1a1aa'); },
        },
    },
    {
        keys: ['input'],
        selector: 'input::-moz-placeholder',
        properties: {
            'opacity': '1',
            'color': function (theme) { return theme('colors.gray.400', '#a1a1aa'); },
        },
    },
    {
        keys: ['input'],
        selector: 'input:-ms-input-placeholder',
        properties: {
            'opacity': '1',
            'color': function (theme) { return theme('colors.gray.400', '#a1a1aa'); },
        },
    },
    {
        keys: ['input'],
        selector: 'input::-ms-input-placeholder',
        properties: {
            'opacity': '1',
            'color': function (theme) { return theme('colors.gray.400', '#a1a1aa'); },
        },
    },
    {
        keys: ['textarea'],
        selector: 'textarea::placeholder',
        properties: {
            'opacity': '1',
            'color': function (theme) { return theme('colors.gray.400', '#a1a1aa'); },
        },
    },
    {
        keys: ['textarea'],
        selector: 'textarea::webkit-input-placeholder',
        properties: {
            'opacity': '1',
            'color': function (theme) { return theme('colors.gray.400', '#a1a1aa'); },
        },
    },
    {
        keys: ['textarea'],
        selector: 'textarea::-moz-placeholder',
        properties: {
            'opacity': '1',
            'color': function (theme) { return theme('colors.gray.400', '#a1a1aa'); },
        },
    },
    {
        keys: ['textarea'],
        selector: 'textarea:-ms-input-placeholder',
        properties: {
            'opacity': '1',
            'color': function (theme) { return theme('colors.gray.400', '#a1a1aa'); },
        },
    },
    {
        keys: ['textarea'],
        selector: 'textarea::-ms-input-placeholder',
        properties: {
            'opacity': '1',
            'color': function (theme) { return theme('colors.gray.400', '#a1a1aa'); },
        },
    },
    {
        keys: ['button'],
        selector: 'button, [role="button"]',
        properties: {
            'cursor': 'pointer',
        },
    },
    {
        keys: ['table'],
        properties: {
            'border-collapse': 'collapse',
        },
    },
    {
        keys: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
        properties: {
            'font-size': 'inherit',
            'font-weight': 'inherit',
        },
    },
    /**
   * Reset links to optimize for opt-in styling instead of
   * opt-out.
   */
    {
        keys: ['a'],
        properties: {
            'color': 'inherit',
            'text-decoration': 'inherit',
        },
    },
    /**
   * Reset form element properties that are easy to forget to
   * style explicitly so you don't inadvertently introduce
   * styles that deviate from your design system. These styles
   * supplement a partial reset that is already applied by
   * normalize.css.
   */
    {
        keys: ['button', 'input', 'optgroup', 'select', 'textarea'],
        properties: {
            'padding': '0',
            'line-height': 'inherit',
            'color': 'inherit',
        },
    },
    /**
   * Use the configured 'mono' font family for elements that
   * are expected to be rendered with a monospace font, falling
   * back to the system monospace stack if there is no configured
   * 'mono' font family.
   */
    {
        keys: ['pre', 'code', 'kbd', 'samp'],
        properties: {
            'font-family': function (theme) { return theme('fontFamily.mono', 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace'); },
        },
    },
    /**
   * Make replaced elements `display: block` by default as that's
   * the behavior you want almost all of the time. Inspired by
   * CSS Remedy, with `svg` added as well.
   *
   * https://github.com/mozdevs/cssremedy/issues/14
   */
    {
        keys: ['img', 'svg', 'video', 'canvas', 'audio', 'iframe', 'embed', 'object'],
        properties: {
            'display': 'block',
            'vertical-align': 'middle',
        },
    },
    /**
   * Constrain images and videos to the parent width and preserve
   * their instrinsic aspect ratio.
   *
   * https://github.com/mozdevs/cssremedy/issues/14
   */
    {
        keys: ['img', 'video'],
        properties: {
            'max-width': '100%',
            'height': 'auto',
        },
    },
    // added by ringWidth
    // https://windicss.org/utilities/borders.html#ring-width
    {
        keys: ['*'],
        global: true,
        selector: '*',
        properties: {
            '--tw-ring-inset': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-ring-offset-width': function (theme) { return theme('ringOffsetWidth.DEFAULT', '0px'); },
            '--tw-ring-offset-color': function (theme) { return theme('ringOffsetColor.DEFAULT', '#fff'); },
            '--tw-ring-color': function (theme) { var _a; return "rgba(".concat((_a = hex2RGB$1(theme('ringColor.DEFAULT', '#93C5FD'))) === null || _a === void 0 ? void 0 : _a.join(', '), ", ").concat(theme('ringOpacity.DEFAULT', '0.5'), ")"); },
            '--tw-ring-offset-shadow': '0 0 #0000',
            '--tw-ring-shadow': '0 0 #0000',
        },
    },
    // added by boxShadow
    // https://windicss.org/utilities/effects.html#box-shadow
    {
        keys: ['*'],
        global: true,
        selector: '*',
        properties: {
            '--tw-shadow': '0 0 #0000',
        },
    },
];

var fontVariants = {
    '--tw-ordinal': 'var(--tw-empty,/*!*/ /*!*/)',
    '--tw-slashed-zero': 'var(--tw-empty,/*!*/ /*!*/)',
    '--tw-numeric-figure': 'var(--tw-empty,/*!*/ /*!*/)',
    '--tw-numeric-spacing': 'var(--tw-empty,/*!*/ /*!*/)',
    '--tw-numeric-fraction': 'var(--tw-empty,/*!*/ /*!*/)',
    'font-variant-numeric': 'var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)',
};
var staticUtilities$1 = {
    // https://windicss.org/utilities/behaviors.html#box-decoration-break
    'decoration-slice': {
        'utility': {
            '-webkit-box-decoration-break': 'slice',
            'box-decoration-break': 'slice',
        },
        'meta': {
            'group': 'boxDecorationBreak',
            'order': 1,
        },
    },
    'decoration-clone': {
        'utility': {
            '-webkit-box-decoration-break': 'clone',
            'box-decoration-break': 'clone',
        },
        'meta': {
            'group': 'boxDecorationBreak',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/flexbox.html#flex-basis
    'basis-auto': {
        'utility': {
            'flex-basis': 'auto',
        },
        'meta': {
            'group': 'flexBasis',
            'order': 1,
        },
    },
    'basis-full': {
        'utility': {
            'flex-basis': '100%',
        },
        'meta': {
            'group': 'flexBasis',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/sizing.html#box-sizing
    'box-border': {
        'utility': {
            '-webkit-box-sizing': 'border-box',
            'box-sizing': 'border-box',
        },
        'meta': {
            'group': 'boxSizing',
            'order': 1,
        },
    },
    'box-content': {
        'utility': {
            '-webkit-box-sizing': 'content-box',
            'box-sizing': 'content-box',
        },
        'meta': {
            'group': 'boxSizing',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/display.html
    'block': {
        'utility': {
            'display': 'block',
        },
        'meta': {
            'group': 'display',
            'order': 1,
        },
    },
    'inline-block': {
        'utility': {
            'display': 'inline-block',
        },
        'meta': {
            'group': 'display',
            'order': 2,
        },
    },
    'inline': {
        'utility': {
            'display': 'inline',
        },
        'meta': {
            'group': 'display',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/flexbox.html
    'flex': {
        'utility': {
            'display': [
                '-webkit-box',
                '-ms-flexbox',
                '-webkit-flex',
                'flex',
            ],
        },
        'meta': {
            'group': 'display',
            'order': 4,
        },
    },
    'inline-flex': {
        'utility': {
            'display': [
                '-webkit-inline-box',
                '-ms-inline-flexbox',
                '-webkit-inline-flex',
                'inline-flex',
            ],
        },
        'meta': {
            'group': 'display',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/tables.html
    'table': {
        'utility': {
            'display': 'table',
        },
        'meta': {
            'group': 'display',
            'order': 6,
        },
    },
    'inline-table': {
        'utility': {
            'display': 'inline-table',
        },
        'meta': {
            'group': 'display',
            'order': 7,
        },
    },
    'table-caption': {
        'utility': {
            'display': 'table-caption',
        },
        'meta': {
            'group': 'display',
            'order': 8,
        },
    },
    'table-cell': {
        'utility': {
            'display': 'table-cell',
        },
        'meta': {
            'group': 'display',
            'order': 9,
        },
    },
    'table-column': {
        'utility': {
            'display': 'table-column',
        },
        'meta': {
            'group': 'display',
            'order': 10,
        },
    },
    'table-column-group': {
        'utility': {
            'display': 'table-column-group',
        },
        'meta': {
            'group': 'display',
            'order': 11,
        },
    },
    'table-footer-group': {
        'utility': {
            'display': 'table-footer-group',
        },
        'meta': {
            'group': 'display',
            'order': 12,
        },
    },
    'table-header-group': {
        'utility': {
            'display': 'table-header-group',
        },
        'meta': {
            'group': 'display',
            'order': 13,
        },
    },
    'table-row-group': {
        'utility': {
            'display': 'table-row-group',
        },
        'meta': {
            'group': 'display',
            'order': 14,
        },
    },
    'table-row': {
        'utility': {
            'display': 'table-row',
        },
        'meta': {
            'group': 'display',
            'order': 15,
        },
    },
    'flow-root': {
        'utility': {
            'display': 'flow-root',
        },
        'meta': {
            'group': 'display',
            'order': 16,
        },
    },
    // https://windicss.org/utilities/grid.html
    'grid': {
        'utility': {
            'display': [
                '-ms-grid',
                'grid',
            ],
        },
        'meta': {
            'group': 'display',
            'order': 17,
        },
    },
    'inline-grid': {
        'utility': {
            'display': [
                '-ms-inline-grid',
                'inline-grid',
            ],
        },
        'meta': {
            'group': 'display',
            'order': 18,
        },
    },
    'contents': {
        'utility': {
            'display': 'contents',
        },
        'meta': {
            'group': 'display',
            'order': 19,
        },
    },
    'list-item': {
        'utility': {
            'display': 'list-item',
        },
        'meta': {
            'group': 'display',
            'order': 20,
        },
    },
    'hidden': {
        'utility': {
            'display': 'none',
        },
        'meta': {
            'group': 'display',
            'order': 21,
        },
    },
    // https://windicss.org/utilities/columns.html
    'break-after-auto': {
        'utility': {
            'break-after': 'auto',
        },
        'meta': {
            'group': 'columns',
            'order': 1,
        },
    },
    'break-after-avoid': {
        'utility': {
            'break-after': 'avoid',
        },
        'meta': {
            'group': 'columns',
            'order': 2,
        },
    },
    'break-after-all': {
        'utility': {
            'break-after': 'all',
        },
        'meta': {
            'group': 'columns',
            'order': 3,
        },
    },
    'break-after-avoid-page': {
        'utility': {
            'break-after': 'avoid-page',
        },
        'meta': {
            'group': 'columns',
            'order': 4,
        },
    },
    'break-after-page': {
        'utility': {
            'break-after': 'page',
        },
        'meta': {
            'group': 'columns',
            'order': 5,
        },
    },
    'break-after-left': {
        'utility': {
            'break-after': 'left',
        },
        'meta': {
            'group': 'columns',
            'order': 6,
        },
    },
    'break-after-right': {
        'utility': {
            'break-after': 'right',
        },
        'meta': {
            'group': 'columns',
            'order': 7,
        },
    },
    'break-after-column': {
        'utility': {
            'break-after': 'column',
        },
        'meta': {
            'group': 'columns',
            'order': 8,
        },
    },
    'break-before-auto': {
        'utility': {
            'break-before': 'auto',
        },
        'meta': {
            'group': 'columns',
            'order': 9,
        },
    },
    'break-before-avoid': {
        'utility': {
            'break-before': 'avoid',
        },
        'meta': {
            'group': 'columns',
            'order': 10,
        },
    },
    'break-before-all': {
        'utility': {
            'break-before': 'all',
        },
        'meta': {
            'group': 'columns',
            'order': 11,
        },
    },
    'break-before-avoid-page': {
        'utility': {
            'break-before': 'avoid-page',
        },
        'meta': {
            'group': 'columns',
            'order': 12,
        },
    },
    'break-before-page': {
        'utility': {
            'break-before': 'page',
        },
        'meta': {
            'group': 'columns',
            'order': 13,
        },
    },
    'break-before-left': {
        'utility': {
            'break-before': 'left',
        },
        'meta': {
            'group': 'columns',
            'order': 14,
        },
    },
    'break-before-right': {
        'utility': {
            'break-before': 'right',
        },
        'meta': {
            'group': 'columns',
            'order': 15,
        },
    },
    'break-before-column': {
        'utility': {
            'break-before': 'column',
        },
        'meta': {
            'group': 'columns',
            'order': 16,
        },
    },
    'break-inside-auto': {
        'utility': {
            'break-inside': 'auto',
        },
        'meta': {
            'group': 'columns',
            'order': 17,
        },
    },
    'break-inside-avoid': {
        'utility': {
            'break-inside': 'avoid',
        },
        'meta': {
            'group': 'columns',
            'order': 18,
        },
    },
    'break-inside-avoid-page': {
        'utility': {
            'break-inside': 'avoid-page',
        },
        'meta': {
            'group': 'columns',
            'order': 19,
        },
    },
    'break-inside-avoid-column': {
        'utility': {
            'break-inside': 'avoid-column',
        },
        'meta': {
            'group': 'columns',
            'order': 20,
        },
    },
    // https://windicss.org/utilities/positioning.html#floats
    'float-right': {
        'utility': {
            'float': 'right',
        },
        'meta': {
            'group': 'float',
            'order': 1,
        },
    },
    'float-left': {
        'utility': {
            'float': 'left',
        },
        'meta': {
            'group': 'float',
            'order': 2,
        },
    },
    'float-none': {
        'utility': {
            'float': 'none',
        },
        'meta': {
            'group': 'float',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/positioning.html#clear
    'clear-left': {
        'utility': {
            'clear': 'left',
        },
        'meta': {
            'group': 'clear',
            'order': 1,
        },
    },
    'clear-right': {
        'utility': {
            'clear': 'right',
        },
        'meta': {
            'group': 'clear',
            'order': 2,
        },
    },
    'clear-both': {
        'utility': {
            'clear': 'both',
        },
        'meta': {
            'group': 'clear',
            'order': 3,
        },
    },
    'clear-none': {
        'utility': {
            'clear': 'none',
        },
        'meta': {
            'group': 'clear',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/positioning.html#isolation
    'isolate': {
        'utility': {
            'isolation': 'isolate',
        },
        'meta': {
            'group': 'isolation',
            'order': 1,
        },
    },
    'isolation-auto': {
        'utility': {
            'isolation': 'auto',
        },
        'meta': {
            'group': 'isolation',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/positioning.html#object-fit
    'object-contain': {
        'utility': {
            '-o-object-fit': 'contain',
            'object-fit': 'contain',
        },
        'meta': {
            'group': 'objectFit',
            'order': 1,
        },
    },
    'object-cover': {
        'utility': {
            '-o-object-fit': 'cover',
            'object-fit': 'cover',
        },
        'meta': {
            'group': 'objectFit',
            'order': 2,
        },
    },
    'object-fill': {
        'utility': {
            '-o-object-fit': 'fill',
            'object-fit': 'fill',
        },
        'meta': {
            'group': 'objectFit',
            'order': 3,
        },
    },
    'object-none': {
        'utility': {
            '-o-object-fit': 'none',
            'object-fit': 'none',
        },
        'meta': {
            'group': 'objectFit',
            'order': 4,
        },
    },
    'object-scale-down': {
        'utility': {
            '-o-object-fit': 'scale-down',
            'object-fit': 'scale-down',
        },
        'meta': {
            'group': 'objectFit',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/behaviors.html#overflow
    'overflow-auto': {
        'utility': {
            'overflow': 'auto',
        },
        'meta': {
            'group': 'overflow',
            'order': 1,
        },
    },
    'overflow-hidden': {
        'utility': {
            'overflow': 'hidden',
        },
        'meta': {
            'group': 'overflow',
            'order': 2,
        },
    },
    'overflow-clip': {
        'utility': {
            'overflow': 'clip',
        },
        'meta': {
            'group': 'overflow',
            'order': 3,
        },
    },
    'overflow-visible': {
        'utility': {
            'overflow': 'visible',
        },
        'meta': {
            'group': 'overflow',
            'order': 4,
        },
    },
    'overflow-scroll': {
        'utility': {
            'overflow': 'scroll',
        },
        'meta': {
            'group': 'overflow',
            'order': 5,
        },
    },
    'overflow-x-auto': {
        'utility': {
            'overflow-x': 'auto',
        },
        'meta': {
            'group': 'overflow',
            'order': 6,
        },
    },
    'overflow-y-auto': {
        'utility': {
            'overflow-y': 'auto',
        },
        'meta': {
            'group': 'overflow',
            'order': 7,
        },
    },
    'overflow-x-hidden': {
        'utility': {
            'overflow-x': 'hidden',
        },
        'meta': {
            'group': 'overflow',
            'order': 8,
        },
    },
    'overflow-y-hidden': {
        'utility': {
            'overflow-y': 'hidden',
        },
        'meta': {
            'group': 'overflow',
            'order': 9,
        },
    },
    'overflow-x-clip': {
        'utility': {
            'overflow-x': 'clip',
        },
        'meta': {
            'group': 'overflow',
            'order': 10,
        },
    },
    'overflow-y-clip': {
        'utility': {
            'overflow-y': 'clip',
        },
        'meta': {
            'group': 'overflow',
            'order': 11,
        },
    },
    'overflow-x-visible': {
        'utility': {
            'overflow-x': 'visible',
        },
        'meta': {
            'group': 'overflow',
            'order': 12,
        },
    },
    'overflow-y-visible': {
        'utility': {
            'overflow-y': 'visible',
        },
        'meta': {
            'group': 'overflow',
            'order': 13,
        },
    },
    'overflow-x-scroll': {
        'utility': {
            'overflow-x': 'scroll',
        },
        'meta': {
            'group': 'overflow',
            'order': 14,
        },
    },
    'overflow-y-scroll': {
        'utility': {
            'overflow-y': 'scroll',
        },
        'meta': {
            'group': 'overflow',
            'order': 15,
        },
    },
    // https://windicss.org/utilities/behaviors.html#overscroll-behavior
    'overscroll-auto': {
        'utility': {
            'overscroll-behavior': 'auto',
            '-ms-scroll-chaining': 'chained',
        },
        'meta': {
            'group': 'overscrollBehavior',
            'order': 1,
        },
    },
    'overscroll-contain': {
        'utility': {
            'overscroll-behavior': 'contain',
            '-ms-scroll-chaining': 'none',
        },
        'meta': {
            'group': 'overscrollBehavior',
            'order': 2,
        },
    },
    'overscroll-none': {
        'utility': {
            'overscroll-behavior': 'none',
            '-ms-scroll-chaining': 'none',
        },
        'meta': {
            'group': 'overscrollBehavior',
            'order': 3,
        },
    },
    'overscroll-y-auto': {
        'utility': {
            'overscroll-behavior-y': 'auto',
        },
        'meta': {
            'group': 'overscrollBehavior',
            'order': 4,
        },
    },
    'overscroll-y-contain': {
        'utility': {
            'overscroll-behavior-y': 'contain',
        },
        'meta': {
            'group': 'overscrollBehavior',
            'order': 5,
        },
    },
    'overscroll-y-none': {
        'utility': {
            'overscroll-behavior-y': 'none',
        },
        'meta': {
            'group': 'overscrollBehavior',
            'order': 6,
        },
    },
    'overscroll-x-auto': {
        'utility': {
            'overscroll-behavior-x': 'auto',
        },
        'meta': {
            'group': 'overscrollBehavior',
            'order': 7,
        },
    },
    'overscroll-x-contain': {
        'utility': {
            'overscroll-behavior-x': 'contain',
        },
        'meta': {
            'group': 'overscrollBehavior',
            'order': 8,
        },
    },
    'overscroll-x-none': {
        'utility': {
            'overscroll-behavior-x': 'none',
        },
        'meta': {
            'group': 'overscrollBehavior',
            'order': 9,
        },
    },
    // https://windicss.org/utilities/positioning.html#position
    'static': {
        'utility': {
            'position': 'static',
        },
        'meta': {
            'group': 'position',
            'order': 1,
        },
    },
    'fixed': {
        'utility': {
            'position': 'fixed',
        },
        'meta': {
            'group': 'position',
            'order': 2,
        },
    },
    'absolute': {
        'utility': {
            'position': 'absolute',
        },
        'meta': {
            'group': 'position',
            'order': 3,
        },
    },
    'relative': {
        'utility': {
            'position': 'relative',
        },
        'meta': {
            'group': 'position',
            'order': 4,
        },
    },
    'sticky': {
        'utility': {
            'position': [
                '-webkit-sticky',
                'sticky',
            ],
        },
        'meta': {
            'group': 'position',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/display.html#visibility
    'visible': {
        'utility': {
            'visibility': 'visible',
        },
        'meta': {
            'group': 'visibility',
            'order': 1,
        },
    },
    'invisible': {
        'utility': {
            'visibility': 'hidden',
        },
        'meta': {
            'group': 'visibility',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/display.html#backface-visibility
    'backface-visible': {
        'utility': {
            '-webkit-backface-visibility': 'visible',
            'backface-visibility': 'visible',
        },
        'meta': {
            'group': 'backfaceVisibility',
            'order': 1,
        },
    },
    'backface-hidden': {
        'utility': {
            '-webkit-backface-visibility': 'hidden',
            'backface-visibility': 'hidden',
        },
        'meta': {
            'group': 'backfaceVisibility',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/flexbox.html#flex-direction
    'flex-row': {
        'utility': {
            '-webkit-box-orient': 'horizontal',
            '-webkit-box-direction': 'normal',
            '-ms-flex-direction': 'row',
            '-webkit-flex-direction': 'row',
            'flex-direction': 'row',
        },
        'meta': {
            'group': 'flexDirection',
            'order': 1,
        },
    },
    'flex-row-reverse': {
        'utility': {
            '-webkit-box-orient': 'horizontal',
            '-webkit-box-direction': 'reverse',
            '-ms-flex-direction': 'row-reverse',
            '-webkit-flex-direction': 'row-reverse',
            'flex-direction': 'row-reverse',
        },
        'meta': {
            'group': 'flexDirection',
            'order': 2,
        },
    },
    'flex-col': {
        'utility': {
            '-webkit-box-orient': 'vertical',
            '-webkit-box-direction': 'normal',
            '-ms-flex-direction': 'column',
            '-webkit-flex-direction': 'column',
            'flex-direction': 'column',
        },
        'meta': {
            'group': 'flexDirection',
            'order': 3,
        },
    },
    'flex-col-reverse': {
        'utility': {
            '-webkit-box-orient': 'vertical',
            '-webkit-box-direction': 'reverse',
            '-ms-flex-direction': 'column-reverse',
            '-webkit-flex-direction': 'column-reverse',
            'flex-direction': 'column-reverse',
        },
        'meta': {
            'group': 'flexDirection',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/flexbox.html#flex-wrap
    'flex-wrap': {
        'utility': {
            '-ms-flex-wrap': 'wrap',
            '-webkit-flex-wrap': 'wrap',
            'flex-wrap': 'wrap',
        },
        'meta': {
            'group': 'flexWrap',
            'order': 1,
        },
    },
    'flex-wrap-reverse': {
        'utility': {
            '-ms-flex-wrap': 'wrap-reverse',
            '-webkit-flex-wrap': 'wrap-reverse',
            'flex-wrap': 'wrap-reverse',
        },
        'meta': {
            'group': 'flexWrap',
            'order': 2,
        },
    },
    'flex-nowrap': {
        'utility': {
            '-ms-flex-wrap': 'nowrap',
            '-webkit-flex-wrap': 'nowrap',
            'flex-wrap': 'nowrap',
        },
        'meta': {
            'group': 'flexWrap',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/grid.html#grid-column-span
    'col-auto': {
        'utility': {
            'grid-column': 'auto',
        },
        'meta': {
            'group': 'gridColumn',
            'order': 1,
        },
    },
    // https://windicss.org/utilities/grid.html#grid-row-span
    'row-auto': {
        'utility': {
            'grid-row': 'auto',
        },
        'meta': {
            'group': 'gridRow',
            'order': 1,
        },
    },
    // https://windicss.org/utilities/grid.html#grid-auto-flow
    'grid-flow-row': {
        'utility': {
            'grid-auto-flow': 'row',
        },
        'meta': {
            'group': 'gridAutoFlow',
            'order': 1,
        },
    },
    'grid-flow-col': {
        'utility': {
            'grid-auto-flow': 'column',
        },
        'meta': {
            'group': 'gridAutoFlow',
            'order': 2,
        },
    },
    'grid-flow-row-dense': {
        'utility': {
            'grid-auto-flow': 'row dense',
        },
        'meta': {
            'group': 'gridAutoFlow',
            'order': 3,
        },
    },
    'grid-flow-col-dense': {
        'utility': {
            'grid-auto-flow': 'column dense',
        },
        'meta': {
            'group': 'gridAutoFlow',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/positioning.html#justify-content
    'justify-start': {
        'utility': {
            '-webkit-box-pack': 'start',
            '-ms-flex-pack': 'start',
            '-webkit-justify-content': 'flex-start',
            'justify-content': 'flex-start',
        },
        'meta': {
            'group': 'justifyContent',
            'order': 1,
        },
    },
    'justify-end': {
        'utility': {
            '-webkit-box-pack': 'end',
            '-ms-flex-pack': 'end',
            '-webkit-justify-content': 'flex-end',
            'justify-content': 'flex-end',
        },
        'meta': {
            'group': 'justifyContent',
            'order': 2,
        },
    },
    'justify-center': {
        'utility': {
            '-webkit-box-pack': 'center',
            '-ms-flex-pack': 'center',
            '-webkit-justify-content': 'center',
            'justify-content': 'center',
        },
        'meta': {
            'group': 'justifyContent',
            'order': 3,
        },
    },
    'justify-between': {
        'utility': {
            '-webkit-box-pack': 'justify',
            '-ms-flex-pack': 'justify',
            '-webkit-justify-content': 'space-between',
            'justify-content': 'space-between',
        },
        'meta': {
            'group': 'justifyContent',
            'order': 4,
        },
    },
    'justify-around': {
        'utility': {
            '-ms-flex-pack': 'distribute',
            '-webkit-justify-content': 'space-around',
            'justify-content': 'space-around',
        },
        'meta': {
            'group': 'justifyContent',
            'order': 5,
        },
    },
    'justify-evenly': {
        'utility': {
            '-webkit-box-pack': 'space-evenly',
            '-ms-flex-pack': 'space-evenly',
            '-webkit-justify-content': 'space-evenly',
            'justify-content': 'space-evenly',
        },
        'meta': {
            'group': 'justifyContent',
            'order': 6,
        },
    },
    // https://windicss.org/utilities/positioning.html#justify-items
    'justify-items-auto': {
        'utility': {
            'justify-items': 'auto',
        },
        'meta': {
            'group': 'justifyItems',
            'order': 1,
        },
    },
    'justify-items-start': {
        'utility': {
            'justify-items': 'start',
        },
        'meta': {
            'group': 'justifyItems',
            'order': 2,
        },
    },
    'justify-items-end': {
        'utility': {
            'justify-items': 'end',
        },
        'meta': {
            'group': 'justifyItems',
            'order': 3,
        },
    },
    'justify-items-center': {
        'utility': {
            'justify-items': 'center',
        },
        'meta': {
            'group': 'justifyItems',
            'order': 4,
        },
    },
    'justify-items-stretch': {
        'utility': {
            'justify-items': 'stretch',
        },
        'meta': {
            'group': 'justifyItems',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/positioning.html#justify-self
    'justify-self-auto': {
        'utility': {
            '-ms-grid-column-align': 'auto',
            'justify-self': 'auto',
        },
        'meta': {
            'group': 'justifySelf',
            'order': 1,
        },
    },
    'justify-self-start': {
        'utility': {
            '-ms-grid-column-align': 'start',
            'justify-self': 'start',
        },
        'meta': {
            'group': 'justifySelf',
            'order': 2,
        },
    },
    'justify-self-end': {
        'utility': {
            '-ms-grid-column-align': 'end',
            'justify-self': 'end',
        },
        'meta': {
            'group': 'justifySelf',
            'order': 3,
        },
    },
    'justify-self-center': {
        'utility': {
            '-ms-grid-column-align': 'center',
            'justify-self': 'center',
        },
        'meta': {
            'group': 'justifySelf',
            'order': 4,
        },
    },
    'justify-self-stretch': {
        'utility': {
            '-ms-grid-column-align': 'stretch',
            'justify-self': 'stretch',
        },
        'meta': {
            'group': 'justifySelf',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/positioning.html#align-content
    'content-center': {
        'utility': {
            '-ms-flex-line-pack': 'center',
            '-webkit-align-content': 'center',
            'align-content': 'center',
        },
        'meta': {
            'group': 'alignContent',
            'order': 1,
        },
    },
    'content-start': {
        'utility': {
            '-ms-flex-line-pack': 'start',
            '-webkit-align-content': 'flex-start',
            'align-content': 'flex-start',
        },
        'meta': {
            'group': 'alignContent',
            'order': 2,
        },
    },
    'content-end': {
        'utility': {
            '-ms-flex-line-pack': 'end',
            '-webkit-align-content': 'flex-end',
            'align-content': 'flex-end',
        },
        'meta': {
            'group': 'alignContent',
            'order': 3,
        },
    },
    'content-between': {
        'utility': {
            '-ms-flex-line-pack': 'justify',
            '-webkit-align-content': 'space-between',
            'align-content': 'space-between',
        },
        'meta': {
            'group': 'alignContent',
            'order': 4,
        },
    },
    'content-around': {
        'utility': {
            '-ms-flex-line-pack': 'distribute',
            '-webkit-align-content': 'space-around',
            'align-content': 'space-around',
        },
        'meta': {
            'group': 'alignContent',
            'order': 5,
        },
    },
    'content-evenly': {
        'utility': {
            '-ms-flex-line-pack': 'space-evenly',
            '-webkit-align-content': 'space-evenly',
            'align-content': 'space-evenly',
        },
        'meta': {
            'group': 'alignContent',
            'order': 6,
        },
    },
    // https://windicss.org/utilities/positioning.html#align-items
    'items-start': {
        'utility': {
            '-webkit-box-align': 'start',
            '-ms-flex-align': 'start',
            '-webkit-align-items': 'flex-start',
            'align-items': 'flex-start',
        },
        'meta': {
            'group': 'alignItems',
            'order': 1,
        },
    },
    'items-end': {
        'utility': {
            '-webkit-box-align': 'end',
            '-ms-flex-align': 'end',
            '-webkit-align-items': 'flex-end',
            'align-items': 'flex-end',
        },
        'meta': {
            'group': 'alignItems',
            'order': 2,
        },
    },
    'items-center': {
        'utility': {
            '-webkit-box-align': 'center',
            '-ms-flex-align': 'center',
            '-webkit-align-items': 'center',
            'align-items': 'center',
        },
        'meta': {
            'group': 'alignItems',
            'order': 3,
        },
    },
    'items-baseline': {
        'utility': {
            '-webkit-box-align': 'baseline',
            '-ms-flex-align': 'baseline',
            '-webkit-align-items': 'baseline',
            'align-items': 'baseline',
        },
        'meta': {
            'group': 'alignItems',
            'order': 4,
        },
    },
    'items-stretch': {
        'utility': {
            '-webkit-box-align': 'stretch',
            '-ms-flex-align': 'stretch',
            '-webkit-align-items': 'stretch',
            'align-items': 'stretch',
        },
        'meta': {
            'group': 'alignItems',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/positioning.html#align-self
    'self-auto': {
        'utility': {
            '-ms-flex-item-align': 'auto',
            '-ms-grid-row-align': 'auto',
            '-webkit-align-self': 'auto',
            'align-self': 'auto',
        },
        'meta': {
            'group': 'alignSelf',
            'order': 1,
        },
    },
    'self-start': {
        'utility': {
            '-ms-flex-item-align': 'start',
            '-webkit-align-self': 'flex-start',
            'align-self': 'flex-start',
        },
        'meta': {
            'group': 'alignSelf',
            'order': 2,
        },
    },
    'self-end': {
        'utility': {
            '-ms-flex-item-align': 'end',
            '-webkit-align-self': 'flex-end',
            'align-self': 'flex-end',
        },
        'meta': {
            'group': 'alignSelf',
            'order': 3,
        },
    },
    'self-center': {
        'utility': {
            '-ms-flex-item-align': 'center',
            '-ms-grid-row-align': 'center',
            '-webkit-align-self': 'center',
            'align-self': 'center',
        },
        'meta': {
            'group': 'alignSelf',
            'order': 4,
        },
    },
    'self-stretch': {
        'utility': {
            '-ms-flex-item-align': 'stretch',
            '-ms-grid-row-align': 'stretch',
            '-webkit-align-self': 'stretch',
            'align-self': 'stretch',
        },
        'meta': {
            'group': 'alignSelf',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/positioning.html#place-content
    'place-content-center': {
        'utility': {
            'place-content': 'center',
        },
        'meta': {
            'group': 'placeContent',
            'order': 1,
        },
    },
    'place-content-start': {
        'utility': {
            'place-content': 'start',
        },
        'meta': {
            'group': 'placeContent',
            'order': 2,
        },
    },
    'place-content-end': {
        'utility': {
            'place-content': 'end',
        },
        'meta': {
            'group': 'placeContent',
            'order': 3,
        },
    },
    'place-content-between': {
        'utility': {
            'place-content': 'space-between',
        },
        'meta': {
            'group': 'placeContent',
            'order': 4,
        },
    },
    'place-content-around': {
        'utility': {
            'place-content': 'space-around',
        },
        'meta': {
            'group': 'placeContent',
            'order': 5,
        },
    },
    'place-content-evenly': {
        'utility': {
            'place-content': 'space-evenly',
        },
        'meta': {
            'group': 'placeContent',
            'order': 6,
        },
    },
    'place-content-stretch': {
        'utility': {
            'place-content': 'stretch',
        },
        'meta': {
            'group': 'placeContent',
            'order': 7,
        },
    },
    // https://windicss.org/utilities/positioning.html#place-items
    'place-items-auto': {
        'utility': {
            'place-items': 'auto',
        },
        'meta': {
            'group': 'placeItems',
            'order': 1,
        },
    },
    'place-items-start': {
        'utility': {
            'place-items': 'start',
        },
        'meta': {
            'group': 'placeItems',
            'order': 2,
        },
    },
    'place-items-end': {
        'utility': {
            'place-items': 'end',
        },
        'meta': {
            'group': 'placeItems',
            'order': 3,
        },
    },
    'place-items-center': {
        'utility': {
            'place-items': 'center',
        },
        'meta': {
            'group': 'placeItems',
            'order': 4,
        },
    },
    'place-items-stretch': {
        'utility': {
            'place-items': 'stretch',
        },
        'meta': {
            'group': 'placeItems',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/positioning.html#place-self
    'place-self-auto': {
        'utility': {
            '-ms-grid-row-align': 'auto',
            '-ms-grid-column-align': 'auto',
            'place-self': 'auto',
        },
        'meta': {
            'group': 'placeSelf',
            'order': 1,
        },
    },
    'place-self-start': {
        'utility': {
            '-ms-grid-row-align': 'start',
            '-ms-grid-column-align': 'start',
            'place-self': 'start',
        },
        'meta': {
            'group': 'placeSelf',
            'order': 2,
        },
    },
    'place-self-end': {
        'utility': {
            '-ms-grid-row-align': 'end',
            '-ms-grid-column-align': 'end',
            'place-self': 'end',
        },
        'meta': {
            'group': 'placeSelf',
            'order': 3,
        },
    },
    'place-self-center': {
        'utility': {
            '-ms-grid-row-align': 'center',
            '-ms-grid-column-align': 'center',
            'place-self': 'center',
        },
        'meta': {
            'group': 'placeSelf',
            'order': 4,
        },
    },
    'place-self-stretch': {
        'utility': {
            '-ms-grid-row-align': 'stretch',
            '-ms-grid-column-align': 'stretch',
            'place-self': 'stretch',
        },
        'meta': {
            'group': 'placeSelf',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/typography.html#font-smoothing
    'antialiased': {
        'utility': {
            '-webkit-font-smoothing': 'antialiased',
            '-moz-osx-font-smoothing': 'grayscale',
        },
        'meta': {
            'group': 'fontSmoothing',
            'order': 1,
        },
    },
    'subpixel-antialiased': {
        'utility': {
            '-webkit-font-smoothing': 'auto',
            '-moz-osx-font-smoothing': 'auto',
        },
        'meta': {
            'group': 'fontSmoothing',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/typography.html#font-style
    'italic': {
        'utility': {
            'font-style': 'italic',
        },
        'meta': {
            'group': 'fontStyle',
            'order': 1,
        },
    },
    'not-italic': {
        'utility': {
            'font-style': 'normal',
        },
        'meta': {
            'group': 'fontStyle',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/typography.html#font-variant-numeric
    'normal-nums': {
        'utility': {
            'font-variant-numeric': 'normal',
        },
        'meta': {
            'group': 'fontVariantNumeric',
            'order': 1,
        },
    },
    'ordinal': {
        'utility': __assign$4(__assign$4({}, fontVariants), { '--tw-ordinal': 'ordinal' }),
        'meta': {
            'group': 'fontVariantNumeric',
            'order': 2,
        },
    },
    'slashed-zero': {
        'utility': __assign$4(__assign$4({}, fontVariants), { '--tw-slashed-zero': 'slashed-zero' }),
        'meta': {
            'group': 'fontVariantNumeric',
            'order': 3,
        },
    },
    'lining-nums': {
        'utility': __assign$4(__assign$4({}, fontVariants), { '--tw-numeric-figure': 'lining-nums' }),
        'meta': {
            'group': 'fontVariantNumeric',
            'order': 4,
        },
    },
    'oldstyle-nums': {
        'utility': __assign$4(__assign$4({}, fontVariants), { '--tw-numeric-figure': 'oldstyle-nums' }),
        'meta': {
            'group': 'fontVariantNumeric',
            'order': 5,
        },
    },
    'proportional-nums': {
        'utility': __assign$4(__assign$4({}, fontVariants), { '--tw-numeric-spacing': 'proportional-nums' }),
        'meta': {
            'group': 'fontVariantNumeric',
            'order': 6,
        },
    },
    'tabular-nums': {
        'utility': __assign$4(__assign$4({}, fontVariants), { '--tw-numeric-spacing': 'tabular-nums' }),
        'meta': {
            'group': 'fontVariantNumeric',
            'order': 7,
        },
    },
    'diagonal-fractions': {
        'utility': __assign$4(__assign$4({}, fontVariants), { '--tw-numeric-fraction': 'diagonal-fractions' }),
        'meta': {
            'group': 'fontVariantNumeric',
            'order': 8,
        },
    },
    'stacked-fractions': {
        'utility': __assign$4(__assign$4({}, fontVariants), { '--tw-numeric-fraction': 'stacked-fractions' }),
        'meta': {
            'group': 'fontVariantNumeric',
            'order': 9,
        },
    },
    // https://windicss.org/utilities/behaviors.html#list-style-position
    'list-inside': {
        'utility': {
            'list-style-position': 'inside',
        },
        'meta': {
            'group': 'listStylePosition',
            'order': 1,
        },
    },
    'list-outside': {
        'utility': {
            'list-style-position': 'outside',
        },
        'meta': {
            'group': 'listStylePosition',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/typography.html#text-alignment
    'text-left': {
        'utility': {
            'text-align': 'left',
        },
        'meta': {
            'group': 'textAlign',
            'order': 1,
        },
    },
    'text-center': {
        'utility': {
            'text-align': 'center',
        },
        'meta': {
            'group': 'textAlign',
            'order': 2,
        },
    },
    'text-right': {
        'utility': {
            'text-align': 'right',
        },
        'meta': {
            'group': 'textAlign',
            'order': 3,
        },
    },
    'text-justify': {
        'utility': {
            'text-align': 'justify',
        },
        'meta': {
            'group': 'textAlign',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/typography.html#text-decoration
    'underline': {
        'utility': {
            '-webkit-text-decoration-line': 'underline',
            'text-decoration-line': 'underline',
        },
        'meta': {
            'group': 'textDecoration',
            'order': 1,
        },
    },
    'overline': {
        'utility': {
            '-webkit-text-decoration-line': 'overline',
            'text-decoration-line': 'overline',
        },
        'meta': {
            'group': 'textDecoration',
            'order': 2,
        },
    },
    'line-through': {
        'utility': {
            '-webkit-text-decoration-line': 'line-through',
            'text-decoration-line': 'line-through',
        },
        'meta': {
            'group': 'textDecoration',
            'order': 3,
        },
    },
    'no-underline': {
        'utility': {
            'text-decoration': 'none',
        },
        'meta': {
            'group': 'textDecoration',
            'order': 4,
        },
    },
    // http://localhost:3001/utilities/typography.html#text-decoration-style
    'decoration-solid': {
        'utility': {
            '-webkit-text-decoration-style': 'solid',
            'text-decoration-style': 'solid',
        },
        'meta': {
            'group': 'textDecorationStyle',
            'order': 1,
        },
    },
    'decoration-double': {
        'utility': {
            '-webkit-text-decoration-style': 'double',
            'text-decoration-style': 'double',
        },
        'meta': {
            'group': 'textDecorationStyle',
            'order': 2,
        },
    },
    'decoration-dotted': {
        'utility': {
            '-webkit-text-decoration-style': 'dotted',
            'text-decoration-style': 'dotted',
        },
        'meta': {
            'group': 'textDecorationStyle',
            'order': 3,
        },
    },
    'decoration-dashed': {
        'utility': {
            '-webkit-text-decoration-style': 'dashed',
            'text-decoration-style': 'dashed',
        },
        'meta': {
            'group': 'textDecorationStyle',
            'order': 4,
        },
    },
    'decoration-wavy': {
        'utility': {
            '-webkit-text-decoration-style': 'wavy',
            'text-decoration-style': 'wavy',
        },
        'meta': {
            'group': 'textDecorationStyle',
            'order': 5,
        },
    },
    // http://localhost:3001/utilities/typography.html#text-decoration-style - Fallback to .decoration-{style}
    'underline-solid': {
        'utility': {
            '-webkit-text-decoration-style': 'solid',
            'text-decoration-style': 'solid',
        },
        'meta': {
            'group': 'textDecorationStyle',
            'order': 1,
        },
    },
    'underline-double': {
        'utility': {
            '-webkit-text-decoration-style': 'double',
            'text-decoration-style': 'double',
        },
        'meta': {
            'group': 'textDecorationStyle',
            'order': 2,
        },
    },
    'underline-dotted': {
        'utility': {
            '-webkit-text-decoration-style': 'dotted',
            'text-decoration-style': 'dotted',
        },
        'meta': {
            'group': 'textDecorationStyle',
            'order': 3,
        },
    },
    'underline-dashed': {
        'utility': {
            '-webkit-text-decoration-style': 'dashed',
            'text-decoration-style': 'dashed',
        },
        'meta': {
            'group': 'textDecorationStyle',
            'order': 4,
        },
    },
    'underline-wavy': {
        'utility': {
            '-webkit-text-decoration-style': 'wavy',
            'text-decoration-style': 'wavy',
        },
        'meta': {
            'group': 'textDecorationStyle',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/typography.html#text-transform
    'uppercase': {
        'utility': {
            'text-transform': 'uppercase',
        },
        'meta': {
            'group': 'textTransform',
            'order': 1,
        },
    },
    'lowercase': {
        'utility': {
            'text-transform': 'lowercase',
        },
        'meta': {
            'group': 'textTransform',
            'order': 2,
        },
    },
    'capitalize': {
        'utility': {
            'text-transform': 'capitalize',
        },
        'meta': {
            'group': 'textTransform',
            'order': 3,
        },
    },
    'normal-case': {
        'utility': {
            'text-transform': 'none',
        },
        'meta': {
            'group': 'textTransform',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/typography.html#text-overflow
    'truncate': {
        'utility': {
            'overflow': 'hidden',
            '-o-text-overflow': 'ellipsis',
            'text-overflow': 'ellipsis',
            'white-space': 'nowrap',
        },
        'meta': {
            'group': 'textOverflow',
            'order': 1,
        },
    },
    'overflow-ellipsis': {
        'utility': {
            '-o-text-overflow': 'ellipsis',
            'text-overflow': 'ellipsis',
        },
        'meta': {
            'group': 'textOverflow',
            'order': 2,
        },
    },
    'text-ellipsis': {
        'utility': {
            '-o-text-overflow': 'ellipsis',
            'text-overflow': 'ellipsis',
        },
        'meta': {
            'group': 'textOverflow',
            'order': 3,
        },
    },
    'text-clip': {
        'utility': {
            '-o-text-overflow': 'clip',
            'text-overflow': 'clip',
        },
        'meta': {
            'group': 'textOverflow',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/typography.html#vertical-alignment
    'align-baseline': {
        'utility': {
            'vertical-align': 'baseline',
        },
        'meta': {
            'group': 'verticalAlign',
            'order': 1,
        },
    },
    'align-top': {
        'utility': {
            'vertical-align': 'top',
        },
        'meta': {
            'group': 'verticalAlign',
            'order': 2,
        },
    },
    'align-middle': {
        'utility': {
            'vertical-align': 'middle',
        },
        'meta': {
            'group': 'verticalAlign',
            'order': 3,
        },
    },
    'align-bottom': {
        'utility': {
            'vertical-align': 'bottom',
        },
        'meta': {
            'group': 'verticalAlign',
            'order': 4,
        },
    },
    'align-text-top': {
        'utility': {
            'vertical-align': 'text-top',
        },
        'meta': {
            'group': 'verticalAlign',
            'order': 5,
        },
    },
    'align-text-bottom': {
        'utility': {
            'vertical-align': 'text-bottom',
        },
        'meta': {
            'group': 'verticalAlign',
            'order': 6,
        },
    },
    'align-sub': {
        'utility': {
            'vertical-align': 'sub',
        },
        'meta': {
            'group': 'verticalAlign',
            'order': 7,
        },
    },
    'align-super': {
        'utility': {
            'vertical-align': 'super',
        },
        'meta': {
            'group': 'verticalAlign',
            'order': 8,
        },
    },
    // https://windicss.org/utilities/typography.html#whitespace
    'whitespace-normal': {
        'utility': {
            'white-space': 'normal',
        },
        'meta': {
            'group': 'whitespace',
            'order': 1,
        },
    },
    'whitespace-nowrap': {
        'utility': {
            'white-space': 'nowrap',
        },
        'meta': {
            'group': 'whitespace',
            'order': 2,
        },
    },
    'whitespace-pre': {
        'utility': {
            'white-space': 'pre',
        },
        'meta': {
            'group': 'whitespace',
            'order': 3,
        },
    },
    'whitespace-pre-line': {
        'utility': {
            'white-space': 'pre-line',
        },
        'meta': {
            'group': 'whitespace',
            'order': 4,
        },
    },
    'whitespace-pre-wrap': {
        'utility': {
            'white-space': 'pre-wrap',
        },
        'meta': {
            'group': 'whitespace',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/typography.html#word-break
    'break-normal': {
        'utility': {
            'word-break': 'normal',
            'overflow-wrap': 'normal',
        },
        'meta': {
            'group': 'wordBreak',
            'order': 1,
        },
    },
    'break-words': {
        'utility': {
            'overflow-wrap': 'break-word',
        },
        'meta': {
            'group': 'wordBreak',
            'order': 2,
        },
    },
    'break-all': {
        'utility': {
            'word-break': 'break-all',
        },
        'meta': {
            'group': 'wordBreak',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/typography.html#writing-mode
    'write-normal': {
        'utility': {
            '-webkit-writing-mode': 'horizontal-tb',
            '-ms-writing-mode': 'lr-tb',
            'writing-mode': 'horizontal-tb',
        },
        'meta': {
            'group': 'writingMode',
            'order': 1,
        },
    },
    'write-vertical-right': {
        'utility': {
            '-webkit-writing-mode': 'vertical-rl',
            '-ms-writing-mode': 'tb-rl',
            'writing-mode': 'vertical-rl',
        },
        'meta': {
            'group': 'writingMode',
            'order': 2,
        },
    },
    'write-vertical-left': {
        'utility': {
            '-webkit-writing-mode': 'vertical-lr',
            '-ms-writing-mode': 'tb-lr',
            'writing-mode': 'vertical-lr',
        },
        'meta': {
            'group': 'writingMode',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/typography.html#writing-orientation
    'write-orient-mixed': {
        'utility': {
            '-webkit-text-orientation': 'mixed',
            'text-orientation': 'mixed',
        },
        'meta': {
            'group': 'writingMode',
            'order': 4,
        },
    },
    'write-orient-upright': {
        'utility': {
            '-webkit-text-orientation': 'upright',
            'text-orientation': 'upright',
        },
        'meta': {
            'group': 'writingMode',
            'order': 5,
        },
    },
    'write-orient-sideways': {
        'utility': {
            '-webkit-text-orientation': 'sideways',
            'text-orientation': 'sideways',
        },
        'meta': {
            'group': 'writingMode',
            'order': 6,
        },
    },
    // https://windicss.org/utilities/typography.html#hyphens
    'hyphens-none': {
        'utility': {
            '-webkit-hyphens': 'none',
            '-ms-hyphens': 'none',
            'hyphens': 'none',
        },
        'meta': {
            'group': 'hyphens',
            'order': 1,
        },
    },
    'hyphens-manual': {
        'utility': {
            '-webkit-hyphens': 'manual',
            '-ms-hyphens': 'manual',
            'hyphens': 'manual',
        },
        'meta': {
            'group': 'hyphens',
            'order': 2,
        },
    },
    'hyphens-auto': {
        'utility': {
            '-webkit-hyphens': 'auto',
            '-ms-hyphens': 'auto',
            'hyphens': 'auto',
        },
        'meta': {
            'group': 'hyphens',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/backgrounds.html#background-attachment
    'bg-fixed': {
        'utility': {
            'background-attachment': 'fixed',
        },
        'meta': {
            'group': 'backgroundAttachment',
            'order': 1,
        },
    },
    'bg-local': {
        'utility': {
            'background-attachment': 'local',
        },
        'meta': {
            'group': 'backgroundAttachment',
            'order': 2,
        },
    },
    'bg-scroll': {
        'utility': {
            'background-attachment': 'scroll',
        },
        'meta': {
            'group': 'backgroundAttachment',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/backgrounds.html#background-clip
    'bg-clip-border': {
        'utility': {
            '-webkit-background-clip': 'border-box',
            'background-clip': 'border-box',
        },
        'meta': {
            'group': 'backgroundClip',
            'order': 1,
        },
    },
    'bg-clip-padding': {
        'utility': {
            '-webkit-background-clip': 'padding-box',
            'background-clip': 'padding-box',
        },
        'meta': {
            'group': 'backgroundClip',
            'order': 2,
        },
    },
    'bg-clip-content': {
        'utility': {
            '-webkit-background-clip': 'content-box',
            'background-clip': 'content-box',
        },
        'meta': {
            'group': 'backgroundClip',
            'order': 3,
        },
    },
    'bg-clip-text': {
        'utility': {
            '-webkit-background-clip': 'text',
            'background-clip': 'text',
        },
        'meta': {
            'group': 'backgroundClip',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/backgrounds.html#background-repeat
    'bg-repeat': {
        'utility': {
            'background-repeat': 'repeat',
        },
        'meta': {
            'group': 'backgroundRepeat',
            'order': 1,
        },
    },
    'bg-no-repeat': {
        'utility': {
            'background-repeat': 'no-repeat',
        },
        'meta': {
            'group': 'backgroundRepeat',
            'order': 2,
        },
    },
    'bg-repeat-x': {
        'utility': {
            'background-repeat': 'repeat-x',
        },
        'meta': {
            'group': 'backgroundRepeat',
            'order': 3,
        },
    },
    'bg-repeat-y': {
        'utility': {
            'background-repeat': 'repeat-y',
        },
        'meta': {
            'group': 'backgroundRepeat',
            'order': 4,
        },
    },
    'bg-repeat-round': {
        'utility': {
            'background-repeat': 'round',
        },
        'meta': {
            'group': 'backgroundRepeat',
            'order': 5,
        },
    },
    'bg-repeat-space': {
        'utility': {
            'background-repeat': 'space',
        },
        'meta': {
            'group': 'backgroundRepeat',
            'order': 6,
        },
    },
    // https://windicss.org/utilities/backgrounds.html#background-origin
    'bg-origin-border': {
        'utility': {
            'background-origin': 'border-box',
        },
        'meta': {
            'group': 'backgroundOrigin',
            'order': 1,
        },
    },
    'bg-origin-padding': {
        'utility': {
            'background-origin': 'padding-box',
        },
        'meta': {
            'group': 'backgroundOrigin',
            'order': 2,
        },
    },
    'bg-origin-content': {
        'utility': {
            'background-origin': 'content-box',
        },
        'meta': {
            'group': 'backgroundOrigin',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/borders.html#border-style
    'border-solid': {
        'utility': {
            'border-style': 'solid',
        },
        'meta': {
            'group': 'borderStyle',
            'order': 1,
        },
    },
    'border-dashed': {
        'utility': {
            'border-style': 'dashed',
        },
        'meta': {
            'group': 'borderStyle',
            'order': 2,
        },
    },
    'border-dotted': {
        'utility': {
            'border-style': 'dotted',
        },
        'meta': {
            'group': 'borderStyle',
            'order': 3,
        },
    },
    'border-double': {
        'utility': {
            'border-style': 'double',
        },
        'meta': {
            'group': 'borderStyle',
            'order': 4,
        },
    },
    'border-none': {
        'utility': {
            'border-style': 'none',
        },
        'meta': {
            'group': 'borderStyle',
            'order': 5,
        },
    },
    'border-hidden': {
        'utility': {
            'border-style': 'hidden',
        },
        'meta': {
            'group': 'borderStyle',
            'order': 6,
        },
    },
    // https://windicss.org/utilities/behaviors.html#image-rendering
    'image-render-auto': {
        'utility': {
            'image-rendering': 'auto',
        },
        'meta': {
            'group': 'imageRendering',
            'order': 1,
        },
    },
    'image-render-pixel': {
        'utility': {
            '-ms-interpolation-mode': 'nearest-neighbor',
            'image-rendering': ['-webkit-optimize-contrast', '-moz-crisp-edges', '-o-pixelated', 'pixelated'],
        },
        'meta': {
            'group': 'imageRendering',
            'order': 2,
        },
    },
    'image-render-edge': {
        'utility': {
            'image-rendering': 'crisp-edges',
        },
        'meta': {
            'group': 'imageRendering',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/effects.html#mix-blend-mode
    'mix-blend-normal': {
        'utility': {
            'mix-blend-mode': 'normal',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 1,
        },
    },
    'mix-blend-multiply': {
        'utility': {
            'mix-blend-mode': 'multiply',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 2,
        },
    },
    'mix-blend-screen': {
        'utility': {
            'mix-blend-mode': 'screen',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 3,
        },
    },
    'mix-blend-overlay': {
        'utility': {
            'mix-blend-mode': 'overlay',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 4,
        },
    },
    'mix-blend-darken': {
        'utility': {
            'mix-blend-mode': 'darken',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 5,
        },
    },
    'mix-blend-lighten': {
        'utility': {
            'mix-blend-mode': 'lighten',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 6,
        },
    },
    'mix-blend-color-dodge': {
        'utility': {
            'mix-blend-mode': 'color-dodge',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 7,
        },
    },
    'mix-blend-color-burn': {
        'utility': {
            'mix-blend-mode': 'color-burn',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 8,
        },
    },
    'mix-blend-hard-light': {
        'utility': {
            'mix-blend-mode': 'hard-light',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 9,
        },
    },
    'mix-blend-soft-light': {
        'utility': {
            'mix-blend-mode': 'soft-light',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 10,
        },
    },
    'mix-blend-difference': {
        'utility': {
            'mix-blend-mode': 'difference',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 11,
        },
    },
    'mix-blend-exclusion': {
        'utility': {
            'mix-blend-mode': 'exclusion',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 12,
        },
    },
    'mix-blend-hue': {
        'utility': {
            'mix-blend-mode': 'hue',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 13,
        },
    },
    'mix-blend-saturation': {
        'utility': {
            'mix-blend-mode': 'saturation',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 14,
        },
    },
    'mix-blend-color': {
        'utility': {
            'mix-blend-mode': 'color',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 15,
        },
    },
    'mix-blend-luminosity': {
        'utility': {
            'mix-blend-mode': 'luminosity',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 16,
        },
    },
    // https://windicss.org/utilities/backgrounds.html#background-blend-mode
    'bg-blend-normal': {
        'utility': {
            'background-blend-mode': 'normal',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 1,
        },
    },
    'bg-blend-multiply': {
        'utility': {
            'background-blend-mode': 'multiply',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 2,
        },
    },
    'bg-blend-screen': {
        'utility': {
            'background-blend-mode': 'screen',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 3,
        },
    },
    'bg-blend-overlay': {
        'utility': {
            'background-blend-mode': 'overlay',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 4,
        },
    },
    'bg-blend-darken': {
        'utility': {
            'background-blend-mode': 'darken',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 5,
        },
    },
    'bg-blend-lighten': {
        'utility': {
            'background-blend-mode': 'lighten',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 6,
        },
    },
    'bg-blend-color-dodge': {
        'utility': {
            'background-blend-mode': 'color-dodge',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 7,
        },
    },
    'bg-blend-color-burn': {
        'utility': {
            'background-blend-mode': 'color-burn',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 8,
        },
    },
    'bg-blend-hard-light': {
        'utility': {
            'background-blend-mode': 'hard-light',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 9,
        },
    },
    'bg-blend-soft-light': {
        'utility': {
            'background-blend-mode': 'soft-light',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 10,
        },
    },
    'bg-blend-difference': {
        'utility': {
            'background-blend-mode': 'difference',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 11,
        },
    },
    'bg-blend-exclusion': {
        'utility': {
            'background-blend-mode': 'exclusion',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 12,
        },
    },
    'bg-blend-hue': {
        'utility': {
            'background-blend-mode': 'hue',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 13,
        },
    },
    'bg-blend-saturation': {
        'utility': {
            'background-blend-mode': 'saturation',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 14,
        },
    },
    'bg-blend-color': {
        'utility': {
            'background-blend-mode': 'color',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 15,
        },
    },
    'bg-blend-luminosity': {
        'utility': {
            'background-blend-mode': 'luminosity',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 16,
        },
    },
    // https://windicss.org/utilities/filters.html#filter
    'filter': {
        'utility': {
            '--tw-blur': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-brightness': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-contrast': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-grayscale': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-hue-rotate': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-invert': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-saturate': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-sepia': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-drop-shadow': 'var(--tw-empty,/*!*/ /*!*/)',
            '-webkit-filter': 'var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)',
            'filter': 'var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)',
        },
        'meta': {
            'group': 'filter',
            'order': 1,
        },
    },
    'filter-none': {
        'utility': {
            '-webkit-filter': 'none',
            'filter': 'none',
        },
        'meta': {
            'group': 'filter',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/filters.html#backdrop-filter
    'backdrop-filter': {
        'utility': {
            '--tw-backdrop-blur': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-backdrop-brightness': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-backdrop-contrast': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-backdrop-grayscale': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-backdrop-hue-rotate': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-backdrop-invert': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-backdrop-opacity': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-backdrop-saturate': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-backdrop-sepia': 'var(--tw-empty,/*!*/ /*!*/)',
            '-webkit-backdrop-filter': 'var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)',
            'backdrop-filter': 'var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)',
        },
        'meta': {
            'group': 'backdropFilter',
            'order': 1,
        },
    },
    'backdrop-filter-none': {
        'utility': {
            '-webkit-backdrop-filter': 'none',
            'backdrop-filter': 'none',
        },
        'meta': {
            'group': 'backdropFilter',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/tables.html#table-border-collapse
    'border-collapse': {
        'utility': {
            'border-collapse': 'collapse',
        },
        'meta': {
            'group': 'borderCollapse',
            'order': 1,
        },
    },
    'border-separate': {
        'utility': {
            'border-collapse': 'separate',
        },
        'meta': {
            'group': 'borderCollapse',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/tables.html#table-caption-side
    'caption-top': {
        'utility': {
            'caption-side': 'top',
        },
        'meta': {
            'group': 'captionSide',
            'order': 1,
        },
    },
    'caption-bottom': {
        'utility': {
            'caption-side': 'bottom',
        },
        'meta': {
            'group': 'captionSide',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/tables.html#table-empty-cells
    'empty-cells-visible': {
        'utility': {
            'empty-cells': 'show',
        },
        'meta': {
            'group': 'emptyCells',
            'order': 1,
        },
    },
    'empty-cells-hidden': {
        'utility': {
            'empty-cells': 'hide',
        },
        'meta': {
            'group': 'emptyCells',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/tables.html#table-layout
    'table-auto': {
        'utility': {
            'table-layout': 'auto',
        },
        'meta': {
            'group': 'tableLayout',
            'order': 1,
        },
    },
    'table-fixed': {
        'utility': {
            'table-layout': 'fixed',
        },
        'meta': {
            'group': 'tableLayout',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/transforms.html
    'transform': {
        'utility': {
            '--tw-translate-x': '0',
            '--tw-translate-y': '0',
            '--tw-translate-z': '0',
            '--tw-rotate': '0',
            '--tw-rotate-x': '0',
            '--tw-rotate-y': '0',
            '--tw-rotate-z': '0',
            '--tw-skew-x': '0',
            '--tw-skew-y': '0',
            '--tw-scale-x': '1',
            '--tw-scale-y': '1',
            '--tw-scale-z': '1',
            '-webkit-transform': 'translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) translateZ(var(--tw-translate-z)) rotate(var(--tw-rotate)) rotateX(var(--tw-rotate-x)) rotateY(var(--tw-rotate-y)) rotateZ(var(--tw-rotate-z)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y)) scaleZ(var(--tw-scale-z))',
            '-ms-transform': 'translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) translateZ(var(--tw-translate-z)) rotate(var(--tw-rotate)) rotateX(var(--tw-rotate-x)) rotateY(var(--tw-rotate-y)) rotateZ(var(--tw-rotate-z)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y)) scaleZ(var(--tw-scale-z))',
            'transform': 'translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) translateZ(var(--tw-translate-z)) rotate(var(--tw-rotate)) rotateX(var(--tw-rotate-x)) rotateY(var(--tw-rotate-y)) rotateZ(var(--tw-rotate-z)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y)) scaleZ(var(--tw-scale-z))',
        },
        'meta': {
            'group': 'transform',
            'order': 1,
        },
    },
    'transform-gpu': {
        'utility': {
            '--tw-translate-x': '0',
            '--tw-translate-y': '0',
            '--tw-translate-z': '0',
            '--tw-rotate': '0',
            '--tw-rotate-x': '0',
            '--tw-rotate-y': '0',
            '--tw-rotate-z': '0',
            '--tw-skew-x': '0',
            '--tw-skew-y': '0',
            '--tw-scale-x': '1',
            '--tw-scale-y': '1',
            '--tw-scale-z': '1',
            '-webkit-transform': 'translate3d(var(--tw-translate-x), var(--tw-translate-y), var(--tw-translate-z)) rotate(var(--tw-rotate)) rotateX(var(--tw-rotate-x)) rotateY(var(--tw-rotate-y)) rotateZ(var(--tw-rotate-z)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y)) scaleZ(var(--tw-scale-z))',
            '-ms-transform': 'translate3d(var(--tw-translate-x), var(--tw-translate-y), var(--tw-translate-z)) rotate(var(--tw-rotate)) rotateX(var(--tw-rotate-x)) rotateY(var(--tw-rotate-y)) rotateZ(var(--tw-rotate-z)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y)) scaleZ(var(--tw-scale-z))',
            'transform': 'translate3d(var(--tw-translate-x), var(--tw-translate-y), var(--tw-translate-z)) rotate(var(--tw-rotate)) rotateX(var(--tw-rotate-x)) rotateY(var(--tw-rotate-y)) rotateZ(var(--tw-rotate-z)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y)) scaleZ(var(--tw-scale-z))',
        },
        'meta': {
            'group': 'transform',
            'order': 2,
        },
    },
    'transform-none': {
        'utility': {
            '-webkit-transform': 'none',
            '-ms-transform': 'none',
            'transform': 'none',
        },
        'meta': {
            'group': 'transform',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/transforms.html#transform-type
    'preserve-flat': {
        'utility': {
            '-webkit-transform-style': 'flat',
            'transform-style': 'flat',
        },
        'meta': {
            'group': 'transform',
            'order': 4,
        },
    },
    'preserve-3d': {
        'utility': {
            '-webkit-transform-style': 'preserve-3d',
            'transform-style': 'preserve-3d',
        },
        'meta': {
            'group': 'transform',
            'order': 5,
        },
    },
    'animated': {
        'utility': {
            '-webkit-animation-duration': '1000ms',
            '-webkit-animation-fill-mode': 'both',
            'animation-duration': '1000ms',
            'animation-fill-mode': 'both',
        },
        'meta': {
            'group': 'animation',
            'order': 3,
        },
    },
    'animate-reverse': {
        'utility': {
            '-webkit-animation-direction': 'reverse',
            'animation-direction': 'reverse',
        },
        'meta': {
            'group': 'animation',
            'order': 4,
        },
    },
    'animate-alternate': {
        'utility': {
            '-webkit-animation-direction': 'alternate',
            'animation-direction': 'alternate',
        },
        'meta': {
            'group': 'animation',
            'order': 5,
        },
    },
    'animate-alternate-reverse': {
        'utility': {
            '-webkit-animation-direction': 'alternate-reverse',
            'animation-direction': 'alternate-reverse',
        },
        'meta': {
            'group': 'animation',
            'order': 6,
        },
    },
    'animate-fill-none': {
        'utility': {
            '-webkit-animation-fill-mode': 'none',
            'animation-fill-mode': 'none',
        },
        'meta': {
            'group': 'animation',
            'order': 7,
        },
    },
    'animate-fill-forwards': {
        'utility': {
            '-webkit-animation-fill-mode': 'forwards',
            'animation-fill-mode': 'forwards',
        },
        'meta': {
            'group': 'animation',
            'order': 8,
        },
    },
    'animate-fill-backwards': {
        'utility': {
            '-webkit-animation-fill-mode': 'backwards',
            'animation-fill-mode': 'backwards',
        },
        'meta': {
            'group': 'animation',
            'order': 9,
        },
    },
    'animate-fill-both': {
        'utility': {
            '-webkit-animation-fill-mode': 'both',
            'animation-fill-mode': 'both',
        },
        'meta': {
            'group': 'animation',
            'order': 10,
        },
    },
    'animate-paused': {
        'utility': {
            '-webkit-animation-play-state': 'paused',
            'animation-play-state': 'paused',
        },
        'meta': {
            'group': 'animation',
            'order': 11,
        },
    },
    'animate-running': {
        'utility': {
            '-webkit-animation-play-state': 'running',
            'animation-play-state': 'running',
        },
        'meta': {
            'group': 'animation',
            'order': 12,
        },
    },
    // https://windicss.org/utilities/behaviors.html#appearance
    'appearance-none': {
        'utility': {
            '-webkit-appearance': 'none',
            '-moz-appearance': 'none',
            'appearance': 'none',
        },
        'meta': {
            'group': 'appearance',
            'order': 1,
        },
    },
    // https://windicss.org/utilities/behaviors.html#pointer-events
    'pointer-events-none': {
        'utility': {
            'pointer-events': 'none',
        },
        'meta': {
            'group': 'pointerEvents',
            'order': 1,
        },
    },
    'pointer-events-auto': {
        'utility': {
            'pointer-events': 'auto',
        },
        'meta': {
            'group': 'pointerEvents',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/behaviors.html#resize
    'resize-none': {
        'utility': {
            'resize': 'none',
        },
        'meta': {
            'group': 'resize',
            'order': 1,
        },
    },
    'resize-y': {
        'utility': {
            'resize': 'vertical',
        },
        'meta': {
            'group': 'resize',
            'order': 2,
        },
    },
    'resize-x': {
        'utility': {
            'resize': 'horizontal',
        },
        'meta': {
            'group': 'resize',
            'order': 3,
        },
    },
    'resize': {
        'utility': {
            'resize': 'both',
        },
        'meta': {
            'group': 'resize',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/behaviors.html#user-select
    'select-none': {
        'utility': {
            '-webkit-user-select': 'none',
            '-moz-user-select': 'none',
            '-ms-user-select': 'none',
            'user-select': 'none',
        },
        'meta': {
            'group': 'userSelect',
            'order': 1,
        },
    },
    'select-text': {
        'utility': {
            '-webkit-user-select': 'text',
            '-moz-user-select': 'text',
            '-ms-user-select': 'text',
            'user-select': 'text',
        },
        'meta': {
            'group': 'userSelect',
            'order': 2,
        },
    },
    'select-all': {
        'utility': {
            '-webkit-user-select': 'all',
            '-moz-user-select': 'all',
            '-ms-user-select': 'all',
            'user-select': 'all',
        },
        'meta': {
            'group': 'userSelect',
            'order': 3,
        },
    },
    'select-auto': {
        'utility': {
            '-webkit-user-select': 'auto',
            '-moz-user-select': 'auto',
            '-ms-user-select': 'auto',
            'user-select': 'auto',
        },
        'meta': {
            'group': 'userSelect',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/svg.html#fill-color
    // https://windicss.org/utilities/svg.html#stroke-color
    'fill-current': {
        'utility': {
            'fill': 'currentColor',
        },
        'meta': {
            'group': 'fill',
            'order': 1,
        },
    },
    'stroke-current': {
        'utility': {
            'stroke': 'currentColor',
        },
        'meta': {
            'group': 'stroke',
            'order': 1,
        },
    },
    // https://windicss.org/utilities/svg.html#stroke-linecap
    'stroke-cap-auto': {
        'utility': {
            'stroke-linecap': 'butt',
        },
        'meta': {
            'group': 'stroke',
            'order': 2,
        },
    },
    'stroke-cap-square': {
        'utility': {
            'stroke-linecap': 'square',
        },
        'meta': {
            'group': 'stroke',
            'order': 3,
        },
    },
    'stroke-cap-round': {
        'utility': {
            'stroke-linecap': 'round',
        },
        'meta': {
            'group': 'stroke',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/svg.html#stroke-linejoin
    'stroke-join-auto': {
        'utility': {
            'stroke-linejoin': 'miter',
        },
        'meta': {
            'group': 'stroke',
            'order': 5,
        },
    },
    'stroke-join-arcs': {
        'utility': {
            'stroke-linejoin': 'arcs',
        },
        'meta': {
            'group': 'stroke',
            'order': 6,
        },
    },
    'stroke-join-bevel': {
        'utility': {
            'stroke-linejoin': 'bevel',
        },
        'meta': {
            'group': 'stroke',
            'order': 7,
        },
    },
    'stroke-join-clip': {
        'utility': {
            'stroke-linejoin': 'miter-clip',
        },
        'meta': {
            'group': 'stroke',
            'order': 8,
        },
    },
    'stroke-join-round': {
        'utility': {
            'stroke-linejoin': 'round',
        },
        'meta': {
            'group': 'stroke',
            'order': 9,
        },
    },
    // https://windicss.org/utilities/behaviors.html#screen-readers-access
    'sr-only': {
        'utility': {
            'position': 'absolute',
            'width': '1px',
            'height': '1px',
            'padding': '0',
            'margin': '-1px',
            'overflow': 'hidden',
            'clip': 'rect(0, 0, 0, 0)',
            'white-space': 'nowrap',
            'border-width': '0',
        },
        'meta': {
            'group': 'accessibility',
            'order': 1,
        },
    },
    'not-sr-only': {
        'utility': {
            'position': 'static',
            'width': 'auto',
            'height': 'auto',
            'padding': '0',
            'margin': '0',
            'overflow': 'visible',
            'clip': 'auto',
            'white-space': 'normal',
        },
        'meta': {
            'group': 'accessibility',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/behaviors.html#will-change
    'will-change-auto': {
        'utility': {
            'will-change': 'auto',
        },
        'meta': {
            'group': 'willChange',
            'order': 1,
        },
    },
    'will-change-scroll': {
        'utility': {
            'will-change': 'scroll',
        },
        'meta': {
            'group': 'willChange',
            'order': 2,
        },
    },
    'will-change-contents': {
        'utility': {
            'will-change': 'contents',
        },
        'meta': {
            'group': 'willChange',
            'order': 3,
        },
    },
    'will-change-transform': {
        'utility': {
            'will-change': 'transform',
        },
        'meta': {
            'group': 'willChange',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/behaviors.html#touch-action
    'touch-auto': {
        'utility': {
            'touch-action': 'auto',
        },
        'meta': {
            'group': 'touchAction',
            'order': 1,
        },
    },
    'touch-none': {
        'utility': {
            'touch-action': 'none',
        },
        'meta': {
            'group': 'touchAction',
            'order': 2,
        },
    },
    'touch-pan-x': {
        'utility': {
            'touch-action': 'pan-x',
        },
        'meta': {
            'group': 'touchAction',
            'order': 3,
        },
    },
    'touch-pan-left': {
        'utility': {
            'touch-action': 'pan-left',
        },
        'meta': {
            'group': 'touchAction',
            'order': 4,
        },
    },
    'touch-pan-right': {
        'utility': {
            'touch-action': 'pan-right',
        },
        'meta': {
            'group': 'touchAction',
            'order': 5,
        },
    },
    'touch-pan-y': {
        'utility': {
            'touch-action': 'pan-y',
        },
        'meta': {
            'group': 'touchAction',
            'order': 6,
        },
    },
    'touch-pan-up': {
        'utility': {
            'touch-action': 'pan-up',
        },
        'meta': {
            'group': 'touchAction',
            'order': 7,
        },
    },
    'touch-pan-down': {
        'utility': {
            'touch-action': 'pan-down',
        },
        'meta': {
            'group': 'touchAction',
            'order': 8,
        },
    },
    'touch-pinch-zoom': {
        'utility': {
            'touch-action': 'pinch-zoom',
        },
        'meta': {
            'group': 'touchAction',
            'order': 9,
        },
    },
    'touch-manipulation': {
        'utility': {
            'touch-action': 'manipulation',
        },
        'meta': {
            'group': 'touchAction',
            'order': 10,
        },
    },
    // https://windicss.org/utilities/behaviors.html#scroll-behavior
    'scroll-auto': {
        'utility': {
            'scroll-behavior': 'auto',
        },
        'meta': {
            'group': 'scrollBehavior',
            'order': 1,
        },
    },
    'scroll-smooth': {
        'utility': {
            'scroll-behavior': 'smooth',
        },
        'meta': {
            'group': 'scrollBehavior',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/borders/outline.html
    'outline-none': {
        'utility': {
            'outline': '2px solid transparent',
            'outline-offset': '2px',
        },
        'meta': {
            'group': 'outline',
            'order': 1,
        },
    },
    'outline': {
        'utility': {
            'outline-style': 'solid',
        },
        'meta': {
            'group': 'outline',
            'order': 2,
        },
    },
    'outline-dashed': {
        'utility': {
            'outline-style': 'dashed',
        },
        'meta': {
            'group': 'outline',
            'order': 3,
        },
    },
    'outline-dotted': {
        'utility': {
            'outline-style': 'dotted',
        },
        'meta': {
            'group': 'outline',
            'order': 4,
        },
    },
    'outline-double': {
        'utility': {
            'outline-style': 'double',
        },
        'meta': {
            'group': 'outline',
            'order': 5,
        },
    },
    'outline-hidden': {
        'utility': {
            'outline-style': 'hidden',
        },
        'meta': {
            'group': 'outline',
            'order': 6,
        },
    },
};

var variantOrder = [
    'hover',
    'focus',
    'active',
    'visited',
    'link',
    'target',
    'focus-visible',
    'focus-within',
    'checked',
    'not-checked',
    'default',
    'disabled',
    'enabled',
    'indeterminate',
    'invalid',
    'valid',
    'optional',
    'required',
    'placeholder-shown',
    'read-only',
    'read-write',
    'not-disabled',
    'first-of-type',
    'not-first-of-type',
    'last-of-type',
    'not-last-of-type',
    'first',
    'last',
    'not-first',
    'not-last',
    'only-child',
    'not-only-child',
    'only-of-type',
    'not-only-of-type',
    'even',
    'odd',
    'even-of-type',
    'odd-of-type',
    'root',
    'empty',
    'before',
    'after',
    'first-letter',
    'first-line',
    'file-selector-button',
    'file',
    'selection',
    'marker',
    'svg',
    'all',
    'children',
    'siblings',
    'sibling',
    'ltr',
    'rtl',
    'group-hover',
    'group-focus',
    'group-active',
    'group-visited',
    'motion-safe',
    'motion-reduce',
];
var layerOrder$1;
(function (layerOrder) {
    layerOrder[layerOrder["base"] = 10] = "base";
    layerOrder[layerOrder["components"] = 150] = "components";
    layerOrder[layerOrder["shortcuts"] = 160] = "shortcuts";
    layerOrder[layerOrder["utilities"] = 20000] = "utilities";
})(layerOrder$1 || (layerOrder$1 = {}));
var pluginOrder$1;
(function (pluginOrder) {
    pluginOrder[pluginOrder["columns"] = 80] = "columns";
    pluginOrder[pluginOrder["container"] = 100] = "container";
    pluginOrder[pluginOrder["space"] = 200] = "space";
    pluginOrder[pluginOrder["divideWidth"] = 300] = "divideWidth";
    pluginOrder[pluginOrder["divideColor"] = 400] = "divideColor";
    pluginOrder[pluginOrder["divideStyle"] = 500] = "divideStyle";
    pluginOrder[pluginOrder["divideOpacity"] = 600] = "divideOpacity";
    pluginOrder[pluginOrder["accessibility"] = 700] = "accessibility";
    pluginOrder[pluginOrder["appearance"] = 800] = "appearance";
    pluginOrder[pluginOrder["backgroundAttachment"] = 900] = "backgroundAttachment";
    pluginOrder[pluginOrder["backgroundClip"] = 1000] = "backgroundClip";
    pluginOrder[pluginOrder["backgroundColor"] = 1100] = "backgroundColor";
    pluginOrder[pluginOrder["backgroundImage"] = 1200] = "backgroundImage";
    pluginOrder[pluginOrder["gradientColorStops"] = 1300] = "gradientColorStops";
    pluginOrder[pluginOrder["backgroundOpacity"] = 1400] = "backgroundOpacity";
    pluginOrder[pluginOrder["backgroundPosition"] = 1500] = "backgroundPosition";
    pluginOrder[pluginOrder["backgroundRepeat"] = 1600] = "backgroundRepeat";
    pluginOrder[pluginOrder["backgroundSize"] = 1700] = "backgroundSize";
    pluginOrder[pluginOrder["backgroundOrigin"] = 1750] = "backgroundOrigin";
    pluginOrder[pluginOrder["borderCollapse"] = 1800] = "borderCollapse";
    pluginOrder[pluginOrder["borderColor"] = 1900] = "borderColor";
    pluginOrder[pluginOrder["borderOpacity"] = 2000] = "borderOpacity";
    pluginOrder[pluginOrder["borderRadius"] = 2100] = "borderRadius";
    pluginOrder[pluginOrder["borderStyle"] = 2200] = "borderStyle";
    pluginOrder[pluginOrder["borderWidth"] = 2300] = "borderWidth";
    pluginOrder[pluginOrder["boxDecorationBreak"] = 2350] = "boxDecorationBreak";
    pluginOrder[pluginOrder["boxSizing"] = 2400] = "boxSizing";
    pluginOrder[pluginOrder["cursor"] = 2500] = "cursor";
    pluginOrder[pluginOrder["captionSide"] = 2550] = "captionSide";
    pluginOrder[pluginOrder["emptyCells"] = 2560] = "emptyCells";
    pluginOrder[pluginOrder["display"] = 2600] = "display";
    pluginOrder[pluginOrder["flexBasis"] = 2699] = "flexBasis";
    pluginOrder[pluginOrder["flexDirection"] = 2700] = "flexDirection";
    pluginOrder[pluginOrder["flexWrap"] = 2800] = "flexWrap";
    pluginOrder[pluginOrder["placeItems"] = 2900] = "placeItems";
    pluginOrder[pluginOrder["placeContent"] = 3000] = "placeContent";
    pluginOrder[pluginOrder["placeSelf"] = 3100] = "placeSelf";
    pluginOrder[pluginOrder["alignItems"] = 3200] = "alignItems";
    pluginOrder[pluginOrder["alignContent"] = 3300] = "alignContent";
    pluginOrder[pluginOrder["alignSelf"] = 3400] = "alignSelf";
    pluginOrder[pluginOrder["justifyItems"] = 3500] = "justifyItems";
    pluginOrder[pluginOrder["justifyContent"] = 3600] = "justifyContent";
    pluginOrder[pluginOrder["justifySelf"] = 3700] = "justifySelf";
    pluginOrder[pluginOrder["flex"] = 3800] = "flex";
    pluginOrder[pluginOrder["flexGrow"] = 3900] = "flexGrow";
    pluginOrder[pluginOrder["flexShrink"] = 4000] = "flexShrink";
    pluginOrder[pluginOrder["order"] = 4100] = "order";
    pluginOrder[pluginOrder["float"] = 4200] = "float";
    pluginOrder[pluginOrder["clear"] = 4300] = "clear";
    pluginOrder[pluginOrder["fontFamily"] = 4400] = "fontFamily";
    pluginOrder[pluginOrder["fontWeight"] = 4500] = "fontWeight";
    pluginOrder[pluginOrder["height"] = 4600] = "height";
    pluginOrder[pluginOrder["fontSize"] = 4700] = "fontSize";
    pluginOrder[pluginOrder["lineHeight"] = 4800] = "lineHeight";
    pluginOrder[pluginOrder["listStylePosition"] = 4900] = "listStylePosition";
    pluginOrder[pluginOrder["listStyleType"] = 5000] = "listStyleType";
    pluginOrder[pluginOrder["margin"] = 5100] = "margin";
    pluginOrder[pluginOrder["maxHeight"] = 5200] = "maxHeight";
    pluginOrder[pluginOrder["maxWidth"] = 5300] = "maxWidth";
    pluginOrder[pluginOrder["minHeight"] = 5400] = "minHeight";
    pluginOrder[pluginOrder["minWidth"] = 5500] = "minWidth";
    pluginOrder[pluginOrder["objectFit"] = 5600] = "objectFit";
    pluginOrder[pluginOrder["objectPosition"] = 5700] = "objectPosition";
    pluginOrder[pluginOrder["opacity"] = 5800] = "opacity";
    pluginOrder[pluginOrder["outline"] = 5900] = "outline";
    pluginOrder[pluginOrder["overflow"] = 6000] = "overflow";
    pluginOrder[pluginOrder["overscrollBehavior"] = 6100] = "overscrollBehavior";
    pluginOrder[pluginOrder["padding"] = 6200] = "padding";
    pluginOrder[pluginOrder["placeholderColor"] = 6300] = "placeholderColor";
    pluginOrder[pluginOrder["placeholderOpacity"] = 6400] = "placeholderOpacity";
    pluginOrder[pluginOrder["caretColor"] = 6450] = "caretColor";
    pluginOrder[pluginOrder["caretOpacity"] = 6460] = "caretOpacity";
    pluginOrder[pluginOrder["tabSize"] = 6470] = "tabSize";
    pluginOrder[pluginOrder["pointerEvents"] = 6500] = "pointerEvents";
    pluginOrder[pluginOrder["position"] = 6600] = "position";
    pluginOrder[pluginOrder["inset"] = 6700] = "inset";
    pluginOrder[pluginOrder["resize"] = 6800] = "resize";
    pluginOrder[pluginOrder["boxShadow"] = 6900] = "boxShadow";
    pluginOrder[pluginOrder["boxShadowColor"] = 6950] = "boxShadowColor";
    pluginOrder[pluginOrder["ringWidth"] = 7000] = "ringWidth";
    pluginOrder[pluginOrder["ringOffsetColor"] = 7100] = "ringOffsetColor";
    pluginOrder[pluginOrder["ringOffsetWidth"] = 7200] = "ringOffsetWidth";
    pluginOrder[pluginOrder["ringColor"] = 7300] = "ringColor";
    pluginOrder[pluginOrder["ringOpacity"] = 7400] = "ringOpacity";
    pluginOrder[pluginOrder["fill"] = 7500] = "fill";
    pluginOrder[pluginOrder["stroke"] = 7600] = "stroke";
    pluginOrder[pluginOrder["strokeWidth"] = 7700] = "strokeWidth";
    pluginOrder[pluginOrder["strokeDashArray"] = 7750] = "strokeDashArray";
    pluginOrder[pluginOrder["strokeDashOffset"] = 7760] = "strokeDashOffset";
    pluginOrder[pluginOrder["tableLayout"] = 7800] = "tableLayout";
    pluginOrder[pluginOrder["textAlign"] = 7900] = "textAlign";
    pluginOrder[pluginOrder["textColor"] = 8000] = "textColor";
    pluginOrder[pluginOrder["textOpacity"] = 8100] = "textOpacity";
    pluginOrder[pluginOrder["textOverflow"] = 8200] = "textOverflow";
    pluginOrder[pluginOrder["textShadow"] = 8250] = "textShadow";
    pluginOrder[pluginOrder["fontStyle"] = 8300] = "fontStyle";
    pluginOrder[pluginOrder["textTransform"] = 8400] = "textTransform";
    pluginOrder[pluginOrder["textDecorationStyle"] = 8450] = "textDecorationStyle";
    pluginOrder[pluginOrder["textDecorationLength"] = 8455] = "textDecorationLength";
    pluginOrder[pluginOrder["textDecorationColor"] = 8460] = "textDecorationColor";
    pluginOrder[pluginOrder["textDecorationOpacity"] = 8470] = "textDecorationOpacity";
    pluginOrder[pluginOrder["textDecorationOffset"] = 8480] = "textDecorationOffset";
    pluginOrder[pluginOrder["textDecorationThickness"] = 8490] = "textDecorationThickness";
    pluginOrder[pluginOrder["textDecoration"] = 8500] = "textDecoration";
    pluginOrder[pluginOrder["textIndent"] = 8550] = "textIndent";
    pluginOrder[pluginOrder["textStrokeColor"] = 8560] = "textStrokeColor";
    pluginOrder[pluginOrder["textStrokeWidth"] = 8570] = "textStrokeWidth";
    pluginOrder[pluginOrder["content"] = 8580] = "content";
    pluginOrder[pluginOrder["fontSmoothing"] = 8600] = "fontSmoothing";
    pluginOrder[pluginOrder["fontVariantNumeric"] = 8700] = "fontVariantNumeric";
    pluginOrder[pluginOrder["letterSpacing"] = 8800] = "letterSpacing";
    pluginOrder[pluginOrder["userSelect"] = 8900] = "userSelect";
    pluginOrder[pluginOrder["verticalAlign"] = 9000] = "verticalAlign";
    pluginOrder[pluginOrder["visibility"] = 9100] = "visibility";
    pluginOrder[pluginOrder["backfaceVisibility"] = 9150] = "backfaceVisibility";
    pluginOrder[pluginOrder["whitespace"] = 9200] = "whitespace";
    pluginOrder[pluginOrder["wordBreak"] = 9300] = "wordBreak";
    pluginOrder[pluginOrder["writingMode"] = 9340] = "writingMode";
    pluginOrder[pluginOrder["hyphens"] = 9350] = "hyphens";
    pluginOrder[pluginOrder["width"] = 9400] = "width";
    pluginOrder[pluginOrder["zIndex"] = 9500] = "zIndex";
    pluginOrder[pluginOrder["isolation"] = 9550] = "isolation";
    pluginOrder[pluginOrder["gap"] = 9600] = "gap";
    pluginOrder[pluginOrder["gridAutoFlow"] = 9700] = "gridAutoFlow";
    pluginOrder[pluginOrder["gridTemplateColumns"] = 9800] = "gridTemplateColumns";
    pluginOrder[pluginOrder["gridAutoColumns"] = 9900] = "gridAutoColumns";
    pluginOrder[pluginOrder["gridColumn"] = 10000] = "gridColumn";
    pluginOrder[pluginOrder["gridColumnStart"] = 10100] = "gridColumnStart";
    pluginOrder[pluginOrder["gridColumnEnd"] = 10200] = "gridColumnEnd";
    pluginOrder[pluginOrder["gridTemplateRows"] = 10300] = "gridTemplateRows";
    pluginOrder[pluginOrder["gridAutoRows"] = 10400] = "gridAutoRows";
    pluginOrder[pluginOrder["gridRow"] = 10500] = "gridRow";
    pluginOrder[pluginOrder["gridRowStart"] = 10600] = "gridRowStart";
    pluginOrder[pluginOrder["gridRowEnd"] = 10700] = "gridRowEnd";
    pluginOrder[pluginOrder["transform"] = 10800] = "transform";
    pluginOrder[pluginOrder["transformOrigin"] = 10900] = "transformOrigin";
    pluginOrder[pluginOrder["scale"] = 11000] = "scale";
    pluginOrder[pluginOrder["rotate"] = 11100] = "rotate";
    pluginOrder[pluginOrder["translate"] = 11200] = "translate";
    pluginOrder[pluginOrder["skew"] = 11300] = "skew";
    pluginOrder[pluginOrder["perspective"] = 11350] = "perspective";
    pluginOrder[pluginOrder["perspectiveOrigin"] = 11360] = "perspectiveOrigin";
    pluginOrder[pluginOrder["transitionProperty"] = 11400] = "transitionProperty";
    pluginOrder[pluginOrder["transitionTimingFunction"] = 11500] = "transitionTimingFunction";
    pluginOrder[pluginOrder["transitionDuration"] = 11600] = "transitionDuration";
    pluginOrder[pluginOrder["transitionDelay"] = 11700] = "transitionDelay";
    pluginOrder[pluginOrder["keyframes"] = 11800] = "keyframes";
    pluginOrder[pluginOrder["animation"] = 11900] = "animation";
    pluginOrder[pluginOrder["imageRendering"] = 11950] = "imageRendering";
    pluginOrder[pluginOrder["mixBlendMode"] = 12000] = "mixBlendMode";
    pluginOrder[pluginOrder["backgroundBlendMode"] = 12100] = "backgroundBlendMode";
    pluginOrder[pluginOrder["filter"] = 12200] = "filter";
    pluginOrder[pluginOrder["blur"] = 12300] = "blur";
    pluginOrder[pluginOrder["brightness"] = 12400] = "brightness";
    pluginOrder[pluginOrder["contrast"] = 12500] = "contrast";
    pluginOrder[pluginOrder["dropShadow"] = 12600] = "dropShadow";
    pluginOrder[pluginOrder["grayscale"] = 12700] = "grayscale";
    pluginOrder[pluginOrder["hueRotate"] = 12800] = "hueRotate";
    pluginOrder[pluginOrder["invert"] = 12900] = "invert";
    pluginOrder[pluginOrder["saturate"] = 13000] = "saturate";
    pluginOrder[pluginOrder["sepia"] = 13100] = "sepia";
    pluginOrder[pluginOrder["backdropFilter"] = 13200] = "backdropFilter";
    pluginOrder[pluginOrder["backdropBlur"] = 13300] = "backdropBlur";
    pluginOrder[pluginOrder["backdropBrightness"] = 13400] = "backdropBrightness";
    pluginOrder[pluginOrder["backdropContrast"] = 13500] = "backdropContrast";
    pluginOrder[pluginOrder["backdropGrayscale"] = 13600] = "backdropGrayscale";
    pluginOrder[pluginOrder["backdropHueRotate"] = 13700] = "backdropHueRotate";
    pluginOrder[pluginOrder["backdropInvert"] = 13800] = "backdropInvert";
    pluginOrder[pluginOrder["backdropOpacity"] = 13900] = "backdropOpacity";
    pluginOrder[pluginOrder["backdropSaturate"] = 14000] = "backdropSaturate";
    pluginOrder[pluginOrder["backdropSepia"] = 14100] = "backdropSepia";
    pluginOrder[pluginOrder["willChange"] = 14200] = "willChange";
    pluginOrder[pluginOrder["touchAction"] = 14300] = "touchAction";
    pluginOrder[pluginOrder["scrollBehavior"] = 14400] = "scrollBehavior";
    pluginOrder[pluginOrder["accentColor"] = 14500] = "accentColor";
})(pluginOrder$1 || (pluginOrder$1 = {}));

function isNumberLead(i) {
    return /^\d/.test(i) ? i : undefined;
}
function notNumberLead(i) {
    return /^\d/.test(i) ? undefined : i;
}
// https://windicss.org/utilities/container.html
function container(utility, _a) {
    var theme = _a.theme;
    if (utility.raw === 'container') {
        var className = utility.class;
        var baseStyle = new Container(utility.class, new Property$3('width', '100%'));
        var paddingDefault = toType(theme('container.padding'), 'string') ? toType(theme('container.padding'), 'string') : toType(theme('container.padding.DEFAULT'), 'string');
        if (paddingDefault) {
            baseStyle.add(new Property$3('padding-left', paddingDefault));
            baseStyle.add(new Property$3('padding-right', paddingDefault));
        }
        var center = theme('container.center');
        if (center && typeof center === 'boolean') {
            baseStyle.add(new Property$3(['margin-left', 'margin-right'], 'auto'));
        }
        var output = [baseStyle];
        var screens = toType(theme('container.screens', theme('screens')), 'object');
        for (var _i = 0, _b = Object.entries(screens); _i < _b.length; _i++) {
            var _c = _b[_i], screen_1 = _c[0], size_1 = _c[1];
            if (!isString$1(size_1))
                continue;
            var props = [new Property$3('max-width', "".concat(size_1))];
            var padding_1 = theme("container.padding.".concat(screen_1));
            if (padding_1 && typeof padding_1 === 'string') {
                props.push(new Property$3('padding-left', padding_1));
                props.push(new Property$3('padding-right', padding_1));
            }
            output.push(new Container(className, props).atRule("@media (min-width: ".concat(size_1, ")")));
        }
        output.forEach(function (style) { return style.updateMeta('utilities', 'container', pluginOrder$1.container, 0, true); });
        return output;
    }
}
// https://windicss.org/utilities/positioning.html#object-position
function objectPosition(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleBody(theme('objectPosition'))
        .createProperty(['-o-object-position', 'object-position'])) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'objectPosition', pluginOrder$1.objectPosition, 0, true);
}
// https://windicss.org/utilities/positioning.html#top-right-bottom-left
function inset(utility, _a) {
    var theme = _a.theme;
    return utility.handler
        .handleStatic(theme('inset'))
        .handleSquareBrackets()
        .handleSpacing()
        .handleFraction()
        .handleSize()
        .handleNegative()
        .handleVariable()
        .callback(function (value) {
        switch (utility.identifier) {
            case 'top':
            case 'right':
            case 'bottom':
            case 'left':
                return new Property$3(utility.identifier, value).updateMeta('utilities', 'inset', pluginOrder$1.inset, 4, true);
            case 'inset':
                if (utility.raw.match(/^-?inset-x/))
                    return new Property$3(['right', 'left'], value).updateMeta('utilities', 'inset', pluginOrder$1.inset, 3, true);
                if (utility.raw.match(/^-?inset-y/))
                    return new Property$3(['top', 'bottom'], value).updateMeta('utilities', 'inset', pluginOrder$1.inset, 2, true);
                return new Property$3(['top', 'right', 'bottom', 'left'], value).updateMeta('utilities', 'inset', pluginOrder$1.inset, 1, true);
        }
    });
}
// https://windicss.org/utilities/positioning.html#z-index
function zIndex(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleStatic(theme('zIndex'))
        .handleNumber(0, 99999, 'int')
        .handleNegative()
        .handleVariable()
        .createProperty('z-index')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'zIndex', pluginOrder$1.zIndex, 0, true);
}
// https://windicss.org/utilities/flexbox.html#flex
// https://windicss.org/utilities/flexbox.html#flex-grow
// https://windicss.org/utilities/flexbox.html#flex-shrink
function flex(utility, _a) {
    var _b, _c, _d;
    var theme = _a.theme;
    var className = utility.raw;
    if (className.startsWith('flex-grow')) {
        var map = toType(theme('flexGrow'), 'object');
        var amount = className.replace(/flex-grow-?/, '') || 'DEFAULT';
        if (Object.keys(map).includes(amount))
            return new Property$3(['-webkit-box-flex', '-ms-flex-positive', '-webkit-flex-grow', 'flex-grow'], map[amount]).toStyle(utility.class).updateMeta('utilities', 'flexGrow', pluginOrder$1.flexGrow, 0, true);
        return (_b = utility.handler.handleSquareBrackets().createProperty(['-webkit-box-flex', '-ms-flex-positive', '-webkit-flex-grow', 'flex-grow'])) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'flexGrow', pluginOrder$1.flexGrow, 1, true);
    }
    else if (className.startsWith('flex-shrink')) {
        var map = toType(theme('flexShrink'), 'object');
        var amount = className.replace(/flex-shrink-?/, '') || 'DEFAULT';
        if (Object.keys(map).includes(amount))
            return new Property$3(['-ms-flex-negative', '-webkit-flex-shrink', 'flex-shrink'], map[amount]).toStyle(utility.class).updateMeta('utilities', 'flexShrink', pluginOrder$1.flexShrink, 0, true);
        return (_c = utility.handler.handleSquareBrackets().createProperty(['-ms-flex-negative', '-webkit-flex-shrink', 'flex-shrink'])) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'flexShrink', pluginOrder$1.flexShrink, 1, true);
    }
    else {
        return (_d = utility.handler.handleStatic(theme('flex')).handleSquareBrackets().createStyle(utility.class, function (value) {
            value = value.trim();
            return [
                new Property$3('-webkit-box-flex', value.startsWith('0') || value === 'none' ? '0' : '1'),
                new Property$3(['-ms-flex', '-webkit-flex', 'flex'], value),
            ];
        })) === null || _d === void 0 ? void 0 : _d.updateMeta('utilities', 'flex', pluginOrder$1.flex, 0, true);
    }
}
// https://windicss.org/utilities/flexbox.html#flex-basis
function basis(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleStatic(theme('spacing'))
        .handleNumber(1, Infinity, undefined, function (number) { return "".concat(number / 4, "rem"); })
        .handleSize()
        .handleFraction()
        .handleVariable()
        .handleSquareBrackets()
        .createProperty('flex-basis')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'flexBasis', pluginOrder$1.flexBasis, 1, true);
}
// https://windicss.org/utilities/positioning.html#order
function order$1(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleStatic(theme('order'))
        .handleNumber(1, 9999, 'int')
        .handleNegative()
        .handleVariable()
        .createStyle(utility.class, function (value) { return [
        new Property$3('-webkit-box-ordinal-group', value.includes('var') ? "calc(".concat(value, "+1)") : (parseInt(value) + 1).toString()),
        new Property$3(['-webkit-order', '-ms-flex-order', 'order'], value),
    ]; })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'order', pluginOrder$1.order, utility.raw.charAt(0) === '-' ? 2 : 1, true);
}
// https://windicss.org/utilities/grid.html#grid-template-columns
// https://windicss.org/utilities/grid.html#grid-template-rows
function gridTemplate(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    var type = utility.raw.match(/^grid-rows-/) ? 'rows' : utility.raw.match(/^grid-cols-/) ? 'columns' : undefined;
    if (!type)
        return;
    var group = type === 'rows' ? 'gridTemplateRows' : 'gridTemplateColumns';
    return ((_b = utility.handler
        .handleStatic(theme(group))
        .handleSquareBrackets(function (i) { return i.replace(/\(.*?\)|,/g, function (r) { return r === ',' ? ' ' : r; } /* ignore content inside nested-brackets */); })
        .createProperty("grid-template-".concat(type), function (value) { return value === 'none' ? 'none' : value; })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', group, pluginOrder$1[group], 1, true))
        || ((_c = utility.handler
            .handleNumber(1, undefined, 'int')
            .handleVariable()
            .createProperty("grid-template-".concat(type), function (value) { return "repeat(".concat(value, ", minmax(0, 1fr))"); })) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', group, pluginOrder$1[group], 2, true));
}
// https://windicss.org/utilities/grid.html#grid-column-span
// https://windicss.org/utilities/grid.html#grid-column-start
// https://windicss.org/utilities/grid.html#grid-column-end
function gridColumn(utility, _a) {
    var _b, _c, _d, _e;
    var theme = _a.theme;
    var body = utility.body;
    // col span
    var spans = toType(theme('gridColumn'), 'object');
    if (Object.keys(spans).includes(body))
        return new Property$3(['-ms-grid-column-span', 'grid-column'], spans[body]).updateMeta('utilities', 'gridColumn', pluginOrder$1.gridColumn, 1, true);
    if (utility.raw.startsWith('col-span')) {
        return (_b = utility.handler
            .handleNumber(1, undefined, 'int')
            .handleVariable()
            .createProperty(['-ms-grid-column-span', 'grid-column'], function (value) { return "span ".concat(value, " / span ").concat(value); })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'gridColumn', pluginOrder$1.gridColumn, 1, true);
    }
    // col end
    if (utility.raw.startsWith('col-end')) {
        return (_c = utility.handler
            .handleStatic(theme('gridColumnEnd'))
            .handleSquareBrackets()
            .handleNumber(1, undefined, 'int')
            .handleVariable()
            .createProperty('grid-column-end')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'gridColumnEnd', pluginOrder$1.gridColumnEnd, 1, true);
    }
    // col start
    if (utility.raw.startsWith('col-start')) {
        return (_d = utility.handler
            .handleStatic(theme('gridColumnStart'))
            .handleSquareBrackets()
            .handleNumber(1, undefined, 'int')
            .handleVariable()
            .createProperty('grid-column-start')) === null || _d === void 0 ? void 0 : _d.updateMeta('utilities', 'gridColumnStart', pluginOrder$1.gridColumnStart, 1, true);
    }
    return (_e = utility.handler
        .handleSquareBrackets()
        .createProperty(['-ms-grid-column-span', 'grid-column'], function (value) { return "span ".concat(value, " / span ").concat(value); })) === null || _e === void 0 ? void 0 : _e.updateMeta('utilities', 'gridColumn', pluginOrder$1.gridColumn, 1, true);
}
// https://windicss.org/utilities/grid.html#grid-row-span
// https://windicss.org/utilities/grid.html#grid-row-start
// https://windicss.org/utilities/grid.html#grid-row-end
function gridRow(utility, _a) {
    var _b, _c, _d, _e;
    var theme = _a.theme;
    var body = utility.body;
    // row span
    var spans = toType(theme('gridRow'), 'object');
    if (Object.keys(spans).includes(body))
        return new Property$3(['-ms-grid-row-span', 'grid-row'], spans[body]).updateMeta('utilities', 'gridRow', pluginOrder$1.gridRow, 1, true);
    if (utility.raw.startsWith('row-span')) {
        return (_b = utility.handler
            .handleNumber(1, undefined, 'int')
            .handleVariable()
            .createProperty(['-ms-grid-row-span', 'grid-row'], function (value) { return "span ".concat(value, " / span ").concat(value); })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'gridRow', pluginOrder$1.gridRow, 2, true);
    }
    // row end
    if (utility.raw.startsWith('row-end')) {
        return (_c = utility.handler
            .handleStatic(theme('gridRowEnd'))
            .handleSquareBrackets()
            .handleNumber(1, undefined, 'int')
            .handleVariable()
            .createProperty('grid-row-end')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'gridRowEnd', pluginOrder$1.gridRowEnd, 1, true);
    }
    // row start
    if (utility.raw.startsWith('row-start')) {
        return (_d = utility.handler
            .handleStatic(theme('gridRowStart'))
            .handleSquareBrackets()
            .handleNumber(1, undefined, 'int')
            .handleVariable()
            .createProperty('grid-row-start')) === null || _d === void 0 ? void 0 : _d.updateMeta('utilities', 'gridRowStart', pluginOrder$1.gridRowStart, 1, true);
    }
    return (_e = utility.handler
        .handleSquareBrackets()
        .createProperty(['-ms-grid-row-span', 'grid-row'], function (value) { return "span ".concat(value, " / span ").concat(value); })) === null || _e === void 0 ? void 0 : _e.updateMeta('utilities', 'gridRow', pluginOrder$1.gridRow, 2, true);
}
// https://windicss.org/utilities/grid.html#grid-auto-columns
// https://windicss.org/utilities/grid.html#grid-auto-rows
function gridAuto(utility, _a) {
    var theme = _a.theme;
    var type = utility.raw.startsWith('auto-cols') ? 'columns' : utility.raw.startsWith('auto-rows') ? 'rows' : undefined;
    if (!type)
        return;
    var group = type === 'columns' ? 'gridAutoColumns' : 'gridAutoRows';
    var value = utility.handler.handleStatic(theme(group)).value;
    if (value) {
        var prefixer = minMaxContent(value);
        if (typeof prefixer === 'string')
            return new Property$3("grid-auto-".concat(type), prefixer).updateMeta('utilities', group, pluginOrder$1[group], 1, true);
        return new Style$3(utility.class, prefixer.map(function (i) { return new Property$3("grid-auto-".concat(type), i); })).updateMeta('utilities', group, pluginOrder$1[group], 2, true);
    }
}
// https://windicss.org/utilities/grid.html#gap
function gap$1(utility, _a) {
    var theme = _a.theme, config = _a.config;
    return utility.handler
        .handleStatic(theme('gap'))
        .handleSquareBrackets()
        .handleSpacing()
        .handleSize()
        .handleVariable()
        .callback(function (value) {
        if (utility.raw.match(/^gap-x-/))
            return new Property$3(config('prefixer') ? ['-webkit-column-gap', '-moz-column-gap', 'grid-column-gap', 'column-gap'] : 'column-gap', value).updateMeta('utilities', 'gap', pluginOrder$1.gap, 2, true);
        if (utility.raw.match(/^gap-y-/))
            return new Property$3(config('prefixer') ? ['-webkit-row-gap', '-moz-row-gap', 'grid-row-gap', 'row-gap'] : 'row-gap', value).updateMeta('utilities', 'gap', pluginOrder$1.gap, 3, true);
        return new Property$3(config('prefixer') ? ['grid-gap', 'gap'] : 'gap', value).updateMeta('utilities', 'gap', pluginOrder$1.gap, 1, true);
    });
}
// https://windicss.org/utilities/columns.html
function columns(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleStatic(theme('columns'))
        .handleSquareBrackets()
        .handleSize()
        .handleNxl(function (number) { return "".concat((number - 3) * 8 + 48, "rem"); })
        .handleVariable()
        .createProperty('columns')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'columns', pluginOrder$1.columns, 1, true);
}
// https://windicss.org/utilities/spacing.html#padding
function padding(utility, _a) {
    var theme = _a.theme;
    return utility.handler
        .handleStatic(theme('padding'))
        .handleSquareBrackets()
        .handleSpacing()
        .handleFraction()
        .handleSize()
        .handleVariable()
        .callback(function (value) {
        var directions = expandDirection(utility.identifier.substring(1), false);
        if (directions) {
            if (directions[0] === '*')
                return new Property$3('padding', value).updateMeta('utilities', 'padding', pluginOrder$1.padding, -4, true);
            return new Property$3(directions.map(function (i) { return "padding-".concat(i); }), value).updateMeta('utilities', 'padding', pluginOrder$1.padding, -directions.length, true);
        }
    });
}
// https://windicss.org/utilities/spacing.html#margin
function margin(utility, _a) {
    var theme = _a.theme;
    return utility.handler
        .handleStatic(theme('margin'))
        .handleSquareBrackets()
        .handleSpacing()
        .handleFraction()
        .handleSize()
        .handleNegative()
        .handleVariable()
        .callback(function (value) {
        var directions = expandDirection(utility.identifier.substring(1), false);
        if (directions) {
            if (directions[0] === '*')
                return new Property$3('margin', value).updateMeta('utilities', 'margin', pluginOrder$1.margin, -4, true);
            return new Property$3(directions.map(function (i) { return "margin-".concat(i); }), value).updateMeta('utilities', 'margin', pluginOrder$1.margin, -directions.length, true);
        }
    });
}
// https://windicss.org/utilities/spacing.html#space-between-y
function space(utility, _a) {
    var theme = _a.theme;
    if (utility.raw === 'space-x-reverse') {
        return new Style$3(utility.class, [
            new Property$3('--tw-space-x-reverse', '1'),
        ]).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'space', pluginOrder$1.space, 6, true);
    }
    if (utility.raw === 'space-y-reverse') {
        return new Style$3(utility.class, [
            new Property$3('--tw-space-y-reverse', '1'),
        ]).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'space', pluginOrder$1.space, 5, true);
    }
    return utility.handler
        .handleStatic(theme('space'))
        .handleSquareBrackets()
        .handleSpacing()
        .handleSize()
        .handleNegative()
        .handleVariable()
        .callback(function (value) {
        if (utility.raw.match(/^-?space-x-/)) {
            return new Style$3(utility.class, [
                new Property$3('--tw-space-x-reverse', '0'),
                new Property$3('margin-right', "calc(".concat(value, " * var(--tw-space-x-reverse))")),
                new Property$3('margin-left', "calc(".concat(value, " * calc(1 - var(--tw-space-x-reverse)))")),
            ]).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'space', pluginOrder$1.space, (utility.raw.charAt(0) === '-' ? 4 : 2), true);
        }
        if (utility.raw.match(/^-?space-y-/)) {
            return new Style$3(utility.class, [
                new Property$3('--tw-space-y-reverse', '0'),
                new Property$3('margin-top', "calc(".concat(value, " * calc(1 - var(--tw-space-y-reverse)))")),
                new Property$3('margin-bottom', "calc(".concat(value, " * var(--tw-space-y-reverse))")),
            ]).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'space', pluginOrder$1.space, (utility.raw.charAt(0) === '-' ? 3 : 1), true);
        }
    });
}
// https://windicss.org/utilities/sizing.html#width
// https://windicss.org/utilities/sizing.html#height
function size(utility, _a) {
    var _b;
    var theme = _a.theme;
    var name = utility.identifier === 'w' ? 'width' : 'height';
    var body = utility.body;
    var sizes = toType(theme(name), 'object');
    // handle static
    if (Object.keys(sizes).includes(body)) {
        var value = sizes[body];
        if (value === 'min-content') {
            return new Style$3(utility.class, [
                new Property$3(name, '-webkit-min-content'),
                new Property$3(name, '-moz-min-content'),
                new Property$3(name, 'min-content'),
            ]).updateMeta('utilities', name, pluginOrder$1[name], 2, true);
        }
        if (value === 'max-content') {
            return new Style$3(utility.class, [
                new Property$3(name, '-webkit-max-content'),
                new Property$3(name, '-moz-max-content'),
                new Property$3(name, 'max-content'),
            ]).updateMeta('utilities', name, pluginOrder$1[name], 3, true);
        }
        return new Style$3(utility.class, new Property$3(name, value)).updateMeta('utilities', name, pluginOrder$1[name], 1, true);
    }
    return (_b = utility.handler
        .handleSquareBrackets()
        .handleSpacing()
        .handleFraction()
        .handleSize()
        .handleNxl(function (number) { return "".concat((number - 3) * 8 + 48, "rem"); })
        .handleVariable()
        .createProperty(name)) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', name, pluginOrder$1[name], 4, true);
}
// https://windicss.org/utilities/sizing.html#min-width
// https://windicss.org/utilities/sizing.html#min-height
// https://windicss.org/utilities/sizing.html#max-width
// https://windicss.org/utilities/sizing.html#max-height
function minMaxSize(utility, _a) {
    var _b;
    var theme = _a.theme;
    if (!utility.raw.match(/^(min|max)-[w|h]-/))
        return;
    var body = utility.raw.replace(/^(min|max)-[w|h]-/, '');
    var prop = utility.raw.substring(0, 5).replace('h', 'height').replace('w', 'width');
    var group = dashToCamel(prop);
    var sizes = toType(theme(group), 'object');
    // handle static
    if (Object.keys(sizes).includes(body)) {
        var value = sizes[body];
        if (value === 'min-content') {
            return new Style$3(utility.class, [
                new Property$3(prop, '-webkit-min-content'),
                new Property$3(prop, '-moz-min-content'),
                new Property$3(prop, 'min-content'),
            ]).updateMeta('utilities', group, pluginOrder$1[group], 2, true);
        }
        if (value === 'max-content') {
            return new Style$3(utility.class, [
                new Property$3(prop, '-webkit-max-content'),
                new Property$3(prop, '-moz-max-content'),
                new Property$3(prop, 'max-content'),
            ]).updateMeta('utilities', group, pluginOrder$1[group], 3, true);
        }
        return new Style$3(utility.class, new Property$3(prop, value)).updateMeta('utilities', group, pluginOrder$1[group], 1, true);
    }
    return (_b = utility.handler
        .handleSquareBrackets()
        .handleSpacing()
        .handleFraction()
        .handleSize()
        .handleNxl(function (number) { return "".concat((number - 3) * 8 + 48, "rem"); })
        .handleVariable()
        .createProperty(prop)) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', group, pluginOrder$1[group], 4, true);
}
// https://windicss.org/utilities/typography.html#text-opacity
// https://windicss.org/utilities/typography.html#text-shadow
// https://windicss.org/utilities/typography.html#text-stroke
// https://windicss.org/utilities/typography.html#text-color
// https://windicss.org/utilities/typography.html#font-size
function text$2(utility, _a) {
    var _b, _c, _d, _e, _f, _g;
    var theme = _a.theme;
    // handle font opacity
    if (utility.raw.startsWith('text-opacity')) {
        return (_b = utility.handler
            .handleStatic(theme('textOpacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-text-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'textOpacity', pluginOrder$1.textOpacity, 1, true);
    }
    if (utility.raw.startsWith('text-shadow')) {
        return (_c = (utility.raw === 'text-shadow'
            ? new Property$3('text-shadow', theme('textShadow.DEFAULT', '0px 0px 1px rgb(0 0 0 / 20%), 0px 0px 1px rgb(1 0 5 / 10%)'))
            : utility.handler
                .handleStatic(theme('textShadow'))
                .createProperty('text-shadow'))) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'textShadow', pluginOrder$1.textShadow, 1, true);
    }
    if (utility.raw.startsWith('text-stroke')) {
        if (utility.raw === 'text-stroke')
            return new Style$3('text-stroke', [
                new Property$3('-webkit-text-stroke-color', theme('textStrokeColor.DEFAULT', '#e4e4e7')),
                new Property$3('-webkit-text-stroke-width', theme('textStrokeWidth.DEFAULT', 'medium')),
            ]).updateMeta('utilities', 'textStrokeColor', pluginOrder$1.textStrokeColor, 1, true);
        if (utility.raw.startsWith('text-stroke-opacity')) {
            return (_d = utility.handler
                .handleStatic(theme('opacity'))
                .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
                .handleVariable()
                .createProperty('--tw-ring-offset-opacity')) === null || _d === void 0 ? void 0 : _d.updateMeta('utilities', 'textStrokeColor', pluginOrder$1.textStrokeColor, 3, true);
        }
        return ((_e = utility.clone('textStroke' + utility.raw.slice(11)).handler
            .handleColor(theme('textStrokeColor'))
            .handleOpacity(theme('opacity'))
            .handleVariable()
            .createColorStyle(utility.class, '-webkit-text-stroke-color', '--tw-text-stroke-opacity')) === null || _e === void 0 ? void 0 : _e.updateMeta('utilities', 'textStrokeColor', pluginOrder$1.textStrokeColor, 2, true))
            || ((_f = utility.handler
                .handleStatic(theme('textStrokeWidth'))
                .handleNumber(0, undefined, 'int', function (number) { return "".concat(number, "px"); })
                .handleSize()
                .createProperty('-webkit-text-stroke-width')) === null || _f === void 0 ? void 0 : _f.updateMeta('utilities', 'textStrokeWidth', pluginOrder$1.textStrokeWidth, 1, true));
    }
    // handle text colors
    var textColor = (_g = utility.handler
        .handleColor(theme('textColor'))
        .handleOpacity(theme('textOpacity'))
        .handleSquareBrackets(notNumberLead)
        .handleVariable()
        .createColorStyle(utility.class, 'color', '--tw-text-opacity')) === null || _g === void 0 ? void 0 : _g.updateMeta('utilities', 'textColor', pluginOrder$1.textColor, 0, true);
    if (textColor)
        return textColor;
    // handle font sizes
    var amount = utility.amount;
    var fontSizes = toType(theme('fontSize'), 'object');
    if (Object.keys(fontSizes).includes(amount))
        return new Style$3(utility.class, generateFontSize(fontSizes[amount])).updateMeta('utilities', 'fontSize', pluginOrder$1.fontSize, 1, true);
    var value = utility.handler
        .handleSquareBrackets(isNumberLead)
        .handleNxl(function (number) { return "".concat(number, "rem"); })
        .handleSize()
        .value;
    if (utility.raw.startsWith('text-size-$'))
        value = utility.handler.handleVariable().value;
    if (value)
        return new Style$3(utility.class, [new Property$3('font-size', value), new Property$3('line-height', '1')]).updateMeta('utilities', 'fontSize', pluginOrder$1.fontSize, 2, true);
}
// https://windicss.org/utilities/typography.html#font-family
// https://windicss.org/utilities/typography.html#font-weight
function font(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    var fonts = theme('fontFamily');
    var map = {};
    for (var _i = 0, _d = Object.entries(fonts); _i < _d.length; _i++) {
        var _e = _d[_i], key = _e[0], value = _e[1];
        map[key] = Array.isArray(value) ? value.join(',') : value;
    }
    return (((_b = utility.handler
        .handleStatic(map)
        .createProperty('font-family')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'fontFamily', pluginOrder$1.fontFamily, 1, true))
        || ((_c = utility.handler
            .handleStatic(theme('fontWeight'))
            .handleNumber(0, 900, 'int')
            .handleVariable()
            .createProperty('font-weight')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'fontWeight', pluginOrder$1.fontWeight, 1, true)));
}
// https://windicss.org/utilities/typography.html#letter-spacing
function letterSpacing(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleStatic(theme('letterSpacing'))
        .handleSquareBrackets()
        .handleSize()
        .handleNegative()
        .handleVariable()
        .createProperty('letter-spacing')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'letterSpacing', pluginOrder$1.letterSpacing, 1, true);
}
// https://windicss.org/utilities/typography.html#text-decoration
function textDecoration(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    return (
    // .decoration-{color}/{opacity}
    ((_b = utility.handler
        .handleColor(theme('textDecorationColor'))
        .handleOpacity(theme('textDecorationOpacity'))
        .handleSquareBrackets(notNumberLead)
        .handleVariable()
        .createColorStyle(utility.class, ['-webkit-text-decoration-color', 'text-decoration-color'], '--tw-text-decoration-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'textDecorationColor', pluginOrder$1.textDecorationColor, 1, true))
        // .decoration-{thickness}
        || ((_c = utility.handler
            .handleStatic(theme('textDecorationThickness'))
            .handleNumber(0, undefined, 'int', function (number) { return "".concat(number, "px"); })
            .handleSize()
            .createProperty('text-decoration-thickness')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'textDecorationThickness', pluginOrder$1.textDecorationThickness, 1, true)));
}
// https://windicss.org/utilities/typography.html#text-decoration
function textUnderline(utility, _a) {
    var _b, _c, _d, _e;
    var theme = _a.theme;
    // .underline-offset-{offset}
    if (utility.raw.startsWith('underline-offset')) {
        return (_b = utility.handler
            .handleStatic(theme('textDecorationOffset'))
            .handleNumber(0, undefined, 'int', function (number) { return "".concat(number, "px"); })
            .handleSize()
            .createProperty('text-underline-offset')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'textDecorationOffset', pluginOrder$1.textDecorationOffset, 1, true);
    }
    // .underline-opacity-{opacity} - This is a fallback for .decoration-{color}/{opacity}
    if (utility.raw.startsWith('underline-opacity')) {
        return (_c = utility.handler
            .handleStatic(theme('textDecorationOpacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-line-opacity')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'textDecorationOpacity', pluginOrder$1.textDecorationOpacity, 1, true);
    }
    // .underline-{color} - This is a fallback for .decoration-{color} to avoid breaking changes
    // .underline-{thickness} - This is a fallback for .decoration-{thickness} to avoid breaking changes
    return ((_d = utility.handler
        .handleColor(theme('textDecorationColor'))
        .handleOpacity(theme('opacity'))
        .handleVariable()
        .createColorStyle(utility.class, ['-webkit-text-decoration-color', 'text-decoration-color'], '--tw-line-opacity')) === null || _d === void 0 ? void 0 : _d.updateMeta('utilities', 'textDecorationColor', pluginOrder$1.textDecorationColor, 0, true))
        || ((_e = utility.handler
            .handleStatic(theme('textDecorationLength'))
            .handleNumber(0, undefined, 'int', function (number) { return "".concat(number, "px"); })
            .handleSize()
            .createProperty('text-decoration-thickness')) === null || _e === void 0 ? void 0 : _e.updateMeta('utilities', 'textDecorationLength', pluginOrder$1.textDecorationLength, 1, true));
}
// https://windicss.org/utilities/typography.html#line-height
function lineHeight(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleStatic(theme('lineHeight'))
        .handleNumber(0, undefined, 'int', function (number) { return "".concat(number * 0.25, "rem"); })
        .handleSquareBrackets()
        .handleSize()
        .handleVariable()
        .createProperty('line-height')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'lineHeight', pluginOrder$1.lineHeight, 1, true);
}
// https://windicss.org/utilities/behaviors.html#list-style-type
function listStyleType(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleBody(theme('listStyleType'))
        .createProperty('list-style-type')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'listStyleType', pluginOrder$1.listStyleType, 1, true);
}
// https://windicss.org/utilities/behaviors.html#placeholder-color
// https://windicss.org/utilities/behaviors.html#placeholder-opacity
function placeholder(utility, _a) {
    var theme = _a.theme, config = _a.config;
    // handle placeholder opacity
    if (utility.raw.startsWith('placeholder-opacity')) {
        return utility.handler
            .handleStatic(theme('placeholderOpacity'))
            .handleSquareBrackets()
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .callback(function (value) { return generatePlaceholder(utility.class, new Property$3('--tw-placeholder-opacity', value), config('prefixer'))
            .map(function (style) { return style.updateMeta('utilities', 'placeholderOpacity', pluginOrder$1.placeholderOpacity, 1, true); }); });
    }
    var color = utility.handler
        .handleColor(theme('placeholderColor'))
        .handleOpacity(theme('placeholderOpacity'))
        .handleSquareBrackets()
        .handleVariable()
        .createColorStyle(utility.class, 'color', '--tw-placeholder-opacity');
    if (color)
        return generatePlaceholder(color.selector || '', color.property, config('prefixer')).map(function (i) { return i.updateMeta('utilities', 'placeholderColor', pluginOrder$1.placeholderColor, 2, true); });
}
// https://windicss.org/utilities/behaviors.html#caret-color
// https://windicss.org/utilities/behaviors.html#caret-opacity
function caret$1(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    // handle caret opacity
    if (utility.raw.startsWith('caret-opacity')) {
        return (_b = utility.handler
            .handleStatic(theme('caretOpacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-caret-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'caretOpacity', pluginOrder$1.caretOpacity, 1, true);
    }
    return (_c = utility.handler
        .handleColor(theme('caretColor'))
        .handleOpacity(theme('caretOpacity'))
        .handleVariable()
        .createColorStyle(utility.class, 'caret-color', '--tw-caret-opacity')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'caretColor', pluginOrder$1.caretColor, 0, true);
}
// https://windicss.org/utilities/typography.html#tab-size
function tabSize(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleStatic(theme('tabSize'))
        .handleNumber(0, undefined, 'int')
        .handleSize()
        .createProperty(['-moz-tab-size', '-o-tab-size', 'tab-size'])) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'tabSize', pluginOrder$1.tabSize, 1, true);
}
// https://windicss.org/utilities/typography.html#text-indent
function textIndent(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleStatic(theme('textIndent'))
        .handleSize()
        .handleFraction()
        .handleNegative()
        .createProperty('text-indent')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'textIndent', pluginOrder$1.textIndent, 1, true);
}
// https://windicss.org/utilities/backgrounds.html#background-color
// https://windicss.org/utilities/backgrounds.html#background-opacity
// https://windicss.org/utilities/backgrounds.html#background-position
// https://windicss.org/utilities/backgrounds.html#background-size
// https://windicss.org/utilities/backgrounds.html#background-image
function background(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    var body = utility.body;
    // handle background positions
    var positions = toType(theme('backgroundPosition'), 'object');
    if (Object.keys(positions).includes(body))
        return new Property$3('background-position', positions[body]).updateMeta('utilities', 'backgroundPosition', pluginOrder$1.backgroundPosition, 1, true);
    // handle background sizes
    var sizes = toType(theme('backgroundSize'), 'object');
    if (Object.keys(sizes).includes(body))
        return new Property$3('background-size', sizes[body]).updateMeta('utilities', 'backgroundSize', pluginOrder$1.backgroundSize, 1, true);
    // handle background image
    var images = toType(theme('backgroundImage'), 'object');
    if (Object.keys(images).includes(body)) {
        var prefixer = linearGradient(images[body]);
        if (Array.isArray(prefixer))
            return new Style$3(utility.class, prefixer.map(function (i) { return new Property$3('background-image', i); })).updateMeta('utilities', 'backgroundImage', pluginOrder$1.backgroundImage, 2, true);
        return new Property$3('background-image', prefixer).updateMeta('utilities', 'backgroundImage', pluginOrder$1.backgroundImage, 1, true);
    }
    // handle background opacity
    if (utility.raw.startsWith('bg-opacity'))
        return (_b = utility.handler
            .handleStatic(theme('backgroundOpacity'))
            .handleSquareBrackets()
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-bg-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'backgroundOpacity', pluginOrder$1.backgroundOpacity, 1, true);
    // handle background color
    return (_c = utility.handler
        .handleColor(theme('backgroundColor'))
        .handleOpacity(theme('backgroundOpacity'))
        .handleSquareBrackets(notNumberLead)
        .handleVariable()
        .createColorStyle(utility.class, 'background-color', '--tw-bg-opacity')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'backgroundColor', pluginOrder$1.backgroundColor, 0, true);
}
// https://windicss.org/utilities/backgrounds.html#gradient-from
function gradientColorFrom(utility, _a) {
    var _b;
    var theme = _a.theme;
    if (utility.raw.startsWith('from-opacity')) {
        return (_b = utility.handler
            .handleStatic(theme('opacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-from-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'gradientColorStops', pluginOrder$1.gradientColorStops, 2, true);
    }
    var handler = utility.handler.handleColor(theme('gradientColorStops')).handleOpacity(theme('opacity')).handleVariable().handleSquareBrackets();
    if (handler.color || handler.value) {
        return new Style$3(utility.class, [
            new Property$3('--tw-gradient-from', handler.createColorValue('var(--tw-from-opacity, 1)')),
            new Property$3('--tw-gradient-stops', 'var(--tw-gradient-from), var(--tw-gradient-to, rgba(255, 255, 255, 0))'),
        ]).updateMeta('utilities', 'gradientColorStops', pluginOrder$1.gradientColorStops, 1, true);
    }
}
// https://windicss.org/utilities/backgrounds.html#gradient-via
function gradientColorVia(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    if (utility.raw.startsWith('via-opacity')) {
        return (_b = utility.handler
            .handleStatic(theme('opacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-via-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'gradientColorStops', pluginOrder$1.gradientColorStops, 4, true);
    }
    var handler = utility.handler.handleColor(theme('gradientColorStops')).handleOpacity(theme('opacity')).handleVariable().handleSquareBrackets();
    if (handler.color || handler.value) {
        return (_c = new Style$3(utility.class, new Property$3('--tw-gradient-stops', "var(--tw-gradient-from), ".concat(handler.createColorValue('var(--tw-via-opacity, 1)'), ", var(--tw-gradient-to, rgba(255, 255, 255, 0))")))) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'gradientColorStops', pluginOrder$1.gradientColorStops, 3, true);
    }
}
// https://windicss.org/utilities/backgrounds.html#gradient-to
function gradientColorTo(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    if (utility.raw.startsWith('to-opacity')) {
        return (_b = utility.handler
            .handleStatic(theme('opacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-to-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'gradientColorStops', pluginOrder$1.gradientColorStops, 6, true);
    }
    var handler = utility.handler.handleColor(theme('gradientColorStops')).handleOpacity(theme('opacity')).handleVariable().handleSquareBrackets();
    if (handler.color || handler.value) {
        return (_c = new Style$3(utility.class, new Property$3('--tw-gradient-to', handler.createColorValue('var(--tw-to-opacity, 1)')))) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'gradientColorStops', pluginOrder$1.gradientColorStops, 5, true);
    }
}
// https://windicss.org/utilities/borders.html#border-radius
function borderRadius(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    var raw = ['rounded', 'rounded-t', 'rounded-l', 'rounded-r', 'rounded-b', 'rounded-tl', 'rounded-tr', 'rounded-br', 'rounded-bl'].includes(utility.raw) ? utility.raw + '-DEFAULT' : utility.raw;
    utility = utility.clone(raw);
    var directions = expandDirection(((_b = raw.match(/rounded-[trbl][trbl]?-/)) === null || _b === void 0 ? void 0 : _b[0].slice(8, -1)) || '', true);
    if (!directions)
        return;
    return (_c = utility.handler
        .handleStatic(theme('borderRadius'))
        .handleSquareBrackets()
        .handleFraction()
        .handleNxl(function (number) { return "".concat(number * 0.5, "rem"); })
        .handleSize()
        .handleVariable()
        .createProperty(directions[0] === '*' ? 'border-radius' : directions.map(function (i) { return "border-".concat(i, "-radius"); }))) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'borderRadius', pluginOrder$1.borderRadius, -(directions[0] === '*' ? 3 : directions.length), true);
}
// https://windicss.org/utilities/borders.html#border-width
// https://windicss.org/utilities/borders.html#border-color
// https://windicss.org/utilities/borders.html#border-opacity
function border(utility, _a) {
    var _b, _c, _d, _e, _f, _g;
    var theme = _a.theme;
    // handle border opacity
    if (utility.raw.startsWith('border-opacity')) {
        return (_b = utility.handler
            .handleStatic(theme('borderOpacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-border-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'borderOpacity', pluginOrder$1.borderOpacity, 1, true);
    }
    // handle border color
    var borderColor = (_c = utility.handler
        .handleColor(theme('borderColor'))
        .handleOpacity(theme('borderOpacity'))
        .handleSquareBrackets(notNumberLead)
        .handleVariable(function (variable) { return utility.raw.startsWith('border-$') ? "var(--".concat(variable, ")") : undefined; })
        .createColorStyle(utility.class, 'border-color', '--tw-border-opacity')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'borderColor', pluginOrder$1.borderColor, 2, true);
    if (borderColor)
        return borderColor;
    // handle border width
    var directions = (_d = expandDirection(utility.raw.substring(7, 8), false)) !== null && _d !== void 0 ? _d : ['*'];
    var borders = toType(theme('borderWidth'), 'object');
    var raw = ['border', 'border-t', 'border-r', 'border-b', 'border-l', 'border-x', 'border-y'].includes(utility.raw) ? "".concat(utility.raw, "-").concat((_e = borders.DEFAULT) !== null && _e !== void 0 ? _e : '1px') : utility.raw;
    // handle border side color
    var borderSide = utility.clone(raw.slice(7)).handler
        .handleColor(theme('borderColor'))
        .handleOpacity(theme('borderOpacity'));
    if (borderSide.value || borderSide.color) {
        if (borderSide.opacity) {
            return new Property$3("border-".concat(directions[0], "-color"), borderSide.createColorValue(borderSide.opacity)).updateMeta('utilities', 'borderColor', pluginOrder$1.borderColor, 4, true);
        }
        return (_f = borderSide.createColorStyle(utility.class, "border-".concat(directions[0], "-color"), '--tw-border-opacity')) === null || _f === void 0 ? void 0 : _f.updateMeta('utilities', 'borderColor', pluginOrder$1.borderColor, 3, true);
    }
    utility = utility.clone(raw);
    return (_g = utility.handler
        .handleStatic(borders)
        .handleSquareBrackets()
        .handleNumber(0, undefined, 'int', function (number) { return /^border(-[tlbrxy])?$/.test(utility.key) ? "".concat(number, "px") : undefined; })
        .handleSize()
        .handleVariable()
        .createProperty(directions[0] === '*' ? 'border-width' : directions.map(function (i) { return "border-".concat(i, "-width"); }))) === null || _g === void 0 ? void 0 : _g.updateMeta('utilities', 'borderWidth', pluginOrder$1.borderWidth, (directions[0] === '*' ? 1 : (directions.length + 1)), true);
}
// https://windicss.org/utilities/borders.html#divide-width
// https://windicss.org/utilities/borders.html#divide-color
// https://windicss.org/utilities/borders.html#divide-opacity
// https://windicss.org/utilities/borders.html#divide-style
function divide$2(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    // handle divide style
    if (['solid', 'dashed', 'dotted', 'double', 'none'].includes(utility.amount))
        return new Property$3('border-style', utility.amount).toStyle(utility.class).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'divideStyle', pluginOrder$1.divideStyle, 1, true);
    // handle divide opacity
    if (utility.raw.startsWith('divide-opacity'))
        return (_b = utility.handler
            .handleStatic(theme('divideOpacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-divide-opacity')) === null || _b === void 0 ? void 0 : _b.toStyle(utility.class).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'divideOpacity', pluginOrder$1.divideOpacity, 1, true);
    // handle divide color
    var divideColor = (_c = utility.handler
        .handleColor(theme('divideColor'))
        .handleOpacity(theme('divideOpacity'))
        .handleVariable(function (variable) { return utility.raw.startsWith('divide-$') ? "var(--".concat(variable, ")") : undefined; })
        .createColorStyle(utility.class, 'border-color', '--tw-divide-opacity')) === null || _c === void 0 ? void 0 : _c.child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'divideColor', pluginOrder$1.divideColor, 0, true);
    if (divideColor)
        return divideColor;
    // handle divide width
    switch (utility.raw) {
        case 'divide-x-reverse':
            return new Style$3(utility.class, new Property$3('--tw-divide-x-reverse', '1')).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'divideWidth', pluginOrder$1.divideWidth, 6, true);
        case 'divide-y-reverse':
            return new Style$3(utility.class, new Property$3('--tw-divide-y-reverse', '1')).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'divideWidth', pluginOrder$1.divideWidth, 5, true);
        case 'divide-y':
            return new Style$3(utility.class, [
                new Property$3('--tw-divide-y-reverse', '0'),
                new Property$3('border-top-width', 'calc(1px * calc(1 - var(--tw-divide-y-reverse)))'),
                new Property$3('border-bottom-width', 'calc(1px * var(--tw-divide-y-reverse))'),
            ]).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'divideWidth', pluginOrder$1.divideWidth, 3, true);
        case 'divide-x':
            return new Style$3(utility.class, [
                new Property$3('--tw-divide-x-reverse', '0'),
                new Property$3('border-right-width', 'calc(1px * var(--tw-divide-x-reverse))'),
                new Property$3('border-left-width', 'calc(1px * calc(1 - var(--tw-divide-x-reverse)))'),
            ]).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'divideWidth', pluginOrder$1.divideWidth, 4, true);
    }
    return utility.handler
        .handleSquareBrackets()
        .handleNumber(0, undefined, 'float', function (number) { return "".concat(number, "px"); })
        .handleSize()
        .handleVariable()
        .callback(function (value) {
        var centerMatch = utility.raw.match(/^-?divide-[x|y]/);
        if (centerMatch) {
            var center = centerMatch[0].replace(/^-?divide-/, '');
            switch (center) {
                case 'x':
                    return new Style$3(utility.class, [
                        new Property$3('--tw-divide-x-reverse', '0'),
                        new Property$3('border-right-width', "calc(".concat(value, " * var(--tw-divide-x-reverse))")),
                        new Property$3('border-left-width', "calc(".concat(value, " * calc(1 - var(--tw-divide-x-reverse)))")),
                    ]).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'divideWidth', pluginOrder$1.divideWidth, 2, true);
                case 'y':
                    return new Style$3(utility.class, [
                        new Property$3('--tw-divide-y-reverse', '0'),
                        new Property$3('border-top-width', "calc(".concat(value, " * calc(1 - var(--tw-divide-y-reverse)))")),
                        new Property$3('border-bottom-width', "calc(".concat(value, " * var(--tw-divide-y-reverse))")),
                    ]).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'divideWidth', pluginOrder$1.divideWidth, 1, true);
            }
        }
    });
}
// https://windicss.org/utilities/borders.html#ring-offset-width
// https://windicss.org/utilities/borders.html#ring-offset-color
function ringOffset(utility, _a) {
    var _b, _c, _d;
    var theme = _a.theme;
    var value;
    // handle ring offset width variable
    if (utility.raw.startsWith('ringOffset-width-$')) {
        value = utility.handler.handleVariable().value;
        if (value)
            return new Property$3('--tw-ring-offset-width', value).toStyle(utility.class.replace('ringOffset', 'ring-offset')).updateMeta('utilities', 'ringOffsetWidth', pluginOrder$1.ringOffsetWidth, 2, true);
    }
    if (utility.raw.startsWith('ringOffset-opacity')) {
        return (_b = utility.handler
            .handleStatic(theme('opacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-ring-offset-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'ringOffsetColor', pluginOrder$1.ringOffsetColor, 2, true);
    }
    // handle ring offset color || ring offset width
    return ((_c = utility.handler
        .handleColor(theme('ringOffsetColor'))
        .handleOpacity('ringOpacity')
        .handleVariable()
        .handleSquareBrackets()
        .createColorStyle(utility.class.replace('ringOffset', 'ring-offset'), '--tw-ring-offset-color', '--tw-ring-offset-opacity')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'ringOffsetColor', pluginOrder$1.ringOffsetColor, 1, true))
        || ((_d = utility.handler
            .handleStatic(theme('ringOffsetWidth'))
            .handleSquareBrackets(isNumberLead)
            .handleNumber(0, undefined, 'float', function (number) { return "".concat(number, "px"); })
            .handleSize()
            .createStyle(utility.class.replace('ringOffset', 'ring-offset'), function (value) { return new Property$3('--tw-ring-offset-width', value); })) === null || _d === void 0 ? void 0 : _d.updateMeta('utilities', 'ringOffsetWidth', pluginOrder$1.ringOffsetWidth, 1, true));
}
// https://windicss.org/utilities/borders.html#ring-width
// https://windicss.org/utilities/borders.html#ring-color
// https://windicss.org/utilities/borders.html#ring-opacity
function ring$1(utility, utils) {
    var _a, _b, _c;
    // handle ring offset
    if (utility.raw.startsWith('ring-offset'))
        return ringOffset(utility.clone(utility.raw.replace('ring-offset', 'ringOffset')), utils);
    // handle ring opacity
    if (utility.raw.startsWith('ring-opacity'))
        return (_a = utility.handler
            .handleStatic(utils.theme('ringOpacity'))
            .handleSquareBrackets()
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-ring-opacity')) === null || _a === void 0 ? void 0 : _a.updateMeta('utilities', 'ringOpacity', pluginOrder$1.ringOpacity, 1, true);
    // handle ring color
    var ringColor = (_b = utility.handler
        .handleColor(utils.theme('ringColor'))
        .handleOpacity(utils.theme('ringOpacity'))
        .handleSquareBrackets(notNumberLead)
        .handleVariable(function (variable) { return utility.raw.startsWith('ring-$') ? "var(--".concat(variable, ")") : undefined; })
        .createColorStyle(utility.class, '--tw-ring-color', '--tw-ring-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'ringColor', pluginOrder$1.ringColor, 0, true);
    if (ringColor)
        return ringColor;
    // handle ring width
    if (utility.raw === 'ring-inset')
        return new Property$3('--tw-ring-inset', 'inset').updateMeta('utilities', 'ringWidth', pluginOrder$1.ringWidth, 3, true);
    var value = utility.raw === 'ring'
        ? ((_c = toType(utils.theme('ringWidth.DEFAULT'), 'string')) !== null && _c !== void 0 ? _c : '3px')
        : utility.handler
            .handleStatic(utils.theme('ringWidth'))
            .handleSquareBrackets()
            .handleNumber(0, undefined, 'float', function (number) { return "".concat(number, "px"); })
            .handleSize()
            .handleVariable()
            .value;
    if (!value)
        return;
    return new Style$3(utility.class, [
        new Property$3('--tw-ring-offset-shadow', 'var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)'),
        new Property$3('--tw-ring-shadow', "var(--tw-ring-inset) 0 0 0 calc(".concat(value, " + var(--tw-ring-offset-width)) var(--tw-ring-color)")),
        new Property$3(['-webkit-box-shadow', 'box-shadow'], 'var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)'),
    ]).updateMeta('utilities', 'ringWidth', pluginOrder$1.ringWidth, (utility.raw === 'ring' ? 1 : 2), true);
}
// https://windicss.org/utilities/filters.html#filter-blur
function blur(utility, _a) {
    var _b;
    var theme = _a.theme;
    if (utility.raw === 'blur')
        utility.raw = 'blur-DEFAULT';
    return (_b = utility.handler
        .handleBody(theme('blur'))
        .handleSquareBrackets()
        .handleNumber(0, undefined, 'int', function (number) { return "".concat(number, "px"); })
        .handleSize()
        .createProperty('--tw-blur', function (value) { return "blur(".concat(value, ")"); })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'blur', pluginOrder$1.blur, 1, true);
}
// https://windicss.org/utilities/filters.html#filter-brightness
function brightness(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleBody(theme('brightness'))
        .handleSquareBrackets()
        .handleNumber(0, undefined, 'int', function (number) { return "".concat(number / 100); })
        .createProperty('--tw-brightness', function (value) { return "brightness(".concat(value, ")"); })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'brightness', pluginOrder$1.brightness, 1, true);
}
// https://windicss.org/utilities/filters.html#filter-contrast
function contrast(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleBody(theme('contrast'))
        .handleSquareBrackets()
        .handleNumber(0, undefined, 'int', function (number) { return "".concat(number / 100); })
        .createProperty('--tw-contrast', function (value) { return "contrast(".concat(value, ")"); })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'contrast', pluginOrder$1.contrast, 1, true);
}
// https://windicss.org/utilities/filters.html#filter-drop-shadow
function dropShadow(utility, _a) {
    var theme = _a.theme;
    var value;
    if (utility.raw === 'drop-shadow') {
        value = theme('dropShadow.DEFAULT', ['0 1px 2px rgba(0, 0, 0, 0.1)', '0 1px 1px rgba(0, 0, 0, 0.06)']);
    }
    else {
        var dropShadows = theme('dropShadow');
        var amount = utility.amount;
        if (utility.raw.startsWith('drop-shadow') && amount in dropShadows)
            value = dropShadows[amount];
    }
    if (value)
        return new Property$3('--tw-drop-shadow', Array.isArray(value) ? value.map(function (i) { return "drop-shadow(".concat(i, ")"); }).join(' ') : "drop-shadow(".concat(value, ")")).updateMeta('utilities', 'dropShadow', pluginOrder$1.dropShadow, 1, true);
}
// https://windicss.org/utilities/filters.html#filter-grayscale
function grayscale(utility, _a) {
    var _b;
    var theme = _a.theme;
    if (utility.raw === 'grayscale')
        utility.raw = 'grayscale-DEFAULT';
    return (_b = utility.handler
        .handleBody(theme('grayscale'))
        .handleSquareBrackets()
        .handleNumber(0, 100, 'int', function (number) { return "".concat(number / 100); })
        .createProperty('--tw-grayscale', function (value) { return "grayscale(".concat(value, ")"); })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'grayscale', pluginOrder$1.grayscale, 1, true);
}
// https://windicss.org/utilities/filters.html#filter-hue-rotate
function hueRotate(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleBody(theme('hueRotate'))
        .handleSquareBrackets()
        .handleNumber(0, undefined, 'float', function (number) { return "".concat(number, "deg"); })
        .handleNegative()
        .createProperty('--tw-hue-rotate', function (value) { return "hue-rotate(".concat(value, ")"); })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'hueRotate', pluginOrder$1.hueRotate, 1, true);
}
// https://windicss.org/utilities/filters.html#filter-invert
function invert(utility, _a) {
    var _b;
    var theme = _a.theme;
    if (utility.raw === 'invert')
        utility.raw = 'invert-DEFAULT';
    return (_b = utility.handler
        .handleBody(theme('invert'))
        .handleSquareBrackets()
        .handleNumber(0, 100, 'int', function (number) { return "".concat(number / 100); })
        .createProperty('--tw-invert', function (value) { return "invert(".concat(value, ")"); })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'invert', pluginOrder$1.invert, 1, true);
}
// https://windicss.org/utilities/filters.html#filter-saturate
function saturate(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleBody(theme('saturate'))
        .handleSquareBrackets()
        .handleNumber(0, undefined, 'int', function (number) { return "".concat(number / 100); })
        .createProperty('--tw-saturate', function (value) { return "saturate(".concat(value, ")"); })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'saturate', pluginOrder$1.saturate, 1, true);
}
// https://windicss.org/utilities/filters.html#filter-sepia
function sepia(utility, _a) {
    var _b;
    var theme = _a.theme;
    if (utility.raw === 'sepia')
        utility.raw = 'sepia-DEFAULT';
    return (_b = utility.handler
        .handleBody(theme('sepia'))
        .handleSquareBrackets()
        .handleNumber(0, 100, 'int', function (number) { return "".concat(number / 100); })
        .createProperty('--tw-sepia', function (value) { return "sepia(".concat(value, ")"); })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'sepia', pluginOrder$1.sepia, 1, true);
}
// https://windicss.org/utilities/filters.html#backdrop-filter
// https://windicss.org/utilities/filters.html#backdrop-blur
// https://windicss.org/utilities/filters.html#backdrop-brightness
// https://windicss.org/utilities/filters.html#backdrop-contrast
// https://windicss.org/utilities/filters.html#backdrop-grayscale
// https://windicss.org/utilities/filters.html#backdrop-hue-rotate
// https://windicss.org/utilities/filters.html#backdrop-invert
// https://windicss.org/utilities/filters.html#backdrop-opacity
// https://windicss.org/utilities/filters.html#backdrop-saturate
// https://windicss.org/utilities/filters.html#backdrop-sepia
function backdrop(utility, _a) {
    var _b, _c, _d, _e, _f, _g, _h, _j, _k;
    var theme = _a.theme;
    utility = utility.clone(utility.raw.slice(9));
    switch (utility.match(/[^-]+/)) {
        case 'blur':
            if (utility.raw === 'blur')
                utility.raw = 'blur-DEFAULT';
            return (_b = utility.handler
                .handleBody(theme('backdropBlur'))
                .handleSquareBrackets()
                .handleNumber(0, undefined, 'int', function (number) { return "".concat(number, "px"); })
                .handleSize()
                .createProperty('--tw-backdrop-blur', function (value) { return "blur(".concat(value, ")"); })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'backdropBlur', pluginOrder$1.backdropBlur, 1, true);
        case 'brightness':
            return (_c = utility.handler
                .handleBody(theme('backdropBrightness'))
                .handleSquareBrackets()
                .handleNumber(0, undefined, 'int', function (number) { return "".concat(number / 100); })
                .createProperty('--tw-backdrop-brightness', function (value) { return "brightness(".concat(value, ")"); })) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'backdropBrightness', pluginOrder$1.backdropBrightness, 1, true);
        case 'contrast':
            return (_d = utility.handler
                .handleBody(theme('backdropContrast'))
                .handleSquareBrackets()
                .handleNumber(0, undefined, 'int', function (number) { return "".concat(number / 100); })
                .createProperty('--tw-backdrop-contrast', function (value) { return "contrast(".concat(value, ")"); })) === null || _d === void 0 ? void 0 : _d.updateMeta('utilities', 'backdropContrast', pluginOrder$1.backdropContrast, 1, true);
        case 'grayscale':
            if (utility.raw === 'grayscale')
                utility.raw = 'grayscale-DEFAULT';
            return (_e = utility.handler
                .handleBody(theme('backdropGrayscale'))
                .handleSquareBrackets()
                .handleNumber(0, 100, 'int', function (number) { return "".concat(number / 100); })
                .createProperty('--tw-backdrop-grayscale', function (value) { return "grayscale(".concat(value, ")"); })) === null || _e === void 0 ? void 0 : _e.updateMeta('utilities', 'backdropGrayscale', pluginOrder$1.backdropGrayscale, 1, true);
        case 'hue':
            return (_f = utility.handler
                .handleBody(theme('backdropHueRotate'))
                .handleSquareBrackets()
                .handleNumber(0, undefined, 'float', function (number) { return "".concat(number, "deg"); })
                .handleNegative()
                .createProperty('--tw-backdrop-hue-rotate', function (value) { return "hue-rotate(".concat(value, ")"); })) === null || _f === void 0 ? void 0 : _f.updateMeta('utilities', 'backdropHueRotate', pluginOrder$1.backdropHueRotate, 1, true);
        case 'invert':
            if (utility.raw === 'invert')
                utility.raw = 'invert-DEFAULT';
            return (_g = utility.handler
                .handleBody(theme('backdropInvert'))
                .handleSquareBrackets()
                .handleNumber(0, 100, 'int', function (number) { return "".concat(number / 100); })
                .createProperty('--tw-backdrop-invert', function (value) { return "invert(".concat(value, ")"); })) === null || _g === void 0 ? void 0 : _g.updateMeta('utilities', 'backdropInvert', pluginOrder$1.backdropInvert, 1, true);
        case 'opacity':
            return (_h = utility.handler
                .handleBody(theme('backdropOpacity'))
                .handleSquareBrackets()
                .handleNumber(0, 100, 'int', function (number) { return "".concat(number / 100); })
                .createProperty('--tw-backdrop-opacity', function (value) { return "opacity(".concat(value, ")"); })) === null || _h === void 0 ? void 0 : _h.updateMeta('utilities', 'backdropOpacity', pluginOrder$1.backdropOpacity, 1, true);
        case 'saturate':
            return (_j = utility.handler
                .handleBody(theme('backdropSaturate'))
                .handleSquareBrackets()
                .handleNumber(0, undefined, 'int', function (number) { return "".concat(number / 100); })
                .createProperty('--tw-backdrop-saturate', function (value) { return "saturate(".concat(value, ")"); })) === null || _j === void 0 ? void 0 : _j.updateMeta('utilities', 'backdropSaturate', pluginOrder$1.backdropSaturate, 1, true);
        case 'sepia':
            if (utility.raw === 'sepia')
                utility.raw = 'sepia-DEFAULT';
            return (_k = utility.handler
                .handleBody(theme('backdropSepia'))
                .handleSquareBrackets()
                .handleNumber(0, 100, 'int', function (number) { return "".concat(number / 100); })
                .createProperty('--tw-backdrop-sepia', function (value) { return "sepia(".concat(value, ")"); })) === null || _k === void 0 ? void 0 : _k.updateMeta('utilities', 'backdropSepia', pluginOrder$1.backdropSepia, 1, true);
    }
}
// https://windicss.org/utilities/effects.html#box-shadow
function boxShadow(utility, _a) {
    var theme = _a.theme;
    var body = utility.body || 'DEFAULT';
    var shadows = toType(theme('boxShadow'), 'object');
    if (Object.keys(shadows).includes(body)) {
        var coloredShadow = shadows[body].replace(/rgba?\([0-9.,/\s]*\)/g, 'var(--tw-shadow-color)');
        return new Style$3(utility.class, [
            new Property$3('--tw-shadow', shadows[body]),
            new Property$3('--tw-shadow-colored', coloredShadow),
            new Property$3('-webkit-box-shadow', 'var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)'),
            new Property$3('box-shadow', 'var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)'),
        ]).updateMeta('utilities', 'boxShadow', pluginOrder$1.boxShadow, 0, true);
    }
    var color = utility.handler
        .handleColor(theme('boxShadowColor'))
        .handleOpacity(theme('opacity'))
        .handleSquareBrackets()
        .handleVariable()
        .createColorValue('1');
    return new Style$3(utility.class, [
        new Property$3('--tw-shadow-color', color),
        new Property$3('--tw-shadow', 'var(--tw-shadow-colored)'),
    ]).updateMeta('utilities', 'boxShadowColor', pluginOrder$1.boxShadowColor, 0, true);
}
// https://windicss.org/utilities/effects.html#opacity
function opacity(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleStatic(theme('opacity'))
        .handleSquareBrackets()
        .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
        .handleVariable()
        .createProperty('opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'opacity', pluginOrder$1.opacity, 0, true);
}
// https://windicss.org/utilities/transitions.html#transition-property
function transition(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    var body = utility.body;
    var props = toType(theme('transitionProperty'), 'object');
    for (var _i = 0, _d = Object.entries(props); _i < _d.length; _i++) {
        var _e = _d[_i], key = _e[0], value = _e[1];
        if (body === key || (body === '' && key === 'DEFAULT')) {
            if (value === 'none')
                return new Property$3(['-webkit-transition-property', '-o-transition-property', 'transition-property'], 'none').updateMeta('utilities', 'transitionProperty', pluginOrder$1.transitionProperty, 1, true);
            return new Style$3(utility.class, [
                new Property$3('-webkit-transition-property', value.replace(/(?=(transform|box-shadow))/g, '-webkit-')),
                new Property$3('-o-transition-property', value),
                new Property$3('transition-property', value.replace(/transform/g, 'transform, -webkit-transform').replace(/box-shadow/g, 'box-shadow, -webkit-box-shadow')),
                new Property$3(['-webkit-transition-timing-function', '-o-transition-timing-function', 'transition-timing-function'], (_b = toType(theme('transitionTimingFunction.DEFAULT'), 'string')) !== null && _b !== void 0 ? _b : 'cubic-bezier(0.4, 0, 0.2, 1)'),
                new Property$3(['-webkit-transition-duration', '-o-transition-duration', 'transition-duration'], (_c = toType(theme('transitionDuration.DEFAULT'), 'string')) !== null && _c !== void 0 ? _c : '150ms'),
            ]).updateMeta('utilities', 'transitionProperty', pluginOrder$1.transitionProperty, 2, true);
        }
    }
}
// https://windicss.org/utilities/transitions.html#transition-duration
function duration(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleStatic(theme('transitionDuration'))
        .handleSquareBrackets()
        .handleTime(0, undefined, 'float')
        .handleNumber(0, undefined, 'int', function (number) { return "".concat(number, "ms"); })
        .handleVariable()
        .createProperty(['-webkit-transition-duration', '-o-transition-duration', 'transition-duration'])) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'transitionDuration', pluginOrder$1.transitionDuration, 1, true);
}
// https://windicss.org/utilities/transitions.html#transition-timing-function
function transitionTimingFunction(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleBody(theme('transitionTimingFunction'))
        .createProperty(['-webkit-transition-timing-function', '-o-transition-timing-function', 'transition-timing-function'])) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'transitionTimingFunction', pluginOrder$1.transitionTimingFunction, 1, true);
}
// https://windicss.org/utilities/transitions.html#transition-delay
function delay(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleStatic(theme('transitionDelay'))
        .handleSquareBrackets()
        .handleTime(0, undefined, 'float')
        .handleNumber(0, undefined, 'int', function (number) { return "".concat(number, "ms"); })
        .handleVariable()
        .createProperty(['-webkit-transition-delay', '-o-transition-delay', 'transition-delay'])) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'transitionDelay', pluginOrder$1.transitionDelay, 0, true);
}
// https://windicss.org/utilities/behaviors.html#animation
function animation(utility, _a) {
    var _b, _c, _d, _e, _f;
    var theme = _a.theme, config = _a.config;
    var body = utility.body;
    if (utility.raw.startsWith('animate-ease')) {
        return (_b = utility.clone(utility.raw.slice(8)).handler
            .handleBody(theme('animationTimingFunction'))
            .handleSquareBrackets()
            .createProperty(['-webkit-animation-timing-function', 'animation-timing-function'])) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'animation', pluginOrder$1.animation, 20, true);
    }
    if (utility.raw.startsWith('animate-duration')) {
        return (_c = utility.clone(utility.raw.slice(8)).handler
            .handleStatic(theme('animationDuration'))
            .handleSquareBrackets()
            .handleTime(0, undefined, 'float')
            .handleNumber(0, undefined, 'int', function (number) { return "".concat(number, "ms"); })
            .handleVariable()
            .createProperty(['-webkit-animation-duration', 'animation-duration'])) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'animation', pluginOrder$1.animation, 21, true);
    }
    if (utility.raw.startsWith('animate-delay')) {
        return (_d = utility.clone(utility.raw.slice(8)).handler
            .handleStatic(theme('animationDelay'))
            .handleSquareBrackets()
            .handleTime(0, undefined, 'float')
            .handleNumber(0, undefined, 'int', function (number) { return "".concat(number, "ms"); })
            .handleVariable()
            .createProperty(['-webkit-animation-delay', 'animation-delay'])) === null || _d === void 0 ? void 0 : _d.updateMeta('utilities', 'animation', pluginOrder$1.animation, 22, true);
    }
    var animateIterationCount = utility.handler.handleBody(theme('animationIterationCount')).handleNumber(0, undefined, 'int').handleSquareBrackets().value;
    if (animateIterationCount)
        return new Property$3(['-webkit-animation-iteration-count', 'animation-iteration-count'], animateIterationCount).updateMeta('utilities', 'animation', pluginOrder$1.animation, 23, true);
    var animations = toType(theme('animation'), 'object');
    if (Object.keys(animations).includes(body)) {
        var value = animations[body];
        var prop = config('prefixer') ? ['-webkit-animation', 'animation'] : 'animation';
        if (value === 'none')
            return new Property$3(prop, 'none').updateMeta('utilities', 'animation', pluginOrder$1.animation, 1, true);
        var styles = void 0, keyframe = void 0;
        if (typeof value === 'string') {
            keyframe = (_e = value.match(/^\w+/)) === null || _e === void 0 ? void 0 : _e[0];
            styles = [new Style$3(utility.class, new Property$3(prop, value))];
        }
        else {
            keyframe = value['animation'] || value['animationName'] || value['animation-name'];
            if (config('prefixer')) {
                var props = {};
                for (var _i = 0, _g = Object.entries(value); _i < _g.length; _i++) {
                    var _h = _g[_i], k = _h[0], v = _h[1];
                    if (k.startsWith('animation') || k.startsWith('backface')) {
                        props['-webkit-' + k] = v;
                    }
                    else if (k.startsWith('transform')) {
                        props['-webkit-' + k] = v;
                        props['-ms-' + k] = v;
                    }
                    props[k] = v;
                }
                value = props;
            }
            styles = Style$3.generate(utility.class, value).map(function (i) { return i.updateMeta('utilities', 'animation', pluginOrder$1.animation, 2, true); });
        }
        if (styles) {
            return __spreadArray$6(__spreadArray$6([], styles.map(function (i) { return i.updateMeta('utilities', 'animation', pluginOrder$1.animation, 2, true); }), true), keyframe ? Keyframes$1.generate(keyframe, ((_f = theme("keyframes.".concat(keyframe))) !== null && _f !== void 0 ? _f : {}), undefined, config('prefixer', false)).map(function (i) { return i.updateMeta('utilities', 'keyframes', pluginOrder$1.keyframes, 1, true); }) : [], true);
        }
    }
}
// https://windicss.org/utilities/transforms.html#transform-origin
function transformOrigin(utility, _a) {
    var theme = _a.theme;
    var body = utility.body;
    var origins = toType(theme('transformOrigin'), 'object');
    if (Object.keys(origins).includes(body))
        return new Property$3(['-webkit-transform-origin', '-ms-transform-origin', 'transform-origin'], origins[body]).updateMeta('utilities', 'transformOrigin', pluginOrder$1.transformOrigin, 0, true);
}
// https://windicss.org/utilities/transforms.html#transform-scale
function scale(utility, _a) {
    var theme = _a.theme;
    return utility.handler
        .handleStatic(theme('scale'))
        .handleNumber(0, undefined, 'int', function (number) { return (number / 100).toString(); })
        .handleVariable()
        .callback(function (value) {
        if (utility.raw.startsWith('scale-x'))
            return new Property$3('--tw-scale-x', value).updateMeta('utilities', 'scale', pluginOrder$1.scale, 2, true);
        if (utility.raw.startsWith('scale-y'))
            return new Property$3('--tw-scale-y', value).updateMeta('utilities', 'scale', pluginOrder$1.scale, 3, true);
        if (utility.raw.startsWith('scale-z'))
            return new Property$3('--tw-scale-z', value).updateMeta('utilities', 'scale', pluginOrder$1.scale, 4, true);
        return new Property$3(['--tw-scale-x', '--tw-scale-y', '--tw-scale-z'], value).updateMeta('utilities', 'scale', pluginOrder$1.scale, 1, true);
    });
}
// https://windicss.org/utilities/transforms.html#transform-rotate
function rotate(utility, _a) {
    var theme = _a.theme;
    return utility.handler
        .handleStatic(theme('rotate'))
        .handleSquareBrackets()
        .handleNumber(0, undefined, 'float', function (number) { return "".concat(number, "deg"); })
        .handleNegative()
        .handleVariable()
        .callback(function (value) {
        var abs = utility.absolute;
        if (abs.startsWith('rotate-x'))
            return new Property$3('--tw-rotate-x', value).updateMeta('utilities', 'rotate', pluginOrder$1.rotate, 2, true);
        if (abs.startsWith('rotate-y'))
            return new Property$3('--tw-rotate-y', value).updateMeta('utilities', 'rotate', pluginOrder$1.rotate, 3, true);
        if (abs.startsWith('rotate-z'))
            return new Property$3('--tw-rotate-z', value).updateMeta('utilities', 'rotate', pluginOrder$1.rotate, 4, true);
        return new Property$3('--tw-rotate', value).updateMeta('utilities', 'rotate', pluginOrder$1.rotate, 1, true);
    });
}
// https://windicss.org/utilities/transforms.html#transform-translate
function translate(utility, _a) {
    var _b;
    var theme = _a.theme;
    var centerMatch = utility.raw.match(/^-?translate-[x|y|z]/);
    if (centerMatch) {
        var center = centerMatch[0].replace(/^-?translate-/, '');
        return (_b = utility.handler
            .handleStatic(theme('translate'))
            .handleSquareBrackets()
            .handleSpacing()
            .handleFraction()
            .handleSize()
            .handleNegative()
            .handleVariable()
            .createProperty("--tw-translate-".concat(center))) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'translate', pluginOrder$1.translate, utility.raw.charAt(0) === '-' ? 2 : 1, true);
    }
}
// https://windicss.org/utilities/transforms.html#transform-skew
function skew(utility, _a) {
    var _b;
    var theme = _a.theme;
    var centerMatch = utility.raw.match(/^-?skew-[x|y]/);
    if (centerMatch) {
        var center = centerMatch[0].replace(/^-?skew-/, '');
        return (_b = utility.handler
            .handleStatic(theme('skew'))
            .handleSquareBrackets()
            .handleNumber(0, undefined, 'float', function (number) { return "".concat(number, "deg"); })
            .handleNegative()
            .handleVariable()
            .createProperty("--tw-skew-".concat(center))) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'skew', pluginOrder$1.skew, utility.raw.charAt(0) === '-' ? 2 : 1, true);
    }
}
// https://windicss.org/utilities/transforms.html#perspective
function perspective(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    if (utility.raw.startsWith('perspect-origin')) {
        var origin_1 = (_b = utility.clone('perspectOrigin' + utility.raw.slice(15)).handler
            .handleBody(theme('perspectiveOrigin'))
            .handleSquareBrackets()
            .createProperty(['-webkit-perspective-origin', 'perspective-origin'])) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'perspectiveOrigin', pluginOrder$1.perspectiveOrigin, 0, true);
        if (origin_1)
            return origin_1;
    }
    return (_c = utility.handler
        .handleStatic(theme('perspective'))
        .handleNumber(0, undefined, 'int', function (number) { return "".concat(number, "px"); })
        .handleSize()
        .handleSquareBrackets()
        .createProperty(['-webkit-perspective', 'perspective'])) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'perspective', pluginOrder$1.perspective, 0, true);
}
// https://windicss.org/utilities/behaviors.html#cursor
function cursor(utility, _a) {
    var theme = _a.theme;
    var body = utility.body;
    var cursors = toType(theme('cursor'), 'object');
    if (Object.keys(cursors).includes(body))
        return new Property$3('cursor', cursors[body]).updateMeta('utilities', 'cursor', pluginOrder$1.cursor, 1, true);
}
// https://windicss.org/utilities/borders/outline.html
function outline(utility, _a) {
    var _b, _c, _d, _e;
    var theme = _a.theme;
    if (utility.raw.startsWith('outline-offset')) {
        return (_b = utility.handler
            .handleStatic(theme('outlineOffset'))
            .handleNumber(0, undefined, 'int')
            .handleVariable()
            .handleSquareBrackets()
            .createProperty('outline-offset')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'outline', pluginOrder$1.outline, 0, true);
    }
    if (utility.raw.startsWith('outline-opacity')) {
        return (_c = utility.handler
            .handleStatic(theme('opacity'))
            .handleNumber(0, 1, 'float')
            .handleVariable()
            .handleSquareBrackets()
            .createProperty('--tw-outline-opacity')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'outline', pluginOrder$1.outline, 1, true);
    }
    var outlineColor = (_d = utility.handler
        .handleColor(theme('outlineColor'))
        .handleOpacity(theme('opacity'))
        .handleSquareBrackets(notNumberLead)
        .handleVariable(function (variable) { return utility.raw.startsWith('outline-$') ? "var(--".concat(variable, ")") : undefined; })
        .createColorStyle(utility.class, 'outline-color', '--tw-outline-opacity')) === null || _d === void 0 ? void 0 : _d.updateMeta('utilities', 'outline', pluginOrder$1.outline, 2, true);
    if (outlineColor)
        return outlineColor;
    return (_e = utility.handler
        .handleStatic(theme('outlineWidth'))
        .handleNumber(0, undefined, 'float', function (number) { return "".concat(number, "px"); })
        .handleSquareBrackets()
        .handleVariable()
        .createProperty('outline-width')) === null || _e === void 0 ? void 0 : _e.updateMeta('utilities', 'outline', pluginOrder$1.outline, 3, true);
}
// https://windicss.org/utilities/svg.html#fill-color
function fill$3(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    if (utility.raw.startsWith('fill-opacity')) {
        return (_b = utility.handler
            .handleStatic(theme('opacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-fill-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'fill', pluginOrder$1.ringOffsetColor, 2, true);
    }
    return (_c = utility.handler
        .handleColor(theme('fill'))
        .handleOpacity(theme('opacity'))
        .handleSquareBrackets()
        .handleVariable()
        .createColorStyle(utility.class, 'fill', '--tw-fill-opacity')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'fill', pluginOrder$1.fill, 1, true);
}
// https://windicss.org/utilities/svg.html#stroke-color
// https://windicss.org/utilities/svg.html#stroke-width
function stroke(utility, _a) {
    var _b, _c, _d, _e, _f, _g;
    var theme = _a.theme;
    if (utility.raw.startsWith('stroke-dash')) {
        return (_b = utility.handler.handleNumber().createProperty('stroke-dasharray')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'strokeDashArray', pluginOrder$1.strokeDashArray, 0, true);
    }
    if (utility.raw.startsWith('stroke-offset')) {
        return (_c = utility.handler.handleNumber().createProperty('stroke-dashoffset')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'strokeDashOffset', pluginOrder$1.strokeDashOffset, 0, true);
    }
    if (utility.raw.startsWith('stroke-opacity')) {
        return (_d = utility.handler
            .handleStatic(theme('opacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-stroke-opacity')) === null || _d === void 0 ? void 0 : _d.updateMeta('utilities', 'stroke', pluginOrder$1.stroke, 2, true);
    }
    return ((_e = utility.handler
        .handleColor(theme('stroke'))
        .handleOpacity(theme('opacity'))
        .handleVariable()
        .handleSquareBrackets()
        .createColorStyle(utility.class, 'stroke', '--tw-stroke-opacity')) === null || _e === void 0 ? void 0 : _e.updateMeta('utilities', 'stroke', pluginOrder$1.stroke, 1, true))
        || (utility.raw.startsWith('stroke-$')
            ? (_f = utility.handler
                .handleVariable()
                .createProperty('stroke-width')) === null || _f === void 0 ? void 0 : _f.updateMeta('utilities', 'strokeWidth', pluginOrder$1.strokeWidth, 2, true)
            : (_g = utility.handler
                .handleStatic(theme('strokeWidth'))
                .handleNumber(0, undefined, 'int')
                .createProperty('stroke-width')) === null || _g === void 0 ? void 0 : _g.updateMeta('utilities', 'strokeWidth', pluginOrder$1.strokeWidth, 1, true));
}
function content(utility, _a) {
    var _b;
    var theme = _a.theme;
    if (!/^content-(?!$)/.test(utility.raw))
        return;
    return (_b = utility.handler
        .handleBody(theme('content'))
        .handleSquareBrackets()
        .handleVariable()
        .handleString(function (string) { return "\"".concat(string, "\""); })
        .createProperty('content')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'content', pluginOrder$1.content, 1, true);
}
// https://windicss.org/utilities/behaviors.html#accent-color
function accent(utility, _a) {
    var theme = _a.theme;
    var color = utility.handler
        .handleColor(theme('boxShadowColor'))
        .handleOpacity(theme('opacity'))
        .handleSquareBrackets()
        .handleVariable()
        .createColorValue('1');
    return new Style$3(utility.class, new Property$3('accent-color', color))
        .updateMeta('utilities', 'accentColor', pluginOrder$1.accentColor, 0, true);
}
var dynamicUtilities$1 = {
    columns: columns,
    container: container,
    space: space,
    divide: divide$2,
    bg: background,
    basis: basis,
    from: gradientColorFrom,
    via: gradientColorVia,
    to: gradientColorTo,
    border: border,
    rounded: borderRadius,
    cursor: cursor,
    flex: flex,
    order: order$1,
    font: font,
    h: size,
    leading: lineHeight,
    list: listStyleType,
    m: margin,
    my: margin,
    mx: margin,
    mt: margin,
    mr: margin,
    mb: margin,
    ml: margin,
    min: minMaxSize,
    max: minMaxSize,
    object: objectPosition,
    opacity: opacity,
    outline: outline,
    p: padding,
    py: padding,
    px: padding,
    pt: padding,
    pr: padding,
    pb: padding,
    pl: padding,
    placeholder: placeholder,
    caret: caret$1,
    tab: tabSize,
    indent: textIndent,
    inset: inset,
    top: inset,
    right: inset,
    bottom: inset,
    left: inset,
    shadow: boxShadow,
    ring: ring$1,
    blur: blur,
    brightness: brightness,
    contrast: contrast,
    drop: dropShadow,
    grayscale: grayscale,
    hue: hueRotate,
    invert: invert,
    saturate: saturate,
    sepia: sepia,
    backdrop: backdrop,
    fill: fill$3,
    stroke: stroke,
    text: text$2,
    tracking: letterSpacing,
    decoration: textDecoration,
    underline: textUnderline,
    w: size,
    z: zIndex,
    gap: gap$1,
    auto: gridAuto,
    grid: gridTemplate,
    col: gridColumn,
    row: gridRow,
    origin: transformOrigin,
    scale: scale,
    rotate: rotate,
    translate: translate,
    skew: skew,
    perspect: perspective,
    transition: transition,
    ease: transitionTimingFunction,
    duration: duration,
    delay: delay,
    content: content,
    animate: animation,
    accent: accent,
};

var sky = {
    50: '#f0f9ff',
    100: '#e0f2fe',
    200: '#bae6fd',
    300: '#7dd3fc',
    400: '#38bdf8',
    500: '#0ea5e9',
    600: '#0284c7',
    700: '#0369a1',
    800: '#075985',
    900: '#0c4a6e',
};
var neutral = {
    50: '#fafafa',
    100: '#f5f5f5',
    200: '#e5e5e5',
    300: '#d4d4d4',
    400: '#a3a3a3',
    500: '#737373',
    600: '#525252',
    700: '#404040',
    800: '#262626',
    900: '#171717',
};
var stone = {
    50: '#fafaf9',
    100: '#f5f5f4',
    200: '#e7e5e4',
    300: '#d6d3d1',
    400: '#a8a29e',
    500: '#78716c',
    600: '#57534e',
    700: '#44403c',
    800: '#292524',
    900: '#1c1917',
};
var slate = {
    50: '#f8fafc',
    100: '#f1f5f9',
    200: '#e2e8f0',
    300: '#cbd5e1',
    400: '#94A3B8',
    500: '#64748B',
    600: '#475569',
    700: '#334155',
    800: '#1E293B',
    900: '#0F172A',
};
var zinc = {
    50: '#fafafa',
    100: '#f4f4f5',
    200: '#e4e4e7',
    300: '#d4d4d8',
    400: '#a1a1aa',
    500: '#71717A',
    600: '#52525B',
    700: '#3F3F46',
    800: '#27272A',
    900: '#18181B',
};
var gray = {
    50: '#f9fafb',
    100: '#f3f4f6',
    200: '#e5e7eb',
    300: '#d1d5db',
    400: '#9ca3af',
    500: '#6b7280',
    600: '#4b5563',
    700: '#374151',
    800: '#1f2937',
    900: '#111827',
};
var warned$1 = false;
function color_warn(from, to) {
    if (!warned$1) {
        Console.log("warn - '".concat(from, "' has been renamed to '").concat(to, "'."));
        Console.log('warn - Please update your color palette to eliminate this warning.');
        warned$1 = true;
    }
}
var colors = {
    inherit: 'inherit',
    current: 'currentColor',
    transparent: 'transparent',
    black: '#000',
    white: '#fff',
    rose: {
        50: '#fff1f2',
        100: '#ffe4e6',
        200: '#fecdd3',
        300: '#fda4af',
        400: '#fb7185',
        500: '#f43f5e',
        600: '#e11d48',
        700: '#be123c',
        800: '#9f1239',
        900: '#881337',
    },
    pink: {
        50: '#fdf2f8',
        100: '#fce7f3',
        200: '#fbcfe8',
        300: '#f9a8d4',
        400: '#f472b6',
        500: '#ec4899',
        600: '#db2777',
        700: '#be185d',
        800: '#9d174d',
        900: '#831843',
    },
    fuchsia: {
        50: '#fdf4ff',
        100: '#fae8ff',
        200: '#f5d0fe',
        300: '#f0abfc',
        400: '#e879f9',
        500: '#d946ef',
        600: '#c026d3',
        700: '#a21caf',
        800: '#86198f',
        900: '#701a75',
    },
    purple: {
        50: '#faf5ff',
        100: '#f3e8ff',
        200: '#e9d5ff',
        300: '#d8b4fe',
        400: '#c084fc',
        500: '#a855f7',
        600: '#9333ea',
        700: '#7e22ce',
        800: '#6b21a8',
        900: '#581c87',
    },
    violet: {
        50: '#f5f3ff',
        100: '#ede9fe',
        200: '#ddd6fe',
        300: '#c4b5fd',
        400: '#a78bfa',
        500: '#8b5cf6',
        600: '#7c3aed',
        700: '#6d28d9',
        800: '#5b21b6',
        900: '#4c1d95',
    },
    indigo: {
        50: '#eef2ff',
        100: '#e0e7ff',
        200: '#c7d2fe',
        300: '#a5b4fc',
        400: '#818cf8',
        500: '#6366f1',
        600: '#4f46e5',
        700: '#4338ca',
        800: '#3730a3',
        900: '#312e81',
    },
    blue: {
        50: '#eff6ff',
        100: '#dbeafe',
        200: '#bfdbfe',
        300: '#93c5fd',
        400: '#60a5fa',
        500: '#3b82f6',
        600: '#2563eb',
        700: '#1d4ed8',
        800: '#1e40af',
        900: '#1e3a8a',
    },
    sky: sky,
    get lightBlue() {
        color_warn('lightBlue', 'sky');
        return sky;
    },
    cyan: {
        50: '#ecfeff',
        100: '#cffafe',
        200: '#a5f3fc',
        300: '#67e8f9',
        400: '#22d3ee',
        500: '#06b6d4',
        600: '#0891b2',
        700: '#0e7490',
        800: '#155e75',
        900: '#164e63',
    },
    teal: {
        50: '#f0fdfa',
        100: '#ccfbf1',
        200: '#99f6e4',
        300: '#5eead4',
        400: '#2dd4bf',
        500: '#14b8a6',
        600: '#0d9488',
        700: '#0f766e',
        800: '#115e59',
        900: '#134e4a',
    },
    emerald: {
        50: '#ecfdf5',
        100: '#d1fae5',
        200: '#a7f3d0',
        300: '#6ee7b7',
        400: '#34d399',
        500: '#10b981',
        600: '#059669',
        700: '#047857',
        800: '#065f46',
        900: '#064e3b',
    },
    green: {
        50: '#f0fdf4',
        100: '#dcfce7',
        200: '#bbf7d0',
        300: '#86efac',
        400: '#4ade80',
        500: '#22c55e',
        600: '#16a34a',
        700: '#15803d',
        800: '#166534',
        900: '#14532d',
    },
    lime: {
        50: '#f7fee7',
        100: '#ecfccb',
        200: '#d9f99d',
        300: '#bef264',
        400: '#a3e635',
        500: '#84cc16',
        600: '#65a30d',
        700: '#4d7c0f',
        800: '#3f6212',
        900: '#365314',
    },
    yellow: {
        50: '#fefce8',
        100: '#fef9c3',
        200: '#fef08a',
        300: '#fde047',
        400: '#facc15',
        500: '#eab308',
        600: '#ca8a04',
        700: '#a16207',
        800: '#854d0e',
        900: '#713f12',
    },
    amber: {
        50: '#fffbeb',
        100: '#fef3c7',
        200: '#fde68a',
        300: '#fcd34d',
        400: '#fbbf24',
        500: '#f59e0b',
        600: '#d97706',
        700: '#b45309',
        800: '#92400e',
        900: '#78350f',
    },
    orange: {
        50: '#fff7ed',
        100: '#ffedd5',
        200: '#fed7aa',
        300: '#fdba74',
        400: '#fb923c',
        500: '#f97316',
        600: '#ea580c',
        700: '#c2410c',
        800: '#9a3412',
        900: '#7c2d12',
    },
    red: {
        50: '#fef2f2',
        100: '#fee2e2',
        200: '#fecaca',
        300: '#fca5a5',
        400: '#f87171',
        500: '#ef4444',
        600: '#dc2626',
        700: '#b91c1c',
        800: '#991b1b',
        900: '#7f1d1d',
    },
    get warmGray() {
        color_warn('warmGray', 'stone');
        return stone;
    },
    get trueGray() {
        color_warn('trueGray', 'neutral');
        return neutral;
    },
    gray: gray,
    get coolGray() {
        color_warn('coolGray', 'gray');
        return gray;
    },
    get blueGray() {
        color_warn('blueGray', 'slate');
        return slate;
    },
    slate: slate,
    zinc: zinc,
    get zink() {
        color_warn('zink', 'zinc');
        return zinc;
    },
    neutral: neutral,
    stone: stone,
    light: {
        50: '#fdfdfd',
        100: '#fcfcfc',
        200: '#fafafa',
        300: '#f8f9fa',
        400: '#f6f6f6',
        500: '#f2f2f2',
        600: '#f1f3f5',
        700: '#e9ecef',
        800: '#dee2e6',
        900: '#dde1e3',
    },
    dark: {
        50: '#4a4a4a',
        100: '#3c3c3c',
        200: '#323232',
        300: '#2d2d2d',
        400: '#222222',
        500: '#1f1f1f',
        600: '#1c1c1e',
        700: '#1b1b1b',
        800: '#181818',
        900: '#0f0f0f',
    },
};

var keyframes = {
    spin: {
        from: {
            transform: 'rotate(0deg)',
        },
        to: {
            transform: 'rotate(360deg)',
        },
    },
    ping: {
        '0%': {
            transform: 'scale(1)',
            opacity: '1',
        },
        '75%, 100%': {
            transform: 'scale(2)',
            opacity: '0',
        },
    },
    pulse: {
        '0%, 100%': {
            opacity: '1',
        },
        '50%': {
            opacity: '.5',
        },
    },
    bounce: {
        '0%, 100%': {
            transform: 'translateY(-25%)',
            animationTimingFunction: 'cubic-bezier(0.8,0,1,1)',
        },
        '50%': {
            transform: 'translateY(0)',
            animationTimingFunction: 'cubic-bezier(0,0,0.2,1)',
        },
    },
    shock: {
        'from, 20%, 53%, 80%, to': {
            animationTimingFunction: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
            transform: 'translate3d(0, 0, 0)',
        },
        '40%, 43%': {
            animationTimingFunction: 'cubic-bezier(0.755, 0.05, 0.855, 0.06)',
            transform: 'translate3d(0, -30px, 0)',
        },
        '70%': {
            animationTimingFunction: 'cubic-bezier(0.755, 0.05, 0.855, 0.06)',
            transform: 'translate3d(0, -15px, 0)',
        },
        '90%': {
            transform: 'translate3d(0, -4px, 0)',
        },
    },
    flash: {
        'from, 50%, to': {
            opacity: '1',
        },
        '25%, 75%': {
            opacity: '0',
        },
    },
    bubble: {
        'from': {
            transform: 'scale3d(1, 1, 1)',
        },
        '50%': {
            transform: 'scale3d(1.05, 1.05, 1.05)',
        },
        'to': {
            transform: 'scale3d(1, 1, 1)',
        },
    },
    rubberBand: {
        'from': {
            transform: 'scale3d(1, 1, 1)',
        },
        '30%': {
            transform: 'scale3d(1.25, 0.75, 1)',
        },
        '40%': {
            transform: 'scale3d(0.75, 1.25, 1)',
        },
        '50%': {
            transform: 'scale3d(1.15, 0.85, 1)',
        },
        '65%': {
            transform: 'scale3d(0.95, 1.05, 1)',
        },
        '75%': {
            transform: 'scale3d(1.05, 0.95, 1)',
        },
        'to': {
            transform: 'scale3d(1, 1, 1)',
        },
    },
    shakeX: {
        'from, to': {
            transform: 'translate3d(0, 0, 0)',
        },
        '10%, 30%, 50%, 70%, 90%': {
            transform: 'translate3d(-10px, 0, 0)',
        },
        '20%, 40%, 60%, 80%': {
            transform: 'translate3d(10px, 0, 0)',
        },
    },
    shakeY: {
        'from, to': {
            transform: 'translate3d(0, 0, 0)',
        },
        '10%, 30%, 50%, 70%, 90%': {
            transform: 'translate3d(0, -10px, 0)',
        },
        '20%, 40%, 60%, 80%': {
            transform: 'translate3d(0, 10px, 0)',
        },
    },
    headShake: {
        '0%': {
            transform: 'translateX(0)',
        },
        '6.5%': {
            transform: 'translateX(-6px) rotateY(-9deg)',
        },
        '18.5%': {
            transform: 'translateX(5px) rotateY(7deg)',
        },
        '31.5%': {
            transform: 'translateX(-3px) rotateY(-5deg)',
        },
        '43.5%': {
            transform: 'translateX(2px) rotateY(3deg)',
        },
        '50%': {
            transform: 'translateX(0)',
        },
    },
    swing: {
        '20%': {
            transform: 'rotate3d(0, 0, 1, 15deg)',
        },
        '40%': {
            transform: 'rotate3d(0, 0, 1, -10deg)',
        },
        '60%': {
            transform: 'rotate3d(0, 0, 1, 5deg)',
        },
        '80%': {
            transform: 'rotate3d(0, 0, 1, -5deg)',
        },
        'to': {
            transform: 'rotate3d(0, 0, 1, 0deg)',
        },
    },
    tada: {
        'from': {
            transform: 'scale3d(1, 1, 1)',
        },
        '10%, 20%': {
            transform: 'scale3d(0.9, 0.9, 0.9) rotate3d(0, 0, 1, -3deg)',
        },
        '30%, 50%, 70%, 90%': {
            transform: 'scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)',
        },
        '40%, 60%, 80%': {
            transform: 'scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg)',
        },
        'to': {
            transform: 'scale3d(1, 1, 1)',
        },
    },
    wobble: {
        'from': {
            transform: 'translate3d(0, 0, 0)',
        },
        '15%': {
            transform: 'translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg)',
        },
        '30%': {
            transform: 'translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg)',
        },
        '45%': {
            transform: 'translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg)',
        },
        '60%': {
            transform: 'translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg)',
        },
        '75%': {
            transform: 'translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg)',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    jello: {
        'from, 11.1% to': {
            transform: 'translate3d(0, 0, 0)',
        },
        '22.2%': {
            transform: 'skewX(-12.5deg) skewY(-12.5deg)',
        },
        '33.3%': {
            transform: 'skewX(6.25deg) skewY(6.25deg)',
        },
        '44.4%': {
            transform: 'skewX(-3.125deg) skewY(-3.125deg)',
        },
        '55.5%': {
            transform: 'skewX(1.5625deg) skewY(1.5625deg)',
        },
        '66.6%': {
            transform: 'skewX(-0.78125deg) skewY(-0.78125deg)',
        },
        '77.7%': {
            transform: 'skewX(0.390625deg) skewY(0.390625deg)',
        },
        '88.8%': {
            transform: 'skewX(-0.1953125deg) skewY(-0.1953125deg)',
        },
    },
    heartBeat: {
        '0%': {
            transform: 'scale(1)',
        },
        '14%': {
            transform: 'scale(1.3)',
        },
        '28%': {
            transform: 'scale(1)',
        },
        '42%': {
            transform: 'scale(1.3)',
        },
        '70%': {
            transform: 'scale(1)',
        },
    },
    hinge: {
        '0%': {
            transformOrigin: 'top left',
            animationTimingFunction: 'ease-in-out',
        },
        '20%, 60%': {
            transform: 'rotate3d(0, 0, 1, 80deg)',
            transformOrigin: 'top left',
            animationTimingFunction: 'ease-in-out',
        },
        '40%, 80%': {
            transform: 'rotate3d(0, 0, 1, 60deg)',
            transformOrigin: 'top left',
            animationTimingFunction: 'ease-in-out',
        },
        'to': {
            transform: 'translate3d(0, 700px, 0)',
            opacity: '0',
        },
    },
    jackInTheBox: {
        'from': {
            opacity: '0',
            transformOrigin: 'center bottom',
            transform: 'scale(0.1) rotate(30deg)',
        },
        '50%': {
            transform: 'rotate(-10deg)',
        },
        '70%': {
            transform: 'rotate(3deg)',
        },
        'to': {
            transform: 'scale(1)',
        },
    },
    // light speed
    lightSpeedInRight: {
        'from': {
            opacity: '0',
            transform: 'translate3d(100%, 0, 0) skewX(-30deg)',
        },
        '60%': {
            opacity: '1',
            transform: 'skewX(20deg)',
        },
        '80%': {
            transform: 'skewX(-5deg)',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    lightSpeedInLeft: {
        'from': {
            opacity: '0',
            transform: 'translate3d(100%, 0, 0) skewX(-30deg)',
        },
        '60%': {
            opacity: '1',
            transform: 'skewX(20deg)',
        },
        '80%': {
            transform: 'skewX(-5deg)',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    lightSpeedOutLeft: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(100%, 0, 0) skewX(30deg)',
        },
    },
    lightSpeedOutRight: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(100%, 0, 0) skewX(30deg)',
        },
    },
    // flip
    flip: {
        'from': {
            transform: 'perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, -360deg)',
            animationTimingFunction: 'ease-out',
        },
        '40%': {
            transform: 'perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -190deg)',
            animationTimingFunction: 'ease-out',
        },
        '50%': {
            transform: 'perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -170deg)',
            animationTimingFunction: 'ease-in',
        },
        '80%': {
            transform: 'perspective(400px) scale3d(0.95, 0.95, 0.95) translate3d(0, 0, 0) rotate3d(0, 1, 0, 0deg)',
            animationTimingFunction: 'ease-in',
        },
        'to': {
            transform: 'perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, 0deg)',
            animationTimingFunction: 'ease-in',
        },
    },
    flipInX: {
        'from': {
            transform: 'perspective(400px) rotate3d(1, 0, 0, 90deg)',
            animationTimingFunction: 'ease-in',
            opacity: '0',
        },
        '40%': {
            transform: 'perspective(400px) rotate3d(1, 0, 0, -20deg)',
            animationTimingFunction: 'ease-in',
        },
        '60%': {
            transform: 'perspective(400px) rotate3d(1, 0, 0, 10deg)',
            opacity: '1',
        },
        '80%': {
            transform: 'perspective(400px) rotate3d(1, 0, 0, -5deg)',
        },
        'to': {
            transform: 'perspective(400px)',
        },
    },
    flipInY: {
        'from': {
            transform: 'perspective(400px) rotate3d(0, 1, 0, 90deg)',
            animationTimingFunction: 'ease-in',
            opacity: '0',
        },
        '40%': {
            transform: 'perspective(400px) rotate3d(0, 1, 0, -20deg)',
            animationTimingFunction: 'ease-in',
        },
        '60%': {
            transform: 'perspective(400px) rotate3d(0, 1, 0, 10deg)',
            opacity: '1',
        },
        '80%': {
            transform: 'perspective(400px) rotate3d(0, 1, 0, -5deg)',
        },
        'to': {
            transform: 'perspective(400px)',
        },
    },
    flipOutX: {
        'from': {
            transform: 'perspective(400px)',
        },
        '30%': {
            transform: 'perspective(400px) rotate3d(1, 0, 0, -20deg)',
            opacity: '1',
        },
        'to': {
            transform: 'perspective(400px) rotate3d(1, 0, 0, 90deg)',
            opacity: '0',
        },
    },
    flipOutY: {
        'from': {
            transform: 'perspective(400px)',
        },
        '30%': {
            transform: 'perspective(400px) rotate3d(0, 1, 0, -15deg)',
            opacity: '1',
        },
        'to': {
            transform: 'perspective(400px) rotate3d(0, 1, 0, 90deg)',
            opacity: '0',
        },
    },
    // rotate in
    rotateIn: {
        'from': {
            transformOrigin: 'center',
            transform: 'rotate3d(0, 0, 1, -200deg)',
            opacity: '0',
        },
        'to': {
            transformOrigin: 'center',
            transform: 'translate3d(0, 0, 0)',
            opacity: '1',
        },
    },
    rotateInDownLeft: {
        'from': {
            transformOrigin: 'left bottom',
            transform: 'rotate3d(0, 0, 1, -45deg)',
            opacity: '0',
        },
        'to': {
            transformOrigin: 'left bottom',
            transform: 'translate3d(0, 0, 0)',
            opacity: '1',
        },
    },
    rotateInDownRight: {
        'from': {
            transformOrigin: 'right bottom',
            transform: 'rotate3d(0, 0, 1, 45deg)',
            opacity: '0',
        },
        'to': {
            transformOrigin: 'right bottom',
            transform: 'translate3d(0, 0, 0)',
            opacity: '1',
        },
    },
    rotateInUpLeft: {
        'from': {
            transformOrigin: 'left top',
            transform: 'rotate3d(0, 0, 1, 45deg)',
            opacity: '0',
        },
        'to': {
            transformOrigin: 'left top',
            transform: 'translate3d(0, 0, 0)',
            opacity: '1',
        },
    },
    rotateInUpRight: {
        'from': {
            transformOrigin: 'right bottom',
            transform: 'rotate3d(0, 0, 1, -90deg)',
            opacity: '0',
        },
        'to': {
            transformOrigin: 'right bottom',
            transform: 'translate3d(0, 0, 0)',
            opacity: '1',
        },
    },
    rotateOut: {
        'from': {
            transformOrigin: 'center',
            opacity: '1',
        },
        'to': {
            transformOrigin: 'center',
            transform: 'rotate3d(0, 0, 1, 200deg)',
            opacity: '0',
        },
    },
    rotateOutDownLeft: {
        'from': {
            transformOrigin: 'left bottom',
            opacity: '1',
        },
        'to': {
            transformOrigin: 'left bottom',
            transform: 'rotate3d(0, 0, 1, 45deg)',
            opacity: '0',
        },
    },
    rotateOutDownRight: {
        'from': {
            transformOrigin: 'right bottom',
            opacity: '1',
        },
        'to': {
            transformOrigin: 'right bottom',
            transform: 'rotate3d(0, 0, 1, -45deg)',
            opacity: '0',
        },
    },
    rotateOutUpLeft: {
        'from': {
            transformOrigin: 'left bottom',
            opacity: '1',
        },
        'to': {
            transformOrigin: 'left bottom',
            transform: 'rotate3d(0, 0, 1, -45deg)',
            opacity: '0',
        },
    },
    rotateOutUpRight: {
        'from': {
            transformOrigin: 'right bottom',
            opacity: '1',
        },
        'to': {
            transformOrigin: 'left bottom',
            transform: 'rotate3d(0, 0, 1, 90deg)',
            opacity: '0',
        },
    },
    // roll
    rollIn: {
        'from': {
            opacity: '0',
            transform: 'translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    rollOut: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(100%, 0, 0) rotate3d(0, 0, 1, 120deg)',
        },
    },
    // zoom in
    zoomIn: {
        'from': {
            opacity: '0',
            transform: 'scale3d(0.3, 0.3, 0.3)',
        },
        '50%': {
            opacity: '1',
        },
    },
    zoomInDown: {
        'from': {
            opacity: '0',
            transform: 'scale3d(0.1, 0.1, 0.1) translate3d(0, -1000px, 0)',
            animationTimingFunction: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)',
        },
        '60%': {
            opacity: '1',
            transform: 'scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0)',
            animationTimingFunction: 'cubic-bezier(0.175, 0.885, 0.32, 1)',
        },
    },
    zoomInLeft: {
        'from': {
            opacity: '0',
            transform: 'scale3d(0.1, 0.1, 0.1) translate3d(-1000px, 0, 0)',
            animationTimingFunction: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)',
        },
        '60%': {
            opacity: '1',
            transform: 'scale3d(0.475, 0.475, 0.475) translate3d(10px, 0, 0)',
            animationTimingFunction: 'cubic-bezier(0.175, 0.885, 0.32, 1)',
        },
    },
    zoomInRight: {
        'from': {
            opacity: '0',
            transform: 'scale3d(0.1, 0.1, 0.1) translate3d(1000px, 0, 0)',
            animationTimingFunction: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)',
        },
        '60%': {
            opacity: '1',
            transform: 'scale3d(0.475, 0.475, 0.475) translate3d(-10px, 0, 0)',
            animationTimingFunction: 'cubic-bezier(0.175, 0.885, 0.32, 1)',
        },
    },
    zoomInUp: {
        'from': {
            opacity: '0',
            transform: 'scale3d(0.1, 0.1, 0.1) translate3d(0, 1000px, 0)',
            animationTimingFunction: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)',
        },
        '60%': {
            opacity: '1',
            transform: 'scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0)',
            animationTimingFunction: 'cubic-bezier(0.175, 0.885, 0.32, 1)',
        },
    },
    // bounce in
    bounceIn: {
        'from, 20%, 40%, 60%, 80%, to': {
            animationTimingFunction: 'ease-in-out',
        },
        '0%': {
            opacity: '0',
            transform: 'scale3d(0.3, 0.3, 0.3)',
        },
        '20%': {
            transform: 'scale3d(1.1, 1.1, 1.1)',
        },
        '40%': {
            transform: 'scale3d(0.9, 0.9, 0.9)',
        },
        '60%': {
            transform: 'scale3d(1.03, 1.03, 1.03)',
            opacity: '1',
        },
        '80%': {
            transform: 'scale3d(0.97, 0.97, 0.97)',
        },
        'to': {
            opacity: '1',
            transform: 'scale3d(1, 1, 1)',
        },
    },
    bounceInDown: {
        'from, 60%, 75%, 90%, to': {
            animationTimingFunction: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
        },
        '0%': {
            opacity: '0',
            transform: 'translate3d(0, -3000px, 0)',
        },
        '60%': {
            opacity: '1',
            transform: 'translate3d(0, 25px, 0)',
        },
        '75%': {
            transform: 'translate3d(0, -10px, 0)',
        },
        '90%': {
            transform: 'translate3d(0, 5px, 0)',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    bounceInLeft: {
        'from, 60%, 75%, 90%, to': {
            animationTimingFunction: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
        },
        '0%': {
            opacity: '0',
            transform: 'translate3d(-3000px, 0, 0)',
        },
        '60%': {
            opacity: '1',
            transform: 'translate3d(25px, 0, 0)',
        },
        '75%': {
            transform: 'translate3d(-10px, 0, 0)',
        },
        '90%': {
            transform: 'translate3d(5px, 0, 0)',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    bounceInRight: {
        'from, 60%, 75%, 90%, to': {
            animationTimingFunction: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
        },
        '0%': {
            opacity: '0',
            transform: 'translate3d(3000px, 0, 0)',
        },
        '60%': {
            opacity: '1',
            transform: 'translate3d(-25px, 0, 0)',
        },
        '75%': {
            transform: 'translate3d(10px, 0, 0)',
        },
        '90%': {
            transform: 'translate3d(-5px, 0, 0)',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    bounceInUp: {
        'from, 60%, 75%, 90%, to': {
            animationTimingFunction: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
        },
        '0%': {
            opacity: '0',
            transform: 'translate3d(0, 3000px, 0)',
        },
        '60%': {
            opacity: '1',
            transform: 'translate3d(0, -20px, 0)',
        },
        '75%': {
            transform: 'translate3d(0, 10px, 0)',
        },
        '90%': {
            transform: 'translate3d(0, -5px, 0)',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    // bounce out
    bounceOut: {
        '20%': {
            transform: 'scale3d(0.9, 0.9, 0.9)',
        },
        '50%, 55%': {
            opacity: '1',
            transform: 'scale3d(1.1, 1.1, 1.1)',
        },
        'to': {
            opacity: '0',
            transform: 'scale3d(0.3, 0.3, 0.3)',
        },
    },
    bounceOutDown: {
        '20%': {
            transform: 'translate3d(0, 10px, 0)',
        },
        '40%, 45%': {
            opacity: '1',
            transform: 'translate3d(0, -20px, 0)',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(0, 2000px, 0)',
        },
    },
    bounceOutLeft: {
        '20%': {
            opacity: '1',
            transform: 'translate3d(20px, 0, 0)',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(-2000px, 0, 0)',
        },
    },
    bounceOutRight: {
        '20%': {
            opacity: '1',
            transform: 'translate3d(-20px, 0, 0)',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(2000px, 0, 0)',
        },
    },
    bounceOutUp: {
        '20%': {
            transform: 'translate3d(0, -10px, 0)',
        },
        '40%, 45%': {
            opacity: '1',
            transform: 'translate3d(0, 20px, 0)',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(0, -2000px, 0)',
        },
    },
    // zoom out
    zoomOut: {
        'from': {
            opacity: '1',
        },
        '50%': {
            opacity: '0',
            transform: 'scale3d(0.3, 0.3, 0.3)',
        },
        'to': {
            opacity: '0',
        },
    },
    zoomOutDown: {
        '40%': {
            opacity: '1',
            transform: 'scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0)',
            animationTimingFunction: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)',
        },
        'to': {
            opacity: '0',
            transform: 'scale3d(0.1, 0.1, 0.1) translate3d(0, 2000px, 0)',
            transformOrigin: 'center bottom',
            animationTimingFunction: 'cubic-bezier(0.175, 0.885, 0.32, 1)',
        },
    },
    zoomOutLeft: {
        '40%': {
            opacity: '1',
            transform: 'scale3d(0.475, 0.475, 0.475) translate3d(42px, 0, 0)',
        },
        'to': {
            opacity: '0',
            transform: 'scale(0.1) translate3d(-2000px, 0, 0)',
            transformOrigin: 'left center',
        },
    },
    zoomOutRight: {
        '40%': {
            opacity: '1',
            transform: 'scale3d(0.475, 0.475, 0.475) translate3d(-42px, 0, 0)',
        },
        'to': {
            opacity: '0',
            transform: 'scale(0.1) translate3d(2000px, 0, 0)',
            transformOrigin: 'right center',
        },
    },
    zoomOutUp: {
        '40%': {
            opacity: '1',
            transform: 'scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0)',
            animationTimingFunction: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)',
        },
        'to': {
            opacity: '0',
            transform: 'scale3d(0.1, 0.1, 0.1) translate3d(0, -2000px, 0)',
            transformOrigin: 'center bottom',
            animationTimingFunction: 'cubic-bezier(0.175, 0.885, 0.32, 1)',
        },
    },
    // slide in
    slideInDown: {
        'from': {
            transform: 'translate3d(0, -100%, 0)',
            visibility: 'visible',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    slideInLeft: {
        'from': {
            transform: 'translate3d(-100%, 0, 0)',
            visibility: 'visible',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    slideInRight: {
        'from': {
            transform: 'translate3d(100%, 0, 0)',
            visibility: 'visible',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    slideInUp: {
        'from': {
            transform: 'translate3d(0, 100%, 0)',
            visibility: 'visible',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    // slide out
    slideOutDown: {
        'from': {
            transform: 'translate3d(0, 0, 0)',
        },
        'to': {
            visibility: 'hidden',
            transform: 'translate3d(0, 100%, 0)',
        },
    },
    slideOutLeft: {
        'from': {
            transform: 'translate3d(0, 0, 0)',
        },
        'to': {
            visibility: 'hidden',
            transform: 'translate3d(-100%, 0, 0)',
        },
    },
    slideOutRight: {
        'from': {
            transform: 'translate3d(0, 0, 0)',
        },
        'to': {
            visibility: 'hidden',
            transform: 'translate3d(100%, 0, 0)',
        },
    },
    slideOutUp: {
        'from': {
            transform: 'translate3d(0, 0, 0)',
        },
        'to': {
            visibility: 'hidden',
            transform: 'translate3d(0, -100%, 0)',
        },
    },
    // fade in
    fadeIn: {
        'from': {
            opacity: '0',
        },
        'to': {
            opacity: '1',
        },
    },
    fadeInDown: {
        'from': {
            opacity: '0',
            transform: 'translate3d(0, -100%, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInDownBig: {
        'from': {
            opacity: '0',
            transform: 'translate3d(0, -2000px, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInLeft: {
        'from': {
            opacity: '0',
            transform: 'translate3d(-100%, 0, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInLeftBig: {
        'from': {
            opacity: '0',
            transform: 'translate3d(-2000px, 0, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInRight: {
        'from': {
            opacity: '0',
            transform: 'translate3d(100%, 0, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInRightBig: {
        'from': {
            opacity: '0',
            transform: 'translate3d(2000px, 0, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInUp: {
        'from': {
            opacity: '0',
            transform: 'translate3d(0, 100%, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInUpBig: {
        'from': {
            opacity: '0',
            transform: 'translate3d(0, 2000px, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInTopLeft: {
        'from': {
            opacity: '0',
            transform: 'translate3d(-100%, -100%, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInTopRight: {
        'from': {
            opacity: '0',
            transform: 'translate3d(100%, -100%, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInBottomLeft: {
        'from': {
            opacity: '0',
            transform: 'translate3d(-100%, 100%, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInBottomRight: {
        'from': {
            opacity: '0',
            transform: 'translate3d(100%, 100%, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    // fade out
    fadeOut: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
        },
    },
    fadeOutDown: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(0, 100%, 0)',
        },
    },
    fadeOutDownBig: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(0, 2000px, 0)',
        },
    },
    fadeOutLeft: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(-100%, 0, 0)',
        },
    },
    fadeOutLeftBig: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(-2000px, 0, 0)',
        },
    },
    fadeOutRight: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(100%, 0, 0)',
        },
    },
    fadeOutRightBig: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(2000px, 0, 0)',
        },
    },
    fadeOutUp: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(0, -100%, 0)',
        },
    },
    fadeOutUpBig: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(0, -2000px, 0)',
        },
    },
    fadeOutTopLeft: {
        'from': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(-100%, -100%, 0)',
        },
    },
    fadeOutTopRight: {
        'from': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(100%, -100%, 0)',
        },
    },
    fadeOutBottomLeft: {
        'from': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(-100%, 100%, 0)',
        },
    },
    fadeOutBottomRight: {
        'from': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(100%, 100%, 0)',
        },
    },
    // back in
    backInUp: {
        '0%': {
            opacity: '0.7',
            transform: 'translateY(1200px) scale(0.7)',
        },
        '80%': {
            opacity: '0.7',
            transform: 'translateY(0px) scale(0.7)',
        },
        '100%': {
            opacity: '1',
            transform: 'scale(1)',
        },
    },
    backInDown: {
        '0%': {
            opacity: '0.7',
            transform: 'translateY(-1200px) scale(0.7)',
        },
        '80%': {
            opacity: '0.7',
            transform: 'translateY(0px) scale(0.7)',
        },
        '100%': {
            opacity: '1',
            transform: 'scale(1)',
        },
    },
    backInLeft: {
        '0%': {
            opacity: '0.7',
            transform: 'translateX(-2000px) scale(0.7)',
        },
        '80%': {
            opacity: '0.7',
            transform: 'translateX(0px) scale(0.7)',
        },
        '100%': {
            opacity: '1',
            transform: 'scale(1)',
        },
    },
    backInRight: {
        '0%': {
            opacity: '0.7',
            transform: 'translateX(2000px) scale(0.7)',
        },
        '80%': {
            opacity: '0.7',
            transform: 'translateY(0px) scale(0.7)',
        },
        '100%': {
            opacity: '1',
            transform: 'scale(1)',
        },
    },
    // back out
    backOutUp: {
        '0%': {
            opacity: '1',
            transform: 'scale(1)',
        },
        '80%': {
            opacity: '0.7',
            transform: 'translateY(0px) scale(0.7)',
        },
        '100%': {
            opacity: '0.7',
            transform: 'translateY(-700px) scale(0.7)',
        },
    },
    backOutDown: {
        '0%': {
            opacity: '1',
            transform: 'scale(1)',
        },
        '80%': {
            opacity: '0.7',
            transform: 'translateY(0px) scale(0.7)',
        },
        '100%': {
            opacity: '0.7',
            transform: 'translateY(700px) scale(0.7)',
        },
    },
    backOutLeft: {
        '0%': {
            opacity: '1',
            transform: 'scale(1)',
        },
        '80%': {
            opacity: '0.7',
            transform: 'translateX(-2000px) scale(0.7)',
        },
        '100%': {
            opacity: '0.7',
            transform: 'translateY(-700px) scale(0.7)',
        },
    },
    backOutRight: {
        '0%': {
            opacity: '1',
            transform: 'scale(1)',
        },
        '80%': {
            opacity: '0.7',
            transform: 'translateY(0px) scale(0.7)',
        },
        '100%': {
            opacity: '0.7',
            transform: 'translateX(2000px) scale(0.7)',
        },
    },
};

var createPlugin = function (plugin, config) {
    return {
        handler: plugin,
        config: config,
    };
};
createPlugin.withOptions = function (pluginFunction, configFunction) {
    if (configFunction === void 0) { configFunction = function () { return ({}); }; }
    var optionsFunction = function (options) {
        if (options === void 0) { options = {}; }
        return {
            __options: options,
            handler: pluginFunction(options),
            config: configFunction(options),
        };
    };
    optionsFunction.__isOptionsFunction = true;
    // Expose plugin dependencies so that `object-hash` returns a different
    // value if anything here changes, to ensure a rebuild is triggered.
    optionsFunction.__pluginFunction = pluginFunction;
    optionsFunction.__configFunction = configFunction;
    return optionsFunction;
};

var defaultColors = {
    transparent: 'transparent',
    current: 'currentColor',
    inherit: 'inherit',
    light: colors.light,
    dark: colors.dark,
    black: colors.black,
    white: colors.white,
    slate: colors.slate,
    gray: colors.gray,
    zinc: colors.zinc,
    neutral: colors.neutral,
    stone: colors.stone,
    red: colors.red,
    yellow: colors.amber,
    green: colors.emerald,
    blue: colors.blue,
    indigo: colors.indigo,
    purple: colors.violet,
    pink: colors.pink,
    rose: colors.rose,
    fuchsia: colors.fuchsia,
    violet: colors.violet,
    cyan: colors.cyan,
    teal: colors.teal,
    emerald: colors.emerald,
    lime: colors.lime,
    amber: colors.amber,
    orange: colors.orange,
    sky: colors.sky,
    'light-blue': colors.sky,
    'warm-gray': colors.stone,
    'true-gray': colors.neutral,
    'cool-gray': colors.gray,
    'blue-gray': colors.slate,
};
// tShirtScale describes the sizes xs - 7xl
var tShirtScale = {
    'xs': '20rem',
    'sm': '24rem',
    'md': '28rem',
    'lg': '32rem',
    'xl': '36rem',
    '2xl': '42rem',
    '3xl': '48rem',
    '4xl': '56rem',
    '5xl': '64rem',
    '6xl': '72rem',
    '7xl': '80rem',
};
var baseConfig = {
    // purge: [],
    presets: [],
    prefixer: true,
    attributify: false,
    darkMode: 'class',
    theme: {
        orientation: {
            portrait: 'portrait',
            landscape: 'landscape',
        },
        screens: {
            sm: '640px',
            md: '768px',
            lg: '1024px',
            xl: '1280px',
            '2xl': '1536px',
        },
        colors: defaultColors,
        spacing: {
            px: '1px',
            0: '0px',
            0.5: '0.125rem',
            1: '0.25rem',
            1.5: '0.375rem',
            2: '0.5rem',
            2.5: '0.625rem',
            3: '0.75rem',
            3.5: '0.875rem',
            4: '1rem',
            5: '1.25rem',
            6: '1.5rem',
            7: '1.75rem',
            8: '2rem',
            9: '2.25rem',
            10: '2.5rem',
            11: '2.75rem',
            12: '3rem',
            14: '3.5rem',
            16: '4rem',
            20: '5rem',
            24: '6rem',
            28: '7rem',
            32: '8rem',
            36: '9rem',
            40: '10rem',
            44: '11rem',
            48: '12rem',
            52: '13rem',
            56: '14rem',
            60: '15rem',
            64: '16rem',
            72: '18rem',
            80: '20rem',
            96: '24rem',
            // float -> float/4 rem
        },
        animation: {
            none: 'none',
            spin: 'spin 1s linear infinite',
            ping: 'ping 1s cubic-bezier(0, 0, 0.2, 1) infinite',
            pulse: 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
            bounce: 'bounce 1s infinite',
            'shock': {
                animation: 'shock',
                transformOrigin: 'center bottom',
            },
            'flash': 'flash',
            'bubble': 'bubble',
            'rubber-band': 'rubberBand',
            'shake-x': 'shakeX',
            'shake-y': 'shakeY',
            'head-shake': 'headShake 1s ease-in-out',
            'swing': {
                animation: 'swing',
                transformOrigin: 'top center',
            },
            'tada': 'tada',
            'wobble': 'wobble',
            'jello': 'jello',
            'heart-beat': 'heartBeat 1s ease-in-out',
            'hinge': 'hinge 2s',
            'jack-in': 'jackInTheBox',
            'light-speed-in-left': 'lightSpeedInLeft',
            'light-speed-in-right': 'lightSpeedInRight',
            'light-speed-out-left': 'lightSpeedOutLeft',
            'light-speed-out-right': 'lightSpeedOutRight',
            'flip': {
                animation: 'flip',
                backfaceVisibility: 'visible',
            },
            'flip-in-x': {
                animation: 'flipInX',
                backfaceVisibility: 'visible',
            },
            'flip-in-y': {
                animation: 'flipInY',
                backfaceVisibility: 'visible',
            },
            'flip-out-x': {
                animation: 'flipOutX',
                backfaceVisibility: 'visible',
            },
            'flip-out-y': {
                animation: 'flipOutY',
                backfaceVisibility: 'visible',
            },
            'rotate-in': 'rotateIn',
            'rotate-in-down-left': 'rotateInDownLeft',
            'rotate-in-down-right': 'rotateInDownRight',
            'rotate-in-up-left': 'rotateInUpLeft',
            'rotate-in-up-right': 'rotateInUpRight',
            'rotate-out': 'rotateOut',
            'rotate-out-down-left': 'rotateOutDownLeft',
            'rotate-out-down-right': 'rotateOutDownRight',
            'rotate-out-up-left': 'rotateOutUpLeft',
            'rotate-out-up-right': 'rotateOutUpRight',
            'roll-in': 'rollIn',
            'roll-out': 'rollOut',
            'zoom-in': 'zoomIn',
            'zoom-in-down': 'zoomInDown',
            'zoom-in-left': 'zoomInLeft',
            'zoom-in-right': 'zoomInRight',
            'zoom-in-up': 'zoomInUp',
            'bounce-in': 'bounceIn 750ms',
            'bounce-in-down': 'bounceInDown',
            'bounce-in-left': 'bounceInLeft',
            'bounce-in-right': 'bounceInRight',
            'bounce-in-up': 'bounceInUp',
            'bounce-out': 'bounceOut 750ms',
            'bounce-out-down': 'bounceOutDown',
            'bounce-out-left': 'bounceOutLeft',
            'bounce-out-right': 'bounceOutRight',
            'bounce-out-up': 'bounceOutUp',
            'zoom-out': 'zoomOut',
            'zoom-out-down': 'zoomOutDown',
            'zoom-out-left': 'zoomOutLeft',
            'zoom-out-right': 'zoomOutRight',
            'zoom-out-up': 'zoomOutUp',
            'slide-in-down': 'slideInDown',
            'slide-in-left': 'slideInLeft',
            'slide-in-right': 'slideInRight',
            'slide-in-up': 'slideInUp',
            'slide-out-down': 'slideOutDown',
            'slide-out-left': 'slideOutLeft',
            'slide-out-right': 'slideOutRight',
            'slide-out-up': 'slideOutUp',
            'fade-in': 'fadeIn',
            'fade-in-down': 'fadeInDown',
            'fade-in-down-big': 'fadeInDownBig',
            'fade-in-left': 'fadeInLeft',
            'fade-in-left-big': 'fadeInLeftBig',
            'fade-in-right': 'fadeInRight',
            'fade-in-right-big': 'fadeInRightBig',
            'fade-in-up': 'fadeInUp',
            'fade-in-up-big': 'fadeInUpBig',
            'fade-in-top-left': 'fadeInTopLeft',
            'fade-in-top-right': 'fadeInTopRight',
            'fade-in-bottom-left': 'fadeInBottomLeft',
            'fade-in-bottom-right': 'fadeInBottomRight',
            'fade-out': 'fadeOut',
            'fade-out-down': 'fadeOutDown',
            'fade-out-down-big': 'fadeOutDownBig',
            'fade-out-left': 'fadeOutLeft',
            'fade-out-left-big': 'fadeOutLeftBig',
            'fade-out-right': 'fadeOutRight',
            'fade-out-right-big': 'fadeOutRightBig',
            'fade-out-up': 'fadeOutUp',
            'fade-out-up-big': 'fadeOutUpBig',
            'back-in-up': 'backInUp',
            'back-in-down': 'backInDown',
            'back-in-left': 'backInLeft',
            'back-in-right': 'backInRight',
            'back-out-up': 'backOutUp',
            'back-out-down': 'backOutDown',
            'back-out-left': 'backOutLeft',
            'back-out-right': 'backOutRight',
        },
        animationDuration: {
            DEFAULT: '1000ms',
            75: '75ms',
            100: '100ms',
            150: '150ms',
            200: '200ms',
            300: '300ms',
            500: '500ms',
            700: '700ms',
            1000: '1000ms',
            1500: '1500ms',
            2000: '2000ms',
            2500: '2500ms',
            3000: '3000ms',
            // int >=0 -> int ms
        },
        animationDelay: {
            DEFAULT: '500ms',
            75: '75ms',
            100: '100ms',
            150: '150ms',
            200: '200ms',
            300: '300ms',
            500: '500ms',
            700: '700ms',
            1000: '1000ms',
            1500: '1500ms',
            2000: '2000ms',
            2500: '2500ms',
            3000: '3000ms',
            // int >=0 -> int ms
        },
        animationIterationCount: {
            DEFAULT: '1',
            loop: 'infinite',
            'repeat-1': '1',
            'repeat-2': '2',
            'repeat-3': '3',
            'repeat-4': '4',
            'repeat-5': '5',
            'repeat-6': '6',
            'repeat-7': '7',
            'repeat-8': '8',
            'repeat-9': '9',
            'repeat-10': '10',
            'repeat-11': '11',
            'repeat-12': '12',
        },
        animationTimingFunction: {
            DEFAULT: 'ease',
            linear: 'linear',
            in: 'ease-in',
            out: 'ease-out',
            'in-out': 'ease-in-out',
        },
        backdropBlur: function (theme) { return theme('blur'); },
        backdropBrightness: function (theme) { return theme('brightness'); },
        backdropContrast: function (theme) { return theme('contrast'); },
        backdropGrayscale: function (theme) { return theme('grayscale'); },
        backdropHueRotate: function (theme) { return theme('hueRotate'); },
        backdropInvert: function (theme) { return theme('invert'); },
        backdropOpacity: function (theme) { return theme('opacity'); },
        backdropSaturate: function (theme) { return theme('saturate'); },
        backdropSepia: function (theme) { return theme('sepia'); },
        backgroundColor: function (theme) { return theme('colors'); },
        backgroundImage: {
            none: 'none',
            'gradient-1': 'linear-gradient(135deg, #FDEB71 10%, #F8D800 100%)',
            'gradient-2': 'linear-gradient(135deg, #ABDCFF 10%, #0396FF 100%)',
            'gradient-3': 'linear-gradient(135deg, #FEB692 10%, #EA5455 100%)',
            'gradient-4': 'linear-gradient(135deg, #CE9FFC 10%, #7367F0 100%)',
            'gradient-5': 'linear-gradient(135deg, #90F7EC 10%, #32CCBC 100%)',
            'gradient-6': 'linear-gradient(135deg, #FFF6B7 10%, #F6416C 100%)',
            'gradient-7': 'linear-gradient(135deg, #81FBB8 10%, #28C76F 100%)',
            'gradient-8': 'linear-gradient(135deg, #E2B0FF 10%, #9F44D3 100%)',
            'gradient-9': 'linear-gradient(135deg, #F97794 10%, #623AA2 100%)',
            'gradient-10': 'linear-gradient(135deg, #FCCF31 10%, #F55555 100%)',
            'gradient-11': 'linear-gradient(135deg, #F761A1 10%, #8C1BAB 100%)',
            'gradient-12': 'linear-gradient(135deg, #43CBFF 10%, #9708CC 100%)',
            'gradient-13': 'linear-gradient(135deg, #5EFCE8 10%, #736EFE 100%)',
            'gradient-14': 'linear-gradient(135deg, #FAD7A1 10%, #E96D71 100%)',
            'gradient-15': 'linear-gradient(135deg, #FFD26F 10%, #3677FF 100%)',
            'gradient-16': 'linear-gradient(135deg, #A0FE65 10%, #FA016D 100%)',
            'gradient-17': 'linear-gradient(135deg, #FFDB01 10%, #0E197D 100%)',
            'gradient-18': 'linear-gradient(135deg, #FEC163 10%, #DE4313 100%)',
            'gradient-19': 'linear-gradient(135deg, #92FFC0 10%, #002661 100%)',
            'gradient-20': 'linear-gradient(135deg, #EEAD92 10%, #6018DC 100%)',
            'gradient-21': 'linear-gradient(135deg, #F6CEEC 10%, #D939CD 100%)',
            'gradient-22': 'linear-gradient(135deg, #52E5E7 10%, #130CB7 100%)',
            'gradient-23': 'linear-gradient(135deg, #F1CA74 10%, #A64DB6 100%)',
            'gradient-24': 'linear-gradient(135deg, #E8D07A 10%, #5312D6 100%)',
            'gradient-25': 'linear-gradient(135deg, #EECE13 10%, #B210FF 100%)',
            'gradient-26': 'linear-gradient(135deg, #79F1A4 10%, #0E5CAD 100%)',
            'gradient-27': 'linear-gradient(135deg, #FDD819 10%, #E80505 100%)',
            'gradient-28': 'linear-gradient(135deg, #FFF3B0 10%, #CA26FF 100%)',
            'gradient-29': 'linear-gradient(135deg, #FFF5C3 10%, #9452A5 100%)',
            'gradient-30': 'linear-gradient(135deg, #F05F57 10%, #360940 100%)',
            'gradient-31': 'linear-gradient(135deg, #2AFADF 10%, #4C83FF 100%)',
            'gradient-32': 'linear-gradient(135deg, #FFF886 10%, #F072B6 100%)',
            'gradient-33': 'linear-gradient(135deg, #97ABFF 10%, #123597 100%)',
            'gradient-34': 'linear-gradient(135deg, #F5CBFF 10%, #C346C2 100%)',
            'gradient-35': 'linear-gradient(135deg, #FFF720 10%, #3CD500 100%)',
            'gradient-36': 'linear-gradient(135deg, #FF6FD8 10%, #3813C2 100%)',
            'gradient-37': 'linear-gradient(135deg, #EE9AE5 10%, #5961F9 100%)',
            'gradient-38': 'linear-gradient(135deg, #FFD3A5 10%, #FD6585 100%)',
            'gradient-39': 'linear-gradient(135deg, #C2FFD8 10%, #465EFB 100%)',
            'gradient-40': 'linear-gradient(135deg, #FD6585 10%, #0D25B9 100%)',
            'gradient-41': 'linear-gradient(135deg, #FD6E6A 10%, #FFC600 100%)',
            'gradient-42': 'linear-gradient(135deg, #65FDF0 10%, #1D6FA3 100%)',
            'gradient-43': 'linear-gradient(135deg, #6B73FF 10%, #000DFF 100%)',
            'gradient-44': 'linear-gradient(135deg, #FF7AF5 10%, #513162 100%)',
            'gradient-45': 'linear-gradient(135deg, #F0FF00 10%, #58CFFB 100%)',
            'gradient-46': 'linear-gradient(135deg, #FFE985 10%, #FA742B 100%)',
            'gradient-47': 'linear-gradient(135deg, #FFA6B7 10%, #1E2AD2 100%)',
            'gradient-48': 'linear-gradient(135deg, #FFAA85 10%, #B3315F 100%)',
            'gradient-49': 'linear-gradient(135deg, #72EDF2 10%, #5151E5 100%)',
            'gradient-50': 'linear-gradient(135deg, #FF9D6C 10%, #BB4E75 100%)',
            'gradient-51': 'linear-gradient(135deg, #F6D242 10%, #FF52E5 100%)',
            'gradient-52': 'linear-gradient(135deg, #69FF97 10%, #00E4FF 100%)',
            'gradient-53': 'linear-gradient(135deg, #3B2667 10%, #BC78EC 100%)',
            'gradient-54': 'linear-gradient(135deg, #70F570 10%, #49C628 100%)',
            'gradient-55': 'linear-gradient(135deg, #3C8CE7 10%, #00EAFF 100%)',
            'gradient-56': 'linear-gradient(135deg, #FAB2FF 10%, #1904E5 100%)',
            'gradient-57': 'linear-gradient(135deg, #81FFEF 10%, #F067B4 100%)',
            'gradient-58': 'linear-gradient(135deg, #FFA8A8 10%, #FCFF00 100%)',
            'gradient-59': 'linear-gradient(135deg, #FFCF71 10%, #2376DD 100%)',
            'gradient-60': 'linear-gradient(135deg, #FF96F9 10%, #C32BAC 100%)',
            'gradient-to-t': 'linear-gradient(to top, var(--tw-gradient-stops))',
            'gradient-to-tr': 'linear-gradient(to top right, var(--tw-gradient-stops))',
            'gradient-to-r': 'linear-gradient(to right, var(--tw-gradient-stops))',
            'gradient-to-br': 'linear-gradient(to bottom right, var(--tw-gradient-stops))',
            'gradient-to-b': 'linear-gradient(to bottom, var(--tw-gradient-stops))',
            'gradient-to-bl': 'linear-gradient(to bottom left, var(--tw-gradient-stops))',
            'gradient-to-l': 'linear-gradient(to left, var(--tw-gradient-stops))',
            'gradient-to-tl': 'linear-gradient(to top left, var(--tw-gradient-stops))',
        },
        backgroundOpacity: function (theme) { return theme('opacity'); },
        backgroundPosition: {
            bottom: 'bottom',
            center: 'center',
            left: 'left',
            'left-bottom': 'left bottom',
            'left-top': 'left top',
            right: 'right',
            'right-bottom': 'right bottom',
            'right-top': 'right top',
            top: 'top',
        },
        backgroundSize: {
            auto: 'auto',
            cover: 'cover',
            contain: 'contain',
        },
        blur: {
            DEFAULT: '8px',
            0: '0',
            sm: '4px',
            md: '12px',
            lg: '16px',
            xl: '24px',
            '2xl': '40px',
            '3xl': '64px',
        },
        borderColor: function (theme) {
            var _a;
            return (__assign$4({ DEFAULT: theme('colors.gray.200', 'currentColor') }, ((_a = theme('colors')) !== null && _a !== void 0 ? _a : {})));
        },
        borderOpacity: function (theme) { return theme('opacity'); },
        borderRadius: {
            DEFAULT: '0.25rem',
            none: '0px',
            sm: '0.125rem',
            md: '0.375rem',
            lg: '0.5rem',
            xl: '0.75rem',
            '2xl': '1rem',
            '3xl': '1.5rem',
            '1': '100%',
            full: '9999px',
        },
        borderWidth: {
            DEFAULT: '1px',
            0: '0px',
            2: '2px',
            4: '4px',
            8: '8px',
            // int >=0 -> int px
        },
        boxShadow: {
            DEFAULT: '0 1px 3px 0 rgb(0 0 0/0.1),0 1px 2px -1px rgb(0 0 0/0.1)',
            sm: '0 1px 2px 0 rgb(0 0 0/0.05)',
            md: '0 4px 6px -1px rgb(0 0 0/0.1),0 2px 4px -2px rgb(0 0 0/0.1)',
            lg: '0 10px 15px -3px rgb(0 0 0/0.1),0 4px 6px -4px rgb(0 0 0/0.1)',
            xl: '0 20px 25px -5px rgb(0 0 0/0.1),0 8px 10px -6px rgb(0 0 0/0.1)',
            '2xl': '0 25px 50px -12px rgb(0 0 0/0.25)',
            inner: 'inset 0 2px 4px 0 rgb(0 0 0/0.05)',
            none: '0 0 #0000',
        },
        boxShadowColor: function (theme) { return theme('colors'); },
        brightness: {
            0: '0',
            50: '.5',
            75: '.75',
            90: '.9',
            95: '.95',
            100: '1',
            105: '1.05',
            110: '1.1',
            125: '1.25',
            150: '1.5',
            200: '2',
        },
        caretColor: function (theme) {
            var _a;
            return (__assign$4({ auto: 'auto' }, ((_a = theme('colors')) !== null && _a !== void 0 ? _a : {})));
        },
        caretOpacity: function (theme) { return theme('opacity'); },
        columns: __assign$4(__assign$4({}, tShirtScale), { auto: 'auto', 1: '1', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: '10', 11: '11', 12: '12', '3xs': '16rem', '2xs': '18rem' }),
        container: {},
        content: {
            DEFAULT: '""',
            'open-quote': 'open-quote',
            'close-quote': 'close-quote',
            'open-square': '"["',
            'close-square': '"]"',
            'open-curly': '"{"',
            'close-curly': '"}"',
            'open-bracket': '"("',
            'close-bracket': '")"',
        },
        contrast: {
            0: '0',
            50: '.5',
            75: '.75',
            100: '1',
            125: '1.25',
            150: '1.5',
            200: '2',
        },
        cursor: {
            auto: 'auto',
            default: 'default',
            pointer: 'pointer',
            wait: 'wait',
            text: 'text',
            move: 'move',
            help: 'help',
            'not-allowed': 'not-allowed',
        },
        divideColor: function (theme) { return theme('borderColor'); },
        divideOpacity: function (theme) { return theme('borderOpacity'); },
        divideWidth: function (theme) { return theme('borderWidth'); },
        dropShadow: {
            DEFAULT: ['0 1px 2px rgba(0, 0, 0, 0.1)', '0 1px 1px rgba(0, 0, 0, 0.06)'],
            sm: '0 1px 1px rgba(0,0,0,0.05)',
            md: ['0 4px 3px rgba(0, 0, 0, 0.07)', '0 2px 2px rgba(0, 0, 0, 0.06)'],
            lg: ['0 10px 8px rgba(0, 0, 0, 0.04)', '0 4px 3px rgba(0, 0, 0, 0.1)'],
            xl: ['0 20px 13px rgba(0, 0, 0, 0.03)', '0 8px 5px rgba(0, 0, 0, 0.08)'],
            '2xl': '0 25px 25px rgba(0, 0, 0, 0.15)',
            none: '0 0 #0000',
        },
        fill: function (theme) {
            var _a;
            return (__assign$4(__assign$4({}, ((_a = theme('colors')) !== null && _a !== void 0 ? _a : {})), { none: 'none' }));
        },
        flex: {
            1: '1 1 0%',
            auto: '1 1 auto',
            initial: '0 1 auto',
            none: 'none',
        },
        flexGrow: {
            DEFAULT: '1',
            0: '0',
        },
        flexShrink: {
            DEFAULT: '1',
            0: '0',
        },
        fontFamily: {
            sans: [
                'ui-sans-serif',
                'system-ui',
                '-apple-system',
                'BlinkMacSystemFont',
                '"Segoe UI"',
                'Roboto',
                '"Helvetica Neue"',
                'Arial',
                '"Noto Sans"',
                'sans-serif',
                '"Apple Color Emoji"',
                '"Segoe UI Emoji"',
                '"Segoe UI Symbol"',
                '"Noto Color Emoji"',
            ],
            serif: [
                'ui-serif',
                'Georgia',
                'Cambria',
                '"Times New Roman"',
                'Times',
                'serif',
            ],
            mono: [
                'ui-monospace',
                'SFMono-Regular',
                'Menlo',
                'Monaco',
                'Consolas',
                '"Liberation Mono"',
                '"Courier New"',
                'monospace',
            ],
        },
        fontSize: {
            xs: ['0.75rem', { lineHeight: '1rem' }],
            sm: ['0.875rem', { lineHeight: '1.25rem' }],
            base: ['1rem', { lineHeight: '1.5rem' }],
            lg: ['1.125rem', { lineHeight: '1.75rem' }],
            xl: ['1.25rem', { lineHeight: '1.75rem' }],
            '2xl': ['1.5rem', { lineHeight: '2rem' }],
            '3xl': ['1.875rem', { lineHeight: '2.25rem' }],
            '4xl': ['2.25rem', { lineHeight: '2.5rem' }],
            '5xl': ['3rem', { lineHeight: '1' }],
            '6xl': ['3.75rem', { lineHeight: '1' }],
            '7xl': ['4.5rem', { lineHeight: '1' }],
            '8xl': ['6rem', { lineHeight: '1' }],
            '9xl': ['8rem', { lineHeight: '1' }],
            // nxl -> [n rem, lineHeight: 1]
        },
        fontWeight: {
            thin: '100',
            extralight: '200',
            light: '300',
            normal: '400',
            medium: '500',
            semibold: '600',
            bold: '700',
            extrabold: '800',
            black: '900',
            // int[0, 900] -> int
        },
        gap: function (theme) { return theme('spacing'); },
        gradientColorStops: function (theme) { return theme('colors'); },
        grayscale: {
            DEFAULT: '100%',
            0: '0',
        },
        gridAutoColumns: {
            auto: 'auto',
            min: 'min-content',
            max: 'max-content',
            fr: 'minmax(0, 1fr)',
        },
        gridAutoRows: {
            auto: 'auto',
            min: 'min-content',
            max: 'max-content',
            fr: 'minmax(0, 1fr)',
        },
        gridColumn: {
            auto: 'auto',
            'span-1': 'span 1 / span 1',
            'span-2': 'span 2 / span 2',
            'span-3': 'span 3 / span 3',
            'span-4': 'span 4 / span 4',
            'span-5': 'span 5 / span 5',
            'span-6': 'span 6 / span 6',
            'span-7': 'span 7 / span 7',
            'span-8': 'span 8 / span 8',
            'span-9': 'span 9 / span 9',
            'span-10': 'span 10 / span 10',
            'span-11': 'span 11 / span 11',
            'span-12': 'span 12 / span 12',
            // span-int(>=1) -> span int / span int
            'span-full': '1 / -1',
        },
        gridColumnEnd: {
            auto: 'auto',
            1: '1',
            2: '2',
            3: '3',
            4: '4',
            5: '5',
            6: '6',
            7: '7',
            8: '8',
            9: '9',
            10: '10',
            11: '11',
            12: '12',
            13: '13',
            // int >=1 -> int
        },
        gridColumnStart: {
            auto: 'auto',
            1: '1',
            2: '2',
            3: '3',
            4: '4',
            5: '5',
            6: '6',
            7: '7',
            8: '8',
            9: '9',
            10: '10',
            11: '11',
            12: '12',
            13: '13',
            // int >=1 -> int
        },
        gridRow: {
            auto: 'auto',
            'span-1': 'span 1 / span 1',
            'span-2': 'span 2 / span 2',
            'span-3': 'span 3 / span 3',
            'span-4': 'span 4 / span 4',
            'span-5': 'span 5 / span 5',
            'span-6': 'span 6 / span 6',
            // span-int(>=1) -> span int / span int
            'span-full': '1 / -1',
        },
        gridRowStart: {
            auto: 'auto',
            1: '1',
            2: '2',
            3: '3',
            4: '4',
            5: '5',
            6: '6',
            7: '7',
            // int >=1 -> int
        },
        gridRowEnd: {
            auto: 'auto',
            1: '1',
            2: '2',
            3: '3',
            4: '4',
            5: '5',
            6: '6',
            7: '7',
            // int >=1 -> int
        },
        gridTemplateColumns: {
            none: 'none',
            1: 'repeat(1, minmax(0, 1fr))',
            2: 'repeat(2, minmax(0, 1fr))',
            3: 'repeat(3, minmax(0, 1fr))',
            4: 'repeat(4, minmax(0, 1fr))',
            5: 'repeat(5, minmax(0, 1fr))',
            6: 'repeat(6, minmax(0, 1fr))',
            7: 'repeat(7, minmax(0, 1fr))',
            8: 'repeat(8, minmax(0, 1fr))',
            9: 'repeat(9, minmax(0, 1fr))',
            10: 'repeat(10, minmax(0, 1fr))',
            11: 'repeat(11, minmax(0, 1fr))',
            12: 'repeat(12, minmax(0, 1fr))',
            // int >=1 -> repeat(int, minmax(0, 1fr))
        },
        gridTemplateRows: {
            none: 'none',
            1: 'repeat(1, minmax(0, 1fr))',
            2: 'repeat(2, minmax(0, 1fr))',
            3: 'repeat(3, minmax(0, 1fr))',
            4: 'repeat(4, minmax(0, 1fr))',
            5: 'repeat(5, minmax(0, 1fr))',
            6: 'repeat(6, minmax(0, 1fr))',
            // int >=1 -> repeat(int, minmax(0, 1fr))
        },
        height: function (theme, _a) {
            var _b, _c;
            var breakpoints = _a.breakpoints;
            return (__assign$4(__assign$4(__assign$4(__assign$4({}, ((_b = theme('spacing')) !== null && _b !== void 0 ? _b : {})), tShirtScale), { '1/2': '50%', '1/3': '33.333333%', '2/3': '66.666667%', '1/4': '25%', '2/4': '50%', '3/4': '75%', '1/5': '20%', '2/5': '40%', '3/5': '60%', '4/5': '80%', '1/6': '16.666667%', '2/6': '33.333333%', '3/6': '50%', '4/6': '66.666667%', '5/6': '83.333333%', 
                // fraction -> percent
                auto: 'auto', full: '100%', min: 'min-content', max: 'max-content', prose: '65ch', screen: '100vh' }), breakpoints((_c = theme('screens')) !== null && _c !== void 0 ? _c : {})));
        },
        hueRotate: {
            '-180': '-180deg',
            '-90': '-90deg',
            '-60': '-60deg',
            '-30': '-30deg',
            '-15': '-15deg',
            0: '0deg',
            15: '15deg',
            30: '30deg',
            60: '60deg',
            90: '90deg',
            180: '180deg',
        },
        inset: function (theme, _a) {
            var _b;
            var negative = _a.negative;
            return (__assign$4(__assign$4(__assign$4({ auto: 'auto' }, ((_b = theme('spacing')) !== null && _b !== void 0 ? _b : {})), negative(theme('spacing'))), { '1/2': '50%', '1/3': '33.333333%', '2/3': '66.666667%', '1/4': '25%', '2/4': '50%', '3/4': '75%', full: '100%', '-1/2': '-50%', '-1/3': '-33.333333%', '-2/3': '-66.666667%', '-1/4': '-25%', '-2/4': '-50%', '-3/4': '-75%', '-full': '-100%' }));
        },
        invert: {
            DEFAULT: '100%',
            0: '0',
        },
        keyframes: keyframes,
        letterSpacing: {
            tighter: '-0.05em',
            tight: '-0.025em',
            normal: '0em',
            wide: '0.025em',
            wider: '0.05em',
            widest: '0.1em',
        },
        lineHeight: {
            none: '1',
            tight: '1.25',
            snug: '1.375',
            normal: '1.5',
            relaxed: '1.625',
            loose: '2',
            3: '.75rem',
            4: '1rem',
            5: '1.25rem',
            6: '1.5rem',
            7: '1.75rem',
            8: '2rem',
            9: '2.25rem',
            10: '2.5rem',
            // int>=0 -> int/4 rem
        },
        listStyleType: {
            none: 'none',
            circle: 'circle',
            square: 'square',
            disc: 'disc',
            decimal: 'decimal',
            'zero-decimal': 'decimal-leading-zero',
            greek: 'lower-greek',
            roman: 'lower-roman',
            alpha: 'lower-alpha',
            'upper-roman': 'upper-roman',
            'upper-alpha': 'upper-alpha',
        },
        margin: function (theme, _a) {
            var _b;
            var negative = _a.negative;
            return (__assign$4(__assign$4({ auto: 'auto' }, ((_b = theme('spacing')) !== null && _b !== void 0 ? _b : {})), negative(theme('spacing'))));
        },
        maxHeight: function (theme, _a) {
            var _b, _c;
            var breakpoints = _a.breakpoints;
            return (__assign$4(__assign$4(__assign$4(__assign$4({}, breakpoints((_b = theme('screens')) !== null && _b !== void 0 ? _b : {})), ((_c = theme('spacing')) !== null && _c !== void 0 ? _c : {})), tShirtScale), { none: 'none', full: '100%', min: 'min-content', max: 'max-content', prose: '65ch', screen: '100vh' }));
        },
        maxWidth: function (theme, _a) {
            var _b, _c;
            var breakpoints = _a.breakpoints;
            return (__assign$4(__assign$4(__assign$4(__assign$4({}, breakpoints((_b = theme('screens')) !== null && _b !== void 0 ? _b : {})), ((_c = theme('spacing')) !== null && _c !== void 0 ? _c : {})), tShirtScale), { none: 'none', full: '100%', min: 'min-content', max: 'max-content', prose: '65ch', screen: '100vw' }));
        },
        minHeight: function (theme) { return theme('maxHeight'); },
        minWidth: function (theme) { return theme('maxWidth'); },
        objectPosition: {
            bottom: 'bottom',
            center: 'center',
            left: 'left',
            'left-bottom': 'left bottom',
            'left-top': 'left top',
            right: 'right',
            'right-bottom': 'right bottom',
            'right-top': 'right top',
            top: 'top',
        },
        opacity: {
            0: '0',
            5: '0.05',
            10: '0.1',
            20: '0.2',
            25: '0.25',
            30: '0.3',
            40: '0.4',
            50: '0.5',
            60: '0.6',
            70: '0.7',
            75: '0.75',
            80: '0.8',
            90: '0.9',
            95: '0.95',
            100: '1',
            // float -> float/100
        },
        order: {
            first: '-9999',
            last: '9999',
            none: '0',
            1: '1',
            2: '2',
            3: '3',
            4: '4',
            5: '5',
            6: '6',
            7: '7',
            8: '8',
            9: '9',
            10: '10',
            11: '11',
            12: '12',
            // int[1, 9999]
        },
        outlineColor: function (theme) { return theme('colors'); },
        outlineWidth: {
            0: '0px',
            1: '1px',
            2: '2px',
            4: '4px',
            8: '8px',
        },
        outlineOffset: {
            0: '0px',
            1: '1px',
            2: '2px',
            4: '4px',
            8: '8px',
        },
        padding: function (theme) { return theme('spacing'); },
        perspective: function (theme) {
            var _a;
            return (__assign$4(__assign$4(__assign$4({}, ((_a = theme('spacing')) !== null && _a !== void 0 ? _a : {})), tShirtScale), { none: 'none' }));
        },
        perspectiveOrigin: {
            center: 'center',
            top: 'top',
            'top-right': 'top right',
            right: 'right',
            'bottom-right': 'bottom right',
            bottom: 'bottom',
            'bottom-left': 'bottom left',
            left: 'left',
            'top-left': 'top left',
        },
        placeholderColor: function (theme) { return theme('colors'); },
        placeholderOpacity: function (theme) { return theme('opacity'); },
        ringColor: function (theme) {
            var _a;
            return (__assign$4({ DEFAULT: theme('colors.blue.500', '#3b82f6') }, ((_a = theme('colors')) !== null && _a !== void 0 ? _a : {})));
        },
        ringOffsetColor: function (theme) { return theme('colors'); },
        ringOffsetWidth: {
            0: '0px',
            1: '1px',
            2: '2px',
            4: '4px',
            8: '8px',
            // float -> float px
        },
        ringOpacity: function (theme) {
            var _a;
            return (__assign$4({ DEFAULT: '0.5' }, ((_a = theme('opacity')) !== null && _a !== void 0 ? _a : {})));
        },
        ringWidth: {
            DEFAULT: '3px',
            0: '0px',
            1: '1px',
            2: '2px',
            4: '4px',
            8: '8px',
            // float -> float px
        },
        rotate: {
            '-180': '-180deg',
            '-90': '-90deg',
            '-45': '-45deg',
            '-12': '-12deg',
            '-6': '-6deg',
            '-3': '-3deg',
            '-2': '-2deg',
            '-1': '-1deg',
            0: '0deg',
            1: '1deg',
            2: '2deg',
            3: '3deg',
            6: '6deg',
            12: '12deg',
            45: '45deg',
            90: '90deg',
            180: '180deg',
            // float[0, 360] -> float[0deg, 360deg]
            // ...negative
        },
        saturate: {
            DEFAULT: '0',
            0: '0',
            50: '.5',
            100: '1',
            150: '1.5',
            200: '2',
        },
        scale: {
            0: '0',
            50: '.5',
            75: '.75',
            90: '.9',
            95: '.95',
            100: '1',
            105: '1.05',
            110: '1.1',
            125: '1.25',
            150: '1.5',
            // int >=0 -> int/100
        },
        sepia: {
            DEFAULT: '100%',
            0: '0',
        },
        skew: {
            '-12': '-12deg',
            '-6': '-6deg',
            '-3': '-3deg',
            '-2': '-2deg',
            '-1': '-1deg',
            0: '0deg',
            1: '1deg',
            2: '2deg',
            3: '3deg',
            6: '6deg',
            12: '12deg',
            // float[0, 360] -> float[0deg, 360deg]
            // ...negative
        },
        space: function (theme, _a) {
            var negative = _a.negative;
            return (__assign$4(__assign$4({}, theme('spacing')), negative(theme('spacing'))));
        },
        stroke: function (theme) {
            var _a;
            return (__assign$4(__assign$4({}, ((_a = theme('colors')) !== null && _a !== void 0 ? _a : {})), { none: 'none' }));
        },
        strokeWidth: {
            0: '0',
            1: '1',
            2: '2',
        },
        strokeDashArray: {
            0: '0',
            1: '1',
            2: '2',
        },
        strokeDashOffset: {
            0: '0',
            1: '1',
            2: '2',
        },
        tabSize: {
            DEFAULT: '4',
            0: '0',
            2: '2',
            4: '4',
            8: '8',
            // int >=0 -> int px
        },
        textColor: function (theme) { return theme('colors'); },
        textOpacity: function (theme) { return theme('opacity'); },
        textShadow: {
            DEFAULT: '0px 0px 1px rgb(0 0 0 / 20%), 0px 0px 1px rgb(1 0 5 / 10%)',
            sm: '1px 1px 3px rgb(36 37 47 / 25%)',
            md: '0px 1px 2px rgb(30 29 39 / 19%), 1px 2px 4px rgb(54 64 147 / 18%)',
            lg: '3px 3px 6px rgb(0 0 0 / 26%), 0 0 5px rgb(15 3 86 / 22%)',
            xl: '1px 1px 3px rgb(0 0 0 / 29%), 2px 4px 7px rgb(73 64 125 / 35%)',
            none: 'none',
        },
        textDecorationColor: function (theme) { return theme('colors'); },
        textDecorationOpacity: function (theme) { return theme('opacity'); },
        textDecorationLength: {
            'auto': 'auto',
            0: '0px',
            2: '2px',
            4: '4px',
            8: '8px',
        },
        textDecorationOffset: {
            'auto': 'auto',
            0: '0px',
            1: '1px',
            2: '2px',
            4: '4px',
            8: '8px',
        },
        textDecorationThickness: {
            'auto': 'auto',
            'from-font': 'from-font',
            0: '0px',
            1: '1px',
            2: '2px',
            4: '4px',
            8: '8px',
        },
        textIndent: {
            DEFAULT: '1.5rem',
            xs: '0.5rem',
            sm: '1rem',
            md: '1.5rem',
            lg: '2rem',
            xl: '2.5rem',
            '2xl': '3rem',
            '3xl': '4rem',
        },
        textStrokeColor: function (theme) {
            var _a;
            return (__assign$4({ DEFAULT: theme('colors.gray.200', 'currentColor') }, ((_a = theme('colors')) !== null && _a !== void 0 ? _a : {})));
        },
        textStrokeWidth: {
            DEFAULT: 'medium',
            'none': '0',
            'sm': 'thin',
            'md': 'medium',
            'lg': 'thick',
        },
        transformOrigin: {
            center: 'center',
            top: 'top',
            'top-right': 'top right',
            right: 'right',
            'bottom-right': 'bottom right',
            bottom: 'bottom',
            'bottom-left': 'bottom left',
            left: 'left',
            'top-left': 'top left',
        },
        transitionDuration: {
            DEFAULT: '150ms',
            75: '75ms',
            100: '100ms',
            150: '150ms',
            200: '200ms',
            300: '300ms',
            500: '500ms',
            700: '700ms',
            1000: '1000ms',
            // int >=0 -> int ms
        },
        transitionDelay: {
            75: '75ms',
            100: '100ms',
            150: '150ms',
            200: '200ms',
            300: '300ms',
            500: '500ms',
            700: '700ms',
            1000: '1000ms',
            // int >=0 -> int ms
        },
        transitionProperty: {
            DEFAULT: 'background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter',
            none: 'none',
            all: 'all',
            colors: 'background-color, border-color, color, fill, stroke',
            opacity: 'opacity',
            shadow: 'box-shadow',
            transform: 'transform',
        },
        transitionTimingFunction: {
            DEFAULT: 'cubic-bezier(0.4, 0, 0.2, 1)',
            linear: 'linear',
            in: 'cubic-bezier(0.4, 0, 1, 1)',
            out: 'cubic-bezier(0, 0, 0.2, 1)',
            'in-out': 'cubic-bezier(0.4, 0, 0.2, 1)',
        },
        translate: function (theme, _a) {
            var _b;
            var negative = _a.negative;
            return (__assign$4(__assign$4(__assign$4({}, ((_b = theme('spacing')) !== null && _b !== void 0 ? _b : {})), negative(theme('spacing'))), { '1/2': '50%', '1/3': '33.333333%', '2/3': '66.666667%', '1/4': '25%', '2/4': '50%', '3/4': '75%', full: '100%', '-1/2': '-50%', '-1/3': '-33.333333%', '-2/3': '-66.666667%', '-1/4': '-25%', '-2/4': '-50%', '-3/4': '-75%', '-full': '-100%' }));
        },
        width: function (theme, _a) {
            var _b, _c;
            var breakpoints = _a.breakpoints;
            return (__assign$4(__assign$4(__assign$4(__assign$4({}, ((_b = theme('spacing')) !== null && _b !== void 0 ? _b : {})), tShirtScale), { 
                // fraction -> percent
                '1/2': '50%', '1/3': '33.333333%', '2/3': '66.666667%', '1/4': '25%', '2/4': '50%', '3/4': '75%', '1/5': '20%', '2/5': '40%', '3/5': '60%', '4/5': '80%', '1/6': '16.666667%', '2/6': '33.333333%', '3/6': '50%', '4/6': '66.666667%', '5/6': '83.333333%', '1/12': '8.333333%', '2/12': '16.666667%', '3/12': '25%', '4/12': '33.333333%', '5/12': '41.666667%', '6/12': '50%', '7/12': '58.333333%', '8/12': '66.666667%', '9/12': '75%', '10/12': '83.333333%', '11/12': '91.666667%', auto: 'auto', full: '100%', min: 'min-content', max: 'max-content', prose: '65ch', screen: '100vw' }), breakpoints((_c = theme('screens')) !== null && _c !== void 0 ? _c : {})));
        },
        zIndex: {
            auto: 'auto',
            0: '0',
            10: '10',
            20: '20',
            30: '30',
            40: '40',
            50: '50',
            // int[0, 99999] ->  int[0, 99999]
            // ...negative
        },
    },
    variantOrder: variantOrder,
    plugins: [
        createPlugin(function (_a) {
            var addUtilities = _a.addUtilities;
            addUtilities({
                '.before\\:contents': {
                    '&::before': {
                        content: '""',
                        display: 'contents',
                    },
                },
                '.after\\:contents': {
                    '&::after': {
                        content: '""',
                        display: 'contents',
                    },
                },
            });
        }),
    ],
    handlers: {
        static: true,
        time: true,
        color: true,
        opacity: true,
        number: true,
        string: true,
        bracket: true,
        hex: true,
        nxl: true,
        fraction: true,
        size: true,
        variable: true,
        negative: true,
    },
};

// https://drafts.csswg.org/cssom/#serialize-an-identifier
function cssEscape(str) {
    var length = str.length;
    var index = -1;
    var codeUnit;
    var result = '';
    var firstCodeUnit = str.charCodeAt(0);
    while (++index < length) {
        codeUnit = str.charCodeAt(index);
        // Note: there’s no need to special-case astral symbols, surrogate
        // pairs, or lone surrogates.
        // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
        // (U+FFFD).
        if (codeUnit === 0x0000) {
            result += '\uFFFD';
            continue;
        }
        // Comma
        if (codeUnit === 44) {
            result += '\\2c ';
            continue;
        }
        if (
        // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
        // U+007F, […]
        (codeUnit >= 0x0001 && codeUnit <= 0x001f) ||
            codeUnit === 0x007f ||
            // If the character is the first character and is in the range [0-9]
            // (U+0030 to U+0039), […]
            (index === 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
            // If the character is the second character and is in the range [0-9]
            // (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
            (index === 1 &&
                codeUnit >= 0x0030 &&
                codeUnit <= 0x0039 &&
                firstCodeUnit === 0x002d)) {
            // https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
            result += '\\' + codeUnit.toString(16) + ' ';
            continue;
        }
        if (
        // If the character is the first character and is a `-` (U+002D), and
        // there is no second character, […]
        index === 0 &&
            length === 1 &&
            codeUnit === 0x002d) {
            result += '\\' + str.charAt(index);
            continue;
        }
        // If the character is not handled by one of the above rules and is
        // greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
        // is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
        // U+005A), or [a-z] (U+0061 to U+007A), […]
        if (codeUnit >= 0x0080 ||
            codeUnit === 0x002d ||
            codeUnit === 0x005f ||
            (codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
            (codeUnit >= 0x0041 && codeUnit <= 0x005a) ||
            (codeUnit >= 0x0061 && codeUnit <= 0x007a)) {
            // the character itself
            result += str.charAt(index);
            continue;
        }
        // Otherwise, the escaped character.
        // https://drafts.csswg.org/cssom/#escape-a-character
        result += '\\' + str.charAt(index);
    }
    return result;
}

function combineConfig(a, b, arrayMergeDepth) {
    if (arrayMergeDepth === void 0) { arrayMergeDepth = Infinity; }
    var output = __assign$4({}, a);
    for (var _i = 0, _a = Object.entries(b); _i < _a.length; _i++) {
        var _b = _a[_i], key_of_b = _b[0], value_of_b = _b[1];
        if (key_of_b in a) {
            var value_of_a = a[key_of_b];
            if (value_of_a !== value_of_b) {
                if (value_of_b !== null && value_of_b.constructor !== Object) {
                    if (arrayMergeDepth > 0 && Array.isArray(value_of_a) && Array.isArray(value_of_b)) {
                        output[key_of_b] = __spreadArray$6(__spreadArray$6([], value_of_a, true), value_of_b, true);
                    }
                    else {
                        output[key_of_b] = value_of_b;
                    }
                }
                else if (value_of_a !== null && value_of_a.constructor === Object) {
                    output[key_of_b] = combineConfig(value_of_a, value_of_b, arrayMergeDepth - 1);
                }
                else if (Array.isArray(value_of_a)) {
                    output[key_of_b] = __spreadArray$6(__spreadArray$6([], value_of_a, true), Array.isArray(value_of_b) ? value_of_b : [value_of_b], true);
                }
                else {
                    output[key_of_b] = __assign$4({ DEFAULT: value_of_a }, value_of_b);
                }
            }
        }
        else {
            output[key_of_b] = value_of_b;
        }
    }
    return output;
}

function diffConfig(a, b) {
    if (typeof a !== typeof b)
        return b;
    if (Array.isArray(a) && Array.isArray(b)) {
        if (JSON.stringify(a) !== JSON.stringify(b))
            return b;
        return;
    }
    if (a && b && typeof a === 'object' && typeof b === 'object') {
        var output = {};
        for (var _i = 0, _a = Object.entries(b); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            if (key in a) {
                var diff = diffConfig(a[key], b[key]);
                if (diff)
                    output[key] = diff;
            }
            else {
                output[key] = value;
            }
        }
        if (Object.keys(output).length === 0)
            return;
        return output;
    }
    if (a !== b)
        return b;
}

function createHandler(handlers) {
    if (handlers === void 0) { handlers = { static: true }; }
    return function (utility, value, color) {
        var handler = {
            utility: utility,
            value: value,
            color: color,
            _amount: utility.amount,
            handleStatic: handlers.static ? function (map, callback) {
                if (handler.value)
                    return handler;
                if (map && typeof map === 'object') {
                    var knownMap = map;
                    if (knownMap.DEFAULT)
                        knownMap[handler.utility.raw] = knownMap.DEFAULT;
                    if (handler._amount in knownMap)
                        handler.value = callback
                            ? callback(handler._amount)
                            : "".concat(knownMap[handler._amount]);
                }
                return handler;
            } : function () { return handler; },
            handleBody: handlers.static ? function (map, callback) {
                if (handler.value)
                    return handler;
                if (map && typeof map === 'object') {
                    var knownMap = map;
                    if (knownMap.DEFAULT)
                        knownMap[''] = knownMap.DEFAULT;
                    var body = handler.utility.body;
                    if (body in knownMap)
                        handler.value = callback ? callback(body) : "".concat(knownMap[body]);
                }
                return handler;
            } : function () { return handler; },
            handleNumber: handlers.number ? function (start, end, type, callback) {
                if (start === void 0) { start = -Infinity; }
                if (end === void 0) { end = Infinity; }
                if (type === void 0) { type = 'int'; }
                if (handler.value)
                    return handler;
                if (isNumber$3(handler._amount, start, end, type))
                    handler.value = callback ? callback(+handler._amount) : handler._amount;
                return handler;
            } : function () { return handler; },
            handleTime: handlers.time ? function (start, end, type, callback) {
                if (start === void 0) { start = -Infinity; }
                if (end === void 0) { end = Infinity; }
                if (type === void 0) { type = 'int'; }
                if (handler.value)
                    return handler;
                var unit = 'ms';
                var amount = handler._amount;
                if (amount.endsWith('ms')) {
                    amount = amount.slice(0, -2);
                }
                else if (amount.endsWith('s')) {
                    unit = 's';
                    amount = amount.slice(0, -1);
                }
                else {
                    return handler;
                }
                if (isNumber$3(amount, start, end, type))
                    handler.value = callback ? callback(unit === 's' ? +amount * 1000 : +amount) : handler._amount;
                return handler;
            } : function () { return handler; },
            handleString: handlers.string ? function (callback) {
                if (handler.value)
                    return handler;
                handler.value = callback(handler.utility.body);
                return handler;
            } : function () { return handler; },
            handleSquareBrackets: handlers.bracket ? function (callback) {
                if (handler.value)
                    return handler;
                if (handler._amount[0] === '[' && handler._amount[handler._amount.length - 1] === ']') {
                    var value_1 = handler._amount.slice(1, -1).replace(/_/g, ' '); // replace _ to space
                    if (value_1.indexOf('calc(') > -1) {
                        value_1 = value_1.replace(/(-?\d*\.?\d(?!\b-.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, '$1 $2 ');
                    }
                    handler.value = callback
                        ? callback(value_1)
                        : value_1;
                }
                return handler;
            } : function () { return handler; },
            handleSpacing: handlers.number ? function () {
                // just a short-hand for handle spacing.
                return handler.handleNumber(0, undefined, 'float', function (number) {
                    return number === 0 ? '0px' : "".concat(roundUp(number / 4, 6), "rem");
                });
            } : function () { return handler; },
            handleNxl: handlers.nxl ? function (callback) {
                if (handler.value)
                    return handler;
                if (/^\d*xl$/.test(handler._amount))
                    handler.value = callback
                        ? callback(handler._amount === 'xl' ? 1 : parseInt(handler._amount))
                        : parseInt(handler._amount).toString();
                return handler;
            } : function () { return handler; },
            handleFraction: handlers.fraction ? function (callback) {
                if (handler.value)
                    return handler;
                if (isFraction(handler._amount))
                    handler.value = callback
                        ? callback(handler._amount)
                        : fracToPercent(handler._amount);
                return handler;
            } : function () { return handler; },
            handleSize: handlers.size ? function (callback) {
                if (handler.value)
                    return handler;
                if (isSize(handler._amount))
                    handler.value = callback ? callback(handler._amount) : handler._amount;
                return handler;
            } : function () { return handler; },
            handleVariable: handlers.variable ? function (callback) {
                if (handler.value)
                    return handler;
                var matchVariable = handler.utility.raw.match(/-\$[\w-]+/);
                if (matchVariable) {
                    var variableName = matchVariable[0].substring(2);
                    handler.value = callback ? callback(variableName) : "var(--".concat(variableName, ")");
                }
                return handler;
            } : function () { return handler; },
            handleColor: handlers.color ? function (map) {
                if (map === void 0) { map = defaultColors; }
                if (handler.value)
                    return handler;
                var color;
                if (map && typeof map === 'object') {
                    var colors = flatColors$2(map);
                    var body = handler.utility.raw.replace(/^ring-offset|outline-solid|outline-dotted/, 'head').replace(/^\w+-/, '');
                    var _a = splitColorGroup(body), key = _a[0], opacity = _a[1];
                    handler.opacity = opacity;
                    if (key in colors) {
                        color = colors[key];
                    }
                    else if (handlers.hex && key.startsWith('hex-')) {
                        var hex = key.slice(4);
                        if (hex2RGB$1(hex))
                            color = '#' + hex;
                    }
                    if (typeof color === 'string') {
                        handler.value = color;
                    }
                    else if (typeof color === 'function') {
                        handler.color = color;
                    }
                }
                return handler;
            } : function () { return handler; },
            handleOpacity: handlers.opacity ? function (map) {
                if (handler.opacity && typeof map === 'object') {
                    var _map = map;
                    if (handlers.static && handler.opacity in _map) {
                        handler.opacity = _map[handler.opacity];
                    }
                    else if (handlers.number && isNumber$3(handler.opacity, 0, 100, 'int')) {
                        handler.opacity = (+handler.opacity / 100).toString();
                    }
                    else if (handlers.variable && handler.opacity.charAt(0) === '$') {
                        handler.opacity = "var(--".concat(handler.opacity.slice(1), ")");
                    }
                    else if (handlers.bracket && handler.opacity.charAt(0) === '[' && handler.opacity.charAt(handler.opacity.length - 1) === ']') {
                        handler.opacity = handler.opacity.slice(1, -1).replace(/_/g, ' ');
                    }
                    else {
                        handler.opacity = undefined;
                    }
                }
                return handler;
            } : function () { return handler; },
            handleNegative: handlers.negative ? function (callback) {
                if (callback === void 0) { callback = negateValue; }
                if (!handler.value)
                    return handler;
                handler.value = handler.utility.isNegative ? callback(handler.value) : handler.value;
                return handler;
            } : function () { return handler; },
            createProperty: function (name, callback) {
                if (!handler.value)
                    return;
                var value = callback ? callback(handler.value) : handler.value;
                return new Property$3(name, value);
            },
            createStyle: function (selector, callback) {
                if (!handler.value)
                    return;
                var value = callback ? callback(handler.value) : undefined;
                return new Style$3(selector, value);
            },
            createColorValue: function (opacityValue) {
                if (handler.color)
                    return handler.color({ opacityValue: opacityValue });
                if (handler.value) {
                    if (['transparent', 'currentColor', 'inherit', 'auto', 'none'].includes(handler.value))
                        return handler.value;
                    if (handler.value.includes('var') && opacityValue)
                        return "rgba(".concat(handler.value, ", ").concat(handler.opacity || opacityValue, ")");
                    return opacityValue ? "rgba(".concat(toColor(handler.value).color, ", ").concat(handler.opacity || opacityValue, ")") : "rgb(".concat(toColor(handler.value).color, ")");
                }
            },
            createColorStyle: function (selector, property, opacityVariable, wrapRGB) {
                if (wrapRGB === void 0) { wrapRGB = true; }
                if (handler.color) {
                    var value_2 = handler.color({ opacityVariable: opacityVariable, opacityValue: opacityVariable ? "var(".concat(opacityVariable, ")") : undefined });
                    if (opacityVariable) {
                        return new Style$3(selector, [
                            new Property$3(opacityVariable, handler.opacity || '1'),
                            new Property$3(property, value_2),
                        ]);
                    }
                    return new Style$3(selector, new Property$3(property, value_2));
                }
                var color = handler.value;
                if (!color)
                    return;
                if (['transparent', 'currentColor', 'inherit', 'auto', 'none'].includes(color) || color.includes('var'))
                    return new Style$3(selector, new Property$3(property, color));
                var rgb = toColor(color);
                if (opacityVariable) {
                    return new Style$3(selector, [
                        new Property$3(opacityVariable, handler.opacity || rgb.opacity),
                        new Property$3(property, "rgba(".concat(rgb.color, ", var(").concat(opacityVariable, "))")),
                    ]);
                }
                return new Style$3(selector, new Property$3(property, wrapRGB ? "rgb(".concat(rgb.color, ")") : rgb.color));
            },
            callback: function (func) {
                if (!handler.value)
                    return;
                return func(handler.value);
            },
        };
        return handler;
    };
}
var Utility = /** @class */ (function () {
    function Utility(raw, _h) {
        this.raw = raw; // -placeholder-real-gray-300
        this._h = _h;
    }
    Utility.prototype.match = function (expression) {
        var match = this.absolute.match(expression);
        return match ? match[0] : '';
    };
    Utility.prototype.clone = function (raw) {
        return new Utility(raw || this.raw, this._h);
    };
    Object.defineProperty(Utility.prototype, "class", {
        get: function () {
            return '.' + cssEscape(this.raw); // .-placeholder-real-gray-300
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Utility.prototype, "isNegative", {
        get: function () {
            return this.raw[0] === '-'; // true
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Utility.prototype, "absolute", {
        get: function () {
            return this.isNegative ? this.raw.substring(1) : this.raw;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Utility.prototype, "identifier", {
        get: function () {
            return this.match(/[^-]+/); // placeholder
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Utility.prototype, "key", {
        get: function () {
            return this.match(/^\w[-\w]+(?=-)/); // placeholder-real-gray
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Utility.prototype, "center", {
        get: function () {
            return this.match(/-.+(?=-)/).substring(1); // real-gray
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Utility.prototype, "amount", {
        get: function () {
            return this.match(/(?:[^-]+|\[[\s\S]*?\])$/); // 300
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Utility.prototype, "body", {
        get: function () {
            return this.match(/-.+/).substring(1); // real-gray-300
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Utility.prototype, "handler", {
        get: function () {
            return this._h(this);
        },
        enumerable: false,
        configurable: true
    });
    return Utility;
}());

function generateStaticStyle(processor, className, addComment) {
    if (addComment === void 0) { addComment = false; }
    // eslint-disable-next-line no-prototype-builtins
    if (!staticUtilities$1.hasOwnProperty(className))
        return;
    var style = new Style$3('.' + className);
    var comment = addComment ? className : undefined;
    var _a = staticUtilities$1[className], utility = _a.utility, meta = _a.meta;
    var _loop_1 = function (key, value) {
        style.add(Array.isArray(value)
            ? value.map(function (i) { return new Property$3(key, i, comment); })
            : new Property$3(key, value, comment));
    };
    for (var _i = 0, _b = Object.entries(utility); _i < _b.length; _i++) {
        var _c = _b[_i], key = _c[0], value = _c[1];
        _loop_1(key, value);
    }
    if (processor._plugin.core && !processor._plugin.core[meta.group])
        return;
    return style.updateMeta('utilities', meta.group, pluginOrder$1[meta.group], meta.order, true);
}
function extract(processor, className, addComment, prefix) {
    if (addComment === void 0) { addComment = false; }
    if (prefix && !className.startsWith(prefix))
        return;
    // handle static base utilities
    if (!prefix && className in staticUtilities$1)
        return generateStaticStyle(processor, className, addComment);
    if (prefix && className.startsWith(prefix)) {
        className = className.replace(new RegExp("^".concat(prefix)), '');
        if (className in staticUtilities$1)
            return generateStaticStyle(processor, className, addComment);
    }
    // handle static plugin utilities & components
    var staticPlugins = __assign$4(__assign$4(__assign$4({}, processor._plugin.utilities), processor._plugin.components), processor._plugin.shortcuts);
    if (className in staticPlugins)
        return deepCopy$3(staticPlugins[className]);
    var utility = new Utility(className, processor._handler);
    // handle dynamic plugin utilities
    for (var _i = 0, _a = Object.entries(processor._plugin.dynamic); _i < _a.length; _i++) {
        var _b = _a[_i], key_1 = _b[0], generator = _b[1];
        if (className.match(new RegExp("^-?".concat(key_1)))) {
            var style = generator(utility);
            if (style instanceof Property$3)
                style = style.toStyle(utility.class);
            if (style && addComment)
                Array.isArray(style)
                    ? style.map(function (i) { return i.property.forEach(function (p) { return (p.comment = className); }); })
                    : style.property.forEach(function (p) { return (p.comment = className); });
            if (style)
                return style;
        }
    }
    // handle dynamic base utilities
    var matches = className.match(/\w+/);
    var key = matches ? matches[0] : undefined;
    // eslint-disable-next-line no-prototype-builtins
    if (key && dynamicUtilities$1.hasOwnProperty(key)) {
        var style = dynamicUtilities$1[key](utility, processor.pluginUtils);
        if (!style)
            return;
        if (processor._plugin.core && !processor._plugin.core[Array.isArray(style) ? style[0].meta.group : style.meta.group])
            return;
        if (style instanceof Property$3)
            style = style.toStyle(utility.class);
        if (addComment)
            Array.isArray(style) ? style.map(function (i) { return i.property.forEach(function (p) { return (p.comment = className); }); }) : style.property.forEach(function (p) { return (p.comment = className); });
        return style;
    }
}

function testStatic(processor, className) {
    // eslint-disable-next-line no-prototype-builtins
    if (!staticUtilities$1.hasOwnProperty(className))
        return false;
    var meta = staticUtilities$1[className].meta;
    if (processor._plugin.core && !processor._plugin.core[meta.group])
        return false;
    return true;
}
function test(processor, className, prefix) {
    // handle static base utilities
    if (!prefix && className in staticUtilities$1)
        return testStatic(processor, className);
    if (prefix && className.startsWith(prefix)) {
        className = className.replace(new RegExp("^".concat(prefix)), '');
        if (className in staticUtilities$1)
            return testStatic(processor, className);
    }
    // handle static plugin utilities & components
    var staticPlugins = __assign$4(__assign$4(__assign$4({}, processor._plugin.utilities), processor._plugin.components), processor._plugin.shortcuts);
    if (className in staticPlugins)
        return true;
    var utility = new Utility(className, processor._handler);
    // handle dynamic plugin utilities
    for (var _i = 0, _a = Object.entries(processor._plugin.dynamic); _i < _a.length; _i++) {
        var _b = _a[_i], key_1 = _b[0], generator = _b[1];
        if (className.match(new RegExp("^-?".concat(key_1)))) {
            if (generator(utility))
                return true;
        }
    }
    // handle dynamic base utilities
    var matches = className.match(/\w+/);
    var key = matches ? matches[0] : undefined;
    // eslint-disable-next-line no-prototype-builtins
    if (key && dynamicUtilities$1.hasOwnProperty(key)) {
        var style = dynamicUtilities$1[key](utility, processor.pluginUtils);
        if (!style)
            return false;
        if (processor._plugin.core && !processor._plugin.core[Array.isArray(style) ? style[0].meta.group : style.meta.group])
            return false;
        return true;
    }
    return false;
}

function preflight(processor, html, includeBase, includeGlobal, includePlugins) {
    if (includeBase === void 0) { includeBase = true; }
    if (includeGlobal === void 0) { includeGlobal = true; }
    if (includePlugins === void 0) { includePlugins = true; }
    // Generate preflight style based on html tags.
    var globalSheet = new StyleSheet$2();
    var styleSheet = new StyleSheet$2();
    var pluginSheet = new StyleSheet$2();
    var createStyle = function (selector, properties, isGlobal) {
        if (isGlobal === void 0) { isGlobal = false; }
        var style = new Style$3(selector, undefined, false);
        var _loop_1 = function (key, value) {
            style.add(Array.isArray(value)
                ? value.map(function (v) { return new Property$3(key, v); })
                : new Property$3(key, typeof value === 'function' ? value(function (path, defaultValue) { return processor.theme(path, defaultValue); }) : value));
        };
        for (var _i = 0, _a = Object.entries(properties); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            _loop_1(key, value);
        }
        style.updateMeta('base', 'preflight', 0, isGlobal ? 1 : 2, true);
        return style;
    };
    var safelist = processor.config('preflight.safelist', []);
    var tags = html ? safelist.concat(Array.from(new Set(html.match(/<\w+/g))).map(function (i) { return i.substring(1); })) : undefined;
    // handle base style
    includeBase && (processor.config('prefixer') ? preflights : preflights.filter(function (i) { return !i.selector || !/::?(webkit-input|-moz|-ms-input)-placeholder$/.test(i.selector); })).forEach(function (p) {
        if (includeGlobal && p.global) {
            // global style, such as * or html, body
            globalSheet.add(createStyle(p.selector, p.properties, true));
        }
        else if (tags !== undefined) {
            // only generate matched styles
            var includeTags = tags.filter(function (i) { return p.keys.includes(i); });
            if (includeTags.length > 0)
                styleSheet.add(createStyle(p.selector ? p.selector : includeTags.join(', '), p.properties));
        }
        else {
            // if no tags input, generate all styles
            styleSheet.add(createStyle(p.selector ? p.selector : p.keys.join(', '), p.properties));
        }
    });
    // handle plugin style
    if (includePlugins) {
        // base Styles
        var preflightList_1 = [];
        Object.values(processor._plugin.preflights).forEach(function (styles) {
            preflightList_1 = preflightList_1.concat(styles);
        });
        pluginSheet.add(preflightList_1);
        // always generated styles
        var staticList_1 = [];
        Object.values(processor._plugin.static).forEach(function (styles) {
            staticList_1 = staticList_1.concat(styles);
        });
        pluginSheet.add(staticList_1);
    }
    var result = styleSheet.combine().sort().extend(pluginSheet.combine().sort());
    return includeGlobal ? result.extend(globalSheet.combine().sort(), false) : result;
}

var ClassParser = /** @class */ (function () {
    function ClassParser(classNames, separator, variants) {
        if (separator === void 0) { separator = ':'; }
        this.classNames = classNames;
        this.separator = separator;
        this.variants = variants || [];
        this.index = 0;
    }
    ClassParser.prototype._handle_group = function (removeDuplicated) {
        if (removeDuplicated === void 0) { removeDuplicated = true; }
        if (!this.classNames)
            return [];
        var preChar;
        var char;
        var group;
        var func;
        var variant;
        var variants = [];
        var variantStart = this.index + 1;
        var classStart = this.index + 1;
        var groupStart = this.index + 1;
        var important = false;
        var ignoreSpace = false;
        var ignoreBracket = false;
        var insideSquareBracket = false;
        var brackets = 0;
        var sepLength = this.separator.length;
        var parts = [];
        var length = this.classNames.length;
        while (this.index < length) {
            this.index++;
            char = this.classNames.charAt(this.index);
            // ignore parsing and leave content inside square brackets as-is
            if (insideSquareBracket) {
                if (' \n\t\r'.includes(char)) {
                    insideSquareBracket = false;
                }
                else {
                    if (char === ']')
                        insideSquareBracket = false;
                    continue;
                }
            }
            // handle chars
            switch (char) {
                case '!':
                    important = true;
                    break;
                case this.separator[0]:
                    if (this.classNames.slice(this.index, this.index + sepLength) === this.separator) {
                        variant = this.classNames.slice(variantStart, this.index);
                        if (variant.charAt(0) === '!')
                            variant = variant.slice(1);
                        if (this.variants.includes(variant)) {
                            variants.push(variant);
                            this.index += sepLength - 1;
                            variantStart = this.index + 1;
                            ignoreSpace = true;
                        }
                    }
                    break;
                case '[':
                    insideSquareBracket = true;
                    break;
                case '(':
                    preChar = this.classNames.charAt(this.index - 1);
                    if (preChar === '-' || (!ignoreSpace && preChar === ' ')) {
                        ignoreBracket = true;
                    }
                    else if (ignoreSpace) {
                        group = this._handle_group();
                    }
                    else {
                        brackets += 1;
                        func = this.classNames.slice(groupStart, this.index);
                        while (!isSpace$1(this.classNames.charAt(this.index))) {
                            this.index++;
                        }
                        this.index--;
                    }
                    ignoreSpace = false;
                    break;
                case '"':
                case '`':
                case '\'':
                case ')':
                case ' ':
                case '\n':
                case '\t':
                case '\r':
                    if (!ignoreSpace) {
                        if (groupStart !== this.index) {
                            var raw = this.classNames.slice(classStart, this.index);
                            var start = classStart - 1;
                            var end = this.index - 1;
                            if (Array.isArray(group)) {
                                parts.push({ raw: raw, start: start, end: end, variants: variants, content: group, type: 'group', important: important });
                                group = undefined;
                            }
                            else if (func) {
                                var utility = this.classNames.slice(variantStart, this.index);
                                parts.push({ raw: raw, start: start, end: end, variants: variants, content: utility, type: 'utility', important: important });
                                func = undefined;
                            }
                            else if (ignoreBracket && char === ')') {
                                // utility with bracket
                                var utility = this.classNames.slice(variantStart, this.index + 1);
                                parts.push({ raw: raw + ')', start: start, end: this.index, variants: variants, content: important ? utility.slice(1) : utility, type: 'utility', important: important });
                            }
                            else {
                                var utility = this.classNames.slice(variantStart, this.index);
                                if (utility.charAt(0) === '*') {
                                    parts.push({ raw: raw, start: start, end: end, variants: variants, content: utility.slice(1), type: 'alias', important: important });
                                }
                                else {
                                    parts.push({ raw: raw, start: start, end: end, variants: variants, content: utility.charAt(0) === '!' ? utility.slice(1) : utility, type: 'utility', important: important });
                                }
                            }
                            variants = [];
                            important = false;
                        }
                        groupStart = this.index + 1;
                        classStart = this.index + 1;
                    }
                    variantStart = this.index + 1;
                    break;
                default:
                    ignoreSpace = false;
            }
            if (char === ')') {
                brackets -= 1;
                if (!ignoreBracket && brackets < 0)
                    break; // end group
                ignoreBracket = false;
            }
        }
        if (removeDuplicated) {
            var newParts_1 = [];
            var cache_1 = [];
            parts.forEach(function (item) {
                if (!cache_1.includes(item.raw)) {
                    cache_1.push(item.raw);
                    newParts_1.push(item);
                }
            });
            return newParts_1;
        }
        return parts;
    };
    ClassParser.prototype.parse = function (removeDuplicated) {
        if (removeDuplicated === void 0) { removeDuplicated = true; }
        if (!this.classNames)
            return [];
        // Turn classes into group;
        this.classNames = '(' + this.classNames + ')';
        var elements = this._handle_group(removeDuplicated);
        // Initialization, convenient for next call
        this.index = 0;
        this.classNames = this.classNames.slice(1, -1);
        return elements;
    };
    return ClassParser;
}());

/* toSource by Marcello Bastea-Forte - zlib license */
function toSource(object, replacer, indent = '  ', startingIndent = '') {
    const seen = [];
    return walk(object, replacer, indent === false ? '' : indent, startingIndent, seen);
    function walk(object, replacer, indent, currentIndent, seen) {
        const nextIndent = currentIndent + indent;
        object = replacer ? replacer(object) : object;
        switch (typeof object) {
            case 'string':
                return JSON.stringify(object);
            case 'number':
                if (Object.is(object, -0)) {
                    return '-0';
                }
                return String(object);
            case 'boolean':
            case 'undefined':
                return String(object);
            case 'function':
                return object.toString();
        }
        if (object === null) {
            return 'null';
        }
        if (object instanceof RegExp) {
            return object.toString();
        }
        if (object instanceof Date) {
            return `new Date(${object.getTime()})`;
        }
        if (object instanceof Set) {
            return `new Set(${walk(Array.from(object.values()), replacer, indent, nextIndent, seen)})`;
        }
        if (object instanceof Map) {
            return `new Map(${walk(Array.from(object.entries()), replacer, indent, nextIndent, seen)})`;
        }
        if (seen.indexOf(object) >= 0) {
            return '{$circularReference:1}';
        }
        seen.push(object);
        function join(elements) {
            return (indent.slice(1) +
                elements.join(',' + (indent && '\n') + nextIndent) +
                (indent ? ' ' : ''));
        }
        if (Array.isArray(object)) {
            return `[${join(object.map((element) => walk(element, replacer, indent, nextIndent, seen.slice())))}]`;
        }
        const keys = Object.keys(object);
        if (keys.length) {
            return `{${join(keys.map((key) => (legalKey(key) ? key : JSON.stringify(key)) +
                ':' +
                walk(object[key], replacer, indent, nextIndent, seen.slice())))}}`;
        }
        return '{}';
    }
}
const KEYWORD_REGEXP = /^(abstract|boolean|break|byte|case|catch|char|class|const|continue|debugger|default|delete|do|double|else|enum|export|extends|false|final|finally|float|for|function|goto|if|implements|import|in|instanceof|int|interface|long|native|new|null|package|private|protected|public|return|short|static|super|switch|synchronized|this|throw|throws|transient|true|try|typeof|undefined|var|void|volatile|while|with)$/;
function legalKey(key) {
    return (/^([a-z_$][0-9a-z_$]*|[0-9]+)$/gi.test(key) && !KEYWORD_REGEXP.test(key));
}

var Processor = /** @class */ (function () {
    function Processor(config) {
        var _this = this;
        this._variants = {};
        this._cache = {
            count: 0,
            html: [],
            attrs: [],
            classes: [],
            utilities: [],
            variants: [],
        };
        this._plugin = {
            static: {},
            dynamic: {},
            utilities: {},
            components: {},
            preflights: {},
            shortcuts: {},
            alias: {},
            completions: {},
        };
        this.pluginUtils = {
            addDynamic: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.addDynamic.apply(_this, args);
            },
            addUtilities: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.addUtilities.apply(_this, args);
            },
            addComponents: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.addComponents.apply(_this, args);
            },
            addBase: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.addBase.apply(_this, args);
            },
            addVariant: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.addVariant.apply(_this, args);
            },
            e: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.e.apply(_this, args);
            },
            prefix: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.prefix.apply(_this, args);
            },
            config: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.config.apply(_this, args);
            },
            theme: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.theme.apply(_this, args);
            },
            variants: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.variants.apply(_this, args);
            },
        };
        this.variantUtils = {
            modifySelectors: function (modifier) {
                return new Style$3().wrapSelector(function (selector) {
                    return modifier({
                        className: /^[.#]/.test(selector) ? selector.substring(1) : selector,
                    });
                });
            },
            atRule: function (name) { return new Style$3().atRule(name); },
            pseudoClass: function (name) { return new Style$3().pseudoClass(name); },
            pseudoElement: function (name) { return new Style$3().pseudoElement(name); },
            parent: function (name) { return new Style$3().parent(name); },
            child: function (name) { return new Style$3().child(name); },
        };
        this._config = this.resolveConfig(config, baseConfig);
        this._theme = this._config.theme;
        this._handler = createHandler(this._config.handlers);
        this._config.shortcuts && this.loadShortcuts(this._config.shortcuts);
        this._config.alias && this.loadAlias(this._config.alias);
        if (this._config.preflight && this._config.preflight.safelist) {
            if (typeof this._config.preflight.safelist === 'string') {
                this._config.preflight.safelist = this._config.preflight.safelist.split(/\s+/);
            }
        }
    }
    Processor.prototype._resolveConfig = function (userConfig, presets) {
        var _a;
        if (presets === void 0) { presets = {}; }
        if (userConfig.presets) {
            var resolved = this._resolvePresets(userConfig.presets);
            presets = this._resolveConfig(resolved, presets);
            delete userConfig.presets;
        }
        var userTheme = userConfig.theme;
        if (userTheme)
            delete userConfig.theme;
        var extendTheme = userTheme && 'extend' in userTheme ? (_a = userTheme.extend) !== null && _a !== void 0 ? _a : {} : {};
        var theme = (presets.theme || {});
        if (userTheme) {
            if ('extend' in userTheme)
                delete userTheme.extend;
            for (var _i = 0, _b = Object.entries(userTheme); _i < _b.length; _i++) {
                var _c = _b[_i], key = _c[0], value = _c[1];
                theme[key] = typeof value === 'function' ? value : __assign$4({}, value);
            }
        }
        if (extendTheme && typeof extendTheme === 'object')
            this._reduceFunction(theme, extendTheme);
        return __assign$4(__assign$4(__assign$4({}, presets), userConfig), { theme: theme });
    };
    Processor.prototype._reduceFunction = function (theme, extendTheme) {
        var _loop_1 = function (key, value) {
            var themeValue = theme[key];
            switch (typeof themeValue) {
                case 'function':
                    theme[key] = function (theme, _a) {
                        var negative = _a.negative, breakpoints = _a.breakpoints;
                        return combineConfig(themeValue(theme, { negative: negative, breakpoints: breakpoints }), (typeof value === 'function' ? value(theme, { negative: negative, breakpoints: breakpoints }) : value !== null && value !== void 0 ? value : {}));
                    };
                    break;
                case 'object':
                    theme[key] = function (theme, _a) {
                        var negative = _a.negative, breakpoints = _a.breakpoints;
                        return combineConfig(themeValue, (typeof value === 'function' ? value(theme, { negative: negative, breakpoints: breakpoints }) : value !== null && value !== void 0 ? value : {}), 0 /* prevent fontfamily merge */);
                    };
                    break;
                default:
                    theme[key] = value;
            }
        };
        for (var _i = 0, _a = Object.entries(extendTheme); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            _loop_1(key, value);
        }
    };
    Processor.prototype._resolvePresets = function (presets) {
        var _this = this;
        var config = {};
        var extend = {};
        presets.forEach(function (p) {
            if (p.theme && 'extend' in p.theme && p.theme.extend) {
                _this._reduceFunction(extend, p.theme.extend);
                delete p.theme.extend;
            }
            config = _this._resolveConfig(p, config);
        });
        if (config.theme) {
            config.theme.extend = extend;
        }
        else {
            config.theme = { extend: extend };
        }
        return config;
    };
    Processor.prototype._resolveFunction = function (config) {
        var _this = this;
        var _a;
        if (!config.theme)
            return config;
        var theme = function (path, defaultValue) { return _this.theme(path, defaultValue); };
        for (var _i = 0, _b = [config.theme, 'extend' in config.theme ? (_a = config.theme.extend) !== null && _a !== void 0 ? _a : {} : {}]; _i < _b.length; _i++) {
            var dict = _b[_i];
            for (var _c = 0, _d = Object.entries(dict); _c < _d.length; _c++) {
                var _e = _d[_c], key = _e[0], value = _e[1];
                if (typeof value === 'function') {
                    dict[key] = value(theme, {
                        negative: negative$1,
                        breakpoints: breakpoints,
                    });
                }
            }
        }
        return config;
    };
    Processor.prototype._replaceStyleVariants = function (styles) {
        var _this = this;
        // @screen sm -> @screen (min-width: 640px)
        styles.forEach(function (style) {
            var _a;
            style.atRules = (_a = style.atRules) === null || _a === void 0 ? void 0 : _a.map(function (i) {
                var _a;
                if (i.match(/@screen/)) {
                    var variant = i.replace(/\s*@screen\s*/, '');
                    var atRule = (_a = _this._variants[variant]().atRules) === null || _a === void 0 ? void 0 : _a[0];
                    return atRule !== null && atRule !== void 0 ? atRule : i;
                }
                return i;
            });
        });
    };
    Processor.prototype._addPluginProcessorCache = function (type, key, styles) {
        styles = toArray$5(styles);
        this._plugin[type][key] = key in this._plugin[type]
            ? __spreadArray$6(__spreadArray$6([], this._plugin[type][key], true), styles, true) : styles;
    };
    Processor.prototype._loadVariables = function () {
        var config = this.theme('vars');
        if (!config)
            return;
        this.addBase({ ':root': Object.assign.apply(Object, __spreadArray$6([{}], Object.keys(config).map(function (i) {
                var _a;
                return (_a = {}, _a["--".concat(i)] = config[i], _a);
            }), false)) });
    };
    Processor.prototype.loadConfig = function (config) {
        this._config = this.resolveConfig(config, baseConfig);
        this._theme = this._config.theme;
        this._handler = createHandler(this._config.handlers);
        this._config.shortcuts && this.loadShortcuts(this._config.shortcuts);
        this._config.alias && this.loadAlias(this._config.alias);
        return this._config;
    };
    Processor.prototype.resolveConfig = function (config, presets) {
        var _this = this;
        var _a;
        this._config = this._resolveConfig(__assign$4(__assign$4({}, deepCopy$3(config ? config : {})), { exclude: config === null || config === void 0 ? void 0 : config.exclude }), deepCopy$3(presets)); // deep copy
        this._theme = this._config.theme; // update theme to make sure theme() function works.
        (_a = this._config.plugins) === null || _a === void 0 ? void 0 : _a.map(function (i) { return typeof i === 'function' ? ('__isOptionsFunction' in i ? _this.loadPluginWithOptions(i) : _this.loadPlugin(createPlugin(i))) : _this.loadPlugin(i); });
        this._config = this._resolveFunction(this._config);
        this._variants = __assign$4(__assign$4({}, this._variants), this.resolveVariants());
        this._cache.variants = Object.keys(this._variants);
        this._loadVariables();
        if (this._config.corePlugins)
            this._plugin.core = Array.isArray(this._config.corePlugins) ? Object.assign.apply(Object, __spreadArray$6([{}], this._config.corePlugins.map(function (i) {
                var _a;
                return (_a = {}, _a[i] = true, _a);
            }), false)) : __assign$4(__assign$4({}, Object.assign.apply(Object, __spreadArray$6([{}], Object.keys(pluginOrder$1).slice(Object.keys(pluginOrder$1).length / 2).map(function (i) {
                var _a;
                return (_a = {}, _a[i] = true, _a);
            }), false))), this._config.corePlugins);
        return this._config;
    };
    Processor.prototype.resolveVariants = function (type) {
        var variants = resolveVariants(this._config);
        if (type) {
            return variants[type];
        }
        return __assign$4(__assign$4(__assign$4(__assign$4({}, variants.screen), variants.theme), variants.state), variants.orientation);
    };
    Processor.prototype.resolveStaticUtilities = function (includePlugins) {
        if (includePlugins === void 0) { includePlugins = false; }
        var staticStyles = {};
        for (var key in staticUtilities$1) {
            var style = generateStaticStyle(this, key, true);
            if (style)
                staticStyles[key] = [style];
        }
        if (!includePlugins)
            return staticStyles;
        return __assign$4(__assign$4(__assign$4({}, staticStyles), this._plugin.utilities), this._plugin.components);
    };
    Processor.prototype.resolveDynamicUtilities = function (includePlugins) {
        if (includePlugins === void 0) { includePlugins = false; }
        if (!includePlugins)
            return dynamicUtilities$1;
        return __assign$4(__assign$4({}, dynamicUtilities$1), this._plugin.dynamic);
    };
    Object.defineProperty(Processor.prototype, "allConfig", {
        get: function () {
            return this._config;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Processor.prototype, "allTheme", {
        get: function () {
            var _a;
            return ((_a = this._theme) !== null && _a !== void 0 ? _a : {});
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Processor.prototype, "allVariant", {
        get: function () {
            return this._cache.variants;
        },
        enumerable: false,
        configurable: true
    });
    Processor.prototype.wrapWithVariants = function (variants, styles) {
        var _this = this;
        // apply variant to style
        if (!Array.isArray(styles))
            styles = [styles];
        if (variants.length === 0)
            return styles;
        return styles.map(function (style) {
            if (style instanceof Keyframes$1)
                return style;
            var atrules = [];
            var wrapped = variants
                .filter(function (i) { var _a; return (_a = _this._variants) === null || _a === void 0 ? void 0 : _a[i]; })
                .map(function (i) { return _this._variants[i](); })
                .reduce(function (previousValue, currentValue) {
                var output = previousValue.extend(currentValue);
                if (previousValue.isAtrule)
                    atrules.push(previousValue.atRules[0]);
                return output;
            }, new Style$3())
                .extend(style);
            if (style instanceof Container)
                wrapped = new Container().extend(wrapped);
            if (atrules.length > 0)
                wrapped.meta.variants = atrules;
            return wrapped;
        });
    };
    Processor.prototype.removePrefix = function (className) {
        var prefix = this.config('prefix');
        return prefix ? className.replace(new RegExp("^".concat(prefix)), '') : className;
    };
    Processor.prototype.markAsImportant = function (style, force) {
        if (force === void 0) { force = false; }
        var _important = force ? force : this.config('important', false);
        var important = typeof _important === 'string' ? _important : _important;
        if (important) {
            if (typeof important === 'string') {
                style.parent(important);
            }
            else {
                style.important = true;
                style.property.forEach(function (i) { return i.important = true; });
            }
        }
        return style;
    };
    Processor.prototype.extract = function (className, addComment, prefix) {
        if (addComment === void 0) { addComment = false; }
        return extract(this, className, addComment, prefix);
    };
    Processor.prototype.test = function (className, prefix) {
        return test(this, className, prefix);
    };
    Processor.prototype.preflight = function (html, includeBase, includeGlobal, includePlugins, ignoreProcessed) {
        if (includeBase === void 0) { includeBase = true; }
        if (includeGlobal === void 0) { includeGlobal = true; }
        if (includePlugins === void 0) { includePlugins = true; }
        if (ignoreProcessed === void 0) { ignoreProcessed = false; }
        var id;
        if (html) {
            id = hash$2(html);
            if (ignoreProcessed && this._cache.html.includes(id))
                return new StyleSheet$2();
        }
        id && ignoreProcessed && this._cache.html.push(id);
        return preflight(this, html, includeBase, includeGlobal, includePlugins);
    };
    Processor.prototype.interpret = function (classNames, ignoreProcessed, handleIgnored) {
        var _this = this;
        if (ignoreProcessed === void 0) { ignoreProcessed = false; }
        var ast = new ClassParser(classNames, this.config('separator', ':'), this._cache.variants).parse();
        var success = [];
        var ignored = [];
        var styleSheet = new StyleSheet$2();
        var _hIgnored = function (className) {
            if (handleIgnored) {
                var style = handleIgnored(className);
                if (style) {
                    styleSheet.add(style);
                    success.push(className);
                }
                else {
                    ignored.push(className);
                }
            }
            ignored.push(className);
        };
        var _gStyle = function (baseClass, variants, selector, important, prefix) {
            if (important === void 0) { important = false; }
            if (_this._config.exclude && testRegexr(selector, _this._config.exclude)) {
                // filter exclude className
                ignored.push(selector);
                return;
            }
            if (variants[0] && selector in __assign$4(__assign$4({}, _this._plugin.utilities), _this._plugin.components)) {
                // handle special selector that conflict with class parser, such as 'hover:abc'
                success.push(selector);
                styleSheet.add(deepCopy$3(_this._plugin.utilities[selector]));
                return;
            }
            var result = _this.extract(baseClass, false, prefix);
            if (result) {
                var escapedSelector_1 = '.' + cssEscape(selector);
                if (result instanceof Style$3) {
                    if (!result.meta.respectSelector)
                        result.selector = escapedSelector_1;
                    _this.markAsImportant(result, important);
                }
                else if (Array.isArray(result)) {
                    result = result.map(function (i) {
                        if (i instanceof Keyframes$1)
                            return i;
                        if (!i.meta.respectSelector)
                            i.selector = escapedSelector_1;
                        _this.markAsImportant(i, important);
                        return i;
                    });
                }
                var wrapped = _this.wrapWithVariants(variants, result);
                if (wrapped) {
                    success.push(selector);
                    styleSheet.add(wrapped);
                }
                else {
                    _hIgnored(selector);
                }
            }
            else {
                _hIgnored(selector);
            }
        };
        var _hGroup = function (obj, parentVariants) {
            if (parentVariants === void 0) { parentVariants = []; }
            var _eval = function (u) {
                if (u.type === 'group') {
                    _hGroup(u, obj.variants);
                }
                else if (u.type === 'alias' && u.content in _this._plugin.alias) {
                    _this._plugin.alias[u.content].forEach(function (i) { return _eval(i); });
                }
                else {
                    // utility
                    var variants = __spreadArray$6(__spreadArray$6(__spreadArray$6([], parentVariants, true), obj.variants, true), u.variants, true);
                    var important = obj.important || u.important;
                    var selector = (important ? '!' : '') + __spreadArray$6(__spreadArray$6([], variants, true), [u.content], false).join(':');
                    typeof u.content === 'string' &&
                        _gStyle(u.content, variants, selector, important, _this.config('prefix'));
                }
            };
            Array.isArray(obj.content) && obj.content.forEach(function (u) { return _eval(u); });
        };
        var _gAst = function (ast) {
            ast.forEach(function (obj) {
                if (!(ignoreProcessed && _this._cache.utilities.includes(obj.raw))) {
                    if (ignoreProcessed)
                        _this._cache.utilities.push(obj.raw);
                    if (obj.type === 'utility') {
                        if (Array.isArray(obj.content)) ;
                        else if (obj.content) {
                            _gStyle(obj.content, obj.variants, obj.raw, obj.important, _this.config('prefix'));
                        }
                    }
                    else if (obj.type === 'group') {
                        _hGroup(obj);
                    }
                    else if (obj.type === 'alias' && obj.content in _this._plugin.alias) {
                        _gAst(_this._plugin.alias[obj.content]);
                    }
                    else {
                        _hIgnored(obj.raw);
                    }
                }
            });
        };
        _gAst(ast);
        if (!this.config('prefixer'))
            styleSheet.prefixer = false;
        return {
            success: success,
            ignored: ignored,
            styleSheet: styleSheet.sort(),
        };
    };
    Processor.prototype.validate = function (classNames) {
        var _this = this;
        var ast = new ClassParser(classNames, this.config('separator', ':'), this._cache.variants).parse();
        var success = [];
        var ignored = [];
        var _hSuccess = function (className, self, parent) {
            success.push(__assign$4(__assign$4({ className: className }, self), { parent: parent }));
        };
        var _hIgnored = function (className, self, parent) {
            ignored.push(__assign$4(__assign$4({ className: className }, self), { parent: parent }));
        };
        var _gStyle = function (baseClass, variants, selector, self, parent, prefix) {
            if (_this._config.exclude && testRegexr(selector, _this._config.exclude)) {
                // filter exclude className
                _hIgnored(selector, self, parent);
                return;
            }
            if (variants[0] && selector in __assign$4(__assign$4({}, _this._plugin.utilities), _this._plugin.components)) {
                // handle special selector that conflict with class parser, such as 'hover:abc'
                _hSuccess(selector, self, parent);
                return;
            }
            if (_this.test(baseClass, prefix) && variants.filter(function (i) { return !(i in _this._variants); }).length === 0) {
                _hSuccess(selector, self, parent);
            }
            else {
                _hIgnored(selector, self, parent);
            }
        };
        var _hGroup = function (obj, parentVariants) {
            if (parentVariants === void 0) { parentVariants = []; }
            var _eval = function (u, parent) {
                if (u.type === 'group') {
                    _hGroup(u, obj.variants);
                }
                else if (u.type === 'alias' && u.content in _this._plugin.alias) {
                    _this._plugin.alias[u.content].forEach(function (i) { return _eval(i, u); });
                }
                else {
                    // utility
                    var variants = __spreadArray$6(__spreadArray$6(__spreadArray$6([], parentVariants, true), obj.variants, true), u.variants, true);
                    var important = obj.important || u.important;
                    var selector = (important ? '!' : '') + __spreadArray$6(__spreadArray$6([], variants, true), [u.content], false).join(':');
                    typeof u.content === 'string' &&
                        _gStyle(u.content, variants, selector, u, parent, _this.config('prefix'));
                }
            };
            Array.isArray(obj.content) && obj.content.forEach(function (u) { return _eval(u, obj); });
        };
        var _gAst = function (ast) {
            ast.forEach(function (obj) {
                if (obj.type === 'utility') {
                    if (Array.isArray(obj.content)) ;
                    else if (obj.content) {
                        _gStyle(obj.content, obj.variants, obj.raw, obj, undefined, _this.config('prefix'));
                    }
                }
                else if (obj.type === 'group') {
                    _hGroup(obj);
                }
                else if (obj.type === 'alias' && obj.content in _this._plugin.alias) {
                    _gAst(_this._plugin.alias[obj.content]);
                }
                else {
                    _hIgnored(obj.raw, obj);
                }
            });
        };
        _gAst(ast);
        return {
            success: success,
            ignored: ignored,
        };
    };
    Processor.prototype.compile = function (classNames, prefix, showComment, ignoreGenerated, handleIgnored, outputClassName) {
        var _this = this;
        if (prefix === void 0) { prefix = 'windi-'; }
        if (showComment === void 0) { showComment = false; }
        if (ignoreGenerated === void 0) { ignoreGenerated = false; }
        var ast = new ClassParser(classNames, this.config('separator', ':'), this._cache.variants).parse();
        var success = [];
        var ignored = [];
        var styleSheet = new StyleSheet$2();
        var className = outputClassName !== null && outputClassName !== void 0 ? outputClassName : prefix + hash$2(classNames.trim().split(/\s+/g).join(' '));
        if (ignoreGenerated && this._cache.classes.includes(className))
            return { success: success, ignored: ignored, styleSheet: styleSheet, className: className };
        var buildSelector = '.' + className;
        var _hIgnored = function (className) {
            if (handleIgnored) {
                var style = handleIgnored(className);
                if (style) {
                    styleSheet.add(style);
                    success.push(className);
                }
                else {
                    ignored.push(className);
                }
            }
            ignored.push(className);
        };
        var _gStyle = function (baseClass, variants, selector, important) {
            if (important === void 0) { important = false; }
            if (_this._config.exclude && testRegexr(selector, _this._config.exclude)) {
                // filter exclude className
                ignored.push(selector);
                return;
            }
            if (variants[0] && selector in __assign$4(__assign$4({}, _this._plugin.utilities), _this._plugin.components)) {
                // handle special selector that conflict with class parser, such as 'hover:abc'
                success.push(selector);
                styleSheet.add(deepCopy$3(_this._plugin.utilities[selector]));
                return;
            }
            var result = _this.extract(baseClass, showComment);
            if (result) {
                if (Array.isArray(result)) {
                    result.forEach(function (i) {
                        if (i instanceof Keyframes$1) {
                            i.meta.order = 20;
                            return i;
                        }
                        i.selector = buildSelector;
                        _this.markAsImportant(i, important);
                    });
                }
                else {
                    result.selector = buildSelector;
                    _this.markAsImportant(result, important);
                }
                var wrapped = _this.wrapWithVariants(variants, result);
                if (wrapped) {
                    success.push(selector);
                    styleSheet.add(wrapped);
                }
                else {
                    _hIgnored(selector);
                }
            }
            else {
                _hIgnored(selector);
            }
        };
        var _hGroup = function (obj, parentVariants) {
            if (parentVariants === void 0) { parentVariants = []; }
            Array.isArray(obj.content) &&
                obj.content.forEach(function (u) {
                    if (u.type === 'group') {
                        _hGroup(u, obj.variants);
                    }
                    else {
                        // utility
                        var variants = __spreadArray$6(__spreadArray$6(__spreadArray$6([], parentVariants, true), obj.variants, true), u.variants, true);
                        var selector = __spreadArray$6(__spreadArray$6([], variants, true), [u.content], false).join(':');
                        typeof u.content === 'string' &&
                            _gStyle(_this.removePrefix(u.content), variants, selector, obj.important || u.important);
                    }
                });
        };
        ast.forEach(function (obj) {
            if (obj.type === 'utility') {
                if (Array.isArray(obj.content)) ;
                else if (obj.content) {
                    _gStyle(_this.removePrefix(obj.content), obj.variants, obj.raw, obj.important);
                }
            }
            else if (obj.type === 'group') {
                _hGroup(obj);
            }
            else {
                _hIgnored(obj.raw);
            }
        });
        className = success.length > 0 ? className : undefined;
        if (ignoreGenerated && className)
            this._cache.classes.push(className);
        if (!this.config('prefixer'))
            styleSheet.prefixer = false;
        return {
            success: success,
            ignored: ignored,
            className: className,
            styleSheet: styleSheet.sortby(sortGroup).combine(),
        };
    };
    Processor.prototype.attributify = function (attrs, ignoreProcessed) {
        var _this = this;
        if (ignoreProcessed === void 0) { ignoreProcessed = false; }
        var success = [];
        var ignored = [];
        var styleSheet = new StyleSheet$2();
        var _a = (this._config.attributify && typeof this._config.attributify === 'boolean') ? {} : this._config.attributify || {}, prefix = _a.prefix, separator = _a.separator, disable = _a.disable;
        var _gStyle = function (key, value, equal, notAllow, ignoreProcessed) {
            var _a, _b;
            if (equal === void 0) { equal = false; }
            if (notAllow === void 0) { notAllow = false; }
            if (ignoreProcessed === void 0) { ignoreProcessed = false; }
            var buildSelector = "[".concat(_this.e((prefix || '') + key)).concat(equal ? '=' : '~=', "\"").concat(value, "\"]");
            if (notAllow || (ignoreProcessed && _this._cache.attrs.includes(buildSelector))) {
                ignored.push(buildSelector);
                return;
            }
            var importantValue = value.startsWith('!');
            if (importantValue)
                value = value.slice(1);
            var importantKey = key.startsWith('!');
            if (importantKey)
                key = key.slice(1);
            var id = (_b = (_a = key.match(/\w+$/)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : '';
            var splits = value.split(separator || ':');
            var variants = splits.slice(0, -1);
            var utility = splits.slice(-1)[0];
            var keys = key.split(separator || ':');
            var lastKey = keys.slice(-1)[0];
            if (lastKey in _this._variants && lastKey !== 'svg') {
                variants = __spreadArray$6(__spreadArray$6([], keys, true), variants, true);
            }
            else if (id in _this._variants && id !== 'svg') {
                // sm = ... || sm:hover = ... || sm-hover = ...
                var matches = key.match(/[@<\w]+/g);
                if (!matches) {
                    ignored.push(buildSelector);
                    return;
                }
                variants = __spreadArray$6(__spreadArray$6([], matches, true), variants, true);
            }
            else {
                // text = ... || sm:text = ... || sm-text = ... || sm-hover-text = ...
                if (!keys) {
                    ignored.push(buildSelector);
                    return;
                }
                if (keys.length === 1)
                    keys = key.split('-');
                var last = void 0;
                // handle min-h || max-w ...
                if (['min', 'max'].includes(keys.slice(-2, -1)[0])) {
                    variants = __spreadArray$6(__spreadArray$6([], keys.slice(0, -2), true), variants, true);
                    last = keys.slice(-2).join('-');
                }
                else {
                    variants = __spreadArray$6(__spreadArray$6([], keys.slice(0, -1), true), variants, true);
                    last = keys[keys.length - 1];
                }
                // handle negative, such as m = -x-2
                var negative_1 = utility.charAt(0) === '-';
                if (negative_1)
                    utility = utility.slice(1);
                utility = ['m', 'p'].includes(last) && ['t', 'l', 'b', 'r', 'x', 'y'].includes(utility.charAt(0)) ? last + utility : last + '-' + utility;
                if (negative_1)
                    utility = '-' + utility;
                utility !== 'cursor-default' && (utility = utility.replace(/-(~|default)$/, ''));
                // handle special cases
                switch (last) {
                    case 'w':
                        if (['w-min', 'w-max', 'w-min-content', 'w-max-content'].includes(utility)) {
                            utility = utility.slice(0, 5);
                        }
                        else if (utility.startsWith('w-min')) {
                            utility = 'min-w' + utility.slice(5);
                        }
                        else if (utility.startsWith('w-max')) {
                            utility = 'max-w' + utility.slice(5);
                        }
                        break;
                    case 'h':
                        if (['h-min', 'h-max', 'h-min-content', 'h-max-content'].includes(utility)) {
                            utility = utility.slice(0, 5);
                        }
                        else if (utility.startsWith('h-min')) {
                            utility = 'min-h' + utility.slice(5);
                        }
                        else if (utility.startsWith('h-max')) {
                            utility = 'max-h' + utility.slice(5);
                        }
                        break;
                    case 'flex':
                        switch (utility) {
                            case 'flex-default':
                                utility = 'flex';
                                break;
                            case 'flex-inline':
                                utility = 'inline-flex';
                                break;
                            default:
                                if (/^flex-gap-/.test(utility))
                                    utility = utility.slice(5);
                        }
                        break;
                    case 'grid':
                        switch (utility) {
                            case 'grid-default':
                                utility = 'grid';
                                break;
                            case 'grid-inline':
                                utility = 'inline-grid';
                                break;
                            default:
                                if (/^grid-(auto|gap|col|row)-/.test(utility))
                                    utility = utility.slice(5);
                        }
                        break;
                    case 'justify':
                        if (utility.startsWith('justify-content-')) {
                            utility = 'justify-' + utility.slice(16);
                        }
                        break;
                    case 'align':
                        if (/^align-(items|self|content)-/.test(utility)) {
                            utility = utility.slice(6);
                        }
                        else {
                            utility = 'content-' + utility.slice(6);
                        }
                        break;
                    case 'place':
                        if (!/^place-(items|self|content)-/.test(utility)) {
                            utility = 'place-content-' + utility.slice(6);
                        }
                        break;
                    case 'font':
                        if (/^font-(tracking|leading)-/.test(utility) || ['font-italic', 'font-not-italic', 'font-antialiased', 'font-subpixel-antialiased', 'font-normal-nums', 'font-ordinal', 'font-slashed-zero', 'font-lining-nums', 'font-oldstyle-nums', 'font-proportional-nums', 'font-tabular-nums', 'font-diagonal-fractions', 'font-stacked-fractions'].includes(utility))
                            utility = utility.slice(5);
                        break;
                    case 'text':
                        if (['text-baseline', 'text-top', 'text-middle', 'text-bottom', 'text-text-top', 'text-text-bottom', 'text-sub', 'text-super'].includes(utility)) {
                            utility = 'align-' + utility.slice(5);
                        }
                        else if (utility.startsWith('text-placeholder') || utility.startsWith('text-underline') || utility.startsWith('text-tab') || utility.startsWith('text-indent') || utility.startsWith('text-hyphens') || utility.startsWith('text-write')) {
                            utility = utility.slice(5);
                        }
                        else if (['text-underline', 'text-overline', 'text-line-through', 'text-no-underline', 'text-uppercase', 'text-lowercase', 'text-capitalize', 'text-normal-case', 'text-truncate', 'text-overflow-ellipsis', 'text-text-ellipsis', 'text-text-clip', 'text-break-normal', 'text-break-words', 'text-break-all'].includes(utility)) {
                            utility = utility.slice(5);
                        }
                        else if (utility.startsWith('text-space')) {
                            utility = 'white' + utility.slice(5);
                        }
                        break;
                    case 'underline':
                        if (utility === 'underline-none') {
                            utility = 'no-underline';
                        }
                        else if (utility === 'underline-line-through') {
                            utility = 'line-through';
                        }
                        break;
                    case 'svg':
                        if (utility.startsWith('svg-fill') || utility.startsWith('svg-stroke'))
                            utility = utility.slice(4);
                        break;
                    case 'border':
                        if (utility.startsWith('border-rounded')) {
                            utility = utility.slice(7);
                        }
                        break;
                    case 'gradient':
                        if (utility === 'gradient-none') {
                            utility = 'bg-none';
                        }
                        else if (/^gradient-to-[trbl]{1,2}$/.test(utility)) {
                            utility = 'bg-' + utility;
                        }
                        else if (/^gradient-(from|via|to)-/.test(utility)) {
                            utility = utility.slice(9);
                        }
                        break;
                    case 'display':
                        utility = utility.slice(8);
                        break;
                    case 'pos':
                        utility = utility.slice(4);
                        break;
                    case 'position':
                        utility = utility.slice(9);
                        break;
                    case 'box':
                        if (/^box-(decoration|shadow)/.test(utility)) {
                            utility = utility.slice(4);
                        }
                        break;
                    case 'filter':
                        if (utility !== 'filter-none' && utility !== 'filter') {
                            utility = utility.slice(7);
                        }
                        break;
                    case 'backdrop':
                        if (utility === 'backdrop') {
                            utility = 'backdrop-filter';
                        }
                        else if (utility === 'backdrop-none') {
                            utility = 'backdrop-filter-none';
                        }
                        break;
                    case 'transition':
                        if (/transition-(duration|ease|delay)-/.test(utility)) {
                            utility = utility.slice(11);
                        }
                        break;
                    case 'transform':
                        if (!['transform-gpu', 'transform-none', 'transform'].includes(utility)) {
                            utility = utility.slice(10);
                        }
                        break;
                    case 'isolation':
                        if (utility === 'isolation-isolate')
                            utility = 'isolate';
                        break;
                    case 'table':
                        if (utility === 'table-inline') {
                            utility = 'inline-table';
                        }
                        else if (utility.startsWith('table-caption-') || utility.startsWith('table-empty-cells')) {
                            utility = utility.slice(6);
                        }
                        break;
                    case 'pointer':
                        utility = 'pointer-events' + utility.slice(7);
                        break;
                    case 'resize':
                        if (utility === 'resize-both')
                            utility = 'resize';
                        break;
                    case 'ring':
                        break;
                    case 'blend':
                        utility = 'mix-' + utility;
                        break;
                    case 'sr':
                        if (utility === 'sr-not-only')
                            utility = 'not-sr-only';
                        break;
                }
            }
            var style = _this.extract(utility, false);
            if (style) {
                var important_1 = importantKey || importantValue;
                if (Array.isArray(style)) {
                    style.forEach(function (i) {
                        if (i instanceof Keyframes$1)
                            return i;
                        i.selector = buildSelector;
                        _this.markAsImportant(i, important_1);
                    });
                }
                else {
                    style.selector = buildSelector;
                    _this.markAsImportant(style, important_1);
                }
                if (variants.find(function (i) { return !(i in _this._variants); })) {
                    ignored.push(buildSelector);
                }
                else {
                    var wrapped = _this.wrapWithVariants(variants, style);
                    if (wrapped) {
                        ignoreProcessed && _this._cache.attrs.push(buildSelector);
                        success.push(buildSelector);
                        styleSheet.add(wrapped);
                    }
                    else {
                        ignored.push(buildSelector);
                    }
                }
            }
            else {
                ignored.push(buildSelector);
            }
        };
        var _loop_2 = function (key, value) {
            var notAllow = false;
            if (prefix) {
                if (key.startsWith(prefix)) {
                    key = key.slice(prefix.length);
                }
                else {
                    notAllow = true;
                }
            }
            if (disable === null || disable === void 0 ? void 0 : disable.includes(key))
                notAllow = true;
            if (Array.isArray(value)) {
                value.forEach(function (i) { return _gStyle(key, i, false, notAllow, ignoreProcessed); });
            }
            else {
                _gStyle(key, value, true, notAllow, ignoreProcessed);
            }
        };
        // eslint-disable-next-line prefer-const
        for (var _i = 0, _b = Object.entries(attrs); _i < _b.length; _i++) {
            var _c = _b[_i], key = _c[0], value = _c[1];
            _loop_2(key, value);
        }
        return {
            success: success,
            ignored: ignored,
            styleSheet: styleSheet.sort().combine(),
        };
    };
    Processor.prototype.loadPlugin = function (_a) {
        var handler = _a.handler, config = _a.config;
        if (config) {
            config = this._resolveFunction(config);
            config = combineConfig(config, this._config);
            var pluginTheme = config.theme;
            var extendTheme = pluginTheme === null || pluginTheme === void 0 ? void 0 : pluginTheme.extend;
            if (pluginTheme && extendTheme && typeof extendTheme === 'object') {
                for (var _i = 0, _b = Object.entries(extendTheme); _i < _b.length; _i++) {
                    var _c = _b[_i], key = _c[0], value = _c[1];
                    var themeValue = pluginTheme[key];
                    if (themeValue && typeof themeValue === 'object') {
                        pluginTheme[key] = __assign$4(__assign$4({}, (themeValue !== null && themeValue !== void 0 ? themeValue : {})), value);
                    }
                    else if (value && typeof value === 'object') {
                        pluginTheme[key] = value;
                    }
                }
            }
            this._config = __assign$4(__assign$4({}, config), { theme: pluginTheme });
            this._theme = pluginTheme;
        }
        this._config = this._resolveFunction(this._config);
        this._theme = this._config.theme;
        this._variants = __assign$4(__assign$4({}, this._variants), this.resolveVariants());
        handler(this.pluginUtils);
    };
    Processor.prototype.loadPluginWithOptions = function (optionsFunction, userOptions) {
        var plugin = optionsFunction(userOptions !== null && userOptions !== void 0 ? userOptions : {});
        this.loadPlugin(plugin);
    };
    Processor.prototype.loadShortcuts = function (shortcuts) {
        var _this = this;
        var _loop_3 = function (key, value) {
            var prefix = this_1.config('prefix', '');
            if (typeof value === 'string') {
                this_1._plugin.shortcuts[key] = this_1.compile(value, undefined, undefined, false, undefined, cssEscape(prefix + key)).styleSheet.children.map(function (i) { return i.updateMeta('components', 'shortcuts', layerOrder$1['shortcuts'], ++_this._cache.count); });
            }
            else {
                var styles_1 = [];
                Style$3.generate('.' + cssEscape(key), value).forEach(function (style) {
                    for (var _i = 0, _a = style.property; _i < _a.length; _i++) {
                        var prop = _a[_i];
                        if (!prop.value)
                            continue;
                        if (prop.name === '@apply') {
                            styles_1 = styles_1.concat(_this.compile(Array.isArray(prop.value) ? prop.value.join(' ') : prop.value).styleSheet.children.map(function (i) {
                                var newStyle = deepCopy$3(style);
                                newStyle.property = [];
                                return newStyle.extend(i);
                            }));
                        }
                        else {
                            var newStyle = deepCopy$3(style);
                            newStyle.property = [prop];
                            styles_1.push(newStyle);
                        }
                    }
                });
                this_1._plugin.shortcuts[key] = styles_1.map(function (i) { return i.updateMeta('components', 'shortcuts', layerOrder$1['shortcuts'], ++_this._cache.count); });
            }
        };
        var this_1 = this;
        for (var _i = 0, _a = Object.entries(shortcuts); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            _loop_3(key, value);
        }
    };
    Processor.prototype.loadAlias = function (alias) {
        for (var _i = 0, _a = Object.entries(alias); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            this._plugin.alias[key] = new ClassParser(value, undefined, this._cache.variants).parse();
        }
    };
    Processor.prototype.config = function (path, defaultValue) {
        var _this = this;
        var _a;
        if (path === 'corePlugins')
            return this._plugin.core ? Object.keys(this._plugin.core).filter(function (i) { var _a; return (_a = _this._plugin.core) === null || _a === void 0 ? void 0 : _a[i]; }) : Object.keys(pluginOrder$1).slice(Object.keys(pluginOrder$1).length / 2);
        return (_a = getNestedValue(this._config, path)) !== null && _a !== void 0 ? _a : defaultValue;
    };
    Processor.prototype.theme = function (path, defaultValue) {
        var _a;
        return this._theme ? (_a = getNestedValue(this._theme, path)) !== null && _a !== void 0 ? _a : defaultValue : undefined;
    };
    Processor.prototype.corePlugins = function (path) {
        var _a;
        if (Array.isArray(this._config.corePlugins)) {
            return this._config.corePlugins.includes(path);
        }
        return (_a = this.config("corePlugins.".concat(path), true)) !== null && _a !== void 0 ? _a : false;
    };
    Processor.prototype.variants = function (path, defaultValue) {
        if (defaultValue === void 0) { defaultValue = []; }
        if (Array.isArray(this._config.variants)) {
            return this._config.variants;
        }
        return this.config("variants.".concat(path), defaultValue);
    };
    Processor.prototype.e = function (selector) {
        return cssEscape(selector);
    };
    Processor.prototype.prefix = function (selector) {
        var _a;
        return selector.replace(/(?=[\w])/, (_a = this._config.prefix) !== null && _a !== void 0 ? _a : '');
    };
    Processor.prototype.addUtilities = function (utilities, options) {
        var _this = this;
        var _a;
        if (options === void 0) { options = {
            layer: 'utilities',
            variants: [],
            respectPrefix: true,
            respectImportant: true,
        }; }
        if (Array.isArray(options))
            options = { variants: options };
        if (Array.isArray(utilities))
            utilities = utilities.reduce(function (previous, current) { return combineConfig(previous, current); }, {});
        var output = [];
        var layer = (_a = options.layer) !== null && _a !== void 0 ? _a : 'utilities';
        var order = layerOrder$1[layer] + 1;
        var _loop_4 = function (key, value) {
            var propertyValue = value;
            if (Array.isArray(value)) {
                propertyValue = Object.assign.apply(Object, __spreadArray$6([{}], value, false));
            }
            var styles = Style$3.generate(key.startsWith('.') && options.respectPrefix ? this_2.prefix(key) : key, propertyValue);
            if (options.layer)
                styles.forEach(function (style) { return style.updateMeta(layer, 'plugin', order, ++_this._cache.count); });
            if (options.respectImportant && this_2._config.important)
                styles.forEach(function (style) { return style.important = true; });
            var className = guessClassName(key);
            if (key.charAt(0) === '@') {
                styles.forEach(function (style) {
                    if (style.selector)
                        className = guessClassName(style.selector);
                    if (Array.isArray(className)) {
                        className.filter(function (i) { return i.isClass; }).forEach(function (_a) {
                            var selector = _a.selector, pseudo = _a.pseudo;
                            return _this._addPluginProcessorCache('utilities', selector, pseudo ? style.clone('.' + cssEscape(selector)).wrapSelector(function (selector) { return selector + pseudo; }) : style.clone());
                        });
                        var base = className.filter(function (i) { return !i.isClass; }).map(function (i) { return i.selector; }).join(', ');
                        if (base)
                            _this._addPluginProcessorCache('static', base, style.clone(base));
                    }
                    else {
                        _this._addPluginProcessorCache(className.isClass ? 'utilities' : 'static', className.selector, className.pseudo ? style.clone('.' + cssEscape(className.selector)).wrapSelector(function (selector) { return selector + className.pseudo; }) : style.clone());
                    }
                });
            }
            else if (Array.isArray(className)) {
                className.filter(function (i) { return i.isClass; }).forEach(function (_a) {
                    var selector = _a.selector, pseudo = _a.pseudo;
                    return _this._addPluginProcessorCache('utilities', selector, pseudo ? styles.map(function (i) { return i.clone('.' + cssEscape(selector)).wrapSelector(function (selector) { return selector + pseudo; }); }) : deepCopy$3(styles));
                });
                var base_1 = className.filter(function (i) { return !i.isClass; }).map(function (i) { return i.selector; }).join(', ');
                if (base_1)
                    this_2._addPluginProcessorCache('static', base_1, styles.map(function (i) { return i.clone(base_1); }));
            }
            else {
                this_2._addPluginProcessorCache(className.isClass ? 'utilities' : 'static', className.selector, className.pseudo ? styles.map(function (style) { return style.clone('.' + cssEscape(className.selector)).wrapSelector(function (selector) { return selector + className.pseudo; }); }) : styles);
            }
            output = __spreadArray$6(__spreadArray$6([], output, true), styles, true);
        };
        var this_2 = this;
        for (var _i = 0, _b = Object.entries(utilities); _i < _b.length; _i++) {
            var _c = _b[_i], key = _c[0], value = _c[1];
            _loop_4(key, value);
        }
        return output;
    };
    Processor.prototype.addDynamic = function (key, generator, options) {
        var _this = this;
        if (options === void 0) { options = {
            layer: 'utilities',
            group: 'plugin',
            variants: [],
            completions: [],
            respectPrefix: true,
            respectImportant: true,
            respectSelector: false,
        }; }
        var uOptions = Array.isArray(options) ? { variants: options } : options;
        var layer = uOptions.layer || 'utilities';
        var group = uOptions.group || 'plugin';
        var order = uOptions.order || layerOrder$1[layer] + 1;
        if (uOptions.completions)
            this._plugin.completions[group] = group in this._plugin.completions ? __spreadArray$6(__spreadArray$6([], this._plugin.completions[group], true), uOptions.completions, true) : uOptions.completions;
        var style = function (selector, property, important) {
            if (important === void 0) { important = uOptions.respectImportant && _this._config.important ? true : false; }
            return new Style$3(selector, property, important);
        };
        var prop = function (name, value, comment, important) {
            if (important === void 0) { important = uOptions.respectImportant && _this._config.important ? true : false; }
            return new Property$3(name, value, comment, important);
        };
        var keyframes = function (selector, property, important) {
            if (important === void 0) { important = uOptions.respectImportant && _this._config.important ? true : false; }
            return new Keyframes$1(selector, property, important);
        };
        keyframes.generate = Keyframes$1.generate;
        style.generate = Style$3.generate;
        prop.parse = Property$3.parse;
        this._plugin.dynamic[key] = (key in this._plugin.dynamic)
            ? function (Utility) { return deepCopy$3(_this._plugin.dynamic[key])(Utility) || generator({ Utility: Utility, Style: style, Property: prop, Keyframes: keyframes }); }
            : function (Utility) {
                var output = generator({ Utility: Utility, Style: style, Property: prop, Keyframes: keyframes });
                if (!output)
                    return;
                if (Array.isArray(output))
                    return output.map(function (i) { return i.updateMeta(layer, group, order, ++_this._cache.count, false, i.meta.respectSelector || uOptions.respectSelector); });
                return output.updateMeta(layer, group, order, ++_this._cache.count, false, output.meta.respectSelector || uOptions.respectSelector);
            };
        return generator;
    };
    Processor.prototype.addComponents = function (components, options) {
        var _this = this;
        var _a;
        if (options === void 0) { options = { layer: 'components', variants: [], respectPrefix: false }; }
        if (Array.isArray(options))
            options = { variants: options };
        if (Array.isArray(components))
            components = components.reduce(function (previous, current) { return combineConfig(previous, current); }, {});
        var output = [];
        var layer = (_a = options.layer) !== null && _a !== void 0 ? _a : 'components';
        var order = layerOrder$1[layer] + 1;
        var _loop_5 = function (key, value) {
            var propertyValue = value;
            if (Array.isArray(value)) {
                propertyValue = Object.assign.apply(Object, __spreadArray$6([{}], value, false));
            }
            var styles = Style$3.generate(key.startsWith('.') && options.respectPrefix ? this_3.prefix(key) : key, propertyValue);
            styles.forEach(function (style) { return style.updateMeta(layer, 'plugin', order, ++_this._cache.count); });
            if (options.respectImportant && this_3._config.important)
                styles.forEach(function (style) { return style.important = true; });
            var className = guessClassName(key);
            if (key.charAt(0) === '@') {
                styles.forEach(function (style) {
                    if (style.selector)
                        className = guessClassName(style.selector);
                    if (Array.isArray(className)) {
                        className.filter(function (i) { return i.isClass; }).forEach(function (_a) {
                            var selector = _a.selector, pseudo = _a.pseudo;
                            return _this._addPluginProcessorCache('components', selector, pseudo ? style.clone('.' + cssEscape(selector)).wrapSelector(function (selector) { return selector + pseudo; }) : style.clone());
                        });
                        var base = className.filter(function (i) { return !i.isClass; }).map(function (i) { return i.selector; }).join(', ');
                        if (base)
                            _this._addPluginProcessorCache('static', base, style.clone(base));
                    }
                    else {
                        _this._addPluginProcessorCache(className.isClass ? 'components' : 'static', className.selector, className.pseudo ? style.clone('.' + cssEscape(className.selector)).wrapSelector(function (selector) { return selector + className.pseudo; }) : style.clone());
                    }
                });
            }
            else if (Array.isArray(className)) {
                // one of the selector are not class, treat the entire as static to avoid duplication
                if (className.some(function (i) { return !i.isClass; })) {
                    var base_2 = className.map(function (i) { return i.selector; }).join(', ');
                    if (base_2)
                        this_3._addPluginProcessorCache('static', base_2, styles.map(function (i) { return i.clone(base_2); }));
                }
                // class
                else {
                    className.forEach(function (_a) {
                        var selector = _a.selector, pseudo = _a.pseudo;
                        return _this._addPluginProcessorCache('components', selector, pseudo ? styles.map(function (i) { return i.clone('.' + cssEscape(selector)).wrapSelector(function (selector) { return selector + pseudo; }); }) : deepCopy$3(styles));
                    });
                }
            }
            else {
                this_3._addPluginProcessorCache(className.isClass ? 'components' : 'static', className.selector, className.pseudo ? styles.map(function (style) { return style.clone('.' + cssEscape(className.selector)).wrapSelector(function (selector) { return selector + className.pseudo; }); }) : styles);
            }
            output = __spreadArray$6(__spreadArray$6([], output, true), styles, true);
        };
        var this_3 = this;
        for (var _i = 0, _b = Object.entries(components); _i < _b.length; _i++) {
            var _c = _b[_i], key = _c[0], value = _c[1];
            _loop_5(key, value);
        }
        return output;
    };
    Processor.prototype.addBase = function (baseStyles) {
        var _this = this;
        var output = [];
        for (var _i = 0, _a = Object.entries(baseStyles); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            var propertyValue = value;
            if (Array.isArray(value)) {
                propertyValue = Object.assign.apply(Object, __spreadArray$6([{}], value, false));
            }
            var styles = Style$3.generate(key, propertyValue).map(function (i) { return i.updateMeta('base', 'plugin', 10, ++_this._cache.count); });
            this._replaceStyleVariants(styles);
            this._addPluginProcessorCache('preflights', key, styles);
            output = __spreadArray$6(__spreadArray$6([], output, true), styles, true);
        }
        return output;
    };
    Processor.prototype.addVariant = function (name, generator) {
        // name && generator && options;
        var style = generator(__assign$4(__assign$4({}, this.variantUtils), { separator: this.config('separator', ':'), style: new Style$3() }));
        this._variants[name] = function () { return style; };
        this._cache.variants.push(name);
        return style;
    };
    Processor.prototype.dumpConfig = function () {
        var processor = new Processor();
        var diff = diffConfig(processor._config, this._config);
        var output = { theme: { extend: {} }, plugins: [] };
        if (diff.theme) {
            for (var _i = 0, _a = Object.entries(diff.theme); _i < _a.length; _i++) {
                var _b = _a[_i], key = _b[0], value = _b[1];
                if (key !== 'extend') {
                    output.theme.extend[key] = value;
                }
            }
            delete diff.theme;
        }
        if (diff.plugins) {
            for (var _c = 0, _d = diff.plugins; _c < _d.length; _c++) {
                var plugin_1 = _d[_c];
                if ('config' in plugin_1) {
                    delete plugin_1.config;
                }
                output.plugins.push(plugin_1);
            }
            delete diff.plugins;
        }
        output = __assign$4(__assign$4({}, diff), output);
        return "module.exports = ".concat(toSource(output));
    };
    return Processor;
}());

var dist = {};

var lib$c = {};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics$3 = function(d, b) {
    extendStatics$3 = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics$3(d, b);
};

function __extends$5(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics$3(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign$3 = function() {
    __assign$3 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$3.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding$2 = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding$2(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray$5(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
}
var __setModuleDefault$2 = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar$2(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$2(result, mod, k);
    __setModuleDefault$2(result, mod);
    return result;
}

function __importDefault$8(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

var tslib_es6 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	__extends: __extends$5,
	get __assign () { return __assign$3; },
	__rest: __rest,
	__decorate: __decorate,
	__param: __param,
	__metadata: __metadata,
	__awaiter: __awaiter,
	__generator: __generator,
	__createBinding: __createBinding$2,
	__exportStar: __exportStar,
	__values: __values,
	__read: __read,
	__spread: __spread,
	__spreadArrays: __spreadArrays,
	__spreadArray: __spreadArray$5,
	__await: __await,
	__asyncGenerator: __asyncGenerator,
	__asyncDelegator: __asyncDelegator,
	__asyncValues: __asyncValues,
	__makeTemplateObject: __makeTemplateObject,
	__importStar: __importStar$2,
	__importDefault: __importDefault$8,
	__classPrivateFieldGet: __classPrivateFieldGet,
	__classPrivateFieldSet: __classPrivateFieldSet
});

var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(tslib_es6);

var types = {};

Object.defineProperty(types, "__esModule", { value: true });

var load$1 = {};

var options = {};

Object.defineProperty(options, "__esModule", { value: true });
options.flatten = void 0;
var tslib_1$6 = require$$0$2;
var defaultOpts = {
    xml: false,
    decodeEntities: true,
};
/** Cheerio default options. */
options.default = defaultOpts;
var xmlModeDefault = {
    _useHtmlParser2: true,
    xmlMode: true,
};
function flatten$1(options) {
    return (options === null || options === void 0 ? void 0 : options.xml)
        ? typeof options.xml === 'boolean'
            ? xmlModeDefault
            : tslib_1$6.__assign(tslib_1$6.__assign({}, xmlModeDefault), options.xml)
        : options !== null && options !== void 0 ? options : undefined;
}
options.flatten = flatten$1;

var _static = {};

var lib$b = {};

var lib$a = {};

var parse$f = {};

var __spreadArray$4 = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(parse$f, "__esModule", { value: true });
parse$f.isTraversal = void 0;
var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
var actionTypes$1 = new Map([
    ["~", "element"],
    ["^", "start"],
    ["$", "end"],
    ["*", "any"],
    ["!", "not"],
    ["|", "hyphen"],
]);
var Traversals = {
    ">": "child",
    "<": "parent",
    "~": "sibling",
    "+": "adjacent",
};
var attribSelectors = {
    "#": ["id", "equals"],
    ".": ["class", "element"],
};
// Pseudos, whose data property is parsed as well.
var unpackPseudos = new Set([
    "has",
    "not",
    "matches",
    "is",
    "where",
    "host",
    "host-context",
]);
var traversalNames = new Set(__spreadArray$4([
    "descendant"
], Object.keys(Traversals).map(function (k) { return Traversals[k]; }), true));
/**
 * Attributes that are case-insensitive in HTML.
 *
 * @private
 * @see https://html.spec.whatwg.org/multipage/semantics-other.html#case-sensitivity-of-selectors
 */
var caseInsensitiveAttributes = new Set([
    "accept",
    "accept-charset",
    "align",
    "alink",
    "axis",
    "bgcolor",
    "charset",
    "checked",
    "clear",
    "codetype",
    "color",
    "compact",
    "declare",
    "defer",
    "dir",
    "direction",
    "disabled",
    "enctype",
    "face",
    "frame",
    "hreflang",
    "http-equiv",
    "lang",
    "language",
    "link",
    "media",
    "method",
    "multiple",
    "nohref",
    "noresize",
    "noshade",
    "nowrap",
    "readonly",
    "rel",
    "rev",
    "rules",
    "scope",
    "scrolling",
    "selected",
    "shape",
    "target",
    "text",
    "type",
    "valign",
    "valuetype",
    "vlink",
]);
/**
 * Checks whether a specific selector is a traversal.
 * This is useful eg. in swapping the order of elements that
 * are not traversals.
 *
 * @param selector Selector to check.
 */
function isTraversal(selector) {
    return traversalNames.has(selector.type);
}
parse$f.isTraversal = isTraversal;
var stripQuotesFromPseudos = new Set(["contains", "icontains"]);
var quotes = new Set(['"', "'"]);
// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152
function funescape(_, escaped, escapedWhitespace) {
    var high = parseInt(escaped, 16) - 0x10000;
    // NaN means non-codepoint
    return high !== high || escapedWhitespace
        ? escaped
        : high < 0
            ? // BMP codepoint
                String.fromCharCode(high + 0x10000)
            : // Supplemental Plane codepoint (surrogate pair)
                String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);
}
function unescapeCSS(str) {
    return str.replace(reEscape, funescape);
}
function isWhitespace$1(c) {
    return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}
/**
 * Parses `selector`, optionally with the passed `options`.
 *
 * @param selector Selector to parse.
 * @param options Options for parsing.
 * @returns Returns a two-dimensional array.
 * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),
 * the second contains the relevant tokens for that selector.
 */
function parse$e(selector, options) {
    var subselects = [];
    var endIndex = parseSelector(subselects, "" + selector, options, 0);
    if (endIndex < selector.length) {
        throw new Error("Unmatched selector: " + selector.slice(endIndex));
    }
    return subselects;
}
parse$f.default = parse$e;
function parseSelector(subselects, selector, options, selectorIndex) {
    var _a, _b;
    if (options === void 0) { options = {}; }
    var tokens = [];
    var sawWS = false;
    function getName(offset) {
        var match = selector.slice(selectorIndex + offset).match(reName);
        if (!match) {
            throw new Error("Expected name, found " + selector.slice(selectorIndex));
        }
        var name = match[0];
        selectorIndex += offset + name.length;
        return unescapeCSS(name);
    }
    function stripWhitespace(offset) {
        while (isWhitespace$1(selector.charAt(selectorIndex + offset)))
            offset++;
        selectorIndex += offset;
    }
    function isEscaped(pos) {
        var slashCount = 0;
        while (selector.charAt(--pos) === "\\")
            slashCount++;
        return (slashCount & 1) === 1;
    }
    function ensureNotTraversal() {
        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
            throw new Error("Did not expect successive traversals.");
        }
    }
    stripWhitespace(0);
    while (selector !== "") {
        var firstChar = selector.charAt(selectorIndex);
        if (isWhitespace$1(firstChar)) {
            sawWS = true;
            stripWhitespace(1);
        }
        else if (firstChar in Traversals) {
            ensureNotTraversal();
            tokens.push({ type: Traversals[firstChar] });
            sawWS = false;
            stripWhitespace(1);
        }
        else if (firstChar === ",") {
            if (tokens.length === 0) {
                throw new Error("Empty sub-selector");
            }
            subselects.push(tokens);
            tokens = [];
            sawWS = false;
            stripWhitespace(1);
        }
        else if (selector.startsWith("/*", selectorIndex)) {
            var endIndex = selector.indexOf("*/", selectorIndex + 2);
            if (endIndex < 0) {
                throw new Error("Comment was not terminated");
            }
            selectorIndex = endIndex + 2;
        }
        else {
            if (sawWS) {
                ensureNotTraversal();
                tokens.push({ type: "descendant" });
                sawWS = false;
            }
            if (firstChar in attribSelectors) {
                var _c = attribSelectors[firstChar], name_1 = _c[0], action = _c[1];
                tokens.push({
                    type: "attribute",
                    name: name_1,
                    action: action,
                    value: getName(1),
                    namespace: null,
                    // TODO: Add quirksMode option, which makes `ignoreCase` `true` for HTML.
                    ignoreCase: options.xmlMode ? null : false,
                });
            }
            else if (firstChar === "[") {
                stripWhitespace(1);
                // Determine attribute name and namespace
                var namespace = null;
                if (selector.charAt(selectorIndex) === "|") {
                    namespace = "";
                    selectorIndex += 1;
                }
                if (selector.startsWith("*|", selectorIndex)) {
                    namespace = "*";
                    selectorIndex += 2;
                }
                var name_2 = getName(0);
                if (namespace === null &&
                    selector.charAt(selectorIndex) === "|" &&
                    selector.charAt(selectorIndex + 1) !== "=") {
                    namespace = name_2;
                    name_2 = getName(1);
                }
                if ((_a = options.lowerCaseAttributeNames) !== null && _a !== void 0 ? _a : !options.xmlMode) {
                    name_2 = name_2.toLowerCase();
                }
                stripWhitespace(0);
                // Determine comparison operation
                var action = "exists";
                var possibleAction = actionTypes$1.get(selector.charAt(selectorIndex));
                if (possibleAction) {
                    action = possibleAction;
                    if (selector.charAt(selectorIndex + 1) !== "=") {
                        throw new Error("Expected `=`");
                    }
                    stripWhitespace(2);
                }
                else if (selector.charAt(selectorIndex) === "=") {
                    action = "equals";
                    stripWhitespace(1);
                }
                // Determine value
                var value = "";
                var ignoreCase = null;
                if (action !== "exists") {
                    if (quotes.has(selector.charAt(selectorIndex))) {
                        var quote = selector.charAt(selectorIndex);
                        var sectionEnd = selectorIndex + 1;
                        while (sectionEnd < selector.length &&
                            (selector.charAt(sectionEnd) !== quote ||
                                isEscaped(sectionEnd))) {
                            sectionEnd += 1;
                        }
                        if (selector.charAt(sectionEnd) !== quote) {
                            throw new Error("Attribute value didn't end");
                        }
                        value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
                        selectorIndex = sectionEnd + 1;
                    }
                    else {
                        var valueStart = selectorIndex;
                        while (selectorIndex < selector.length &&
                            ((!isWhitespace$1(selector.charAt(selectorIndex)) &&
                                selector.charAt(selectorIndex) !== "]") ||
                                isEscaped(selectorIndex))) {
                            selectorIndex += 1;
                        }
                        value = unescapeCSS(selector.slice(valueStart, selectorIndex));
                    }
                    stripWhitespace(0);
                    // See if we have a force ignore flag
                    var forceIgnore = selector.charAt(selectorIndex);
                    // If the forceIgnore flag is set (either `i` or `s`), use that value
                    if (forceIgnore === "s" || forceIgnore === "S") {
                        ignoreCase = false;
                        stripWhitespace(1);
                    }
                    else if (forceIgnore === "i" || forceIgnore === "I") {
                        ignoreCase = true;
                        stripWhitespace(1);
                    }
                }
                // If `xmlMode` is set, there are no rules; otherwise, use the `caseInsensitiveAttributes` list.
                if (!options.xmlMode) {
                    // TODO: Skip this for `exists`, as there is no value to compare to.
                    ignoreCase !== null && ignoreCase !== void 0 ? ignoreCase : (ignoreCase = caseInsensitiveAttributes.has(name_2));
                }
                if (selector.charAt(selectorIndex) !== "]") {
                    throw new Error("Attribute selector didn't terminate");
                }
                selectorIndex += 1;
                var attributeSelector = {
                    type: "attribute",
                    name: name_2,
                    action: action,
                    value: value,
                    namespace: namespace,
                    ignoreCase: ignoreCase,
                };
                tokens.push(attributeSelector);
            }
            else if (firstChar === ":") {
                if (selector.charAt(selectorIndex + 1) === ":") {
                    tokens.push({
                        type: "pseudo-element",
                        name: getName(2).toLowerCase(),
                    });
                    continue;
                }
                var name_3 = getName(1).toLowerCase();
                var data = null;
                if (selector.charAt(selectorIndex) === "(") {
                    if (unpackPseudos.has(name_3)) {
                        if (quotes.has(selector.charAt(selectorIndex + 1))) {
                            throw new Error("Pseudo-selector " + name_3 + " cannot be quoted");
                        }
                        data = [];
                        selectorIndex = parseSelector(data, selector, options, selectorIndex + 1);
                        if (selector.charAt(selectorIndex) !== ")") {
                            throw new Error("Missing closing parenthesis in :" + name_3 + " (" + selector + ")");
                        }
                        selectorIndex += 1;
                    }
                    else {
                        selectorIndex += 1;
                        var start = selectorIndex;
                        var counter = 1;
                        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
                            if (selector.charAt(selectorIndex) === "(" &&
                                !isEscaped(selectorIndex)) {
                                counter++;
                            }
                            else if (selector.charAt(selectorIndex) === ")" &&
                                !isEscaped(selectorIndex)) {
                                counter--;
                            }
                        }
                        if (counter) {
                            throw new Error("Parenthesis not matched");
                        }
                        data = selector.slice(start, selectorIndex - 1);
                        if (stripQuotesFromPseudos.has(name_3)) {
                            var quot = data.charAt(0);
                            if (quot === data.slice(-1) && quotes.has(quot)) {
                                data = data.slice(1, -1);
                            }
                            data = unescapeCSS(data);
                        }
                    }
                }
                tokens.push({ type: "pseudo", name: name_3, data: data });
            }
            else {
                var namespace = null;
                var name_4 = void 0;
                if (firstChar === "*") {
                    selectorIndex += 1;
                    name_4 = "*";
                }
                else if (reName.test(selector.slice(selectorIndex))) {
                    if (selector.charAt(selectorIndex) === "|") {
                        namespace = "";
                        selectorIndex += 1;
                    }
                    name_4 = getName(0);
                }
                else {
                    /*
                     * We have finished parsing the selector.
                     * Remove descendant tokens at the end if they exist,
                     * and return the last index, so that parsing can be
                     * picked up from here.
                     */
                    if (tokens.length &&
                        tokens[tokens.length - 1].type === "descendant") {
                        tokens.pop();
                    }
                    addToken(subselects, tokens);
                    return selectorIndex;
                }
                if (selector.charAt(selectorIndex) === "|") {
                    namespace = name_4;
                    if (selector.charAt(selectorIndex + 1) === "*") {
                        name_4 = "*";
                        selectorIndex += 2;
                    }
                    else {
                        name_4 = getName(1);
                    }
                }
                if (name_4 === "*") {
                    tokens.push({ type: "universal", namespace: namespace });
                }
                else {
                    if ((_b = options.lowerCaseTags) !== null && _b !== void 0 ? _b : !options.xmlMode) {
                        name_4 = name_4.toLowerCase();
                    }
                    tokens.push({ type: "tag", name: name_4, namespace: namespace });
                }
            }
        }
    }
    addToken(subselects, tokens);
    return selectorIndex;
}
function addToken(subselects, tokens) {
    if (subselects.length > 0 && tokens.length === 0) {
        throw new Error("Empty sub-selector");
    }
    subselects.push(tokens);
}

var stringify$c = {};

var __spreadArray$3 = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(stringify$c, "__esModule", { value: true });
var actionTypes = {
    equals: "",
    element: "~",
    start: "^",
    end: "$",
    any: "*",
    not: "!",
    hyphen: "|",
};
var charsToEscape = new Set(__spreadArray$3(__spreadArray$3([], Object.keys(actionTypes)
    .map(function (typeKey) { return actionTypes[typeKey]; })
    .filter(Boolean), true), [
    ":",
    "[",
    "]",
    " ",
    "\\",
    "(",
    ")",
    "'",
], false));
/**
 * Turns `selector` back into a string.
 *
 * @param selector Selector to stringify.
 */
function stringify$b(selector) {
    return selector.map(stringifySubselector).join(", ");
}
stringify$c.default = stringify$b;
function stringifySubselector(token) {
    return token.map(stringifyToken).join("");
}
function stringifyToken(token) {
    switch (token.type) {
        // Simple types
        case "child":
            return " > ";
        case "parent":
            return " < ";
        case "sibling":
            return " ~ ";
        case "adjacent":
            return " + ";
        case "descendant":
            return " ";
        case "universal":
            return getNamespace(token.namespace) + "*";
        case "tag":
            return getNamespacedName(token);
        case "pseudo-element":
            return "::" + escapeName(token.name);
        case "pseudo":
            if (token.data === null)
                return ":" + escapeName(token.name);
            if (typeof token.data === "string") {
                return ":" + escapeName(token.name) + "(" + escapeName(token.data) + ")";
            }
            return ":" + escapeName(token.name) + "(" + stringify$b(token.data) + ")";
        case "attribute": {
            if (token.name === "id" &&
                token.action === "equals" &&
                !token.ignoreCase &&
                !token.namespace) {
                return "#" + escapeName(token.value);
            }
            if (token.name === "class" &&
                token.action === "element" &&
                !token.ignoreCase &&
                !token.namespace) {
                return "." + escapeName(token.value);
            }
            var name_1 = getNamespacedName(token);
            if (token.action === "exists") {
                return "[" + name_1 + "]";
            }
            return "[" + name_1 + actionTypes[token.action] + "='" + escapeName(token.value) + "'" + (token.ignoreCase ? "i" : token.ignoreCase === false ? "s" : "") + "]";
        }
    }
}
function getNamespacedName(token) {
    return "" + getNamespace(token.namespace) + escapeName(token.name);
}
function getNamespace(namespace) {
    return namespace !== null
        ? (namespace === "*" ? "*" : escapeName(namespace)) + "|"
        : "";
}
function escapeName(str) {
    return str
        .split("")
        .map(function (c) { return (charsToEscape.has(c) ? "\\" + c : c); })
        .join("");
}

(function (exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringify = exports.parse = void 0;
__exportStar(parse$f, exports);
var parse_1 = parse$f;
Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return __importDefault(parse_1).default; } });
var stringify_1 = stringify$c;
Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return __importDefault(stringify_1).default; } });
}(lib$a));

var lib$9 = {};

var lib$8 = {};

var stringify$a = {};

var lib$7 = {};

var lib$6 = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
/** Types of elements found in htmlparser2's DOM */
var ElementType;
(function (ElementType) {
    /** Type for the root element of a document */
    ElementType["Root"] = "root";
    /** Type for Text */
    ElementType["Text"] = "text";
    /** Type for <? ... ?> */
    ElementType["Directive"] = "directive";
    /** Type for <!-- ... --> */
    ElementType["Comment"] = "comment";
    /** Type for <script> tags */
    ElementType["Script"] = "script";
    /** Type for <style> tags */
    ElementType["Style"] = "style";
    /** Type for Any tag */
    ElementType["Tag"] = "tag";
    /** Type for <![CDATA[ ... ]]> */
    ElementType["CDATA"] = "cdata";
    /** Type for <!doctype ...> */
    ElementType["Doctype"] = "doctype";
})(ElementType = exports.ElementType || (exports.ElementType = {}));
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */
function isTag(elem) {
    return (elem.type === ElementType.Tag ||
        elem.type === ElementType.Script ||
        elem.type === ElementType.Style);
}
exports.isTag = isTag;
// Exports for backwards compatibility
/** Type for the root element of a document */
exports.Root = ElementType.Root;
/** Type for Text */
exports.Text = ElementType.Text;
/** Type for <? ... ?> */
exports.Directive = ElementType.Directive;
/** Type for <!-- ... --> */
exports.Comment = ElementType.Comment;
/** Type for <script> tags */
exports.Script = ElementType.Script;
/** Type for <style> tags */
exports.Style = ElementType.Style;
/** Type for Any tag */
exports.Tag = ElementType.Tag;
/** Type for <![CDATA[ ... ]]> */
exports.CDATA = ElementType.CDATA;
/** Type for <!doctype ...> */
exports.Doctype = ElementType.Doctype;
}(lib$6));

var node$3 = {};

var __extends$4 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign$2 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
    __assign$2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign$2.apply(this, arguments);
};
Object.defineProperty(node$3, "__esModule", { value: true });
node$3.cloneNode = node$3.hasChildren = node$3.isDocument = node$3.isDirective = node$3.isComment = node$3.isText = node$3.isCDATA = node$3.isTag = node$3.Element = node$3.Document = node$3.NodeWithChildren = node$3.ProcessingInstruction = node$3.Comment = node$3.Text = node$3.DataNode = node$3.Node = void 0;
var domelementtype_1$1 = lib$6;
var nodeTypes$1 = new Map([
    [domelementtype_1$1.ElementType.Tag, 1],
    [domelementtype_1$1.ElementType.Script, 1],
    [domelementtype_1$1.ElementType.Style, 1],
    [domelementtype_1$1.ElementType.Directive, 1],
    [domelementtype_1$1.ElementType.Text, 3],
    [domelementtype_1$1.ElementType.CDATA, 4],
    [domelementtype_1$1.ElementType.Comment, 8],
    [domelementtype_1$1.ElementType.Root, 9],
]);
/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */
var Node$1 = /** @class */ (function () {
    /**
     *
     * @param type The type of the node.
     */
    function Node(type) {
        this.type = type;
        /** Parent of the node */
        this.parent = null;
        /** Previous sibling */
        this.prev = null;
        /** Next sibling */
        this.next = null;
        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
        this.startIndex = null;
        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
        this.endIndex = null;
    }
    Object.defineProperty(Node.prototype, "nodeType", {
        // Read-only aliases
        /**
         * [DOM spec](https://dom.spec.whatwg.org/#dom-node-nodetype)-compatible
         * node {@link type}.
         */
        get: function () {
            var _a;
            return (_a = nodeTypes$1.get(this.type)) !== null && _a !== void 0 ? _a : 1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "parentNode", {
        // Read-write aliases for properties
        /**
         * Same as {@link parent}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.parent;
        },
        set: function (parent) {
            this.parent = parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "previousSibling", {
        /**
         * Same as {@link prev}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.prev;
        },
        set: function (prev) {
            this.prev = prev;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "nextSibling", {
        /**
         * Same as {@link next}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.next;
        },
        set: function (next) {
            this.next = next;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Clone this node, and optionally its children.
     *
     * @param recursive Clone child nodes as well.
     * @returns A clone of the node.
     */
    Node.prototype.cloneNode = function (recursive) {
        if (recursive === void 0) { recursive = false; }
        return cloneNode(this, recursive);
    };
    return Node;
}());
node$3.Node = Node$1;
/**
 * A node that contains some data.
 */
var DataNode = /** @class */ (function (_super) {
    __extends$4(DataNode, _super);
    /**
     * @param type The type of the node
     * @param data The content of the data node
     */
    function DataNode(type, data) {
        var _this = _super.call(this, type) || this;
        _this.data = data;
        return _this;
    }
    Object.defineProperty(DataNode.prototype, "nodeValue", {
        /**
         * Same as {@link data}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.data;
        },
        set: function (data) {
            this.data = data;
        },
        enumerable: false,
        configurable: true
    });
    return DataNode;
}(Node$1));
node$3.DataNode = DataNode;
/**
 * Text within the document.
 */
var Text = /** @class */ (function (_super) {
    __extends$4(Text, _super);
    function Text(data) {
        return _super.call(this, domelementtype_1$1.ElementType.Text, data) || this;
    }
    return Text;
}(DataNode));
node$3.Text = Text;
/**
 * Comments within the document.
 */
var Comment = /** @class */ (function (_super) {
    __extends$4(Comment, _super);
    function Comment(data) {
        return _super.call(this, domelementtype_1$1.ElementType.Comment, data) || this;
    }
    return Comment;
}(DataNode));
node$3.Comment = Comment;
/**
 * Processing instructions, including doc types.
 */
var ProcessingInstruction = /** @class */ (function (_super) {
    __extends$4(ProcessingInstruction, _super);
    function ProcessingInstruction(name, data) {
        var _this = _super.call(this, domelementtype_1$1.ElementType.Directive, data) || this;
        _this.name = name;
        return _this;
    }
    return ProcessingInstruction;
}(DataNode));
node$3.ProcessingInstruction = ProcessingInstruction;
/**
 * A `Node` that can have children.
 */
var NodeWithChildren = /** @class */ (function (_super) {
    __extends$4(NodeWithChildren, _super);
    /**
     * @param type Type of the node.
     * @param children Children of the node. Only certain node types can have children.
     */
    function NodeWithChildren(type, children) {
        var _this = _super.call(this, type) || this;
        _this.children = children;
        return _this;
    }
    Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
        // Aliases
        /** First child of the node. */
        get: function () {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
        /** Last child of the node. */
        get: function () {
            return this.children.length > 0
                ? this.children[this.children.length - 1]
                : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
        /**
         * Same as {@link children}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.children;
        },
        set: function (children) {
            this.children = children;
        },
        enumerable: false,
        configurable: true
    });
    return NodeWithChildren;
}(Node$1));
node$3.NodeWithChildren = NodeWithChildren;
/**
 * The root node of the document.
 */
var Document = /** @class */ (function (_super) {
    __extends$4(Document, _super);
    function Document(children) {
        return _super.call(this, domelementtype_1$1.ElementType.Root, children) || this;
    }
    return Document;
}(NodeWithChildren));
node$3.Document = Document;
/**
 * An element within the DOM.
 */
var Element$1 = /** @class */ (function (_super) {
    __extends$4(Element, _super);
    /**
     * @param name Name of the tag, eg. `div`, `span`.
     * @param attribs Object mapping attribute names to attribute values.
     * @param children Children of the node.
     */
    function Element(name, attribs, children, type) {
        if (children === void 0) { children = []; }
        if (type === void 0) { type = name === "script"
            ? domelementtype_1$1.ElementType.Script
            : name === "style"
                ? domelementtype_1$1.ElementType.Style
                : domelementtype_1$1.ElementType.Tag; }
        var _this = _super.call(this, type, children) || this;
        _this.name = name;
        _this.attribs = attribs;
        return _this;
    }
    Object.defineProperty(Element.prototype, "tagName", {
        // DOM Level 1 aliases
        /**
         * Same as {@link name}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.name;
        },
        set: function (name) {
            this.name = name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "attributes", {
        get: function () {
            var _this = this;
            return Object.keys(this.attribs).map(function (name) {
                var _a, _b;
                return ({
                    name: name,
                    value: _this.attribs[name],
                    namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                    prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name],
                });
            });
        },
        enumerable: false,
        configurable: true
    });
    return Element;
}(NodeWithChildren));
node$3.Element = Element$1;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */
function isTag(node) {
    return (0, domelementtype_1$1.isTag)(node);
}
node$3.isTag = isTag;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
 */
function isCDATA(node) {
    return node.type === domelementtype_1$1.ElementType.CDATA;
}
node$3.isCDATA = isCDATA;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Text`, `false` otherwise.
 */
function isText(node) {
    return node.type === domelementtype_1$1.ElementType.Text;
}
node$3.isText = isText;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Comment`, `false` otherwise.
 */
function isComment(node) {
    return node.type === domelementtype_1$1.ElementType.Comment;
}
node$3.isComment = isComment;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDirective(node) {
    return node.type === domelementtype_1$1.ElementType.Directive;
}
node$3.isDirective = isDirective;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDocument(node) {
    return node.type === domelementtype_1$1.ElementType.Root;
}
node$3.isDocument = isDocument;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `NodeWithChildren` (has children), `false` otherwise.
 */
function hasChildren(node) {
    return Object.prototype.hasOwnProperty.call(node, "children");
}
node$3.hasChildren = hasChildren;
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */
function cloneNode(node, recursive) {
    if (recursive === void 0) { recursive = false; }
    var result;
    if (isText(node)) {
        result = new Text(node.data);
    }
    else if (isComment(node)) {
        result = new Comment(node.data);
    }
    else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element$1(node.name, __assign$2({}, node.attribs), children);
        children.forEach(function (child) { return (child.parent = clone_1); });
        if (node.namespace != null) {
            clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
            clone_1["x-attribsNamespace"] = __assign$2({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
            clone_1["x-attribsPrefix"] = __assign$2({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
    }
    else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new NodeWithChildren(domelementtype_1$1.ElementType.CDATA, children);
        children.forEach(function (child) { return (child.parent = clone_2); });
        result = clone_2;
    }
    else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function (child) { return (child.parent = clone_3); });
        if (node["x-mode"]) {
            clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
    }
    else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
            instruction["x-name"] = node["x-name"];
            instruction["x-publicId"] = node["x-publicId"];
            instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
    }
    else {
        throw new Error("Not implemented yet: ".concat(node.type));
    }
    result.startIndex = node.startIndex;
    result.endIndex = node.endIndex;
    if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
    }
    return result;
}
node$3.cloneNode = cloneNode;
function cloneChildren(childs) {
    var children = childs.map(function (child) { return cloneNode(child, true); });
    for (var i = 1; i < children.length; i++) {
        children[i].prev = children[i - 1];
        children[i - 1].next = children[i];
    }
    return children;
}

(function (exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DomHandler = void 0;
var domelementtype_1 = lib$6;
var node_1 = node$3;
__exportStar(node$3, exports);
var reWhitespace = /\s+/g;
// Default options
var defaultOpts = {
    normalizeWhitespace: false,
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false,
};
var DomHandler = /** @class */ (function () {
    /**
     * @param callback Called once parsing has completed.
     * @param options Settings for the handler.
     * @param elementCB Callback whenever a tag is closed.
     */
    function DomHandler(callback, options, elementCB) {
        /** The elements of the DOM */
        this.dom = [];
        /** The root element for the DOM */
        this.root = new node_1.Document(this.dom);
        /** Indicated whether parsing has been completed. */
        this.done = false;
        /** Stack of open tags. */
        this.tagStack = [this.root];
        /** A data node that is still being written to. */
        this.lastNode = null;
        /** Reference to the parser instance. Used for location information. */
        this.parser = null;
        // Make it possible to skip arguments, for backwards-compatibility
        if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
        }
        if (typeof callback === "object") {
            options = callback;
            callback = undefined;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options !== null && options !== void 0 ? options : defaultOpts;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
    }
    DomHandler.prototype.onparserinit = function (parser) {
        this.parser = parser;
    };
    // Resets the handler back to starting state
    DomHandler.prototype.onreset = function () {
        this.dom = [];
        this.root = new node_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
    };
    // Signals the handler that parsing is done
    DomHandler.prototype.onend = function () {
        if (this.done)
            return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
    };
    DomHandler.prototype.onerror = function (error) {
        this.handleCallback(error);
    };
    DomHandler.prototype.onclosetag = function () {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
            this.elementCB(elem);
    };
    DomHandler.prototype.onopentag = function (name, attribs) {
        var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
        var element = new node_1.Element(name, attribs, undefined, type);
        this.addNode(element);
        this.tagStack.push(element);
    };
    DomHandler.prototype.ontext = function (data) {
        var normalizeWhitespace = this.options.normalizeWhitespace;
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            if (normalizeWhitespace) {
                lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
            }
            else {
                lastNode.data += data;
            }
            if (this.options.withEndIndices) {
                lastNode.endIndex = this.parser.endIndex;
            }
        }
        else {
            if (normalizeWhitespace) {
                data = data.replace(reWhitespace, " ");
            }
            var node = new node_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
        }
    };
    DomHandler.prototype.oncomment = function (data) {
        if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
        }
        var node = new node_1.Comment(data);
        this.addNode(node);
        this.lastNode = node;
    };
    DomHandler.prototype.oncommentend = function () {
        this.lastNode = null;
    };
    DomHandler.prototype.oncdatastart = function () {
        var text = new node_1.Text("");
        var node = new node_1.NodeWithChildren(domelementtype_1.ElementType.CDATA, [text]);
        this.addNode(node);
        text.parent = node;
        this.lastNode = text;
    };
    DomHandler.prototype.oncdataend = function () {
        this.lastNode = null;
    };
    DomHandler.prototype.onprocessinginstruction = function (name, data) {
        var node = new node_1.ProcessingInstruction(name, data);
        this.addNode(node);
    };
    DomHandler.prototype.handleCallback = function (error) {
        if (typeof this.callback === "function") {
            this.callback(error, this.dom);
        }
        else if (error) {
            throw error;
        }
    };
    DomHandler.prototype.addNode = function (node) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
        }
        parent.children.push(node);
        if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
        }
        node.parent = parent;
        this.lastNode = null;
    };
    return DomHandler;
}());
exports.DomHandler = DomHandler;
exports.default = DomHandler;
}(lib$7));

var lib$5 = {};

var lib$4 = {};

var decode = {};

var Aacute$1 = "Á";
var aacute$1 = "á";
var Abreve = "Ă";
var abreve = "ă";
var ac = "∾";
var acd = "∿";
var acE = "∾̳";
var Acirc$1 = "Â";
var acirc$1 = "â";
var acute$1 = "´";
var Acy = "А";
var acy = "а";
var AElig$1 = "Æ";
var aelig$1 = "æ";
var af = "⁡";
var Afr = "𝔄";
var afr = "𝔞";
var Agrave$1 = "À";
var agrave$1 = "à";
var alefsym = "ℵ";
var aleph = "ℵ";
var Alpha = "Α";
var alpha = "α";
var Amacr = "Ā";
var amacr = "ā";
var amalg = "⨿";
var amp$2 = "&";
var AMP$1 = "&";
var andand = "⩕";
var And = "⩓";
var and = "∧";
var andd = "⩜";
var andslope = "⩘";
var andv = "⩚";
var ang = "∠";
var ange = "⦤";
var angle = "∠";
var angmsdaa = "⦨";
var angmsdab = "⦩";
var angmsdac = "⦪";
var angmsdad = "⦫";
var angmsdae = "⦬";
var angmsdaf = "⦭";
var angmsdag = "⦮";
var angmsdah = "⦯";
var angmsd = "∡";
var angrt = "∟";
var angrtvb = "⊾";
var angrtvbd = "⦝";
var angsph = "∢";
var angst = "Å";
var angzarr = "⍼";
var Aogon = "Ą";
var aogon = "ą";
var Aopf = "𝔸";
var aopf = "𝕒";
var apacir = "⩯";
var ap = "≈";
var apE = "⩰";
var ape = "≊";
var apid = "≋";
var apos$1 = "'";
var ApplyFunction = "⁡";
var approx = "≈";
var approxeq = "≊";
var Aring$1 = "Å";
var aring$1 = "å";
var Ascr = "𝒜";
var ascr = "𝒶";
var Assign = "≔";
var ast = "*";
var asymp = "≈";
var asympeq = "≍";
var Atilde$1 = "Ã";
var atilde$1 = "ã";
var Auml$1 = "Ä";
var auml$1 = "ä";
var awconint = "∳";
var awint = "⨑";
var backcong = "≌";
var backepsilon = "϶";
var backprime = "‵";
var backsim = "∽";
var backsimeq = "⋍";
var Backslash = "∖";
var Barv = "⫧";
var barvee = "⊽";
var barwed = "⌅";
var Barwed = "⌆";
var barwedge = "⌅";
var bbrk = "⎵";
var bbrktbrk = "⎶";
var bcong = "≌";
var Bcy = "Б";
var bcy = "б";
var bdquo = "„";
var becaus = "∵";
var because = "∵";
var Because = "∵";
var bemptyv = "⦰";
var bepsi = "϶";
var bernou = "ℬ";
var Bernoullis = "ℬ";
var Beta = "Β";
var beta = "β";
var beth = "ℶ";
var between = "≬";
var Bfr = "𝔅";
var bfr = "𝔟";
var bigcap = "⋂";
var bigcirc = "◯";
var bigcup = "⋃";
var bigodot = "⨀";
var bigoplus = "⨁";
var bigotimes = "⨂";
var bigsqcup = "⨆";
var bigstar = "★";
var bigtriangledown = "▽";
var bigtriangleup = "△";
var biguplus = "⨄";
var bigvee = "⋁";
var bigwedge = "⋀";
var bkarow = "⤍";
var blacklozenge = "⧫";
var blacksquare = "▪";
var blacktriangle = "▴";
var blacktriangledown = "▾";
var blacktriangleleft = "◂";
var blacktriangleright = "▸";
var blank = "␣";
var blk12 = "▒";
var blk14 = "░";
var blk34 = "▓";
var block = "█";
var bne = "=⃥";
var bnequiv = "≡⃥";
var bNot = "⫭";
var bnot = "⌐";
var Bopf = "𝔹";
var bopf = "𝕓";
var bot = "⊥";
var bottom = "⊥";
var bowtie = "⋈";
var boxbox = "⧉";
var boxdl = "┐";
var boxdL = "╕";
var boxDl = "╖";
var boxDL = "╗";
var boxdr = "┌";
var boxdR = "╒";
var boxDr = "╓";
var boxDR = "╔";
var boxh = "─";
var boxH = "═";
var boxhd = "┬";
var boxHd = "╤";
var boxhD = "╥";
var boxHD = "╦";
var boxhu = "┴";
var boxHu = "╧";
var boxhU = "╨";
var boxHU = "╩";
var boxminus = "⊟";
var boxplus = "⊞";
var boxtimes = "⊠";
var boxul = "┘";
var boxuL = "╛";
var boxUl = "╜";
var boxUL = "╝";
var boxur = "└";
var boxuR = "╘";
var boxUr = "╙";
var boxUR = "╚";
var boxv = "│";
var boxV = "║";
var boxvh = "┼";
var boxvH = "╪";
var boxVh = "╫";
var boxVH = "╬";
var boxvl = "┤";
var boxvL = "╡";
var boxVl = "╢";
var boxVL = "╣";
var boxvr = "├";
var boxvR = "╞";
var boxVr = "╟";
var boxVR = "╠";
var bprime = "‵";
var breve = "˘";
var Breve = "˘";
var brvbar$1 = "¦";
var bscr = "𝒷";
var Bscr = "ℬ";
var bsemi = "⁏";
var bsim = "∽";
var bsime = "⋍";
var bsolb = "⧅";
var bsol = "\\";
var bsolhsub = "⟈";
var bull = "•";
var bullet = "•";
var bump = "≎";
var bumpE = "⪮";
var bumpe = "≏";
var Bumpeq = "≎";
var bumpeq = "≏";
var Cacute = "Ć";
var cacute = "ć";
var capand = "⩄";
var capbrcup = "⩉";
var capcap = "⩋";
var cap = "∩";
var Cap = "⋒";
var capcup = "⩇";
var capdot = "⩀";
var CapitalDifferentialD = "ⅅ";
var caps = "∩︀";
var caret = "⁁";
var caron = "ˇ";
var Cayleys = "ℭ";
var ccaps = "⩍";
var Ccaron = "Č";
var ccaron = "č";
var Ccedil$1 = "Ç";
var ccedil$1 = "ç";
var Ccirc = "Ĉ";
var ccirc = "ĉ";
var Cconint = "∰";
var ccups = "⩌";
var ccupssm = "⩐";
var Cdot = "Ċ";
var cdot = "ċ";
var cedil$1 = "¸";
var Cedilla = "¸";
var cemptyv = "⦲";
var cent$1 = "¢";
var centerdot = "·";
var CenterDot = "·";
var cfr = "𝔠";
var Cfr = "ℭ";
var CHcy = "Ч";
var chcy = "ч";
var check = "✓";
var checkmark = "✓";
var Chi = "Χ";
var chi = "χ";
var circ = "ˆ";
var circeq = "≗";
var circlearrowleft = "↺";
var circlearrowright = "↻";
var circledast = "⊛";
var circledcirc = "⊚";
var circleddash = "⊝";
var CircleDot = "⊙";
var circledR = "®";
var circledS = "Ⓢ";
var CircleMinus = "⊖";
var CirclePlus = "⊕";
var CircleTimes = "⊗";
var cir = "○";
var cirE = "⧃";
var cire = "≗";
var cirfnint = "⨐";
var cirmid = "⫯";
var cirscir = "⧂";
var ClockwiseContourIntegral = "∲";
var CloseCurlyDoubleQuote = "”";
var CloseCurlyQuote = "’";
var clubs = "♣";
var clubsuit = "♣";
var colon = ":";
var Colon = "∷";
var Colone = "⩴";
var colone = "≔";
var coloneq = "≔";
var comma = ",";
var commat = "@";
var comp = "∁";
var compfn = "∘";
var complement = "∁";
var complexes = "ℂ";
var cong = "≅";
var congdot = "⩭";
var Congruent = "≡";
var conint = "∮";
var Conint = "∯";
var ContourIntegral = "∮";
var copf = "𝕔";
var Copf = "ℂ";
var coprod = "∐";
var Coproduct = "∐";
var copy$4 = "©";
var COPY$1 = "©";
var copysr = "℗";
var CounterClockwiseContourIntegral = "∳";
var crarr = "↵";
var cross = "✗";
var Cross = "⨯";
var Cscr = "𝒞";
var cscr = "𝒸";
var csub = "⫏";
var csube = "⫑";
var csup = "⫐";
var csupe = "⫒";
var ctdot = "⋯";
var cudarrl = "⤸";
var cudarrr = "⤵";
var cuepr = "⋞";
var cuesc = "⋟";
var cularr = "↶";
var cularrp = "⤽";
var cupbrcap = "⩈";
var cupcap = "⩆";
var CupCap = "≍";
var cup = "∪";
var Cup = "⋓";
var cupcup = "⩊";
var cupdot = "⊍";
var cupor = "⩅";
var cups = "∪︀";
var curarr = "↷";
var curarrm = "⤼";
var curlyeqprec = "⋞";
var curlyeqsucc = "⋟";
var curlyvee = "⋎";
var curlywedge = "⋏";
var curren$1 = "¤";
var curvearrowleft = "↶";
var curvearrowright = "↷";
var cuvee = "⋎";
var cuwed = "⋏";
var cwconint = "∲";
var cwint = "∱";
var cylcty = "⌭";
var dagger = "†";
var Dagger = "‡";
var daleth = "ℸ";
var darr = "↓";
var Darr = "↡";
var dArr = "⇓";
var dash = "‐";
var Dashv = "⫤";
var dashv = "⊣";
var dbkarow = "⤏";
var dblac = "˝";
var Dcaron = "Ď";
var dcaron = "ď";
var Dcy = "Д";
var dcy = "д";
var ddagger = "‡";
var ddarr = "⇊";
var DD = "ⅅ";
var dd = "ⅆ";
var DDotrahd = "⤑";
var ddotseq = "⩷";
var deg$1 = "°";
var Del = "∇";
var Delta = "Δ";
var delta = "δ";
var demptyv = "⦱";
var dfisht = "⥿";
var Dfr = "𝔇";
var dfr = "𝔡";
var dHar = "⥥";
var dharl = "⇃";
var dharr = "⇂";
var DiacriticalAcute = "´";
var DiacriticalDot = "˙";
var DiacriticalDoubleAcute = "˝";
var DiacriticalGrave = "`";
var DiacriticalTilde = "˜";
var diam = "⋄";
var diamond = "⋄";
var Diamond = "⋄";
var diamondsuit = "♦";
var diams = "♦";
var die = "¨";
var DifferentialD = "ⅆ";
var digamma = "ϝ";
var disin = "⋲";
var div = "÷";
var divide$1 = "÷";
var divideontimes = "⋇";
var divonx = "⋇";
var DJcy = "Ђ";
var djcy = "ђ";
var dlcorn = "⌞";
var dlcrop = "⌍";
var dollar = "$";
var Dopf = "𝔻";
var dopf = "𝕕";
var Dot = "¨";
var dot = "˙";
var DotDot = "⃜";
var doteq = "≐";
var doteqdot = "≑";
var DotEqual = "≐";
var dotminus = "∸";
var dotplus = "∔";
var dotsquare = "⊡";
var doublebarwedge = "⌆";
var DoubleContourIntegral = "∯";
var DoubleDot = "¨";
var DoubleDownArrow = "⇓";
var DoubleLeftArrow = "⇐";
var DoubleLeftRightArrow = "⇔";
var DoubleLeftTee = "⫤";
var DoubleLongLeftArrow = "⟸";
var DoubleLongLeftRightArrow = "⟺";
var DoubleLongRightArrow = "⟹";
var DoubleRightArrow = "⇒";
var DoubleRightTee = "⊨";
var DoubleUpArrow = "⇑";
var DoubleUpDownArrow = "⇕";
var DoubleVerticalBar = "∥";
var DownArrowBar = "⤓";
var downarrow = "↓";
var DownArrow = "↓";
var Downarrow = "⇓";
var DownArrowUpArrow = "⇵";
var DownBreve = "̑";
var downdownarrows = "⇊";
var downharpoonleft = "⇃";
var downharpoonright = "⇂";
var DownLeftRightVector = "⥐";
var DownLeftTeeVector = "⥞";
var DownLeftVectorBar = "⥖";
var DownLeftVector = "↽";
var DownRightTeeVector = "⥟";
var DownRightVectorBar = "⥗";
var DownRightVector = "⇁";
var DownTeeArrow = "↧";
var DownTee = "⊤";
var drbkarow = "⤐";
var drcorn = "⌟";
var drcrop = "⌌";
var Dscr = "𝒟";
var dscr = "𝒹";
var DScy = "Ѕ";
var dscy = "ѕ";
var dsol = "⧶";
var Dstrok = "Đ";
var dstrok = "đ";
var dtdot = "⋱";
var dtri = "▿";
var dtrif = "▾";
var duarr = "⇵";
var duhar = "⥯";
var dwangle = "⦦";
var DZcy = "Џ";
var dzcy = "џ";
var dzigrarr = "⟿";
var Eacute$1 = "É";
var eacute$1 = "é";
var easter = "⩮";
var Ecaron = "Ě";
var ecaron = "ě";
var Ecirc$1 = "Ê";
var ecirc$1 = "ê";
var ecir = "≖";
var ecolon = "≕";
var Ecy = "Э";
var ecy = "э";
var eDDot = "⩷";
var Edot = "Ė";
var edot = "ė";
var eDot = "≑";
var ee = "ⅇ";
var efDot = "≒";
var Efr = "𝔈";
var efr = "𝔢";
var eg = "⪚";
var Egrave$1 = "È";
var egrave$1 = "è";
var egs = "⪖";
var egsdot = "⪘";
var el = "⪙";
var Element = "∈";
var elinters = "⏧";
var ell = "ℓ";
var els = "⪕";
var elsdot = "⪗";
var Emacr = "Ē";
var emacr = "ē";
var empty$2 = "∅";
var emptyset = "∅";
var EmptySmallSquare = "◻";
var emptyv = "∅";
var EmptyVerySmallSquare = "▫";
var emsp13 = " ";
var emsp14 = " ";
var emsp = " ";
var ENG = "Ŋ";
var eng = "ŋ";
var ensp = " ";
var Eogon = "Ę";
var eogon = "ę";
var Eopf = "𝔼";
var eopf = "𝕖";
var epar = "⋕";
var eparsl = "⧣";
var eplus = "⩱";
var epsi = "ε";
var Epsilon = "Ε";
var epsilon = "ε";
var epsiv = "ϵ";
var eqcirc = "≖";
var eqcolon = "≕";
var eqsim = "≂";
var eqslantgtr = "⪖";
var eqslantless = "⪕";
var Equal = "⩵";
var equals = "=";
var EqualTilde = "≂";
var equest = "≟";
var Equilibrium = "⇌";
var equiv = "≡";
var equivDD = "⩸";
var eqvparsl = "⧥";
var erarr = "⥱";
var erDot = "≓";
var escr = "ℯ";
var Escr = "ℰ";
var esdot = "≐";
var Esim = "⩳";
var esim = "≂";
var Eta = "Η";
var eta = "η";
var ETH$1 = "Ð";
var eth$1 = "ð";
var Euml$1 = "Ë";
var euml$1 = "ë";
var euro = "€";
var excl = "!";
var exist = "∃";
var Exists = "∃";
var expectation = "ℰ";
var exponentiale = "ⅇ";
var ExponentialE = "ⅇ";
var fallingdotseq = "≒";
var Fcy = "Ф";
var fcy = "ф";
var female = "♀";
var ffilig = "ﬃ";
var fflig = "ﬀ";
var ffllig = "ﬄ";
var Ffr = "𝔉";
var ffr = "𝔣";
var filig = "ﬁ";
var FilledSmallSquare = "◼";
var FilledVerySmallSquare = "▪";
var fjlig = "fj";
var flat = "♭";
var fllig = "ﬂ";
var fltns = "▱";
var fnof = "ƒ";
var Fopf = "𝔽";
var fopf = "𝕗";
var forall = "∀";
var ForAll = "∀";
var fork = "⋔";
var forkv = "⫙";
var Fouriertrf = "ℱ";
var fpartint = "⨍";
var frac12$1 = "½";
var frac13 = "⅓";
var frac14$1 = "¼";
var frac15 = "⅕";
var frac16 = "⅙";
var frac18 = "⅛";
var frac23 = "⅔";
var frac25 = "⅖";
var frac34$1 = "¾";
var frac35 = "⅗";
var frac38 = "⅜";
var frac45 = "⅘";
var frac56 = "⅚";
var frac58 = "⅝";
var frac78 = "⅞";
var frasl = "⁄";
var frown = "⌢";
var fscr = "𝒻";
var Fscr = "ℱ";
var gacute = "ǵ";
var Gamma = "Γ";
var gamma = "γ";
var Gammad = "Ϝ";
var gammad = "ϝ";
var gap = "⪆";
var Gbreve = "Ğ";
var gbreve = "ğ";
var Gcedil = "Ģ";
var Gcirc = "Ĝ";
var gcirc = "ĝ";
var Gcy = "Г";
var gcy = "г";
var Gdot = "Ġ";
var gdot = "ġ";
var ge = "≥";
var gE = "≧";
var gEl = "⪌";
var gel = "⋛";
var geq = "≥";
var geqq = "≧";
var geqslant = "⩾";
var gescc = "⪩";
var ges = "⩾";
var gesdot = "⪀";
var gesdoto = "⪂";
var gesdotol = "⪄";
var gesl = "⋛︀";
var gesles = "⪔";
var Gfr = "𝔊";
var gfr = "𝔤";
var gg = "≫";
var Gg = "⋙";
var ggg = "⋙";
var gimel = "ℷ";
var GJcy = "Ѓ";
var gjcy = "ѓ";
var gla = "⪥";
var gl = "≷";
var glE = "⪒";
var glj = "⪤";
var gnap = "⪊";
var gnapprox = "⪊";
var gne = "⪈";
var gnE = "≩";
var gneq = "⪈";
var gneqq = "≩";
var gnsim = "⋧";
var Gopf = "𝔾";
var gopf = "𝕘";
var grave = "`";
var GreaterEqual = "≥";
var GreaterEqualLess = "⋛";
var GreaterFullEqual = "≧";
var GreaterGreater = "⪢";
var GreaterLess = "≷";
var GreaterSlantEqual = "⩾";
var GreaterTilde = "≳";
var Gscr = "𝒢";
var gscr = "ℊ";
var gsim = "≳";
var gsime = "⪎";
var gsiml = "⪐";
var gtcc = "⪧";
var gtcir = "⩺";
var gt$2 = ">";
var GT$1 = ">";
var Gt = "≫";
var gtdot = "⋗";
var gtlPar = "⦕";
var gtquest = "⩼";
var gtrapprox = "⪆";
var gtrarr = "⥸";
var gtrdot = "⋗";
var gtreqless = "⋛";
var gtreqqless = "⪌";
var gtrless = "≷";
var gtrsim = "≳";
var gvertneqq = "≩︀";
var gvnE = "≩︀";
var Hacek = "ˇ";
var hairsp = " ";
var half = "½";
var hamilt = "ℋ";
var HARDcy = "Ъ";
var hardcy = "ъ";
var harrcir = "⥈";
var harr = "↔";
var hArr = "⇔";
var harrw = "↭";
var Hat = "^";
var hbar = "ℏ";
var Hcirc = "Ĥ";
var hcirc = "ĥ";
var hearts = "♥";
var heartsuit = "♥";
var hellip = "…";
var hercon = "⊹";
var hfr = "𝔥";
var Hfr = "ℌ";
var HilbertSpace = "ℋ";
var hksearow = "⤥";
var hkswarow = "⤦";
var hoarr = "⇿";
var homtht = "∻";
var hookleftarrow = "↩";
var hookrightarrow = "↪";
var hopf = "𝕙";
var Hopf = "ℍ";
var horbar = "―";
var HorizontalLine = "─";
var hscr = "𝒽";
var Hscr = "ℋ";
var hslash = "ℏ";
var Hstrok = "Ħ";
var hstrok = "ħ";
var HumpDownHump = "≎";
var HumpEqual = "≏";
var hybull = "⁃";
var hyphen = "‐";
var Iacute$1 = "Í";
var iacute$1 = "í";
var ic = "⁣";
var Icirc$1 = "Î";
var icirc$1 = "î";
var Icy = "И";
var icy = "и";
var Idot = "İ";
var IEcy = "Е";
var iecy = "е";
var iexcl$1 = "¡";
var iff = "⇔";
var ifr = "𝔦";
var Ifr = "ℑ";
var Igrave$1 = "Ì";
var igrave$1 = "ì";
var ii = "ⅈ";
var iiiint = "⨌";
var iiint = "∭";
var iinfin = "⧜";
var iiota = "℩";
var IJlig = "Ĳ";
var ijlig = "ĳ";
var Imacr = "Ī";
var imacr = "ī";
var image = "ℑ";
var ImaginaryI = "ⅈ";
var imagline = "ℐ";
var imagpart = "ℑ";
var imath = "ı";
var Im = "ℑ";
var imof = "⊷";
var imped = "Ƶ";
var Implies = "⇒";
var incare = "℅";
var infin = "∞";
var infintie = "⧝";
var inodot = "ı";
var intcal = "⊺";
var int = "∫";
var Int = "∬";
var integers = "ℤ";
var Integral = "∫";
var intercal = "⊺";
var Intersection = "⋂";
var intlarhk = "⨗";
var intprod = "⨼";
var InvisibleComma = "⁣";
var InvisibleTimes = "⁢";
var IOcy = "Ё";
var iocy = "ё";
var Iogon = "Į";
var iogon = "į";
var Iopf = "𝕀";
var iopf = "𝕚";
var Iota = "Ι";
var iota = "ι";
var iprod = "⨼";
var iquest$1 = "¿";
var iscr = "𝒾";
var Iscr = "ℐ";
var isin = "∈";
var isindot = "⋵";
var isinE = "⋹";
var isins = "⋴";
var isinsv = "⋳";
var isinv = "∈";
var it = "⁢";
var Itilde = "Ĩ";
var itilde = "ĩ";
var Iukcy = "І";
var iukcy = "і";
var Iuml$1 = "Ï";
var iuml$1 = "ï";
var Jcirc = "Ĵ";
var jcirc = "ĵ";
var Jcy = "Й";
var jcy = "й";
var Jfr = "𝔍";
var jfr = "𝔧";
var jmath = "ȷ";
var Jopf = "𝕁";
var jopf = "𝕛";
var Jscr = "𝒥";
var jscr = "𝒿";
var Jsercy = "Ј";
var jsercy = "ј";
var Jukcy = "Є";
var jukcy = "є";
var Kappa = "Κ";
var kappa = "κ";
var kappav = "ϰ";
var Kcedil = "Ķ";
var kcedil = "ķ";
var Kcy = "К";
var kcy = "к";
var Kfr = "𝔎";
var kfr = "𝔨";
var kgreen = "ĸ";
var KHcy = "Х";
var khcy = "х";
var KJcy = "Ќ";
var kjcy = "ќ";
var Kopf = "𝕂";
var kopf = "𝕜";
var Kscr = "𝒦";
var kscr = "𝓀";
var lAarr = "⇚";
var Lacute = "Ĺ";
var lacute = "ĺ";
var laemptyv = "⦴";
var lagran = "ℒ";
var Lambda = "Λ";
var lambda = "λ";
var lang = "⟨";
var Lang = "⟪";
var langd = "⦑";
var langle = "⟨";
var lap = "⪅";
var Laplacetrf = "ℒ";
var laquo$1 = "«";
var larrb = "⇤";
var larrbfs = "⤟";
var larr = "←";
var Larr = "↞";
var lArr = "⇐";
var larrfs = "⤝";
var larrhk = "↩";
var larrlp = "↫";
var larrpl = "⤹";
var larrsim = "⥳";
var larrtl = "↢";
var latail = "⤙";
var lAtail = "⤛";
var lat = "⪫";
var late = "⪭";
var lates = "⪭︀";
var lbarr = "⤌";
var lBarr = "⤎";
var lbbrk = "❲";
var lbrace = "{";
var lbrack = "[";
var lbrke = "⦋";
var lbrksld = "⦏";
var lbrkslu = "⦍";
var Lcaron = "Ľ";
var lcaron = "ľ";
var Lcedil = "Ļ";
var lcedil = "ļ";
var lceil = "⌈";
var lcub = "{";
var Lcy = "Л";
var lcy = "л";
var ldca = "⤶";
var ldquo = "“";
var ldquor = "„";
var ldrdhar = "⥧";
var ldrushar = "⥋";
var ldsh = "↲";
var le = "≤";
var lE = "≦";
var LeftAngleBracket = "⟨";
var LeftArrowBar = "⇤";
var leftarrow = "←";
var LeftArrow = "←";
var Leftarrow = "⇐";
var LeftArrowRightArrow = "⇆";
var leftarrowtail = "↢";
var LeftCeiling = "⌈";
var LeftDoubleBracket = "⟦";
var LeftDownTeeVector = "⥡";
var LeftDownVectorBar = "⥙";
var LeftDownVector = "⇃";
var LeftFloor = "⌊";
var leftharpoondown = "↽";
var leftharpoonup = "↼";
var leftleftarrows = "⇇";
var leftrightarrow = "↔";
var LeftRightArrow = "↔";
var Leftrightarrow = "⇔";
var leftrightarrows = "⇆";
var leftrightharpoons = "⇋";
var leftrightsquigarrow = "↭";
var LeftRightVector = "⥎";
var LeftTeeArrow = "↤";
var LeftTee = "⊣";
var LeftTeeVector = "⥚";
var leftthreetimes = "⋋";
var LeftTriangleBar = "⧏";
var LeftTriangle = "⊲";
var LeftTriangleEqual = "⊴";
var LeftUpDownVector = "⥑";
var LeftUpTeeVector = "⥠";
var LeftUpVectorBar = "⥘";
var LeftUpVector = "↿";
var LeftVectorBar = "⥒";
var LeftVector = "↼";
var lEg = "⪋";
var leg = "⋚";
var leq = "≤";
var leqq = "≦";
var leqslant = "⩽";
var lescc = "⪨";
var les = "⩽";
var lesdot = "⩿";
var lesdoto = "⪁";
var lesdotor = "⪃";
var lesg = "⋚︀";
var lesges = "⪓";
var lessapprox = "⪅";
var lessdot = "⋖";
var lesseqgtr = "⋚";
var lesseqqgtr = "⪋";
var LessEqualGreater = "⋚";
var LessFullEqual = "≦";
var LessGreater = "≶";
var lessgtr = "≶";
var LessLess = "⪡";
var lesssim = "≲";
var LessSlantEqual = "⩽";
var LessTilde = "≲";
var lfisht = "⥼";
var lfloor = "⌊";
var Lfr = "𝔏";
var lfr = "𝔩";
var lg = "≶";
var lgE = "⪑";
var lHar = "⥢";
var lhard = "↽";
var lharu = "↼";
var lharul = "⥪";
var lhblk = "▄";
var LJcy = "Љ";
var ljcy = "љ";
var llarr = "⇇";
var ll = "≪";
var Ll = "⋘";
var llcorner = "⌞";
var Lleftarrow = "⇚";
var llhard = "⥫";
var lltri = "◺";
var Lmidot = "Ŀ";
var lmidot = "ŀ";
var lmoustache = "⎰";
var lmoust = "⎰";
var lnap = "⪉";
var lnapprox = "⪉";
var lne = "⪇";
var lnE = "≨";
var lneq = "⪇";
var lneqq = "≨";
var lnsim = "⋦";
var loang = "⟬";
var loarr = "⇽";
var lobrk = "⟦";
var longleftarrow = "⟵";
var LongLeftArrow = "⟵";
var Longleftarrow = "⟸";
var longleftrightarrow = "⟷";
var LongLeftRightArrow = "⟷";
var Longleftrightarrow = "⟺";
var longmapsto = "⟼";
var longrightarrow = "⟶";
var LongRightArrow = "⟶";
var Longrightarrow = "⟹";
var looparrowleft = "↫";
var looparrowright = "↬";
var lopar = "⦅";
var Lopf = "𝕃";
var lopf = "𝕝";
var loplus = "⨭";
var lotimes = "⨴";
var lowast = "∗";
var lowbar = "_";
var LowerLeftArrow = "↙";
var LowerRightArrow = "↘";
var loz = "◊";
var lozenge = "◊";
var lozf = "⧫";
var lpar = "(";
var lparlt = "⦓";
var lrarr = "⇆";
var lrcorner = "⌟";
var lrhar = "⇋";
var lrhard = "⥭";
var lrm = "‎";
var lrtri = "⊿";
var lsaquo = "‹";
var lscr = "𝓁";
var Lscr = "ℒ";
var lsh = "↰";
var Lsh = "↰";
var lsim = "≲";
var lsime = "⪍";
var lsimg = "⪏";
var lsqb = "[";
var lsquo = "‘";
var lsquor = "‚";
var Lstrok = "Ł";
var lstrok = "ł";
var ltcc = "⪦";
var ltcir = "⩹";
var lt$2 = "<";
var LT$1 = "<";
var Lt = "≪";
var ltdot = "⋖";
var lthree = "⋋";
var ltimes = "⋉";
var ltlarr = "⥶";
var ltquest = "⩻";
var ltri = "◃";
var ltrie = "⊴";
var ltrif = "◂";
var ltrPar = "⦖";
var lurdshar = "⥊";
var luruhar = "⥦";
var lvertneqq = "≨︀";
var lvnE = "≨︀";
var macr$1 = "¯";
var male = "♂";
var malt = "✠";
var maltese = "✠";
var map$1 = "↦";
var mapsto = "↦";
var mapstodown = "↧";
var mapstoleft = "↤";
var mapstoup = "↥";
var marker = "▮";
var mcomma = "⨩";
var Mcy = "М";
var mcy = "м";
var mdash = "—";
var mDDot = "∺";
var measuredangle = "∡";
var MediumSpace = " ";
var Mellintrf = "ℳ";
var Mfr = "𝔐";
var mfr = "𝔪";
var mho = "℧";
var micro$1 = "µ";
var midast = "*";
var midcir = "⫰";
var mid = "∣";
var middot$1 = "·";
var minusb = "⊟";
var minus = "−";
var minusd = "∸";
var minusdu = "⨪";
var MinusPlus = "∓";
var mlcp = "⫛";
var mldr = "…";
var mnplus = "∓";
var models = "⊧";
var Mopf = "𝕄";
var mopf = "𝕞";
var mp = "∓";
var mscr = "𝓂";
var Mscr = "ℳ";
var mstpos = "∾";
var Mu = "Μ";
var mu = "μ";
var multimap = "⊸";
var mumap = "⊸";
var nabla = "∇";
var Nacute = "Ń";
var nacute = "ń";
var nang = "∠⃒";
var nap = "≉";
var napE = "⩰̸";
var napid = "≋̸";
var napos = "ŉ";
var napprox = "≉";
var natural = "♮";
var naturals = "ℕ";
var natur = "♮";
var nbsp$1 = " ";
var nbump = "≎̸";
var nbumpe = "≏̸";
var ncap = "⩃";
var Ncaron = "Ň";
var ncaron = "ň";
var Ncedil = "Ņ";
var ncedil = "ņ";
var ncong = "≇";
var ncongdot = "⩭̸";
var ncup = "⩂";
var Ncy = "Н";
var ncy = "н";
var ndash = "–";
var nearhk = "⤤";
var nearr = "↗";
var neArr = "⇗";
var nearrow = "↗";
var ne = "≠";
var nedot = "≐̸";
var NegativeMediumSpace = "​";
var NegativeThickSpace = "​";
var NegativeThinSpace = "​";
var NegativeVeryThinSpace = "​";
var nequiv = "≢";
var nesear = "⤨";
var nesim = "≂̸";
var NestedGreaterGreater = "≫";
var NestedLessLess = "≪";
var NewLine = "\n";
var nexist = "∄";
var nexists = "∄";
var Nfr = "𝔑";
var nfr = "𝔫";
var ngE = "≧̸";
var nge = "≱";
var ngeq = "≱";
var ngeqq = "≧̸";
var ngeqslant = "⩾̸";
var nges = "⩾̸";
var nGg = "⋙̸";
var ngsim = "≵";
var nGt = "≫⃒";
var ngt = "≯";
var ngtr = "≯";
var nGtv = "≫̸";
var nharr = "↮";
var nhArr = "⇎";
var nhpar = "⫲";
var ni = "∋";
var nis = "⋼";
var nisd = "⋺";
var niv = "∋";
var NJcy = "Њ";
var njcy = "њ";
var nlarr = "↚";
var nlArr = "⇍";
var nldr = "‥";
var nlE = "≦̸";
var nle = "≰";
var nleftarrow = "↚";
var nLeftarrow = "⇍";
var nleftrightarrow = "↮";
var nLeftrightarrow = "⇎";
var nleq = "≰";
var nleqq = "≦̸";
var nleqslant = "⩽̸";
var nles = "⩽̸";
var nless = "≮";
var nLl = "⋘̸";
var nlsim = "≴";
var nLt = "≪⃒";
var nlt = "≮";
var nltri = "⋪";
var nltrie = "⋬";
var nLtv = "≪̸";
var nmid = "∤";
var NoBreak = "⁠";
var NonBreakingSpace = " ";
var nopf = "𝕟";
var Nopf = "ℕ";
var Not = "⫬";
var not$2 = "¬";
var NotCongruent = "≢";
var NotCupCap = "≭";
var NotDoubleVerticalBar = "∦";
var NotElement = "∉";
var NotEqual = "≠";
var NotEqualTilde = "≂̸";
var NotExists = "∄";
var NotGreater = "≯";
var NotGreaterEqual = "≱";
var NotGreaterFullEqual = "≧̸";
var NotGreaterGreater = "≫̸";
var NotGreaterLess = "≹";
var NotGreaterSlantEqual = "⩾̸";
var NotGreaterTilde = "≵";
var NotHumpDownHump = "≎̸";
var NotHumpEqual = "≏̸";
var notin = "∉";
var notindot = "⋵̸";
var notinE = "⋹̸";
var notinva = "∉";
var notinvb = "⋷";
var notinvc = "⋶";
var NotLeftTriangleBar = "⧏̸";
var NotLeftTriangle = "⋪";
var NotLeftTriangleEqual = "⋬";
var NotLess = "≮";
var NotLessEqual = "≰";
var NotLessGreater = "≸";
var NotLessLess = "≪̸";
var NotLessSlantEqual = "⩽̸";
var NotLessTilde = "≴";
var NotNestedGreaterGreater = "⪢̸";
var NotNestedLessLess = "⪡̸";
var notni = "∌";
var notniva = "∌";
var notnivb = "⋾";
var notnivc = "⋽";
var NotPrecedes = "⊀";
var NotPrecedesEqual = "⪯̸";
var NotPrecedesSlantEqual = "⋠";
var NotReverseElement = "∌";
var NotRightTriangleBar = "⧐̸";
var NotRightTriangle = "⋫";
var NotRightTriangleEqual = "⋭";
var NotSquareSubset = "⊏̸";
var NotSquareSubsetEqual = "⋢";
var NotSquareSuperset = "⊐̸";
var NotSquareSupersetEqual = "⋣";
var NotSubset = "⊂⃒";
var NotSubsetEqual = "⊈";
var NotSucceeds = "⊁";
var NotSucceedsEqual = "⪰̸";
var NotSucceedsSlantEqual = "⋡";
var NotSucceedsTilde = "≿̸";
var NotSuperset = "⊃⃒";
var NotSupersetEqual = "⊉";
var NotTilde = "≁";
var NotTildeEqual = "≄";
var NotTildeFullEqual = "≇";
var NotTildeTilde = "≉";
var NotVerticalBar = "∤";
var nparallel = "∦";
var npar = "∦";
var nparsl = "⫽⃥";
var npart = "∂̸";
var npolint = "⨔";
var npr = "⊀";
var nprcue = "⋠";
var nprec = "⊀";
var npreceq = "⪯̸";
var npre = "⪯̸";
var nrarrc = "⤳̸";
var nrarr = "↛";
var nrArr = "⇏";
var nrarrw = "↝̸";
var nrightarrow = "↛";
var nRightarrow = "⇏";
var nrtri = "⋫";
var nrtrie = "⋭";
var nsc = "⊁";
var nsccue = "⋡";
var nsce = "⪰̸";
var Nscr = "𝒩";
var nscr = "𝓃";
var nshortmid = "∤";
var nshortparallel = "∦";
var nsim = "≁";
var nsime = "≄";
var nsimeq = "≄";
var nsmid = "∤";
var nspar = "∦";
var nsqsube = "⋢";
var nsqsupe = "⋣";
var nsub = "⊄";
var nsubE = "⫅̸";
var nsube = "⊈";
var nsubset = "⊂⃒";
var nsubseteq = "⊈";
var nsubseteqq = "⫅̸";
var nsucc = "⊁";
var nsucceq = "⪰̸";
var nsup = "⊅";
var nsupE = "⫆̸";
var nsupe = "⊉";
var nsupset = "⊃⃒";
var nsupseteq = "⊉";
var nsupseteqq = "⫆̸";
var ntgl = "≹";
var Ntilde$1 = "Ñ";
var ntilde$1 = "ñ";
var ntlg = "≸";
var ntriangleleft = "⋪";
var ntrianglelefteq = "⋬";
var ntriangleright = "⋫";
var ntrianglerighteq = "⋭";
var Nu = "Ν";
var nu = "ν";
var num = "#";
var numero = "№";
var numsp = " ";
var nvap = "≍⃒";
var nvdash = "⊬";
var nvDash = "⊭";
var nVdash = "⊮";
var nVDash = "⊯";
var nvge = "≥⃒";
var nvgt = ">⃒";
var nvHarr = "⤄";
var nvinfin = "⧞";
var nvlArr = "⤂";
var nvle = "≤⃒";
var nvlt = "<⃒";
var nvltrie = "⊴⃒";
var nvrArr = "⤃";
var nvrtrie = "⊵⃒";
var nvsim = "∼⃒";
var nwarhk = "⤣";
var nwarr = "↖";
var nwArr = "⇖";
var nwarrow = "↖";
var nwnear = "⤧";
var Oacute$1 = "Ó";
var oacute$1 = "ó";
var oast = "⊛";
var Ocirc$1 = "Ô";
var ocirc$1 = "ô";
var ocir = "⊚";
var Ocy = "О";
var ocy = "о";
var odash = "⊝";
var Odblac = "Ő";
var odblac = "ő";
var odiv = "⨸";
var odot = "⊙";
var odsold = "⦼";
var OElig = "Œ";
var oelig = "œ";
var ofcir = "⦿";
var Ofr = "𝔒";
var ofr = "𝔬";
var ogon = "˛";
var Ograve$1 = "Ò";
var ograve$1 = "ò";
var ogt = "⧁";
var ohbar = "⦵";
var ohm = "Ω";
var oint = "∮";
var olarr = "↺";
var olcir = "⦾";
var olcross = "⦻";
var oline = "‾";
var olt = "⧀";
var Omacr = "Ō";
var omacr = "ō";
var Omega = "Ω";
var omega = "ω";
var Omicron = "Ο";
var omicron = "ο";
var omid = "⦶";
var ominus = "⊖";
var Oopf = "𝕆";
var oopf = "𝕠";
var opar = "⦷";
var OpenCurlyDoubleQuote = "“";
var OpenCurlyQuote = "‘";
var operp = "⦹";
var oplus = "⊕";
var orarr = "↻";
var Or = "⩔";
var or = "∨";
var ord = "⩝";
var order = "ℴ";
var orderof = "ℴ";
var ordf$1 = "ª";
var ordm$1 = "º";
var origof = "⊶";
var oror = "⩖";
var orslope = "⩗";
var orv = "⩛";
var oS = "Ⓢ";
var Oscr = "𝒪";
var oscr = "ℴ";
var Oslash$1 = "Ø";
var oslash$1 = "ø";
var osol = "⊘";
var Otilde$1 = "Õ";
var otilde$1 = "õ";
var otimesas = "⨶";
var Otimes = "⨷";
var otimes = "⊗";
var Ouml$1 = "Ö";
var ouml$1 = "ö";
var ovbar = "⌽";
var OverBar = "‾";
var OverBrace = "⏞";
var OverBracket = "⎴";
var OverParenthesis = "⏜";
var para$1 = "¶";
var parallel = "∥";
var par = "∥";
var parsim = "⫳";
var parsl = "⫽";
var part = "∂";
var PartialD = "∂";
var Pcy = "П";
var pcy = "п";
var percnt = "%";
var period = ".";
var permil = "‰";
var perp = "⊥";
var pertenk = "‱";
var Pfr = "𝔓";
var pfr = "𝔭";
var Phi = "Φ";
var phi = "φ";
var phiv = "ϕ";
var phmmat = "ℳ";
var phone = "☎";
var Pi = "Π";
var pi = "π";
var pitchfork = "⋔";
var piv = "ϖ";
var planck = "ℏ";
var planckh = "ℎ";
var plankv = "ℏ";
var plusacir = "⨣";
var plusb = "⊞";
var pluscir = "⨢";
var plus = "+";
var plusdo = "∔";
var plusdu = "⨥";
var pluse = "⩲";
var PlusMinus = "±";
var plusmn$1 = "±";
var plussim = "⨦";
var plustwo = "⨧";
var pm = "±";
var Poincareplane = "ℌ";
var pointint = "⨕";
var popf = "𝕡";
var Popf = "ℙ";
var pound$1 = "£";
var prap = "⪷";
var Pr = "⪻";
var pr = "≺";
var prcue = "≼";
var precapprox = "⪷";
var prec = "≺";
var preccurlyeq = "≼";
var Precedes = "≺";
var PrecedesEqual = "⪯";
var PrecedesSlantEqual = "≼";
var PrecedesTilde = "≾";
var preceq = "⪯";
var precnapprox = "⪹";
var precneqq = "⪵";
var precnsim = "⋨";
var pre = "⪯";
var prE = "⪳";
var precsim = "≾";
var prime = "′";
var Prime = "″";
var primes = "ℙ";
var prnap = "⪹";
var prnE = "⪵";
var prnsim = "⋨";
var prod = "∏";
var Product = "∏";
var profalar = "⌮";
var profline = "⌒";
var profsurf = "⌓";
var prop$1 = "∝";
var Proportional = "∝";
var Proportion = "∷";
var propto = "∝";
var prsim = "≾";
var prurel = "⊰";
var Pscr = "𝒫";
var pscr = "𝓅";
var Psi = "Ψ";
var psi = "ψ";
var puncsp = " ";
var Qfr = "𝔔";
var qfr = "𝔮";
var qint = "⨌";
var qopf = "𝕢";
var Qopf = "ℚ";
var qprime = "⁗";
var Qscr = "𝒬";
var qscr = "𝓆";
var quaternions = "ℍ";
var quatint = "⨖";
var quest = "?";
var questeq = "≟";
var quot$2 = "\"";
var QUOT$1 = "\"";
var rAarr = "⇛";
var race = "∽̱";
var Racute = "Ŕ";
var racute = "ŕ";
var radic = "√";
var raemptyv = "⦳";
var rang = "⟩";
var Rang = "⟫";
var rangd = "⦒";
var range = "⦥";
var rangle = "⟩";
var raquo$1 = "»";
var rarrap = "⥵";
var rarrb = "⇥";
var rarrbfs = "⤠";
var rarrc = "⤳";
var rarr = "→";
var Rarr = "↠";
var rArr = "⇒";
var rarrfs = "⤞";
var rarrhk = "↪";
var rarrlp = "↬";
var rarrpl = "⥅";
var rarrsim = "⥴";
var Rarrtl = "⤖";
var rarrtl = "↣";
var rarrw = "↝";
var ratail = "⤚";
var rAtail = "⤜";
var ratio = "∶";
var rationals = "ℚ";
var rbarr = "⤍";
var rBarr = "⤏";
var RBarr = "⤐";
var rbbrk = "❳";
var rbrace$1 = "}";
var rbrack = "]";
var rbrke = "⦌";
var rbrksld = "⦎";
var rbrkslu = "⦐";
var Rcaron = "Ř";
var rcaron = "ř";
var Rcedil = "Ŗ";
var rcedil = "ŗ";
var rceil = "⌉";
var rcub = "}";
var Rcy = "Р";
var rcy = "р";
var rdca = "⤷";
var rdldhar = "⥩";
var rdquo = "”";
var rdquor = "”";
var rdsh = "↳";
var real = "ℜ";
var realine = "ℛ";
var realpart = "ℜ";
var reals = "ℝ";
var Re = "ℜ";
var rect = "▭";
var reg$1 = "®";
var REG$1 = "®";
var ReverseElement = "∋";
var ReverseEquilibrium = "⇋";
var ReverseUpEquilibrium = "⥯";
var rfisht = "⥽";
var rfloor = "⌋";
var rfr = "𝔯";
var Rfr = "ℜ";
var rHar = "⥤";
var rhard = "⇁";
var rharu = "⇀";
var rharul = "⥬";
var Rho = "Ρ";
var rho = "ρ";
var rhov = "ϱ";
var RightAngleBracket = "⟩";
var RightArrowBar = "⇥";
var rightarrow = "→";
var RightArrow = "→";
var Rightarrow = "⇒";
var RightArrowLeftArrow = "⇄";
var rightarrowtail = "↣";
var RightCeiling = "⌉";
var RightDoubleBracket = "⟧";
var RightDownTeeVector = "⥝";
var RightDownVectorBar = "⥕";
var RightDownVector = "⇂";
var RightFloor = "⌋";
var rightharpoondown = "⇁";
var rightharpoonup = "⇀";
var rightleftarrows = "⇄";
var rightleftharpoons = "⇌";
var rightrightarrows = "⇉";
var rightsquigarrow = "↝";
var RightTeeArrow = "↦";
var RightTee = "⊢";
var RightTeeVector = "⥛";
var rightthreetimes = "⋌";
var RightTriangleBar = "⧐";
var RightTriangle = "⊳";
var RightTriangleEqual = "⊵";
var RightUpDownVector = "⥏";
var RightUpTeeVector = "⥜";
var RightUpVectorBar = "⥔";
var RightUpVector = "↾";
var RightVectorBar = "⥓";
var RightVector = "⇀";
var ring = "˚";
var risingdotseq = "≓";
var rlarr = "⇄";
var rlhar = "⇌";
var rlm = "‏";
var rmoustache = "⎱";
var rmoust = "⎱";
var rnmid = "⫮";
var roang = "⟭";
var roarr = "⇾";
var robrk = "⟧";
var ropar = "⦆";
var ropf = "𝕣";
var Ropf = "ℝ";
var roplus = "⨮";
var rotimes = "⨵";
var RoundImplies = "⥰";
var rpar = ")";
var rpargt = "⦔";
var rppolint = "⨒";
var rrarr = "⇉";
var Rrightarrow = "⇛";
var rsaquo = "›";
var rscr = "𝓇";
var Rscr = "ℛ";
var rsh = "↱";
var Rsh = "↱";
var rsqb = "]";
var rsquo = "’";
var rsquor = "’";
var rthree = "⋌";
var rtimes = "⋊";
var rtri = "▹";
var rtrie = "⊵";
var rtrif = "▸";
var rtriltri = "⧎";
var RuleDelayed = "⧴";
var ruluhar = "⥨";
var rx = "℞";
var Sacute = "Ś";
var sacute = "ś";
var sbquo = "‚";
var scap = "⪸";
var Scaron = "Š";
var scaron = "š";
var Sc = "⪼";
var sc = "≻";
var sccue = "≽";
var sce = "⪰";
var scE = "⪴";
var Scedil = "Ş";
var scedil = "ş";
var Scirc = "Ŝ";
var scirc = "ŝ";
var scnap = "⪺";
var scnE = "⪶";
var scnsim = "⋩";
var scpolint = "⨓";
var scsim = "≿";
var Scy = "С";
var scy = "с";
var sdotb = "⊡";
var sdot = "⋅";
var sdote = "⩦";
var searhk = "⤥";
var searr = "↘";
var seArr = "⇘";
var searrow = "↘";
var sect$1 = "§";
var semi = ";";
var seswar = "⤩";
var setminus = "∖";
var setmn = "∖";
var sext = "✶";
var Sfr = "𝔖";
var sfr = "𝔰";
var sfrown = "⌢";
var sharp = "♯";
var SHCHcy = "Щ";
var shchcy = "щ";
var SHcy = "Ш";
var shcy = "ш";
var ShortDownArrow = "↓";
var ShortLeftArrow = "←";
var shortmid = "∣";
var shortparallel = "∥";
var ShortRightArrow = "→";
var ShortUpArrow = "↑";
var shy$1 = "­";
var Sigma = "Σ";
var sigma = "σ";
var sigmaf = "ς";
var sigmav = "ς";
var sim = "∼";
var simdot = "⩪";
var sime = "≃";
var simeq = "≃";
var simg = "⪞";
var simgE = "⪠";
var siml = "⪝";
var simlE = "⪟";
var simne = "≆";
var simplus = "⨤";
var simrarr = "⥲";
var slarr = "←";
var SmallCircle = "∘";
var smallsetminus = "∖";
var smashp = "⨳";
var smeparsl = "⧤";
var smid = "∣";
var smile = "⌣";
var smt = "⪪";
var smte = "⪬";
var smtes = "⪬︀";
var SOFTcy = "Ь";
var softcy = "ь";
var solbar = "⌿";
var solb = "⧄";
var sol = "/";
var Sopf = "𝕊";
var sopf = "𝕤";
var spades = "♠";
var spadesuit = "♠";
var spar = "∥";
var sqcap = "⊓";
var sqcaps = "⊓︀";
var sqcup = "⊔";
var sqcups = "⊔︀";
var Sqrt = "√";
var sqsub = "⊏";
var sqsube = "⊑";
var sqsubset = "⊏";
var sqsubseteq = "⊑";
var sqsup = "⊐";
var sqsupe = "⊒";
var sqsupset = "⊐";
var sqsupseteq = "⊒";
var square = "□";
var Square = "□";
var SquareIntersection = "⊓";
var SquareSubset = "⊏";
var SquareSubsetEqual = "⊑";
var SquareSuperset = "⊐";
var SquareSupersetEqual = "⊒";
var SquareUnion = "⊔";
var squarf = "▪";
var squ = "□";
var squf = "▪";
var srarr = "→";
var Sscr = "𝒮";
var sscr = "𝓈";
var ssetmn = "∖";
var ssmile = "⌣";
var sstarf = "⋆";
var Star = "⋆";
var star = "☆";
var starf = "★";
var straightepsilon = "ϵ";
var straightphi = "ϕ";
var strns = "¯";
var sub = "⊂";
var Sub = "⋐";
var subdot = "⪽";
var subE = "⫅";
var sube = "⊆";
var subedot = "⫃";
var submult = "⫁";
var subnE = "⫋";
var subne = "⊊";
var subplus = "⪿";
var subrarr = "⥹";
var subset = "⊂";
var Subset = "⋐";
var subseteq = "⊆";
var subseteqq = "⫅";
var SubsetEqual = "⊆";
var subsetneq = "⊊";
var subsetneqq = "⫋";
var subsim = "⫇";
var subsub = "⫕";
var subsup = "⫓";
var succapprox = "⪸";
var succ = "≻";
var succcurlyeq = "≽";
var Succeeds = "≻";
var SucceedsEqual = "⪰";
var SucceedsSlantEqual = "≽";
var SucceedsTilde = "≿";
var succeq = "⪰";
var succnapprox = "⪺";
var succneqq = "⪶";
var succnsim = "⋩";
var succsim = "≿";
var SuchThat = "∋";
var sum = "∑";
var Sum = "∑";
var sung = "♪";
var sup1$1 = "¹";
var sup2$1 = "²";
var sup3$1 = "³";
var sup = "⊃";
var Sup = "⋑";
var supdot = "⪾";
var supdsub = "⫘";
var supE = "⫆";
var supe = "⊇";
var supedot = "⫄";
var Superset = "⊃";
var SupersetEqual = "⊇";
var suphsol = "⟉";
var suphsub = "⫗";
var suplarr = "⥻";
var supmult = "⫂";
var supnE = "⫌";
var supne = "⊋";
var supplus = "⫀";
var supset = "⊃";
var Supset = "⋑";
var supseteq = "⊇";
var supseteqq = "⫆";
var supsetneq = "⊋";
var supsetneqq = "⫌";
var supsim = "⫈";
var supsub = "⫔";
var supsup = "⫖";
var swarhk = "⤦";
var swarr = "↙";
var swArr = "⇙";
var swarrow = "↙";
var swnwar = "⤪";
var szlig$1 = "ß";
var Tab = "\t";
var target = "⌖";
var Tau = "Τ";
var tau = "τ";
var tbrk = "⎴";
var Tcaron = "Ť";
var tcaron = "ť";
var Tcedil = "Ţ";
var tcedil = "ţ";
var Tcy = "Т";
var tcy = "т";
var tdot = "⃛";
var telrec = "⌕";
var Tfr = "𝔗";
var tfr = "𝔱";
var there4 = "∴";
var therefore = "∴";
var Therefore = "∴";
var Theta = "Θ";
var theta = "θ";
var thetasym = "ϑ";
var thetav = "ϑ";
var thickapprox = "≈";
var thicksim = "∼";
var ThickSpace = "  ";
var ThinSpace = " ";
var thinsp = " ";
var thkap = "≈";
var thksim = "∼";
var THORN$1 = "Þ";
var thorn$1 = "þ";
var tilde = "˜";
var Tilde = "∼";
var TildeEqual = "≃";
var TildeFullEqual = "≅";
var TildeTilde = "≈";
var timesbar = "⨱";
var timesb = "⊠";
var times$1 = "×";
var timesd = "⨰";
var tint = "∭";
var toea = "⤨";
var topbot = "⌶";
var topcir = "⫱";
var top = "⊤";
var Topf = "𝕋";
var topf = "𝕥";
var topfork = "⫚";
var tosa = "⤩";
var tprime = "‴";
var trade = "™";
var TRADE = "™";
var triangle = "▵";
var triangledown = "▿";
var triangleleft = "◃";
var trianglelefteq = "⊴";
var triangleq = "≜";
var triangleright = "▹";
var trianglerighteq = "⊵";
var tridot = "◬";
var trie = "≜";
var triminus = "⨺";
var TripleDot = "⃛";
var triplus = "⨹";
var trisb = "⧍";
var tritime = "⨻";
var trpezium = "⏢";
var Tscr = "𝒯";
var tscr = "𝓉";
var TScy = "Ц";
var tscy = "ц";
var TSHcy = "Ћ";
var tshcy = "ћ";
var Tstrok = "Ŧ";
var tstrok = "ŧ";
var twixt = "≬";
var twoheadleftarrow = "↞";
var twoheadrightarrow = "↠";
var Uacute$1 = "Ú";
var uacute$1 = "ú";
var uarr = "↑";
var Uarr = "↟";
var uArr = "⇑";
var Uarrocir = "⥉";
var Ubrcy = "Ў";
var ubrcy = "ў";
var Ubreve = "Ŭ";
var ubreve = "ŭ";
var Ucirc$1 = "Û";
var ucirc$1 = "û";
var Ucy = "У";
var ucy = "у";
var udarr = "⇅";
var Udblac = "Ű";
var udblac = "ű";
var udhar = "⥮";
var ufisht = "⥾";
var Ufr = "𝔘";
var ufr = "𝔲";
var Ugrave$1 = "Ù";
var ugrave$1 = "ù";
var uHar = "⥣";
var uharl = "↿";
var uharr = "↾";
var uhblk = "▀";
var ulcorn = "⌜";
var ulcorner = "⌜";
var ulcrop = "⌏";
var ultri = "◸";
var Umacr = "Ū";
var umacr = "ū";
var uml$1 = "¨";
var UnderBar = "_";
var UnderBrace = "⏟";
var UnderBracket = "⎵";
var UnderParenthesis = "⏝";
var Union = "⋃";
var UnionPlus = "⊎";
var Uogon = "Ų";
var uogon = "ų";
var Uopf = "𝕌";
var uopf = "𝕦";
var UpArrowBar = "⤒";
var uparrow = "↑";
var UpArrow = "↑";
var Uparrow = "⇑";
var UpArrowDownArrow = "⇅";
var updownarrow = "↕";
var UpDownArrow = "↕";
var Updownarrow = "⇕";
var UpEquilibrium = "⥮";
var upharpoonleft = "↿";
var upharpoonright = "↾";
var uplus = "⊎";
var UpperLeftArrow = "↖";
var UpperRightArrow = "↗";
var upsi = "υ";
var Upsi = "ϒ";
var upsih = "ϒ";
var Upsilon = "Υ";
var upsilon = "υ";
var UpTeeArrow = "↥";
var UpTee = "⊥";
var upuparrows = "⇈";
var urcorn = "⌝";
var urcorner = "⌝";
var urcrop = "⌎";
var Uring = "Ů";
var uring = "ů";
var urtri = "◹";
var Uscr = "𝒰";
var uscr = "𝓊";
var utdot = "⋰";
var Utilde = "Ũ";
var utilde = "ũ";
var utri = "▵";
var utrif = "▴";
var uuarr = "⇈";
var Uuml$1 = "Ü";
var uuml$1 = "ü";
var uwangle = "⦧";
var vangrt = "⦜";
var varepsilon = "ϵ";
var varkappa = "ϰ";
var varnothing = "∅";
var varphi = "ϕ";
var varpi = "ϖ";
var varpropto = "∝";
var varr = "↕";
var vArr = "⇕";
var varrho = "ϱ";
var varsigma = "ς";
var varsubsetneq = "⊊︀";
var varsubsetneqq = "⫋︀";
var varsupsetneq = "⊋︀";
var varsupsetneqq = "⫌︀";
var vartheta = "ϑ";
var vartriangleleft = "⊲";
var vartriangleright = "⊳";
var vBar = "⫨";
var Vbar = "⫫";
var vBarv = "⫩";
var Vcy = "В";
var vcy = "в";
var vdash = "⊢";
var vDash = "⊨";
var Vdash = "⊩";
var VDash = "⊫";
var Vdashl = "⫦";
var veebar = "⊻";
var vee = "∨";
var Vee = "⋁";
var veeeq = "≚";
var vellip = "⋮";
var verbar = "|";
var Verbar = "‖";
var vert = "|";
var Vert = "‖";
var VerticalBar = "∣";
var VerticalLine = "|";
var VerticalSeparator = "❘";
var VerticalTilde = "≀";
var VeryThinSpace = " ";
var Vfr = "𝔙";
var vfr = "𝔳";
var vltri = "⊲";
var vnsub = "⊂⃒";
var vnsup = "⊃⃒";
var Vopf = "𝕍";
var vopf = "𝕧";
var vprop = "∝";
var vrtri = "⊳";
var Vscr = "𝒱";
var vscr = "𝓋";
var vsubnE = "⫋︀";
var vsubne = "⊊︀";
var vsupnE = "⫌︀";
var vsupne = "⊋︀";
var Vvdash = "⊪";
var vzigzag = "⦚";
var Wcirc = "Ŵ";
var wcirc = "ŵ";
var wedbar = "⩟";
var wedge = "∧";
var Wedge = "⋀";
var wedgeq = "≙";
var weierp = "℘";
var Wfr = "𝔚";
var wfr = "𝔴";
var Wopf = "𝕎";
var wopf = "𝕨";
var wp = "℘";
var wr = "≀";
var wreath = "≀";
var Wscr = "𝒲";
var wscr = "𝓌";
var xcap = "⋂";
var xcirc = "◯";
var xcup = "⋃";
var xdtri = "▽";
var Xfr = "𝔛";
var xfr = "𝔵";
var xharr = "⟷";
var xhArr = "⟺";
var Xi = "Ξ";
var xi = "ξ";
var xlarr = "⟵";
var xlArr = "⟸";
var xmap = "⟼";
var xnis = "⋻";
var xodot = "⨀";
var Xopf = "𝕏";
var xopf = "𝕩";
var xoplus = "⨁";
var xotime = "⨂";
var xrarr = "⟶";
var xrArr = "⟹";
var Xscr = "𝒳";
var xscr = "𝓍";
var xsqcup = "⨆";
var xuplus = "⨄";
var xutri = "△";
var xvee = "⋁";
var xwedge = "⋀";
var Yacute$1 = "Ý";
var yacute$1 = "ý";
var YAcy = "Я";
var yacy = "я";
var Ycirc = "Ŷ";
var ycirc = "ŷ";
var Ycy = "Ы";
var ycy = "ы";
var yen$1 = "¥";
var Yfr = "𝔜";
var yfr = "𝔶";
var YIcy = "Ї";
var yicy = "ї";
var Yopf = "𝕐";
var yopf = "𝕪";
var Yscr = "𝒴";
var yscr = "𝓎";
var YUcy = "Ю";
var yucy = "ю";
var yuml$1 = "ÿ";
var Yuml = "Ÿ";
var Zacute = "Ź";
var zacute = "ź";
var Zcaron = "Ž";
var zcaron = "ž";
var Zcy = "З";
var zcy = "з";
var Zdot = "Ż";
var zdot = "ż";
var zeetrf = "ℨ";
var ZeroWidthSpace = "​";
var Zeta = "Ζ";
var zeta = "ζ";
var zfr = "𝔷";
var Zfr = "ℨ";
var ZHcy = "Ж";
var zhcy = "ж";
var zigrarr = "⇝";
var zopf = "𝕫";
var Zopf = "ℤ";
var Zscr = "𝒵";
var zscr = "𝓏";
var zwj = "‍";
var zwnj = "‌";
var require$$1 = {
	Aacute: Aacute$1,
	aacute: aacute$1,
	Abreve: Abreve,
	abreve: abreve,
	ac: ac,
	acd: acd,
	acE: acE,
	Acirc: Acirc$1,
	acirc: acirc$1,
	acute: acute$1,
	Acy: Acy,
	acy: acy,
	AElig: AElig$1,
	aelig: aelig$1,
	af: af,
	Afr: Afr,
	afr: afr,
	Agrave: Agrave$1,
	agrave: agrave$1,
	alefsym: alefsym,
	aleph: aleph,
	Alpha: Alpha,
	alpha: alpha,
	Amacr: Amacr,
	amacr: amacr,
	amalg: amalg,
	amp: amp$2,
	AMP: AMP$1,
	andand: andand,
	And: And,
	and: and,
	andd: andd,
	andslope: andslope,
	andv: andv,
	ang: ang,
	ange: ange,
	angle: angle,
	angmsdaa: angmsdaa,
	angmsdab: angmsdab,
	angmsdac: angmsdac,
	angmsdad: angmsdad,
	angmsdae: angmsdae,
	angmsdaf: angmsdaf,
	angmsdag: angmsdag,
	angmsdah: angmsdah,
	angmsd: angmsd,
	angrt: angrt,
	angrtvb: angrtvb,
	angrtvbd: angrtvbd,
	angsph: angsph,
	angst: angst,
	angzarr: angzarr,
	Aogon: Aogon,
	aogon: aogon,
	Aopf: Aopf,
	aopf: aopf,
	apacir: apacir,
	ap: ap,
	apE: apE,
	ape: ape,
	apid: apid,
	apos: apos$1,
	ApplyFunction: ApplyFunction,
	approx: approx,
	approxeq: approxeq,
	Aring: Aring$1,
	aring: aring$1,
	Ascr: Ascr,
	ascr: ascr,
	Assign: Assign,
	ast: ast,
	asymp: asymp,
	asympeq: asympeq,
	Atilde: Atilde$1,
	atilde: atilde$1,
	Auml: Auml$1,
	auml: auml$1,
	awconint: awconint,
	awint: awint,
	backcong: backcong,
	backepsilon: backepsilon,
	backprime: backprime,
	backsim: backsim,
	backsimeq: backsimeq,
	Backslash: Backslash,
	Barv: Barv,
	barvee: barvee,
	barwed: barwed,
	Barwed: Barwed,
	barwedge: barwedge,
	bbrk: bbrk,
	bbrktbrk: bbrktbrk,
	bcong: bcong,
	Bcy: Bcy,
	bcy: bcy,
	bdquo: bdquo,
	becaus: becaus,
	because: because,
	Because: Because,
	bemptyv: bemptyv,
	bepsi: bepsi,
	bernou: bernou,
	Bernoullis: Bernoullis,
	Beta: Beta,
	beta: beta,
	beth: beth,
	between: between,
	Bfr: Bfr,
	bfr: bfr,
	bigcap: bigcap,
	bigcirc: bigcirc,
	bigcup: bigcup,
	bigodot: bigodot,
	bigoplus: bigoplus,
	bigotimes: bigotimes,
	bigsqcup: bigsqcup,
	bigstar: bigstar,
	bigtriangledown: bigtriangledown,
	bigtriangleup: bigtriangleup,
	biguplus: biguplus,
	bigvee: bigvee,
	bigwedge: bigwedge,
	bkarow: bkarow,
	blacklozenge: blacklozenge,
	blacksquare: blacksquare,
	blacktriangle: blacktriangle,
	blacktriangledown: blacktriangledown,
	blacktriangleleft: blacktriangleleft,
	blacktriangleright: blacktriangleright,
	blank: blank,
	blk12: blk12,
	blk14: blk14,
	blk34: blk34,
	block: block,
	bne: bne,
	bnequiv: bnequiv,
	bNot: bNot,
	bnot: bnot,
	Bopf: Bopf,
	bopf: bopf,
	bot: bot,
	bottom: bottom,
	bowtie: bowtie,
	boxbox: boxbox,
	boxdl: boxdl,
	boxdL: boxdL,
	boxDl: boxDl,
	boxDL: boxDL,
	boxdr: boxdr,
	boxdR: boxdR,
	boxDr: boxDr,
	boxDR: boxDR,
	boxh: boxh,
	boxH: boxH,
	boxhd: boxhd,
	boxHd: boxHd,
	boxhD: boxhD,
	boxHD: boxHD,
	boxhu: boxhu,
	boxHu: boxHu,
	boxhU: boxhU,
	boxHU: boxHU,
	boxminus: boxminus,
	boxplus: boxplus,
	boxtimes: boxtimes,
	boxul: boxul,
	boxuL: boxuL,
	boxUl: boxUl,
	boxUL: boxUL,
	boxur: boxur,
	boxuR: boxuR,
	boxUr: boxUr,
	boxUR: boxUR,
	boxv: boxv,
	boxV: boxV,
	boxvh: boxvh,
	boxvH: boxvH,
	boxVh: boxVh,
	boxVH: boxVH,
	boxvl: boxvl,
	boxvL: boxvL,
	boxVl: boxVl,
	boxVL: boxVL,
	boxvr: boxvr,
	boxvR: boxvR,
	boxVr: boxVr,
	boxVR: boxVR,
	bprime: bprime,
	breve: breve,
	Breve: Breve,
	brvbar: brvbar$1,
	bscr: bscr,
	Bscr: Bscr,
	bsemi: bsemi,
	bsim: bsim,
	bsime: bsime,
	bsolb: bsolb,
	bsol: bsol,
	bsolhsub: bsolhsub,
	bull: bull,
	bullet: bullet,
	bump: bump,
	bumpE: bumpE,
	bumpe: bumpe,
	Bumpeq: Bumpeq,
	bumpeq: bumpeq,
	Cacute: Cacute,
	cacute: cacute,
	capand: capand,
	capbrcup: capbrcup,
	capcap: capcap,
	cap: cap,
	Cap: Cap,
	capcup: capcup,
	capdot: capdot,
	CapitalDifferentialD: CapitalDifferentialD,
	caps: caps,
	caret: caret,
	caron: caron,
	Cayleys: Cayleys,
	ccaps: ccaps,
	Ccaron: Ccaron,
	ccaron: ccaron,
	Ccedil: Ccedil$1,
	ccedil: ccedil$1,
	Ccirc: Ccirc,
	ccirc: ccirc,
	Cconint: Cconint,
	ccups: ccups,
	ccupssm: ccupssm,
	Cdot: Cdot,
	cdot: cdot,
	cedil: cedil$1,
	Cedilla: Cedilla,
	cemptyv: cemptyv,
	cent: cent$1,
	centerdot: centerdot,
	CenterDot: CenterDot,
	cfr: cfr,
	Cfr: Cfr,
	CHcy: CHcy,
	chcy: chcy,
	check: check,
	checkmark: checkmark,
	Chi: Chi,
	chi: chi,
	circ: circ,
	circeq: circeq,
	circlearrowleft: circlearrowleft,
	circlearrowright: circlearrowright,
	circledast: circledast,
	circledcirc: circledcirc,
	circleddash: circleddash,
	CircleDot: CircleDot,
	circledR: circledR,
	circledS: circledS,
	CircleMinus: CircleMinus,
	CirclePlus: CirclePlus,
	CircleTimes: CircleTimes,
	cir: cir,
	cirE: cirE,
	cire: cire,
	cirfnint: cirfnint,
	cirmid: cirmid,
	cirscir: cirscir,
	ClockwiseContourIntegral: ClockwiseContourIntegral,
	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
	CloseCurlyQuote: CloseCurlyQuote,
	clubs: clubs,
	clubsuit: clubsuit,
	colon: colon,
	Colon: Colon,
	Colone: Colone,
	colone: colone,
	coloneq: coloneq,
	comma: comma,
	commat: commat,
	comp: comp,
	compfn: compfn,
	complement: complement,
	complexes: complexes,
	cong: cong,
	congdot: congdot,
	Congruent: Congruent,
	conint: conint,
	Conint: Conint,
	ContourIntegral: ContourIntegral,
	copf: copf,
	Copf: Copf,
	coprod: coprod,
	Coproduct: Coproduct,
	copy: copy$4,
	COPY: COPY$1,
	copysr: copysr,
	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
	crarr: crarr,
	cross: cross,
	Cross: Cross,
	Cscr: Cscr,
	cscr: cscr,
	csub: csub,
	csube: csube,
	csup: csup,
	csupe: csupe,
	ctdot: ctdot,
	cudarrl: cudarrl,
	cudarrr: cudarrr,
	cuepr: cuepr,
	cuesc: cuesc,
	cularr: cularr,
	cularrp: cularrp,
	cupbrcap: cupbrcap,
	cupcap: cupcap,
	CupCap: CupCap,
	cup: cup,
	Cup: Cup,
	cupcup: cupcup,
	cupdot: cupdot,
	cupor: cupor,
	cups: cups,
	curarr: curarr,
	curarrm: curarrm,
	curlyeqprec: curlyeqprec,
	curlyeqsucc: curlyeqsucc,
	curlyvee: curlyvee,
	curlywedge: curlywedge,
	curren: curren$1,
	curvearrowleft: curvearrowleft,
	curvearrowright: curvearrowright,
	cuvee: cuvee,
	cuwed: cuwed,
	cwconint: cwconint,
	cwint: cwint,
	cylcty: cylcty,
	dagger: dagger,
	Dagger: Dagger,
	daleth: daleth,
	darr: darr,
	Darr: Darr,
	dArr: dArr,
	dash: dash,
	Dashv: Dashv,
	dashv: dashv,
	dbkarow: dbkarow,
	dblac: dblac,
	Dcaron: Dcaron,
	dcaron: dcaron,
	Dcy: Dcy,
	dcy: dcy,
	ddagger: ddagger,
	ddarr: ddarr,
	DD: DD,
	dd: dd,
	DDotrahd: DDotrahd,
	ddotseq: ddotseq,
	deg: deg$1,
	Del: Del,
	Delta: Delta,
	delta: delta,
	demptyv: demptyv,
	dfisht: dfisht,
	Dfr: Dfr,
	dfr: dfr,
	dHar: dHar,
	dharl: dharl,
	dharr: dharr,
	DiacriticalAcute: DiacriticalAcute,
	DiacriticalDot: DiacriticalDot,
	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
	DiacriticalGrave: DiacriticalGrave,
	DiacriticalTilde: DiacriticalTilde,
	diam: diam,
	diamond: diamond,
	Diamond: Diamond,
	diamondsuit: diamondsuit,
	diams: diams,
	die: die,
	DifferentialD: DifferentialD,
	digamma: digamma,
	disin: disin,
	div: div,
	divide: divide$1,
	divideontimes: divideontimes,
	divonx: divonx,
	DJcy: DJcy,
	djcy: djcy,
	dlcorn: dlcorn,
	dlcrop: dlcrop,
	dollar: dollar,
	Dopf: Dopf,
	dopf: dopf,
	Dot: Dot,
	dot: dot,
	DotDot: DotDot,
	doteq: doteq,
	doteqdot: doteqdot,
	DotEqual: DotEqual,
	dotminus: dotminus,
	dotplus: dotplus,
	dotsquare: dotsquare,
	doublebarwedge: doublebarwedge,
	DoubleContourIntegral: DoubleContourIntegral,
	DoubleDot: DoubleDot,
	DoubleDownArrow: DoubleDownArrow,
	DoubleLeftArrow: DoubleLeftArrow,
	DoubleLeftRightArrow: DoubleLeftRightArrow,
	DoubleLeftTee: DoubleLeftTee,
	DoubleLongLeftArrow: DoubleLongLeftArrow,
	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
	DoubleLongRightArrow: DoubleLongRightArrow,
	DoubleRightArrow: DoubleRightArrow,
	DoubleRightTee: DoubleRightTee,
	DoubleUpArrow: DoubleUpArrow,
	DoubleUpDownArrow: DoubleUpDownArrow,
	DoubleVerticalBar: DoubleVerticalBar,
	DownArrowBar: DownArrowBar,
	downarrow: downarrow,
	DownArrow: DownArrow,
	Downarrow: Downarrow,
	DownArrowUpArrow: DownArrowUpArrow,
	DownBreve: DownBreve,
	downdownarrows: downdownarrows,
	downharpoonleft: downharpoonleft,
	downharpoonright: downharpoonright,
	DownLeftRightVector: DownLeftRightVector,
	DownLeftTeeVector: DownLeftTeeVector,
	DownLeftVectorBar: DownLeftVectorBar,
	DownLeftVector: DownLeftVector,
	DownRightTeeVector: DownRightTeeVector,
	DownRightVectorBar: DownRightVectorBar,
	DownRightVector: DownRightVector,
	DownTeeArrow: DownTeeArrow,
	DownTee: DownTee,
	drbkarow: drbkarow,
	drcorn: drcorn,
	drcrop: drcrop,
	Dscr: Dscr,
	dscr: dscr,
	DScy: DScy,
	dscy: dscy,
	dsol: dsol,
	Dstrok: Dstrok,
	dstrok: dstrok,
	dtdot: dtdot,
	dtri: dtri,
	dtrif: dtrif,
	duarr: duarr,
	duhar: duhar,
	dwangle: dwangle,
	DZcy: DZcy,
	dzcy: dzcy,
	dzigrarr: dzigrarr,
	Eacute: Eacute$1,
	eacute: eacute$1,
	easter: easter,
	Ecaron: Ecaron,
	ecaron: ecaron,
	Ecirc: Ecirc$1,
	ecirc: ecirc$1,
	ecir: ecir,
	ecolon: ecolon,
	Ecy: Ecy,
	ecy: ecy,
	eDDot: eDDot,
	Edot: Edot,
	edot: edot,
	eDot: eDot,
	ee: ee,
	efDot: efDot,
	Efr: Efr,
	efr: efr,
	eg: eg,
	Egrave: Egrave$1,
	egrave: egrave$1,
	egs: egs,
	egsdot: egsdot,
	el: el,
	Element: Element,
	elinters: elinters,
	ell: ell,
	els: els,
	elsdot: elsdot,
	Emacr: Emacr,
	emacr: emacr,
	empty: empty$2,
	emptyset: emptyset,
	EmptySmallSquare: EmptySmallSquare,
	emptyv: emptyv,
	EmptyVerySmallSquare: EmptyVerySmallSquare,
	emsp13: emsp13,
	emsp14: emsp14,
	emsp: emsp,
	ENG: ENG,
	eng: eng,
	ensp: ensp,
	Eogon: Eogon,
	eogon: eogon,
	Eopf: Eopf,
	eopf: eopf,
	epar: epar,
	eparsl: eparsl,
	eplus: eplus,
	epsi: epsi,
	Epsilon: Epsilon,
	epsilon: epsilon,
	epsiv: epsiv,
	eqcirc: eqcirc,
	eqcolon: eqcolon,
	eqsim: eqsim,
	eqslantgtr: eqslantgtr,
	eqslantless: eqslantless,
	Equal: Equal,
	equals: equals,
	EqualTilde: EqualTilde,
	equest: equest,
	Equilibrium: Equilibrium,
	equiv: equiv,
	equivDD: equivDD,
	eqvparsl: eqvparsl,
	erarr: erarr,
	erDot: erDot,
	escr: escr,
	Escr: Escr,
	esdot: esdot,
	Esim: Esim,
	esim: esim,
	Eta: Eta,
	eta: eta,
	ETH: ETH$1,
	eth: eth$1,
	Euml: Euml$1,
	euml: euml$1,
	euro: euro,
	excl: excl,
	exist: exist,
	Exists: Exists,
	expectation: expectation,
	exponentiale: exponentiale,
	ExponentialE: ExponentialE,
	fallingdotseq: fallingdotseq,
	Fcy: Fcy,
	fcy: fcy,
	female: female,
	ffilig: ffilig,
	fflig: fflig,
	ffllig: ffllig,
	Ffr: Ffr,
	ffr: ffr,
	filig: filig,
	FilledSmallSquare: FilledSmallSquare,
	FilledVerySmallSquare: FilledVerySmallSquare,
	fjlig: fjlig,
	flat: flat,
	fllig: fllig,
	fltns: fltns,
	fnof: fnof,
	Fopf: Fopf,
	fopf: fopf,
	forall: forall,
	ForAll: ForAll,
	fork: fork,
	forkv: forkv,
	Fouriertrf: Fouriertrf,
	fpartint: fpartint,
	frac12: frac12$1,
	frac13: frac13,
	frac14: frac14$1,
	frac15: frac15,
	frac16: frac16,
	frac18: frac18,
	frac23: frac23,
	frac25: frac25,
	frac34: frac34$1,
	frac35: frac35,
	frac38: frac38,
	frac45: frac45,
	frac56: frac56,
	frac58: frac58,
	frac78: frac78,
	frasl: frasl,
	frown: frown,
	fscr: fscr,
	Fscr: Fscr,
	gacute: gacute,
	Gamma: Gamma,
	gamma: gamma,
	Gammad: Gammad,
	gammad: gammad,
	gap: gap,
	Gbreve: Gbreve,
	gbreve: gbreve,
	Gcedil: Gcedil,
	Gcirc: Gcirc,
	gcirc: gcirc,
	Gcy: Gcy,
	gcy: gcy,
	Gdot: Gdot,
	gdot: gdot,
	ge: ge,
	gE: gE,
	gEl: gEl,
	gel: gel,
	geq: geq,
	geqq: geqq,
	geqslant: geqslant,
	gescc: gescc,
	ges: ges,
	gesdot: gesdot,
	gesdoto: gesdoto,
	gesdotol: gesdotol,
	gesl: gesl,
	gesles: gesles,
	Gfr: Gfr,
	gfr: gfr,
	gg: gg,
	Gg: Gg,
	ggg: ggg,
	gimel: gimel,
	GJcy: GJcy,
	gjcy: gjcy,
	gla: gla,
	gl: gl,
	glE: glE,
	glj: glj,
	gnap: gnap,
	gnapprox: gnapprox,
	gne: gne,
	gnE: gnE,
	gneq: gneq,
	gneqq: gneqq,
	gnsim: gnsim,
	Gopf: Gopf,
	gopf: gopf,
	grave: grave,
	GreaterEqual: GreaterEqual,
	GreaterEqualLess: GreaterEqualLess,
	GreaterFullEqual: GreaterFullEqual,
	GreaterGreater: GreaterGreater,
	GreaterLess: GreaterLess,
	GreaterSlantEqual: GreaterSlantEqual,
	GreaterTilde: GreaterTilde,
	Gscr: Gscr,
	gscr: gscr,
	gsim: gsim,
	gsime: gsime,
	gsiml: gsiml,
	gtcc: gtcc,
	gtcir: gtcir,
	gt: gt$2,
	GT: GT$1,
	Gt: Gt,
	gtdot: gtdot,
	gtlPar: gtlPar,
	gtquest: gtquest,
	gtrapprox: gtrapprox,
	gtrarr: gtrarr,
	gtrdot: gtrdot,
	gtreqless: gtreqless,
	gtreqqless: gtreqqless,
	gtrless: gtrless,
	gtrsim: gtrsim,
	gvertneqq: gvertneqq,
	gvnE: gvnE,
	Hacek: Hacek,
	hairsp: hairsp,
	half: half,
	hamilt: hamilt,
	HARDcy: HARDcy,
	hardcy: hardcy,
	harrcir: harrcir,
	harr: harr,
	hArr: hArr,
	harrw: harrw,
	Hat: Hat,
	hbar: hbar,
	Hcirc: Hcirc,
	hcirc: hcirc,
	hearts: hearts,
	heartsuit: heartsuit,
	hellip: hellip,
	hercon: hercon,
	hfr: hfr,
	Hfr: Hfr,
	HilbertSpace: HilbertSpace,
	hksearow: hksearow,
	hkswarow: hkswarow,
	hoarr: hoarr,
	homtht: homtht,
	hookleftarrow: hookleftarrow,
	hookrightarrow: hookrightarrow,
	hopf: hopf,
	Hopf: Hopf,
	horbar: horbar,
	HorizontalLine: HorizontalLine,
	hscr: hscr,
	Hscr: Hscr,
	hslash: hslash,
	Hstrok: Hstrok,
	hstrok: hstrok,
	HumpDownHump: HumpDownHump,
	HumpEqual: HumpEqual,
	hybull: hybull,
	hyphen: hyphen,
	Iacute: Iacute$1,
	iacute: iacute$1,
	ic: ic,
	Icirc: Icirc$1,
	icirc: icirc$1,
	Icy: Icy,
	icy: icy,
	Idot: Idot,
	IEcy: IEcy,
	iecy: iecy,
	iexcl: iexcl$1,
	iff: iff,
	ifr: ifr,
	Ifr: Ifr,
	Igrave: Igrave$1,
	igrave: igrave$1,
	ii: ii,
	iiiint: iiiint,
	iiint: iiint,
	iinfin: iinfin,
	iiota: iiota,
	IJlig: IJlig,
	ijlig: ijlig,
	Imacr: Imacr,
	imacr: imacr,
	image: image,
	ImaginaryI: ImaginaryI,
	imagline: imagline,
	imagpart: imagpart,
	imath: imath,
	Im: Im,
	imof: imof,
	imped: imped,
	Implies: Implies,
	incare: incare,
	"in": "∈",
	infin: infin,
	infintie: infintie,
	inodot: inodot,
	intcal: intcal,
	int: int,
	Int: Int,
	integers: integers,
	Integral: Integral,
	intercal: intercal,
	Intersection: Intersection,
	intlarhk: intlarhk,
	intprod: intprod,
	InvisibleComma: InvisibleComma,
	InvisibleTimes: InvisibleTimes,
	IOcy: IOcy,
	iocy: iocy,
	Iogon: Iogon,
	iogon: iogon,
	Iopf: Iopf,
	iopf: iopf,
	Iota: Iota,
	iota: iota,
	iprod: iprod,
	iquest: iquest$1,
	iscr: iscr,
	Iscr: Iscr,
	isin: isin,
	isindot: isindot,
	isinE: isinE,
	isins: isins,
	isinsv: isinsv,
	isinv: isinv,
	it: it,
	Itilde: Itilde,
	itilde: itilde,
	Iukcy: Iukcy,
	iukcy: iukcy,
	Iuml: Iuml$1,
	iuml: iuml$1,
	Jcirc: Jcirc,
	jcirc: jcirc,
	Jcy: Jcy,
	jcy: jcy,
	Jfr: Jfr,
	jfr: jfr,
	jmath: jmath,
	Jopf: Jopf,
	jopf: jopf,
	Jscr: Jscr,
	jscr: jscr,
	Jsercy: Jsercy,
	jsercy: jsercy,
	Jukcy: Jukcy,
	jukcy: jukcy,
	Kappa: Kappa,
	kappa: kappa,
	kappav: kappav,
	Kcedil: Kcedil,
	kcedil: kcedil,
	Kcy: Kcy,
	kcy: kcy,
	Kfr: Kfr,
	kfr: kfr,
	kgreen: kgreen,
	KHcy: KHcy,
	khcy: khcy,
	KJcy: KJcy,
	kjcy: kjcy,
	Kopf: Kopf,
	kopf: kopf,
	Kscr: Kscr,
	kscr: kscr,
	lAarr: lAarr,
	Lacute: Lacute,
	lacute: lacute,
	laemptyv: laemptyv,
	lagran: lagran,
	Lambda: Lambda,
	lambda: lambda,
	lang: lang,
	Lang: Lang,
	langd: langd,
	langle: langle,
	lap: lap,
	Laplacetrf: Laplacetrf,
	laquo: laquo$1,
	larrb: larrb,
	larrbfs: larrbfs,
	larr: larr,
	Larr: Larr,
	lArr: lArr,
	larrfs: larrfs,
	larrhk: larrhk,
	larrlp: larrlp,
	larrpl: larrpl,
	larrsim: larrsim,
	larrtl: larrtl,
	latail: latail,
	lAtail: lAtail,
	lat: lat,
	late: late,
	lates: lates,
	lbarr: lbarr,
	lBarr: lBarr,
	lbbrk: lbbrk,
	lbrace: lbrace,
	lbrack: lbrack,
	lbrke: lbrke,
	lbrksld: lbrksld,
	lbrkslu: lbrkslu,
	Lcaron: Lcaron,
	lcaron: lcaron,
	Lcedil: Lcedil,
	lcedil: lcedil,
	lceil: lceil,
	lcub: lcub,
	Lcy: Lcy,
	lcy: lcy,
	ldca: ldca,
	ldquo: ldquo,
	ldquor: ldquor,
	ldrdhar: ldrdhar,
	ldrushar: ldrushar,
	ldsh: ldsh,
	le: le,
	lE: lE,
	LeftAngleBracket: LeftAngleBracket,
	LeftArrowBar: LeftArrowBar,
	leftarrow: leftarrow,
	LeftArrow: LeftArrow,
	Leftarrow: Leftarrow,
	LeftArrowRightArrow: LeftArrowRightArrow,
	leftarrowtail: leftarrowtail,
	LeftCeiling: LeftCeiling,
	LeftDoubleBracket: LeftDoubleBracket,
	LeftDownTeeVector: LeftDownTeeVector,
	LeftDownVectorBar: LeftDownVectorBar,
	LeftDownVector: LeftDownVector,
	LeftFloor: LeftFloor,
	leftharpoondown: leftharpoondown,
	leftharpoonup: leftharpoonup,
	leftleftarrows: leftleftarrows,
	leftrightarrow: leftrightarrow,
	LeftRightArrow: LeftRightArrow,
	Leftrightarrow: Leftrightarrow,
	leftrightarrows: leftrightarrows,
	leftrightharpoons: leftrightharpoons,
	leftrightsquigarrow: leftrightsquigarrow,
	LeftRightVector: LeftRightVector,
	LeftTeeArrow: LeftTeeArrow,
	LeftTee: LeftTee,
	LeftTeeVector: LeftTeeVector,
	leftthreetimes: leftthreetimes,
	LeftTriangleBar: LeftTriangleBar,
	LeftTriangle: LeftTriangle,
	LeftTriangleEqual: LeftTriangleEqual,
	LeftUpDownVector: LeftUpDownVector,
	LeftUpTeeVector: LeftUpTeeVector,
	LeftUpVectorBar: LeftUpVectorBar,
	LeftUpVector: LeftUpVector,
	LeftVectorBar: LeftVectorBar,
	LeftVector: LeftVector,
	lEg: lEg,
	leg: leg,
	leq: leq,
	leqq: leqq,
	leqslant: leqslant,
	lescc: lescc,
	les: les,
	lesdot: lesdot,
	lesdoto: lesdoto,
	lesdotor: lesdotor,
	lesg: lesg,
	lesges: lesges,
	lessapprox: lessapprox,
	lessdot: lessdot,
	lesseqgtr: lesseqgtr,
	lesseqqgtr: lesseqqgtr,
	LessEqualGreater: LessEqualGreater,
	LessFullEqual: LessFullEqual,
	LessGreater: LessGreater,
	lessgtr: lessgtr,
	LessLess: LessLess,
	lesssim: lesssim,
	LessSlantEqual: LessSlantEqual,
	LessTilde: LessTilde,
	lfisht: lfisht,
	lfloor: lfloor,
	Lfr: Lfr,
	lfr: lfr,
	lg: lg,
	lgE: lgE,
	lHar: lHar,
	lhard: lhard,
	lharu: lharu,
	lharul: lharul,
	lhblk: lhblk,
	LJcy: LJcy,
	ljcy: ljcy,
	llarr: llarr,
	ll: ll,
	Ll: Ll,
	llcorner: llcorner,
	Lleftarrow: Lleftarrow,
	llhard: llhard,
	lltri: lltri,
	Lmidot: Lmidot,
	lmidot: lmidot,
	lmoustache: lmoustache,
	lmoust: lmoust,
	lnap: lnap,
	lnapprox: lnapprox,
	lne: lne,
	lnE: lnE,
	lneq: lneq,
	lneqq: lneqq,
	lnsim: lnsim,
	loang: loang,
	loarr: loarr,
	lobrk: lobrk,
	longleftarrow: longleftarrow,
	LongLeftArrow: LongLeftArrow,
	Longleftarrow: Longleftarrow,
	longleftrightarrow: longleftrightarrow,
	LongLeftRightArrow: LongLeftRightArrow,
	Longleftrightarrow: Longleftrightarrow,
	longmapsto: longmapsto,
	longrightarrow: longrightarrow,
	LongRightArrow: LongRightArrow,
	Longrightarrow: Longrightarrow,
	looparrowleft: looparrowleft,
	looparrowright: looparrowright,
	lopar: lopar,
	Lopf: Lopf,
	lopf: lopf,
	loplus: loplus,
	lotimes: lotimes,
	lowast: lowast,
	lowbar: lowbar,
	LowerLeftArrow: LowerLeftArrow,
	LowerRightArrow: LowerRightArrow,
	loz: loz,
	lozenge: lozenge,
	lozf: lozf,
	lpar: lpar,
	lparlt: lparlt,
	lrarr: lrarr,
	lrcorner: lrcorner,
	lrhar: lrhar,
	lrhard: lrhard,
	lrm: lrm,
	lrtri: lrtri,
	lsaquo: lsaquo,
	lscr: lscr,
	Lscr: Lscr,
	lsh: lsh,
	Lsh: Lsh,
	lsim: lsim,
	lsime: lsime,
	lsimg: lsimg,
	lsqb: lsqb,
	lsquo: lsquo,
	lsquor: lsquor,
	Lstrok: Lstrok,
	lstrok: lstrok,
	ltcc: ltcc,
	ltcir: ltcir,
	lt: lt$2,
	LT: LT$1,
	Lt: Lt,
	ltdot: ltdot,
	lthree: lthree,
	ltimes: ltimes,
	ltlarr: ltlarr,
	ltquest: ltquest,
	ltri: ltri,
	ltrie: ltrie,
	ltrif: ltrif,
	ltrPar: ltrPar,
	lurdshar: lurdshar,
	luruhar: luruhar,
	lvertneqq: lvertneqq,
	lvnE: lvnE,
	macr: macr$1,
	male: male,
	malt: malt,
	maltese: maltese,
	"Map": "⤅",
	map: map$1,
	mapsto: mapsto,
	mapstodown: mapstodown,
	mapstoleft: mapstoleft,
	mapstoup: mapstoup,
	marker: marker,
	mcomma: mcomma,
	Mcy: Mcy,
	mcy: mcy,
	mdash: mdash,
	mDDot: mDDot,
	measuredangle: measuredangle,
	MediumSpace: MediumSpace,
	Mellintrf: Mellintrf,
	Mfr: Mfr,
	mfr: mfr,
	mho: mho,
	micro: micro$1,
	midast: midast,
	midcir: midcir,
	mid: mid,
	middot: middot$1,
	minusb: minusb,
	minus: minus,
	minusd: minusd,
	minusdu: minusdu,
	MinusPlus: MinusPlus,
	mlcp: mlcp,
	mldr: mldr,
	mnplus: mnplus,
	models: models,
	Mopf: Mopf,
	mopf: mopf,
	mp: mp,
	mscr: mscr,
	Mscr: Mscr,
	mstpos: mstpos,
	Mu: Mu,
	mu: mu,
	multimap: multimap,
	mumap: mumap,
	nabla: nabla,
	Nacute: Nacute,
	nacute: nacute,
	nang: nang,
	nap: nap,
	napE: napE,
	napid: napid,
	napos: napos,
	napprox: napprox,
	natural: natural,
	naturals: naturals,
	natur: natur,
	nbsp: nbsp$1,
	nbump: nbump,
	nbumpe: nbumpe,
	ncap: ncap,
	Ncaron: Ncaron,
	ncaron: ncaron,
	Ncedil: Ncedil,
	ncedil: ncedil,
	ncong: ncong,
	ncongdot: ncongdot,
	ncup: ncup,
	Ncy: Ncy,
	ncy: ncy,
	ndash: ndash,
	nearhk: nearhk,
	nearr: nearr,
	neArr: neArr,
	nearrow: nearrow,
	ne: ne,
	nedot: nedot,
	NegativeMediumSpace: NegativeMediumSpace,
	NegativeThickSpace: NegativeThickSpace,
	NegativeThinSpace: NegativeThinSpace,
	NegativeVeryThinSpace: NegativeVeryThinSpace,
	nequiv: nequiv,
	nesear: nesear,
	nesim: nesim,
	NestedGreaterGreater: NestedGreaterGreater,
	NestedLessLess: NestedLessLess,
	NewLine: NewLine,
	nexist: nexist,
	nexists: nexists,
	Nfr: Nfr,
	nfr: nfr,
	ngE: ngE,
	nge: nge,
	ngeq: ngeq,
	ngeqq: ngeqq,
	ngeqslant: ngeqslant,
	nges: nges,
	nGg: nGg,
	ngsim: ngsim,
	nGt: nGt,
	ngt: ngt,
	ngtr: ngtr,
	nGtv: nGtv,
	nharr: nharr,
	nhArr: nhArr,
	nhpar: nhpar,
	ni: ni,
	nis: nis,
	nisd: nisd,
	niv: niv,
	NJcy: NJcy,
	njcy: njcy,
	nlarr: nlarr,
	nlArr: nlArr,
	nldr: nldr,
	nlE: nlE,
	nle: nle,
	nleftarrow: nleftarrow,
	nLeftarrow: nLeftarrow,
	nleftrightarrow: nleftrightarrow,
	nLeftrightarrow: nLeftrightarrow,
	nleq: nleq,
	nleqq: nleqq,
	nleqslant: nleqslant,
	nles: nles,
	nless: nless,
	nLl: nLl,
	nlsim: nlsim,
	nLt: nLt,
	nlt: nlt,
	nltri: nltri,
	nltrie: nltrie,
	nLtv: nLtv,
	nmid: nmid,
	NoBreak: NoBreak,
	NonBreakingSpace: NonBreakingSpace,
	nopf: nopf,
	Nopf: Nopf,
	Not: Not,
	not: not$2,
	NotCongruent: NotCongruent,
	NotCupCap: NotCupCap,
	NotDoubleVerticalBar: NotDoubleVerticalBar,
	NotElement: NotElement,
	NotEqual: NotEqual,
	NotEqualTilde: NotEqualTilde,
	NotExists: NotExists,
	NotGreater: NotGreater,
	NotGreaterEqual: NotGreaterEqual,
	NotGreaterFullEqual: NotGreaterFullEqual,
	NotGreaterGreater: NotGreaterGreater,
	NotGreaterLess: NotGreaterLess,
	NotGreaterSlantEqual: NotGreaterSlantEqual,
	NotGreaterTilde: NotGreaterTilde,
	NotHumpDownHump: NotHumpDownHump,
	NotHumpEqual: NotHumpEqual,
	notin: notin,
	notindot: notindot,
	notinE: notinE,
	notinva: notinva,
	notinvb: notinvb,
	notinvc: notinvc,
	NotLeftTriangleBar: NotLeftTriangleBar,
	NotLeftTriangle: NotLeftTriangle,
	NotLeftTriangleEqual: NotLeftTriangleEqual,
	NotLess: NotLess,
	NotLessEqual: NotLessEqual,
	NotLessGreater: NotLessGreater,
	NotLessLess: NotLessLess,
	NotLessSlantEqual: NotLessSlantEqual,
	NotLessTilde: NotLessTilde,
	NotNestedGreaterGreater: NotNestedGreaterGreater,
	NotNestedLessLess: NotNestedLessLess,
	notni: notni,
	notniva: notniva,
	notnivb: notnivb,
	notnivc: notnivc,
	NotPrecedes: NotPrecedes,
	NotPrecedesEqual: NotPrecedesEqual,
	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
	NotReverseElement: NotReverseElement,
	NotRightTriangleBar: NotRightTriangleBar,
	NotRightTriangle: NotRightTriangle,
	NotRightTriangleEqual: NotRightTriangleEqual,
	NotSquareSubset: NotSquareSubset,
	NotSquareSubsetEqual: NotSquareSubsetEqual,
	NotSquareSuperset: NotSquareSuperset,
	NotSquareSupersetEqual: NotSquareSupersetEqual,
	NotSubset: NotSubset,
	NotSubsetEqual: NotSubsetEqual,
	NotSucceeds: NotSucceeds,
	NotSucceedsEqual: NotSucceedsEqual,
	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
	NotSucceedsTilde: NotSucceedsTilde,
	NotSuperset: NotSuperset,
	NotSupersetEqual: NotSupersetEqual,
	NotTilde: NotTilde,
	NotTildeEqual: NotTildeEqual,
	NotTildeFullEqual: NotTildeFullEqual,
	NotTildeTilde: NotTildeTilde,
	NotVerticalBar: NotVerticalBar,
	nparallel: nparallel,
	npar: npar,
	nparsl: nparsl,
	npart: npart,
	npolint: npolint,
	npr: npr,
	nprcue: nprcue,
	nprec: nprec,
	npreceq: npreceq,
	npre: npre,
	nrarrc: nrarrc,
	nrarr: nrarr,
	nrArr: nrArr,
	nrarrw: nrarrw,
	nrightarrow: nrightarrow,
	nRightarrow: nRightarrow,
	nrtri: nrtri,
	nrtrie: nrtrie,
	nsc: nsc,
	nsccue: nsccue,
	nsce: nsce,
	Nscr: Nscr,
	nscr: nscr,
	nshortmid: nshortmid,
	nshortparallel: nshortparallel,
	nsim: nsim,
	nsime: nsime,
	nsimeq: nsimeq,
	nsmid: nsmid,
	nspar: nspar,
	nsqsube: nsqsube,
	nsqsupe: nsqsupe,
	nsub: nsub,
	nsubE: nsubE,
	nsube: nsube,
	nsubset: nsubset,
	nsubseteq: nsubseteq,
	nsubseteqq: nsubseteqq,
	nsucc: nsucc,
	nsucceq: nsucceq,
	nsup: nsup,
	nsupE: nsupE,
	nsupe: nsupe,
	nsupset: nsupset,
	nsupseteq: nsupseteq,
	nsupseteqq: nsupseteqq,
	ntgl: ntgl,
	Ntilde: Ntilde$1,
	ntilde: ntilde$1,
	ntlg: ntlg,
	ntriangleleft: ntriangleleft,
	ntrianglelefteq: ntrianglelefteq,
	ntriangleright: ntriangleright,
	ntrianglerighteq: ntrianglerighteq,
	Nu: Nu,
	nu: nu,
	num: num,
	numero: numero,
	numsp: numsp,
	nvap: nvap,
	nvdash: nvdash,
	nvDash: nvDash,
	nVdash: nVdash,
	nVDash: nVDash,
	nvge: nvge,
	nvgt: nvgt,
	nvHarr: nvHarr,
	nvinfin: nvinfin,
	nvlArr: nvlArr,
	nvle: nvle,
	nvlt: nvlt,
	nvltrie: nvltrie,
	nvrArr: nvrArr,
	nvrtrie: nvrtrie,
	nvsim: nvsim,
	nwarhk: nwarhk,
	nwarr: nwarr,
	nwArr: nwArr,
	nwarrow: nwarrow,
	nwnear: nwnear,
	Oacute: Oacute$1,
	oacute: oacute$1,
	oast: oast,
	Ocirc: Ocirc$1,
	ocirc: ocirc$1,
	ocir: ocir,
	Ocy: Ocy,
	ocy: ocy,
	odash: odash,
	Odblac: Odblac,
	odblac: odblac,
	odiv: odiv,
	odot: odot,
	odsold: odsold,
	OElig: OElig,
	oelig: oelig,
	ofcir: ofcir,
	Ofr: Ofr,
	ofr: ofr,
	ogon: ogon,
	Ograve: Ograve$1,
	ograve: ograve$1,
	ogt: ogt,
	ohbar: ohbar,
	ohm: ohm,
	oint: oint,
	olarr: olarr,
	olcir: olcir,
	olcross: olcross,
	oline: oline,
	olt: olt,
	Omacr: Omacr,
	omacr: omacr,
	Omega: Omega,
	omega: omega,
	Omicron: Omicron,
	omicron: omicron,
	omid: omid,
	ominus: ominus,
	Oopf: Oopf,
	oopf: oopf,
	opar: opar,
	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
	OpenCurlyQuote: OpenCurlyQuote,
	operp: operp,
	oplus: oplus,
	orarr: orarr,
	Or: Or,
	or: or,
	ord: ord,
	order: order,
	orderof: orderof,
	ordf: ordf$1,
	ordm: ordm$1,
	origof: origof,
	oror: oror,
	orslope: orslope,
	orv: orv,
	oS: oS,
	Oscr: Oscr,
	oscr: oscr,
	Oslash: Oslash$1,
	oslash: oslash$1,
	osol: osol,
	Otilde: Otilde$1,
	otilde: otilde$1,
	otimesas: otimesas,
	Otimes: Otimes,
	otimes: otimes,
	Ouml: Ouml$1,
	ouml: ouml$1,
	ovbar: ovbar,
	OverBar: OverBar,
	OverBrace: OverBrace,
	OverBracket: OverBracket,
	OverParenthesis: OverParenthesis,
	para: para$1,
	parallel: parallel,
	par: par,
	parsim: parsim,
	parsl: parsl,
	part: part,
	PartialD: PartialD,
	Pcy: Pcy,
	pcy: pcy,
	percnt: percnt,
	period: period,
	permil: permil,
	perp: perp,
	pertenk: pertenk,
	Pfr: Pfr,
	pfr: pfr,
	Phi: Phi,
	phi: phi,
	phiv: phiv,
	phmmat: phmmat,
	phone: phone,
	Pi: Pi,
	pi: pi,
	pitchfork: pitchfork,
	piv: piv,
	planck: planck,
	planckh: planckh,
	plankv: plankv,
	plusacir: plusacir,
	plusb: plusb,
	pluscir: pluscir,
	plus: plus,
	plusdo: plusdo,
	plusdu: plusdu,
	pluse: pluse,
	PlusMinus: PlusMinus,
	plusmn: plusmn$1,
	plussim: plussim,
	plustwo: plustwo,
	pm: pm,
	Poincareplane: Poincareplane,
	pointint: pointint,
	popf: popf,
	Popf: Popf,
	pound: pound$1,
	prap: prap,
	Pr: Pr,
	pr: pr,
	prcue: prcue,
	precapprox: precapprox,
	prec: prec,
	preccurlyeq: preccurlyeq,
	Precedes: Precedes,
	PrecedesEqual: PrecedesEqual,
	PrecedesSlantEqual: PrecedesSlantEqual,
	PrecedesTilde: PrecedesTilde,
	preceq: preceq,
	precnapprox: precnapprox,
	precneqq: precneqq,
	precnsim: precnsim,
	pre: pre,
	prE: prE,
	precsim: precsim,
	prime: prime,
	Prime: Prime,
	primes: primes,
	prnap: prnap,
	prnE: prnE,
	prnsim: prnsim,
	prod: prod,
	Product: Product,
	profalar: profalar,
	profline: profline,
	profsurf: profsurf,
	prop: prop$1,
	Proportional: Proportional,
	Proportion: Proportion,
	propto: propto,
	prsim: prsim,
	prurel: prurel,
	Pscr: Pscr,
	pscr: pscr,
	Psi: Psi,
	psi: psi,
	puncsp: puncsp,
	Qfr: Qfr,
	qfr: qfr,
	qint: qint,
	qopf: qopf,
	Qopf: Qopf,
	qprime: qprime,
	Qscr: Qscr,
	qscr: qscr,
	quaternions: quaternions,
	quatint: quatint,
	quest: quest,
	questeq: questeq,
	quot: quot$2,
	QUOT: QUOT$1,
	rAarr: rAarr,
	race: race,
	Racute: Racute,
	racute: racute,
	radic: radic,
	raemptyv: raemptyv,
	rang: rang,
	Rang: Rang,
	rangd: rangd,
	range: range,
	rangle: rangle,
	raquo: raquo$1,
	rarrap: rarrap,
	rarrb: rarrb,
	rarrbfs: rarrbfs,
	rarrc: rarrc,
	rarr: rarr,
	Rarr: Rarr,
	rArr: rArr,
	rarrfs: rarrfs,
	rarrhk: rarrhk,
	rarrlp: rarrlp,
	rarrpl: rarrpl,
	rarrsim: rarrsim,
	Rarrtl: Rarrtl,
	rarrtl: rarrtl,
	rarrw: rarrw,
	ratail: ratail,
	rAtail: rAtail,
	ratio: ratio,
	rationals: rationals,
	rbarr: rbarr,
	rBarr: rBarr,
	RBarr: RBarr,
	rbbrk: rbbrk,
	rbrace: rbrace$1,
	rbrack: rbrack,
	rbrke: rbrke,
	rbrksld: rbrksld,
	rbrkslu: rbrkslu,
	Rcaron: Rcaron,
	rcaron: rcaron,
	Rcedil: Rcedil,
	rcedil: rcedil,
	rceil: rceil,
	rcub: rcub,
	Rcy: Rcy,
	rcy: rcy,
	rdca: rdca,
	rdldhar: rdldhar,
	rdquo: rdquo,
	rdquor: rdquor,
	rdsh: rdsh,
	real: real,
	realine: realine,
	realpart: realpart,
	reals: reals,
	Re: Re,
	rect: rect,
	reg: reg$1,
	REG: REG$1,
	ReverseElement: ReverseElement,
	ReverseEquilibrium: ReverseEquilibrium,
	ReverseUpEquilibrium: ReverseUpEquilibrium,
	rfisht: rfisht,
	rfloor: rfloor,
	rfr: rfr,
	Rfr: Rfr,
	rHar: rHar,
	rhard: rhard,
	rharu: rharu,
	rharul: rharul,
	Rho: Rho,
	rho: rho,
	rhov: rhov,
	RightAngleBracket: RightAngleBracket,
	RightArrowBar: RightArrowBar,
	rightarrow: rightarrow,
	RightArrow: RightArrow,
	Rightarrow: Rightarrow,
	RightArrowLeftArrow: RightArrowLeftArrow,
	rightarrowtail: rightarrowtail,
	RightCeiling: RightCeiling,
	RightDoubleBracket: RightDoubleBracket,
	RightDownTeeVector: RightDownTeeVector,
	RightDownVectorBar: RightDownVectorBar,
	RightDownVector: RightDownVector,
	RightFloor: RightFloor,
	rightharpoondown: rightharpoondown,
	rightharpoonup: rightharpoonup,
	rightleftarrows: rightleftarrows,
	rightleftharpoons: rightleftharpoons,
	rightrightarrows: rightrightarrows,
	rightsquigarrow: rightsquigarrow,
	RightTeeArrow: RightTeeArrow,
	RightTee: RightTee,
	RightTeeVector: RightTeeVector,
	rightthreetimes: rightthreetimes,
	RightTriangleBar: RightTriangleBar,
	RightTriangle: RightTriangle,
	RightTriangleEqual: RightTriangleEqual,
	RightUpDownVector: RightUpDownVector,
	RightUpTeeVector: RightUpTeeVector,
	RightUpVectorBar: RightUpVectorBar,
	RightUpVector: RightUpVector,
	RightVectorBar: RightVectorBar,
	RightVector: RightVector,
	ring: ring,
	risingdotseq: risingdotseq,
	rlarr: rlarr,
	rlhar: rlhar,
	rlm: rlm,
	rmoustache: rmoustache,
	rmoust: rmoust,
	rnmid: rnmid,
	roang: roang,
	roarr: roarr,
	robrk: robrk,
	ropar: ropar,
	ropf: ropf,
	Ropf: Ropf,
	roplus: roplus,
	rotimes: rotimes,
	RoundImplies: RoundImplies,
	rpar: rpar,
	rpargt: rpargt,
	rppolint: rppolint,
	rrarr: rrarr,
	Rrightarrow: Rrightarrow,
	rsaquo: rsaquo,
	rscr: rscr,
	Rscr: Rscr,
	rsh: rsh,
	Rsh: Rsh,
	rsqb: rsqb,
	rsquo: rsquo,
	rsquor: rsquor,
	rthree: rthree,
	rtimes: rtimes,
	rtri: rtri,
	rtrie: rtrie,
	rtrif: rtrif,
	rtriltri: rtriltri,
	RuleDelayed: RuleDelayed,
	ruluhar: ruluhar,
	rx: rx,
	Sacute: Sacute,
	sacute: sacute,
	sbquo: sbquo,
	scap: scap,
	Scaron: Scaron,
	scaron: scaron,
	Sc: Sc,
	sc: sc,
	sccue: sccue,
	sce: sce,
	scE: scE,
	Scedil: Scedil,
	scedil: scedil,
	Scirc: Scirc,
	scirc: scirc,
	scnap: scnap,
	scnE: scnE,
	scnsim: scnsim,
	scpolint: scpolint,
	scsim: scsim,
	Scy: Scy,
	scy: scy,
	sdotb: sdotb,
	sdot: sdot,
	sdote: sdote,
	searhk: searhk,
	searr: searr,
	seArr: seArr,
	searrow: searrow,
	sect: sect$1,
	semi: semi,
	seswar: seswar,
	setminus: setminus,
	setmn: setmn,
	sext: sext,
	Sfr: Sfr,
	sfr: sfr,
	sfrown: sfrown,
	sharp: sharp,
	SHCHcy: SHCHcy,
	shchcy: shchcy,
	SHcy: SHcy,
	shcy: shcy,
	ShortDownArrow: ShortDownArrow,
	ShortLeftArrow: ShortLeftArrow,
	shortmid: shortmid,
	shortparallel: shortparallel,
	ShortRightArrow: ShortRightArrow,
	ShortUpArrow: ShortUpArrow,
	shy: shy$1,
	Sigma: Sigma,
	sigma: sigma,
	sigmaf: sigmaf,
	sigmav: sigmav,
	sim: sim,
	simdot: simdot,
	sime: sime,
	simeq: simeq,
	simg: simg,
	simgE: simgE,
	siml: siml,
	simlE: simlE,
	simne: simne,
	simplus: simplus,
	simrarr: simrarr,
	slarr: slarr,
	SmallCircle: SmallCircle,
	smallsetminus: smallsetminus,
	smashp: smashp,
	smeparsl: smeparsl,
	smid: smid,
	smile: smile,
	smt: smt,
	smte: smte,
	smtes: smtes,
	SOFTcy: SOFTcy,
	softcy: softcy,
	solbar: solbar,
	solb: solb,
	sol: sol,
	Sopf: Sopf,
	sopf: sopf,
	spades: spades,
	spadesuit: spadesuit,
	spar: spar,
	sqcap: sqcap,
	sqcaps: sqcaps,
	sqcup: sqcup,
	sqcups: sqcups,
	Sqrt: Sqrt,
	sqsub: sqsub,
	sqsube: sqsube,
	sqsubset: sqsubset,
	sqsubseteq: sqsubseteq,
	sqsup: sqsup,
	sqsupe: sqsupe,
	sqsupset: sqsupset,
	sqsupseteq: sqsupseteq,
	square: square,
	Square: Square,
	SquareIntersection: SquareIntersection,
	SquareSubset: SquareSubset,
	SquareSubsetEqual: SquareSubsetEqual,
	SquareSuperset: SquareSuperset,
	SquareSupersetEqual: SquareSupersetEqual,
	SquareUnion: SquareUnion,
	squarf: squarf,
	squ: squ,
	squf: squf,
	srarr: srarr,
	Sscr: Sscr,
	sscr: sscr,
	ssetmn: ssetmn,
	ssmile: ssmile,
	sstarf: sstarf,
	Star: Star,
	star: star,
	starf: starf,
	straightepsilon: straightepsilon,
	straightphi: straightphi,
	strns: strns,
	sub: sub,
	Sub: Sub,
	subdot: subdot,
	subE: subE,
	sube: sube,
	subedot: subedot,
	submult: submult,
	subnE: subnE,
	subne: subne,
	subplus: subplus,
	subrarr: subrarr,
	subset: subset,
	Subset: Subset,
	subseteq: subseteq,
	subseteqq: subseteqq,
	SubsetEqual: SubsetEqual,
	subsetneq: subsetneq,
	subsetneqq: subsetneqq,
	subsim: subsim,
	subsub: subsub,
	subsup: subsup,
	succapprox: succapprox,
	succ: succ,
	succcurlyeq: succcurlyeq,
	Succeeds: Succeeds,
	SucceedsEqual: SucceedsEqual,
	SucceedsSlantEqual: SucceedsSlantEqual,
	SucceedsTilde: SucceedsTilde,
	succeq: succeq,
	succnapprox: succnapprox,
	succneqq: succneqq,
	succnsim: succnsim,
	succsim: succsim,
	SuchThat: SuchThat,
	sum: sum,
	Sum: Sum,
	sung: sung,
	sup1: sup1$1,
	sup2: sup2$1,
	sup3: sup3$1,
	sup: sup,
	Sup: Sup,
	supdot: supdot,
	supdsub: supdsub,
	supE: supE,
	supe: supe,
	supedot: supedot,
	Superset: Superset,
	SupersetEqual: SupersetEqual,
	suphsol: suphsol,
	suphsub: suphsub,
	suplarr: suplarr,
	supmult: supmult,
	supnE: supnE,
	supne: supne,
	supplus: supplus,
	supset: supset,
	Supset: Supset,
	supseteq: supseteq,
	supseteqq: supseteqq,
	supsetneq: supsetneq,
	supsetneqq: supsetneqq,
	supsim: supsim,
	supsub: supsub,
	supsup: supsup,
	swarhk: swarhk,
	swarr: swarr,
	swArr: swArr,
	swarrow: swarrow,
	swnwar: swnwar,
	szlig: szlig$1,
	Tab: Tab,
	target: target,
	Tau: Tau,
	tau: tau,
	tbrk: tbrk,
	Tcaron: Tcaron,
	tcaron: tcaron,
	Tcedil: Tcedil,
	tcedil: tcedil,
	Tcy: Tcy,
	tcy: tcy,
	tdot: tdot,
	telrec: telrec,
	Tfr: Tfr,
	tfr: tfr,
	there4: there4,
	therefore: therefore,
	Therefore: Therefore,
	Theta: Theta,
	theta: theta,
	thetasym: thetasym,
	thetav: thetav,
	thickapprox: thickapprox,
	thicksim: thicksim,
	ThickSpace: ThickSpace,
	ThinSpace: ThinSpace,
	thinsp: thinsp,
	thkap: thkap,
	thksim: thksim,
	THORN: THORN$1,
	thorn: thorn$1,
	tilde: tilde,
	Tilde: Tilde,
	TildeEqual: TildeEqual,
	TildeFullEqual: TildeFullEqual,
	TildeTilde: TildeTilde,
	timesbar: timesbar,
	timesb: timesb,
	times: times$1,
	timesd: timesd,
	tint: tint,
	toea: toea,
	topbot: topbot,
	topcir: topcir,
	top: top,
	Topf: Topf,
	topf: topf,
	topfork: topfork,
	tosa: tosa,
	tprime: tprime,
	trade: trade,
	TRADE: TRADE,
	triangle: triangle,
	triangledown: triangledown,
	triangleleft: triangleleft,
	trianglelefteq: trianglelefteq,
	triangleq: triangleq,
	triangleright: triangleright,
	trianglerighteq: trianglerighteq,
	tridot: tridot,
	trie: trie,
	triminus: triminus,
	TripleDot: TripleDot,
	triplus: triplus,
	trisb: trisb,
	tritime: tritime,
	trpezium: trpezium,
	Tscr: Tscr,
	tscr: tscr,
	TScy: TScy,
	tscy: tscy,
	TSHcy: TSHcy,
	tshcy: tshcy,
	Tstrok: Tstrok,
	tstrok: tstrok,
	twixt: twixt,
	twoheadleftarrow: twoheadleftarrow,
	twoheadrightarrow: twoheadrightarrow,
	Uacute: Uacute$1,
	uacute: uacute$1,
	uarr: uarr,
	Uarr: Uarr,
	uArr: uArr,
	Uarrocir: Uarrocir,
	Ubrcy: Ubrcy,
	ubrcy: ubrcy,
	Ubreve: Ubreve,
	ubreve: ubreve,
	Ucirc: Ucirc$1,
	ucirc: ucirc$1,
	Ucy: Ucy,
	ucy: ucy,
	udarr: udarr,
	Udblac: Udblac,
	udblac: udblac,
	udhar: udhar,
	ufisht: ufisht,
	Ufr: Ufr,
	ufr: ufr,
	Ugrave: Ugrave$1,
	ugrave: ugrave$1,
	uHar: uHar,
	uharl: uharl,
	uharr: uharr,
	uhblk: uhblk,
	ulcorn: ulcorn,
	ulcorner: ulcorner,
	ulcrop: ulcrop,
	ultri: ultri,
	Umacr: Umacr,
	umacr: umacr,
	uml: uml$1,
	UnderBar: UnderBar,
	UnderBrace: UnderBrace,
	UnderBracket: UnderBracket,
	UnderParenthesis: UnderParenthesis,
	Union: Union,
	UnionPlus: UnionPlus,
	Uogon: Uogon,
	uogon: uogon,
	Uopf: Uopf,
	uopf: uopf,
	UpArrowBar: UpArrowBar,
	uparrow: uparrow,
	UpArrow: UpArrow,
	Uparrow: Uparrow,
	UpArrowDownArrow: UpArrowDownArrow,
	updownarrow: updownarrow,
	UpDownArrow: UpDownArrow,
	Updownarrow: Updownarrow,
	UpEquilibrium: UpEquilibrium,
	upharpoonleft: upharpoonleft,
	upharpoonright: upharpoonright,
	uplus: uplus,
	UpperLeftArrow: UpperLeftArrow,
	UpperRightArrow: UpperRightArrow,
	upsi: upsi,
	Upsi: Upsi,
	upsih: upsih,
	Upsilon: Upsilon,
	upsilon: upsilon,
	UpTeeArrow: UpTeeArrow,
	UpTee: UpTee,
	upuparrows: upuparrows,
	urcorn: urcorn,
	urcorner: urcorner,
	urcrop: urcrop,
	Uring: Uring,
	uring: uring,
	urtri: urtri,
	Uscr: Uscr,
	uscr: uscr,
	utdot: utdot,
	Utilde: Utilde,
	utilde: utilde,
	utri: utri,
	utrif: utrif,
	uuarr: uuarr,
	Uuml: Uuml$1,
	uuml: uuml$1,
	uwangle: uwangle,
	vangrt: vangrt,
	varepsilon: varepsilon,
	varkappa: varkappa,
	varnothing: varnothing,
	varphi: varphi,
	varpi: varpi,
	varpropto: varpropto,
	varr: varr,
	vArr: vArr,
	varrho: varrho,
	varsigma: varsigma,
	varsubsetneq: varsubsetneq,
	varsubsetneqq: varsubsetneqq,
	varsupsetneq: varsupsetneq,
	varsupsetneqq: varsupsetneqq,
	vartheta: vartheta,
	vartriangleleft: vartriangleleft,
	vartriangleright: vartriangleright,
	vBar: vBar,
	Vbar: Vbar,
	vBarv: vBarv,
	Vcy: Vcy,
	vcy: vcy,
	vdash: vdash,
	vDash: vDash,
	Vdash: Vdash,
	VDash: VDash,
	Vdashl: Vdashl,
	veebar: veebar,
	vee: vee,
	Vee: Vee,
	veeeq: veeeq,
	vellip: vellip,
	verbar: verbar,
	Verbar: Verbar,
	vert: vert,
	Vert: Vert,
	VerticalBar: VerticalBar,
	VerticalLine: VerticalLine,
	VerticalSeparator: VerticalSeparator,
	VerticalTilde: VerticalTilde,
	VeryThinSpace: VeryThinSpace,
	Vfr: Vfr,
	vfr: vfr,
	vltri: vltri,
	vnsub: vnsub,
	vnsup: vnsup,
	Vopf: Vopf,
	vopf: vopf,
	vprop: vprop,
	vrtri: vrtri,
	Vscr: Vscr,
	vscr: vscr,
	vsubnE: vsubnE,
	vsubne: vsubne,
	vsupnE: vsupnE,
	vsupne: vsupne,
	Vvdash: Vvdash,
	vzigzag: vzigzag,
	Wcirc: Wcirc,
	wcirc: wcirc,
	wedbar: wedbar,
	wedge: wedge,
	Wedge: Wedge,
	wedgeq: wedgeq,
	weierp: weierp,
	Wfr: Wfr,
	wfr: wfr,
	Wopf: Wopf,
	wopf: wopf,
	wp: wp,
	wr: wr,
	wreath: wreath,
	Wscr: Wscr,
	wscr: wscr,
	xcap: xcap,
	xcirc: xcirc,
	xcup: xcup,
	xdtri: xdtri,
	Xfr: Xfr,
	xfr: xfr,
	xharr: xharr,
	xhArr: xhArr,
	Xi: Xi,
	xi: xi,
	xlarr: xlarr,
	xlArr: xlArr,
	xmap: xmap,
	xnis: xnis,
	xodot: xodot,
	Xopf: Xopf,
	xopf: xopf,
	xoplus: xoplus,
	xotime: xotime,
	xrarr: xrarr,
	xrArr: xrArr,
	Xscr: Xscr,
	xscr: xscr,
	xsqcup: xsqcup,
	xuplus: xuplus,
	xutri: xutri,
	xvee: xvee,
	xwedge: xwedge,
	Yacute: Yacute$1,
	yacute: yacute$1,
	YAcy: YAcy,
	yacy: yacy,
	Ycirc: Ycirc,
	ycirc: ycirc,
	Ycy: Ycy,
	ycy: ycy,
	yen: yen$1,
	Yfr: Yfr,
	yfr: yfr,
	YIcy: YIcy,
	yicy: yicy,
	Yopf: Yopf,
	yopf: yopf,
	Yscr: Yscr,
	yscr: yscr,
	YUcy: YUcy,
	yucy: yucy,
	yuml: yuml$1,
	Yuml: Yuml,
	Zacute: Zacute,
	zacute: zacute,
	Zcaron: Zcaron,
	zcaron: zcaron,
	Zcy: Zcy,
	zcy: zcy,
	Zdot: Zdot,
	zdot: zdot,
	zeetrf: zeetrf,
	ZeroWidthSpace: ZeroWidthSpace,
	Zeta: Zeta,
	zeta: zeta,
	zfr: zfr,
	Zfr: Zfr,
	ZHcy: ZHcy,
	zhcy: zhcy,
	zigrarr: zigrarr,
	zopf: zopf,
	Zopf: Zopf,
	Zscr: Zscr,
	zscr: zscr,
	zwj: zwj,
	zwnj: zwnj
};

var Aacute = "Á";
var aacute = "á";
var Acirc = "Â";
var acirc = "â";
var acute = "´";
var AElig = "Æ";
var aelig = "æ";
var Agrave = "À";
var agrave = "à";
var amp$1 = "&";
var AMP = "&";
var Aring = "Å";
var aring = "å";
var Atilde = "Ã";
var atilde = "ã";
var Auml = "Ä";
var auml = "ä";
var brvbar = "¦";
var Ccedil = "Ç";
var ccedil = "ç";
var cedil = "¸";
var cent = "¢";
var copy$3 = "©";
var COPY = "©";
var curren = "¤";
var deg = "°";
var divide = "÷";
var Eacute = "É";
var eacute = "é";
var Ecirc = "Ê";
var ecirc = "ê";
var Egrave = "È";
var egrave = "è";
var ETH = "Ð";
var eth = "ð";
var Euml = "Ë";
var euml = "ë";
var frac12 = "½";
var frac14 = "¼";
var frac34 = "¾";
var gt$1 = ">";
var GT = ">";
var Iacute = "Í";
var iacute = "í";
var Icirc = "Î";
var icirc = "î";
var iexcl = "¡";
var Igrave = "Ì";
var igrave = "ì";
var iquest = "¿";
var Iuml = "Ï";
var iuml = "ï";
var laquo = "«";
var lt$1 = "<";
var LT = "<";
var macr = "¯";
var micro = "µ";
var middot = "·";
var nbsp = " ";
var not$1 = "¬";
var Ntilde = "Ñ";
var ntilde = "ñ";
var Oacute = "Ó";
var oacute = "ó";
var Ocirc = "Ô";
var ocirc = "ô";
var Ograve = "Ò";
var ograve = "ò";
var ordf = "ª";
var ordm = "º";
var Oslash = "Ø";
var oslash = "ø";
var Otilde = "Õ";
var otilde = "õ";
var Ouml = "Ö";
var ouml = "ö";
var para = "¶";
var plusmn = "±";
var pound = "£";
var quot$1 = "\"";
var QUOT = "\"";
var raquo = "»";
var reg = "®";
var REG = "®";
var sect = "§";
var shy = "­";
var sup1 = "¹";
var sup2 = "²";
var sup3 = "³";
var szlig = "ß";
var THORN = "Þ";
var thorn = "þ";
var times = "×";
var Uacute = "Ú";
var uacute = "ú";
var Ucirc = "Û";
var ucirc = "û";
var Ugrave = "Ù";
var ugrave = "ù";
var uml = "¨";
var Uuml = "Ü";
var uuml = "ü";
var Yacute = "Ý";
var yacute = "ý";
var yen = "¥";
var yuml = "ÿ";
var require$$2 = {
	Aacute: Aacute,
	aacute: aacute,
	Acirc: Acirc,
	acirc: acirc,
	acute: acute,
	AElig: AElig,
	aelig: aelig,
	Agrave: Agrave,
	agrave: agrave,
	amp: amp$1,
	AMP: AMP,
	Aring: Aring,
	aring: aring,
	Atilde: Atilde,
	atilde: atilde,
	Auml: Auml,
	auml: auml,
	brvbar: brvbar,
	Ccedil: Ccedil,
	ccedil: ccedil,
	cedil: cedil,
	cent: cent,
	copy: copy$3,
	COPY: COPY,
	curren: curren,
	deg: deg,
	divide: divide,
	Eacute: Eacute,
	eacute: eacute,
	Ecirc: Ecirc,
	ecirc: ecirc,
	Egrave: Egrave,
	egrave: egrave,
	ETH: ETH,
	eth: eth,
	Euml: Euml,
	euml: euml,
	frac12: frac12,
	frac14: frac14,
	frac34: frac34,
	gt: gt$1,
	GT: GT,
	Iacute: Iacute,
	iacute: iacute,
	Icirc: Icirc,
	icirc: icirc,
	iexcl: iexcl,
	Igrave: Igrave,
	igrave: igrave,
	iquest: iquest,
	Iuml: Iuml,
	iuml: iuml,
	laquo: laquo,
	lt: lt$1,
	LT: LT,
	macr: macr,
	micro: micro,
	middot: middot,
	nbsp: nbsp,
	not: not$1,
	Ntilde: Ntilde,
	ntilde: ntilde,
	Oacute: Oacute,
	oacute: oacute,
	Ocirc: Ocirc,
	ocirc: ocirc,
	Ograve: Ograve,
	ograve: ograve,
	ordf: ordf,
	ordm: ordm,
	Oslash: Oslash,
	oslash: oslash,
	Otilde: Otilde,
	otilde: otilde,
	Ouml: Ouml,
	ouml: ouml,
	para: para,
	plusmn: plusmn,
	pound: pound,
	quot: quot$1,
	QUOT: QUOT,
	raquo: raquo,
	reg: reg,
	REG: REG,
	sect: sect,
	shy: shy,
	sup1: sup1,
	sup2: sup2,
	sup3: sup3,
	szlig: szlig,
	THORN: THORN,
	thorn: thorn,
	times: times,
	Uacute: Uacute,
	uacute: uacute,
	Ucirc: Ucirc,
	ucirc: ucirc,
	Ugrave: Ugrave,
	ugrave: ugrave,
	uml: uml,
	Uuml: Uuml,
	uuml: uuml,
	Yacute: Yacute,
	yacute: yacute,
	yen: yen,
	yuml: yuml
};

var amp = "&";
var apos = "'";
var gt = ">";
var lt = "<";
var quot = "\"";
var require$$3 = {
	amp: amp,
	apos: apos,
	gt: gt,
	lt: lt,
	quot: quot
};

var decode_codepoint = {};

var require$$0$1 = {
	"0": 65533,
	"128": 8364,
	"130": 8218,
	"131": 402,
	"132": 8222,
	"133": 8230,
	"134": 8224,
	"135": 8225,
	"136": 710,
	"137": 8240,
	"138": 352,
	"139": 8249,
	"140": 338,
	"142": 381,
	"145": 8216,
	"146": 8217,
	"147": 8220,
	"148": 8221,
	"149": 8226,
	"150": 8211,
	"151": 8212,
	"152": 732,
	"153": 8482,
	"154": 353,
	"155": 8250,
	"156": 339,
	"158": 382,
	"159": 376
};

var __importDefault$7 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(decode_codepoint, "__esModule", { value: true });
var decode_json_1 = __importDefault$7(require$$0$1);
// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
var fromCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.fromCodePoint ||
    function (codePoint) {
        var output = "";
        if (codePoint > 0xffff) {
            codePoint -= 0x10000;
            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
            codePoint = 0xdc00 | (codePoint & 0x3ff);
        }
        output += String.fromCharCode(codePoint);
        return output;
    };
function decodeCodePoint(codePoint) {
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
        return "\uFFFD";
    }
    if (codePoint in decode_json_1.default) {
        codePoint = decode_json_1.default[codePoint];
    }
    return fromCodePoint(codePoint);
}
decode_codepoint.default = decodeCodePoint;

var __importDefault$6 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(decode, "__esModule", { value: true });
decode.decodeHTML = decode.decodeHTMLStrict = decode.decodeXML = void 0;
var entities_json_1$2 = __importDefault$6(require$$1);
var legacy_json_1$1 = __importDefault$6(require$$2);
var xml_json_1$2 = __importDefault$6(require$$3);
var decode_codepoint_1$1 = __importDefault$6(decode_codepoint);
var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
decode.decodeXML = getStrictDecoder(xml_json_1$2.default);
decode.decodeHTMLStrict = getStrictDecoder(entities_json_1$2.default);
function getStrictDecoder(map) {
    var replace = getReplacer(map);
    return function (str) { return String(str).replace(strictEntityRe, replace); };
}
var sorter = function (a, b) { return (a < b ? 1 : -1); };
decode.decodeHTML = (function () {
    var legacy = Object.keys(legacy_json_1$1.default).sort(sorter);
    var keys = Object.keys(entities_json_1$2.default).sort(sorter);
    for (var i = 0, j = 0; i < keys.length; i++) {
        if (legacy[j] === keys[i]) {
            keys[i] += ";?";
            j++;
        }
        else {
            keys[i] += ";";
        }
    }
    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
    var replace = getReplacer(entities_json_1$2.default);
    function replacer(str) {
        if (str.substr(-1) !== ";")
            str += ";";
        return replace(str);
    }
    // TODO consider creating a merged map
    return function (str) { return String(str).replace(re, replacer); };
})();
function getReplacer(map) {
    return function replace(str) {
        if (str.charAt(1) === "#") {
            var secondChar = str.charAt(2);
            if (secondChar === "X" || secondChar === "x") {
                return decode_codepoint_1$1.default(parseInt(str.substr(3), 16));
            }
            return decode_codepoint_1$1.default(parseInt(str.substr(2), 10));
        }
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        return map[str.slice(1, -1)] || str;
    };
}

var encode$1 = {};

var __importDefault$5 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(encode$1, "__esModule", { value: true });
encode$1.escapeUTF8 = encode$1.escape = encode$1.encodeNonAsciiHTML = encode$1.encodeHTML = encode$1.encodeXML = void 0;
var xml_json_1$1 = __importDefault$5(require$$3);
var inverseXML = getInverseObj(xml_json_1$1.default);
var xmlReplacer = getInverseReplacer(inverseXML);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using XML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
encode$1.encodeXML = getASCIIEncoder(inverseXML);
var entities_json_1$1 = __importDefault$5(require$$1);
var inverseHTML = getInverseObj(entities_json_1$1.default);
var htmlReplacer = getInverseReplacer(inverseHTML);
/**
 * Encodes all entities and non-ASCII characters in the input.
 *
 * This includes characters that are valid ASCII characters in HTML documents.
 * For example `#` will be encoded as `&num;`. To get a more compact output,
 * consider using the `encodeNonAsciiHTML` function.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
encode$1.encodeHTML = getInverse(inverseHTML, htmlReplacer);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in HTML
 * documents using HTML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
encode$1.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
function getInverseObj(obj) {
    return Object.keys(obj)
        .sort()
        .reduce(function (inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
    }, {});
}
function getInverseReplacer(inverse) {
    var single = [];
    var multiple = [];
    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
        var k = _a[_i];
        if (k.length === 1) {
            // Add value to single array
            single.push("\\" + k);
        }
        else {
            // Add value to multiple array
            multiple.push(k);
        }
    }
    // Add ranges to single characters.
    single.sort();
    for (var start = 0; start < single.length - 1; start++) {
        // Find the end of a run of characters
        var end = start;
        while (end < single.length - 1 &&
            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
            end += 1;
        }
        var count = 1 + end - start;
        // We want to replace at least three characters
        if (count < 3)
            continue;
        single.splice(start, count, single[start] + "-" + single[end]);
    }
    multiple.unshift("[" + single.join("") + "]");
    return new RegExp(multiple.join("|"), "g");
}
// /[^\0-\x7F]/gu
var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
var getCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.prototype.codePointAt != null
    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        function (str) { return str.codePointAt(0); }
    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        function (c) {
            return (c.charCodeAt(0) - 0xd800) * 0x400 +
                c.charCodeAt(1) -
                0xdc00 +
                0x10000;
        };
function singleCharReplacer(c) {
    return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))
        .toString(16)
        .toUpperCase() + ";";
}
function getInverse(inverse, re) {
    return function (data) {
        return data
            .replace(re, function (name) { return inverse[name]; })
            .replace(reNonASCII, singleCharReplacer);
    };
}
var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
 *
 * Have a look at `escapeUTF8` if you want a more concise output at the expense
 * of reduced transportability.
 *
 * @param data String to escape.
 */
function escape$1(data) {
    return data.replace(reEscapeChars, singleCharReplacer);
}
encode$1.escape = escape$1;
/**
 * Encodes all characters not valid in XML documents using numeric hexadecimal
 * reference (eg. `&#xfc;`).
 *
 * Note that the output will be character-set dependent.
 *
 * @param data String to escape.
 */
function escapeUTF8(data) {
    return data.replace(xmlReplacer, singleCharReplacer);
}
encode$1.escapeUTF8 = escapeUTF8;
function getASCIIEncoder(obj) {
    return function (data) {
        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });
    };
}

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
var decode_1 = decode;
var encode_1 = encode$1;
/**
 * Decodes a string with entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `decodeXML` or `decodeHTML` directly.
 */
function decode$1(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
}
exports.decode = decode$1;
/**
 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.
 */
function decodeStrict(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
}
exports.decodeStrict = decodeStrict;
/**
 * Encodes a string with entities.
 *
 * @param data String to encode.
 * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.
 */
function encode(data, level) {
    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
}
exports.encode = encode;
var encode_2 = encode$1;
Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function () { return encode_2.encodeXML; } });
Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } });
Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return encode_2.escape; } });
Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function () { return encode_2.escapeUTF8; } });
// Legacy aliases (deprecated)
Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
var decode_2 = decode;
Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function () { return decode_2.decodeXML; } });
Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
// Legacy aliases (deprecated)
Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function () { return decode_2.decodeXML; } });
}(lib$4));

var foreignNames = {};

Object.defineProperty(foreignNames, "__esModule", { value: true });
foreignNames.attributeNames = foreignNames.elementNames = void 0;
foreignNames.elementNames = new Map([
    ["altglyph", "altGlyph"],
    ["altglyphdef", "altGlyphDef"],
    ["altglyphitem", "altGlyphItem"],
    ["animatecolor", "animateColor"],
    ["animatemotion", "animateMotion"],
    ["animatetransform", "animateTransform"],
    ["clippath", "clipPath"],
    ["feblend", "feBlend"],
    ["fecolormatrix", "feColorMatrix"],
    ["fecomponenttransfer", "feComponentTransfer"],
    ["fecomposite", "feComposite"],
    ["feconvolvematrix", "feConvolveMatrix"],
    ["fediffuselighting", "feDiffuseLighting"],
    ["fedisplacementmap", "feDisplacementMap"],
    ["fedistantlight", "feDistantLight"],
    ["fedropshadow", "feDropShadow"],
    ["feflood", "feFlood"],
    ["fefunca", "feFuncA"],
    ["fefuncb", "feFuncB"],
    ["fefuncg", "feFuncG"],
    ["fefuncr", "feFuncR"],
    ["fegaussianblur", "feGaussianBlur"],
    ["feimage", "feImage"],
    ["femerge", "feMerge"],
    ["femergenode", "feMergeNode"],
    ["femorphology", "feMorphology"],
    ["feoffset", "feOffset"],
    ["fepointlight", "fePointLight"],
    ["fespecularlighting", "feSpecularLighting"],
    ["fespotlight", "feSpotLight"],
    ["fetile", "feTile"],
    ["feturbulence", "feTurbulence"],
    ["foreignobject", "foreignObject"],
    ["glyphref", "glyphRef"],
    ["lineargradient", "linearGradient"],
    ["radialgradient", "radialGradient"],
    ["textpath", "textPath"],
]);
foreignNames.attributeNames = new Map([
    ["definitionurl", "definitionURL"],
    ["attributename", "attributeName"],
    ["attributetype", "attributeType"],
    ["basefrequency", "baseFrequency"],
    ["baseprofile", "baseProfile"],
    ["calcmode", "calcMode"],
    ["clippathunits", "clipPathUnits"],
    ["diffuseconstant", "diffuseConstant"],
    ["edgemode", "edgeMode"],
    ["filterunits", "filterUnits"],
    ["glyphref", "glyphRef"],
    ["gradienttransform", "gradientTransform"],
    ["gradientunits", "gradientUnits"],
    ["kernelmatrix", "kernelMatrix"],
    ["kernelunitlength", "kernelUnitLength"],
    ["keypoints", "keyPoints"],
    ["keysplines", "keySplines"],
    ["keytimes", "keyTimes"],
    ["lengthadjust", "lengthAdjust"],
    ["limitingconeangle", "limitingConeAngle"],
    ["markerheight", "markerHeight"],
    ["markerunits", "markerUnits"],
    ["markerwidth", "markerWidth"],
    ["maskcontentunits", "maskContentUnits"],
    ["maskunits", "maskUnits"],
    ["numoctaves", "numOctaves"],
    ["pathlength", "pathLength"],
    ["patterncontentunits", "patternContentUnits"],
    ["patterntransform", "patternTransform"],
    ["patternunits", "patternUnits"],
    ["pointsatx", "pointsAtX"],
    ["pointsaty", "pointsAtY"],
    ["pointsatz", "pointsAtZ"],
    ["preservealpha", "preserveAlpha"],
    ["preserveaspectratio", "preserveAspectRatio"],
    ["primitiveunits", "primitiveUnits"],
    ["refx", "refX"],
    ["refy", "refY"],
    ["repeatcount", "repeatCount"],
    ["repeatdur", "repeatDur"],
    ["requiredextensions", "requiredExtensions"],
    ["requiredfeatures", "requiredFeatures"],
    ["specularconstant", "specularConstant"],
    ["specularexponent", "specularExponent"],
    ["spreadmethod", "spreadMethod"],
    ["startoffset", "startOffset"],
    ["stddeviation", "stdDeviation"],
    ["stitchtiles", "stitchTiles"],
    ["surfacescale", "surfaceScale"],
    ["systemlanguage", "systemLanguage"],
    ["tablevalues", "tableValues"],
    ["targetx", "targetX"],
    ["targety", "targetY"],
    ["textlength", "textLength"],
    ["viewbox", "viewBox"],
    ["viewtarget", "viewTarget"],
    ["xchannelselector", "xChannelSelector"],
    ["ychannelselector", "yChannelSelector"],
    ["zoomandpan", "zoomAndPan"],
]);

var __assign$1 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
    __assign$1 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};
var __createBinding$1 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$1 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$1 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result, mod, k);
    __setModuleDefault$1(result, mod);
    return result;
};
Object.defineProperty(lib$5, "__esModule", { value: true });
/*
 * Module dependencies
 */
var ElementType = __importStar$1(lib$6);
var entities_1 = lib$4;
/**
 * Mixed-case SVG and MathML tags & attributes
 * recognized by the HTML parser.
 *
 * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
 */
var foreignNames_1 = foreignNames;
var unencodedElements = new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript",
]);
/**
 * Format attributes
 */
function formatAttributes(attributes, opts) {
    if (!attributes)
        return;
    return Object.keys(attributes)
        .map(function (key) {
        var _a, _b;
        var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
        if (opts.xmlMode === "foreign") {
            /* Fix up mixed-case attribute names */
            key = (_b = foreignNames_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
            return key;
        }
        return key + "=\"" + (opts.decodeEntities !== false
            ? entities_1.encodeXML(value)
            : value.replace(/"/g, "&quot;")) + "\"";
    })
        .join(" ");
}
/**
 * Self-enclosing tags
 */
var singleTag = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr",
]);
/**
 * Renders a DOM node or an array of DOM nodes to a string.
 *
 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
 *
 * @param node Node to be rendered.
 * @param options Changes serialization behavior
 */
function render$2(node, options) {
    if (options === void 0) { options = {}; }
    var nodes = "length" in node ? node : [node];
    var output = "";
    for (var i = 0; i < nodes.length; i++) {
        output += renderNode(nodes[i], options);
    }
    return output;
}
lib$5.default = render$2;
function renderNode(node, options) {
    switch (node.type) {
        case ElementType.Root:
            return render$2(node.children, options);
        case ElementType.Directive:
        case ElementType.Doctype:
            return renderDirective(node);
        case ElementType.Comment:
            return renderComment(node);
        case ElementType.CDATA:
            return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
            return renderTag(node, options);
        case ElementType.Text:
            return renderText(node, options);
    }
}
var foreignModeIntegrationPoints = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title",
]);
var foreignElements = new Set(["svg", "math"]);
function renderTag(elem, opts) {
    var _a;
    // Handle SVG / MathML in HTML
    if (opts.xmlMode === "foreign") {
        /* Fix up mixed-case element names */
        elem.name = (_a = foreignNames_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        /* Exit foreign mode at integration points */
        if (elem.parent &&
            foreignModeIntegrationPoints.has(elem.parent.name)) {
            opts = __assign$1(__assign$1({}, opts), { xmlMode: false });
        }
    }
    if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign$1(__assign$1({}, opts), { xmlMode: "foreign" });
    }
    var tag = "<" + elem.name;
    var attribs = formatAttributes(elem.attribs, opts);
    if (attribs) {
        tag += " " + attribs;
    }
    if (elem.children.length === 0 &&
        (opts.xmlMode
            ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
                opts.selfClosingTags !== false
            : // User explicitly asked for self-closing tags, even in HTML mode
                opts.selfClosingTags && singleTag.has(elem.name))) {
        if (!opts.xmlMode)
            tag += " ";
        tag += "/>";
    }
    else {
        tag += ">";
        if (elem.children.length > 0) {
            tag += render$2(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
            tag += "</" + elem.name + ">";
        }
    }
    return tag;
}
function renderDirective(elem) {
    return "<" + elem.data + ">";
}
function renderText(elem, opts) {
    var data = elem.data || "";
    // If entities weren't decoded, no need to encode them back
    if (opts.decodeEntities !== false &&
        !(!opts.xmlMode &&
            elem.parent &&
            unencodedElements.has(elem.parent.name))) {
        data = entities_1.encodeXML(data);
    }
    return data;
}
function renderCdata(elem) {
    return "<![CDATA[" + elem.children[0].data + "]]>";
}
function renderComment(elem) {
    return "<!--" + elem.data + "-->";
}

var __importDefault$4 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(stringify$a, "__esModule", { value: true });
stringify$a.innerText = stringify$a.textContent = stringify$a.getText = stringify$a.getInnerHTML = stringify$a.getOuterHTML = void 0;
var domhandler_1$a = lib$7;
var dom_serializer_1 = __importDefault$4(lib$5);
var domelementtype_1 = lib$6;
/**
 * @param node Node to get the outer HTML of.
 * @param options Options for serialization.
 * @deprecated Use the `dom-serializer` module directly.
 * @returns `node`'s outer HTML.
 */
function getOuterHTML(node, options) {
    return (0, dom_serializer_1.default)(node, options);
}
stringify$a.getOuterHTML = getOuterHTML;
/**
 * @param node Node to get the inner HTML of.
 * @param options Options for serialization.
 * @deprecated Use the `dom-serializer` module directly.
 * @returns `node`'s inner HTML.
 */
function getInnerHTML(node, options) {
    return (0, domhandler_1$a.hasChildren)(node)
        ? node.children.map(function (node) { return getOuterHTML(node, options); }).join("")
        : "";
}
stringify$a.getInnerHTML = getInnerHTML;
/**
 * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags.
 *
 * @deprecated Use `textContent` instead.
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 */
function getText(node) {
    if (Array.isArray(node))
        return node.map(getText).join("");
    if ((0, domhandler_1$a.isTag)(node))
        return node.name === "br" ? "\n" : getText(node.children);
    if ((0, domhandler_1$a.isCDATA)(node))
        return getText(node.children);
    if ((0, domhandler_1$a.isText)(node))
        return node.data;
    return "";
}
stringify$a.getText = getText;
/**
 * Get a node's text content.
 *
 * @param node Node to get the text content of.
 * @returns `node`'s text content.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
 */
function textContent(node) {
    if (Array.isArray(node))
        return node.map(textContent).join("");
    if ((0, domhandler_1$a.hasChildren)(node) && !(0, domhandler_1$a.isComment)(node)) {
        return textContent(node.children);
    }
    if ((0, domhandler_1$a.isText)(node))
        return node.data;
    return "";
}
stringify$a.textContent = textContent;
/**
 * Get a node's inner text.
 *
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
 */
function innerText(node) {
    if (Array.isArray(node))
        return node.map(innerText).join("");
    if ((0, domhandler_1$a.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1$a.isCDATA)(node))) {
        return innerText(node.children);
    }
    if ((0, domhandler_1$a.isText)(node))
        return node.data;
    return "";
}
stringify$a.innerText = innerText;

var traversal = {};

Object.defineProperty(traversal, "__esModule", { value: true });
traversal.prevElementSibling = traversal.nextElementSibling = traversal.getName = traversal.hasAttrib = traversal.getAttributeValue = traversal.getSiblings = traversal.getParent = traversal.getChildren = void 0;
var domhandler_1$9 = lib$7;
var emptyArray = [];
/**
 * Get a node's children.
 *
 * @param elem Node to get the children of.
 * @returns `elem`'s children, or an empty array.
 */
function getChildren(elem) {
    var _a;
    return (_a = elem.children) !== null && _a !== void 0 ? _a : emptyArray;
}
traversal.getChildren = getChildren;
/**
 * Get a node's parent.
 *
 * @param elem Node to get the parent of.
 * @returns `elem`'s parent node.
 */
function getParent(elem) {
    return elem.parent || null;
}
traversal.getParent = getParent;
/**
 * Gets an elements siblings, including the element itself.
 *
 * Attempts to get the children through the element's parent first.
 * If we don't have a parent (the element is a root node),
 * we walk the element's `prev` & `next` to get all remaining nodes.
 *
 * @param elem Element to get the siblings of.
 * @returns `elem`'s siblings.
 */
function getSiblings(elem) {
    var _a, _b;
    var parent = getParent(elem);
    if (parent != null)
        return getChildren(parent);
    var siblings = [elem];
    var prev = elem.prev, next = elem.next;
    while (prev != null) {
        siblings.unshift(prev);
        (_a = prev, prev = _a.prev);
    }
    while (next != null) {
        siblings.push(next);
        (_b = next, next = _b.next);
    }
    return siblings;
}
traversal.getSiblings = getSiblings;
/**
 * Gets an attribute from an element.
 *
 * @param elem Element to check.
 * @param name Attribute name to retrieve.
 * @returns The element's attribute value, or `undefined`.
 */
function getAttributeValue(elem, name) {
    var _a;
    return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
}
traversal.getAttributeValue = getAttributeValue;
/**
 * Checks whether an element has an attribute.
 *
 * @param elem Element to check.
 * @param name Attribute name to look for.
 * @returns Returns whether `elem` has the attribute `name`.
 */
function hasAttrib(elem, name) {
    return (elem.attribs != null &&
        Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
        elem.attribs[name] != null);
}
traversal.hasAttrib = hasAttrib;
/**
 * Get the tag name of an element.
 *
 * @param elem The element to get the name for.
 * @returns The tag name of `elem`.
 */
function getName(elem) {
    return elem.name;
}
traversal.getName = getName;
/**
 * Returns the next element sibling of a node.
 *
 * @param elem The element to get the next sibling of.
 * @returns `elem`'s next sibling that is a tag.
 */
function nextElementSibling(elem) {
    var _a;
    var next = elem.next;
    while (next !== null && !(0, domhandler_1$9.isTag)(next))
        (_a = next, next = _a.next);
    return next;
}
traversal.nextElementSibling = nextElementSibling;
/**
 * Returns the previous element sibling of a node.
 *
 * @param elem The element to get the previous sibling of.
 * @returns `elem`'s previous sibling that is a tag.
 */
function prevElementSibling(elem) {
    var _a;
    var prev = elem.prev;
    while (prev !== null && !(0, domhandler_1$9.isTag)(prev))
        (_a = prev, prev = _a.prev);
    return prev;
}
traversal.prevElementSibling = prevElementSibling;

var manipulation$1 = {};

Object.defineProperty(manipulation$1, "__esModule", { value: true });
manipulation$1.prepend = manipulation$1.prependChild = manipulation$1.append = manipulation$1.appendChild = manipulation$1.replaceElement = manipulation$1.removeElement = void 0;
/**
 * Remove an element from the dom
 *
 * @param elem The element to be removed
 */
function removeElement(elem) {
    if (elem.prev)
        elem.prev.next = elem.next;
    if (elem.next)
        elem.next.prev = elem.prev;
    if (elem.parent) {
        var childs = elem.parent.children;
        childs.splice(childs.lastIndexOf(elem), 1);
    }
}
manipulation$1.removeElement = removeElement;
/**
 * Replace an element in the dom
 *
 * @param elem The element to be replaced
 * @param replacement The element to be added
 */
function replaceElement(elem, replacement) {
    var prev = (replacement.prev = elem.prev);
    if (prev) {
        prev.next = replacement;
    }
    var next = (replacement.next = elem.next);
    if (next) {
        next.prev = replacement;
    }
    var parent = (replacement.parent = elem.parent);
    if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
    }
}
manipulation$1.replaceElement = replaceElement;
/**
 * Append a child to an element.
 *
 * @param elem The element to append to.
 * @param child The element to be added as a child.
 */
function appendChild$2(elem, child) {
    removeElement(child);
    child.next = null;
    child.parent = elem;
    if (elem.children.push(child) > 1) {
        var sibling = elem.children[elem.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
    }
    else {
        child.prev = null;
    }
}
manipulation$1.appendChild = appendChild$2;
/**
 * Append an element after another.
 *
 * @param elem The element to append after.
 * @param next The element be added.
 */
function append$1(elem, next) {
    removeElement(next);
    var parent = elem.parent;
    var currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
        currNext.prev = next;
        if (parent) {
            var childs = parent.children;
            childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
    }
    else if (parent) {
        parent.children.push(next);
    }
}
manipulation$1.append = append$1;
/**
 * Prepend a child to an element.
 *
 * @param elem The element to prepend before.
 * @param child The element to be added as a child.
 */
function prependChild(elem, child) {
    removeElement(child);
    child.parent = elem;
    child.prev = null;
    if (elem.children.unshift(child) !== 1) {
        var sibling = elem.children[1];
        sibling.prev = child;
        child.next = sibling;
    }
    else {
        child.next = null;
    }
}
manipulation$1.prependChild = prependChild;
/**
 * Prepend an element before another.
 *
 * @param elem The element to prepend before.
 * @param prev The element be added.
 */
function prepend(elem, prev) {
    removeElement(prev);
    var parent = elem.parent;
    if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
    }
    if (elem.prev) {
        elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
}
manipulation$1.prepend = prepend;

var querying = {};

Object.defineProperty(querying, "__esModule", { value: true });
querying.findAll = querying.existsOne = querying.findOne = querying.findOneChild = querying.find = querying.filter = void 0;
var domhandler_1$8 = lib$7;
/**
 * Search a node and its children for nodes passing a test function.
 *
 * @param test Function to test nodes on.
 * @param node Node to search. Will be included in the result set if it matches.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function filter$1(test, node, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    if (!Array.isArray(node))
        node = [node];
    return find$1(test, node, recurse, limit);
}
querying.filter = filter$1;
/**
 * Search an array of node and its children for nodes passing a test function.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function find$1(test, nodes, recurse, limit) {
    var result = [];
    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var elem = nodes_1[_i];
        if (test(elem)) {
            result.push(elem);
            if (--limit <= 0)
                break;
        }
        if (recurse && (0, domhandler_1$8.hasChildren)(elem) && elem.children.length > 0) {
            var children = find$1(test, elem.children, recurse, limit);
            result.push.apply(result, children);
            limit -= children.length;
            if (limit <= 0)
                break;
        }
    }
    return result;
}
querying.find = find$1;
/**
 * Finds the first element inside of an array that matches a test function.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns The first node in the array that passes `test`.
 */
function findOneChild(test, nodes) {
    return nodes.find(test);
}
querying.findOneChild = findOneChild;
/**
 * Finds one element in a tree that passes a test.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @returns The first child node that passes `test`.
 */
function findOne(test, nodes, recurse) {
    if (recurse === void 0) { recurse = true; }
    var elem = null;
    for (var i = 0; i < nodes.length && !elem; i++) {
        var checked = nodes[i];
        if (!(0, domhandler_1$8.isTag)(checked)) {
            continue;
        }
        else if (test(checked)) {
            elem = checked;
        }
        else if (recurse && checked.children.length > 0) {
            elem = findOne(test, checked.children);
        }
    }
    return elem;
}
querying.findOne = findOne;
/**
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns Whether a tree of nodes contains at least one node passing a test.
 */
function existsOne(test, nodes) {
    return nodes.some(function (checked) {
        return (0, domhandler_1$8.isTag)(checked) &&
            (test(checked) ||
                (checked.children.length > 0 &&
                    existsOne(test, checked.children)));
    });
}
querying.existsOne = existsOne;
/**
 * Search and array of nodes and its children for nodes passing a test function.
 *
 * Same as `find`, only with less options, leading to reduced complexity.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns All nodes passing `test`.
 */
function findAll(test, nodes) {
    var _a;
    var result = [];
    var stack = nodes.filter(domhandler_1$8.isTag);
    var elem;
    while ((elem = stack.shift())) {
        var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(domhandler_1$8.isTag);
        if (children && children.length > 0) {
            stack.unshift.apply(stack, children);
        }
        if (test(elem))
            result.push(elem);
    }
    return result;
}
querying.findAll = findAll;

var legacy$2 = {};

Object.defineProperty(legacy$2, "__esModule", { value: true });
legacy$2.getElementsByTagType = legacy$2.getElementsByTagName = legacy$2.getElementById = legacy$2.getElements = legacy$2.testElement = void 0;
var domhandler_1$7 = lib$7;
var querying_1 = querying;
var Checks = {
    tag_name: function (name) {
        if (typeof name === "function") {
            return function (elem) { return (0, domhandler_1$7.isTag)(elem) && name(elem.name); };
        }
        else if (name === "*") {
            return domhandler_1$7.isTag;
        }
        return function (elem) { return (0, domhandler_1$7.isTag)(elem) && elem.name === name; };
    },
    tag_type: function (type) {
        if (typeof type === "function") {
            return function (elem) { return type(elem.type); };
        }
        return function (elem) { return elem.type === type; };
    },
    tag_contains: function (data) {
        if (typeof data === "function") {
            return function (elem) { return (0, domhandler_1$7.isText)(elem) && data(elem.data); };
        }
        return function (elem) { return (0, domhandler_1$7.isText)(elem) && elem.data === data; };
    },
};
/**
 * @param attrib Attribute to check.
 * @param value Attribute value to look for.
 * @returns A function to check whether the a node has an attribute with a particular value.
 */
function getAttribCheck(attrib, value) {
    if (typeof value === "function") {
        return function (elem) { return (0, domhandler_1$7.isTag)(elem) && value(elem.attribs[attrib]); };
    }
    return function (elem) { return (0, domhandler_1$7.isTag)(elem) && elem.attribs[attrib] === value; };
}
/**
 * @param a First function to combine.
 * @param b Second function to combine.
 * @returns A function taking a node and returning `true` if either
 * of the input functions returns `true` for the node.
 */
function combineFuncs(a, b) {
    return function (elem) { return a(elem) || b(elem); };
}
/**
 * @param options An object describing nodes to look for.
 * @returns A function executing all checks in `options` and returning `true`
 * if any of them match a node.
 */
function compileTest(options) {
    var funcs = Object.keys(options).map(function (key) {
        var value = options[key];
        return Object.prototype.hasOwnProperty.call(Checks, key)
            ? Checks[key](value)
            : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
/**
 * @param options An object describing nodes to look for.
 * @param node The element to test.
 * @returns Whether the element matches the description in `options`.
 */
function testElement(options, node) {
    var test = compileTest(options);
    return test ? test(node) : true;
}
legacy$2.testElement = testElement;
/**
 * @param options An object describing nodes to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes that match `options`.
 */
function getElements$1(options, nodes, recurse, limit) {
    if (limit === void 0) { limit = Infinity; }
    var test = compileTest(options);
    return test ? (0, querying_1.filter)(test, nodes, recurse, limit) : [];
}
legacy$2.getElements = getElements$1;
/**
 * @param id The unique ID attribute value to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @returns The node with the supplied ID.
 */
function getElementById(id, nodes, recurse) {
    if (recurse === void 0) { recurse = true; }
    if (!Array.isArray(nodes))
        nodes = [nodes];
    return (0, querying_1.findOne)(getAttribCheck("id", id), nodes, recurse);
}
legacy$2.getElementById = getElementById;
/**
 * @param tagName Tag name to search for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `tagName`.
 */
function getElementsByTagName(tagName, nodes, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    return (0, querying_1.filter)(Checks.tag_name(tagName), nodes, recurse, limit);
}
legacy$2.getElementsByTagName = getElementsByTagName;
/**
 * @param type Element type to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `type`.
 */
function getElementsByTagType(type, nodes, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    return (0, querying_1.filter)(Checks.tag_type(type), nodes, recurse, limit);
}
legacy$2.getElementsByTagType = getElementsByTagType;

var helpers$1 = {};

Object.defineProperty(helpers$1, "__esModule", { value: true });
helpers$1.uniqueSort = helpers$1.compareDocumentPosition = helpers$1.removeSubsets = void 0;
var domhandler_1$6 = lib$7;
/**
 * Given an array of nodes, remove any member that is contained by another.
 *
 * @param nodes Nodes to filter.
 * @returns Remaining nodes that aren't subtrees of each other.
 */
function removeSubsets(nodes) {
    var idx = nodes.length;
    /*
     * Check if each node (or one of its ancestors) is already contained in the
     * array.
     */
    while (--idx >= 0) {
        var node = nodes[idx];
        /*
         * Remove the node if it is not unique.
         * We are going through the array from the end, so we only
         * have to check nodes that preceed the node under consideration in the array.
         */
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
            nodes.splice(idx, 1);
            continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
            if (nodes.includes(ancestor)) {
                nodes.splice(idx, 1);
                break;
            }
        }
    }
    return nodes;
}
helpers$1.removeSubsets = removeSubsets;
/**
 * Compare the position of one node against another node in any other document.
 * The return value is a bitmask with the following values:
 *
 * Document order:
 * > There is an ordering, document order, defined on all the nodes in the
 * > document corresponding to the order in which the first character of the
 * > XML representation of each node occurs in the XML representation of the
 * > document after expansion of general entities. Thus, the document element
 * > node will be the first node. Element nodes occur before their children.
 * > Thus, document order orders element nodes in order of the occurrence of
 * > their start-tag in the XML (after expansion of entities). The attribute
 * > nodes of an element occur after the element and before its children. The
 * > relative order of attribute nodes is implementation-dependent./
 *
 * Source:
 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
 *
 * @param nodeA The first node to use in the comparison
 * @param nodeB The second node to use in the comparison
 * @returns A bitmask describing the input nodes' relative position.
 *
 * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
 * a description of these values.
 */
function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
        return 0;
    }
    var current = (0, domhandler_1$6.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
        aParents.unshift(current);
        current = current.parent;
    }
    current = (0, domhandler_1$6.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
        bParents.unshift(current);
        current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
    }
    if (idx === 0) {
        return 1 /* DISCONNECTED */;
    }
    var sharedParent = aParents[idx - 1];
    var siblings = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
            return 4 /* FOLLOWING */ | 16 /* CONTAINED_BY */;
        }
        return 4 /* FOLLOWING */;
    }
    if (sharedParent === nodeA) {
        return 2 /* PRECEDING */ | 8 /* CONTAINS */;
    }
    return 2 /* PRECEDING */;
}
helpers$1.compareDocumentPosition = compareDocumentPosition;
/**
 * Sort an array of nodes based on their relative position in the document and
 * remove any duplicate nodes. If the array contains nodes that do not belong
 * to the same document, sort order is unspecified.
 *
 * @param nodes Array of DOM nodes.
 * @returns Collection of unique nodes, sorted in document order.
 */
function uniqueSort$1(nodes) {
    nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });
    nodes.sort(function (a, b) {
        var relative = compareDocumentPosition(a, b);
        if (relative & 2 /* PRECEDING */) {
            return -1;
        }
        else if (relative & 4 /* FOLLOWING */) {
            return 1;
        }
        return 0;
    });
    return nodes;
}
helpers$1.uniqueSort = uniqueSort$1;

var feeds = {};

Object.defineProperty(feeds, "__esModule", { value: true });
feeds.getFeed = void 0;
var stringify_1 = stringify$a;
var legacy_1 = legacy$2;
/**
 * Get the feed object from the root of a DOM tree.
 *
 * @param doc - The DOM to to extract the feed from.
 * @returns The feed.
 */
function getFeed(doc) {
    var feedRoot = getOneElement$1(isValidFeed$1, doc);
    return !feedRoot
        ? null
        : feedRoot.name === "feed"
            ? getAtomFeed(feedRoot)
            : getRssFeed(feedRoot);
}
feeds.getFeed = getFeed;
/**
 * Parse an Atom feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getAtomFeed(feedRoot) {
    var _a;
    var childs = feedRoot.children;
    var feed = {
        type: "atom",
        items: (0, legacy_1.getElementsByTagName)("entry", childs).map(function (item) {
            var _a;
            var children = item.children;
            var entry = { media: getMediaElements$1(children) };
            addConditionally$1(entry, "id", "id", children);
            addConditionally$1(entry, "title", "title", children);
            var href = (_a = getOneElement$1("link", children)) === null || _a === void 0 ? void 0 : _a.attribs.href;
            if (href) {
                entry.link = href;
            }
            var description = fetch$1("summary", children) || fetch$1("content", children);
            if (description) {
                entry.description = description;
            }
            var pubDate = fetch$1("updated", children);
            if (pubDate) {
                entry.pubDate = new Date(pubDate);
            }
            return entry;
        }),
    };
    addConditionally$1(feed, "id", "id", childs);
    addConditionally$1(feed, "title", "title", childs);
    var href = (_a = getOneElement$1("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs.href;
    if (href) {
        feed.link = href;
    }
    addConditionally$1(feed, "description", "subtitle", childs);
    var updated = fetch$1("updated", childs);
    if (updated) {
        feed.updated = new Date(updated);
    }
    addConditionally$1(feed, "author", "email", childs, true);
    return feed;
}
/**
 * Parse a RSS feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getRssFeed(feedRoot) {
    var _a, _b;
    var childs = (_b = (_a = getOneElement$1("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
    var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_1.getElementsByTagName)("item", feedRoot.children).map(function (item) {
            var children = item.children;
            var entry = { media: getMediaElements$1(children) };
            addConditionally$1(entry, "id", "guid", children);
            addConditionally$1(entry, "title", "title", children);
            addConditionally$1(entry, "link", "link", children);
            addConditionally$1(entry, "description", "description", children);
            var pubDate = fetch$1("pubDate", children);
            if (pubDate)
                entry.pubDate = new Date(pubDate);
            return entry;
        }),
    };
    addConditionally$1(feed, "title", "title", childs);
    addConditionally$1(feed, "link", "link", childs);
    addConditionally$1(feed, "description", "description", childs);
    var updated = fetch$1("lastBuildDate", childs);
    if (updated) {
        feed.updated = new Date(updated);
    }
    addConditionally$1(feed, "author", "managingEditor", childs, true);
    return feed;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = [
    "fileSize",
    "bitrate",
    "framerate",
    "samplingrate",
    "channels",
    "duration",
    "height",
    "width",
];
/**
 * Get all media elements of a feed item.
 *
 * @param where Nodes to search in.
 * @returns Media elements.
 */
function getMediaElements$1(where) {
    return (0, legacy_1.getElementsByTagName)("media:content", where).map(function (elem) {
        var attribs = elem.attribs;
        var media = {
            medium: attribs.medium,
            isDefault: !!attribs.isDefault,
        };
        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
            var attrib = MEDIA_KEYS_STRING_1[_i];
            if (attribs[attrib]) {
                media[attrib] = attribs[attrib];
            }
        }
        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
            var attrib = MEDIA_KEYS_INT_1[_a];
            if (attribs[attrib]) {
                media[attrib] = parseInt(attribs[attrib], 10);
            }
        }
        if (attribs.expression) {
            media.expression =
                attribs.expression;
        }
        return media;
    });
}
/**
 * Get one element by tag name.
 *
 * @param tagName Tag name to look for
 * @param node Node to search in
 * @returns The element or null
 */
function getOneElement$1(tagName, node) {
    return (0, legacy_1.getElementsByTagName)(tagName, node, true, 1)[0];
}
/**
 * Get the text content of an element with a certain tag name.
 *
 * @param tagName Tag name to look for.
 * @param where  Node to search in.
 * @param recurse Whether to recurse into child nodes.
 * @returns The text content of the element.
 */
function fetch$1(tagName, where, recurse) {
    if (recurse === void 0) { recurse = false; }
    return (0, stringify_1.textContent)((0, legacy_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
}
/**
 * Adds a property to an object if it has a value.
 *
 * @param obj Object to be extended
 * @param prop Property name
 * @param tagName Tag name that contains the conditionally added property
 * @param where Element to search for the property
 * @param recurse Whether to recurse into child nodes.
 */
function addConditionally$1(obj, prop, tagName, where, recurse) {
    if (recurse === void 0) { recurse = false; }
    var val = fetch$1(tagName, where, recurse);
    if (val)
        obj[prop] = val;
}
/**
 * Checks if an element is a feed root node.
 *
 * @param value The name of the element to check.
 * @returns Whether an element is a feed root node.
 */
function isValidFeed$1(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
}

(function (exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
__exportStar(stringify$a, exports);
__exportStar(traversal, exports);
__exportStar(manipulation$1, exports);
__exportStar(querying, exports);
__exportStar(legacy$2, exports);
__exportStar(helpers$1, exports);
__exportStar(feeds, exports);
/** @deprecated Use these methods from `domhandler` directly. */
var domhandler_1 = lib$7;
Object.defineProperty(exports, "isTag", { enumerable: true, get: function () { return domhandler_1.isTag; } });
Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function () { return domhandler_1.isCDATA; } });
Object.defineProperty(exports, "isText", { enumerable: true, get: function () { return domhandler_1.isText; } });
Object.defineProperty(exports, "isComment", { enumerable: true, get: function () { return domhandler_1.isComment; } });
Object.defineProperty(exports, "isDocument", { enumerable: true, get: function () { return domhandler_1.isDocument; } });
Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function () { return domhandler_1.hasChildren; } });
}(lib$8));

var boolbase = {
	trueFunc: function trueFunc(){
		return true;
	},
	falseFunc: function falseFunc(){
		return false;
	}
};

var compile$5 = {};

var sort = {};

var procedure = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTraversal = exports.procedure = void 0;
exports.procedure = {
    universal: 50,
    tag: 30,
    attribute: 1,
    pseudo: 0,
    "pseudo-element": 0,
    descendant: -1,
    child: -1,
    parent: -1,
    sibling: -1,
    adjacent: -1,
    _flexibleDescendant: -1,
};
function isTraversal(t) {
    return exports.procedure[t.type] < 0;
}
exports.isTraversal = isTraversal;
}(procedure));

Object.defineProperty(sort, "__esModule", { value: true });
var procedure_1$1 = procedure;
var attributes$2 = {
    exists: 10,
    equals: 8,
    not: 7,
    start: 6,
    end: 6,
    any: 5,
    hyphen: 4,
    element: 4,
};
/**
 * Sort the parts of the passed selector,
 * as there is potential for optimization
 * (some types of selectors are faster than others)
 *
 * @param arr Selector to sort
 */
function sortByProcedure(arr) {
    var procs = arr.map(getProcedure);
    for (var i = 1; i < arr.length; i++) {
        var procNew = procs[i];
        if (procNew < 0)
            continue;
        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
            var token = arr[j + 1];
            arr[j + 1] = arr[j];
            arr[j] = token;
            procs[j + 1] = procs[j];
            procs[j] = procNew;
        }
    }
}
sort.default = sortByProcedure;
function getProcedure(token) {
    var proc = procedure_1$1.procedure[token.type];
    if (token.type === "attribute") {
        proc = attributes$2[token.action];
        if (proc === attributes$2.equals && token.name === "id") {
            // Prefer ID selectors (eg. #ID)
            proc = 9;
        }
        if (token.ignoreCase) {
            /*
             * IgnoreCase adds some overhead, prefer "normal" token
             * this is a binary operation, to ensure it's still an int
             */
            proc >>= 1;
        }
    }
    else if (token.type === "pseudo") {
        if (!token.data) {
            proc = 3;
        }
        else if (token.name === "has" || token.name === "contains") {
            proc = 0; // Expensive in any case
        }
        else if (Array.isArray(token.data)) {
            // "matches" and "not"
            proc = 0;
            for (var i = 0; i < token.data.length; i++) {
                // TODO better handling of complex selectors
                if (token.data[i].length !== 1)
                    continue;
                var cur = getProcedure(token.data[i][0]);
                // Avoid executing :has or :contains
                if (cur === 0) {
                    proc = 0;
                    break;
                }
                if (cur > proc)
                    proc = cur;
            }
            if (token.data.length > 1 && proc > 0)
                proc -= 1;
        }
        else {
            proc = 1;
        }
    }
    return proc;
}

var general = {};

var attributes$1 = {};

Object.defineProperty(attributes$1, "__esModule", { value: true });
attributes$1.attributeRules = void 0;
var boolbase_1$2 = boolbase;
/**
 * All reserved characters in a regex, used for escaping.
 *
 * Taken from XRegExp, (c) 2007-2020 Steven Levithan under the MIT license
 * https://github.com/slevithan/xregexp/blob/95eeebeb8fac8754d54eafe2b4743661ac1cf028/src/xregexp.js#L794
 */
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex(value) {
    return value.replace(reChars, "\\$&");
}
/**
 * Attribute selectors
 */
attributes$1.attributeRules = {
    equals: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function (elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    attr.length === value.length &&
                    attr.toLowerCase() === value &&
                    next(elem));
            };
        }
        return function (elem) {
            return adapter.getAttributeValue(elem, name) === value && next(elem);
        };
    },
    hyphen: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function hyphenIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    (attr.length === len || attr.charAt(len) === "-") &&
                    attr.substr(0, len).toLowerCase() === value &&
                    next(elem));
            };
        }
        return function hyphen(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (attr != null &&
                (attr.length === len || attr.charAt(len) === "-") &&
                attr.substr(0, len) === value &&
                next(elem));
        };
    },
    element: function (next, _a, _b) {
        var name = _a.name, value = _a.value, ignoreCase = _a.ignoreCase;
        var adapter = _b.adapter;
        if (/\s/.test(value)) {
            return boolbase_1$2.falseFunc;
        }
        var regex = new RegExp("(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"), ignoreCase ? "i" : "");
        return function element(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (attr != null &&
                attr.length >= value.length &&
                regex.test(attr) &&
                next(elem));
        };
    },
    exists: function (next, _a, _b) {
        var name = _a.name;
        var adapter = _b.adapter;
        return function (elem) { return adapter.hasAttrib(elem, name) && next(elem); };
    },
    start: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (len === 0) {
            return boolbase_1$2.falseFunc;
        }
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function (elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    attr.length >= len &&
                    attr.substr(0, len).toLowerCase() === value &&
                    next(elem));
            };
        }
        return function (elem) {
            var _a;
            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) &&
                next(elem);
        };
    },
    end: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        var len = -value.length;
        if (len === 0) {
            return boolbase_1$2.falseFunc;
        }
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function (elem) {
                var _a;
                return ((_a = adapter
                    .getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
            };
        }
        return function (elem) {
            var _a;
            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) &&
                next(elem);
        };
    },
    any: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name, value = data.value;
        if (value === "") {
            return boolbase_1$2.falseFunc;
        }
        if (data.ignoreCase) {
            var regex_1 = new RegExp(escapeRegex(value), "i");
            return function anyIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    attr.length >= value.length &&
                    regex_1.test(attr) &&
                    next(elem));
            };
        }
        return function (elem) {
            var _a;
            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) &&
                next(elem);
        };
    },
    not: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        if (value === "") {
            return function (elem) {
                return !!adapter.getAttributeValue(elem, name) && next(elem);
            };
        }
        else if (data.ignoreCase) {
            value = value.toLowerCase();
            return function (elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return ((attr == null ||
                    attr.length !== value.length ||
                    attr.toLowerCase() !== value) &&
                    next(elem));
            };
        }
        return function (elem) {
            return adapter.getAttributeValue(elem, name) !== value && next(elem);
        };
    },
};

var pseudoSelectors = {};

var filters = {};

var lib$3 = {};

var parse$d = {};

// Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
Object.defineProperty(parse$d, "__esModule", { value: true });
parse$d.parse = void 0;
// Whitespace as per https://www.w3.org/TR/selectors-3/#lex is " \t\r\n\f"
var whitespace$1 = new Set([9, 10, 12, 13, 32]);
var ZERO = "0".charCodeAt(0);
var NINE = "9".charCodeAt(0);
/**
 * Parses an expression.
 *
 * @throws An `Error` if parsing fails.
 * @returns An array containing the integer step size and the integer offset of the nth rule.
 * @example nthCheck.parse("2n+3"); // returns [2, 3]
 */
function parse$c(formula) {
    formula = formula.trim().toLowerCase();
    if (formula === "even") {
        return [2, 0];
    }
    else if (formula === "odd") {
        return [2, 1];
    }
    // Parse [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
    var idx = 0;
    var a = 0;
    var sign = readSign();
    var number = readNumber();
    if (idx < formula.length && formula.charAt(idx) === "n") {
        idx++;
        a = sign * (number !== null && number !== void 0 ? number : 1);
        skipWhitespace();
        if (idx < formula.length) {
            sign = readSign();
            skipWhitespace();
            number = readNumber();
        }
        else {
            sign = number = 0;
        }
    }
    // Throw if there is anything else
    if (number === null || idx < formula.length) {
        throw new Error("n-th rule couldn't be parsed ('" + formula + "')");
    }
    return [a, sign * number];
    function readSign() {
        if (formula.charAt(idx) === "-") {
            idx++;
            return -1;
        }
        if (formula.charAt(idx) === "+") {
            idx++;
        }
        return 1;
    }
    function readNumber() {
        var start = idx;
        var value = 0;
        while (idx < formula.length &&
            formula.charCodeAt(idx) >= ZERO &&
            formula.charCodeAt(idx) <= NINE) {
            value = value * 10 + (formula.charCodeAt(idx) - ZERO);
            idx++;
        }
        // Return `null` if we didn't read anything.
        return idx === start ? null : value;
    }
    function skipWhitespace() {
        while (idx < formula.length &&
            whitespace$1.has(formula.charCodeAt(idx))) {
            idx++;
        }
    }
}
parse$d.parse = parse$c;

var compile$4 = {};

Object.defineProperty(compile$4, "__esModule", { value: true });
compile$4.compile = void 0;
var boolbase_1$1 = boolbase;
/**
 * Returns a function that checks if an elements index matches the given rule
 * highly optimized to return the fastest solution.
 *
 * @param parsed A tuple [a, b], as returned by `parse`.
 * @returns A highly optimized function that returns whether an index matches the nth-check.
 * @example
 * const check = nthCheck.compile([2, 3]);
 *
 * check(0); // `false`
 * check(1); // `false`
 * check(2); // `true`
 * check(3); // `false`
 * check(4); // `true`
 * check(5); // `false`
 * check(6); // `true`
 */
function compile$3(parsed) {
    var a = parsed[0];
    // Subtract 1 from `b`, to convert from one- to zero-indexed.
    var b = parsed[1] - 1;
    /*
     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.
     * Besides, the specification states that no elements are
     * matched when `a` and `b` are 0.
     *
     * `b < 0` here as we subtracted 1 from `b` above.
     */
    if (b < 0 && a <= 0)
        return boolbase_1$1.falseFunc;
    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).
    if (a === -1)
        return function (index) { return index <= b; };
    if (a === 0)
        return function (index) { return index === b; };
    // When `b <= 0` and `a === 1`, they match any element.
    if (a === 1)
        return b < 0 ? boolbase_1$1.trueFunc : function (index) { return index >= b; };
    /*
     * Otherwise, modulo can be used to check if there is a match.
     *
     * Modulo doesn't care about the sign, so let's use `a`s absolute value.
     */
    var absA = Math.abs(a);
    // Get `b mod a`, + a if this is negative.
    var bMod = ((b % absA) + absA) % absA;
    return a > 1
        ? function (index) { return index >= b && index % absA === bMod; }
        : function (index) { return index <= b && index % absA === bMod; };
}
compile$4.compile = compile$3;

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.compile = exports.parse = void 0;
var parse_1 = parse$d;
Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return parse_1.parse; } });
var compile_1 = compile$4;
Object.defineProperty(exports, "compile", { enumerable: true, get: function () { return compile_1.compile; } });
/**
 * Parses and compiles a formula to a highly optimized function.
 * Combination of `parse` and `compile`.
 *
 * If the formula doesn't match any elements,
 * it returns [`boolbase`](https://github.com/fb55/boolbase)'s `falseFunc`.
 * Otherwise, a function accepting an _index_ is returned, which returns
 * whether or not the passed _index_ matches the formula.
 *
 * Note: The nth-rule starts counting at `1`, the returned function at `0`.
 *
 * @param formula The formula to compile.
 * @example
 * const check = nthCheck("2n+3");
 *
 * check(0); // `false`
 * check(1); // `false`
 * check(2); // `true`
 * check(3); // `false`
 * check(4); // `true`
 * check(5); // `false`
 * check(6); // `true`
 */
function nthCheck(formula) {
    return (0, compile_1.compile)((0, parse_1.parse)(formula));
}
exports.default = nthCheck;
}(lib$3));

(function (exports) {
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.filters = void 0;
var nth_check_1 = __importDefault(lib$3);
var boolbase_1 = boolbase;
function getChildFunc(next, adapter) {
    return function (elem) {
        var parent = adapter.getParent(elem);
        return parent != null && adapter.isTag(parent) && next(elem);
    };
}
exports.filters = {
    contains: function (next, text, _a) {
        var adapter = _a.adapter;
        return function contains(elem) {
            return next(elem) && adapter.getText(elem).includes(text);
        };
    },
    icontains: function (next, text, _a) {
        var adapter = _a.adapter;
        var itext = text.toLowerCase();
        return function icontains(elem) {
            return (next(elem) &&
                adapter.getText(elem).toLowerCase().includes(itext));
        };
    },
    // Location specific methods
    "nth-child": function (next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
        return function nthChild(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = 0; i < siblings.length; i++) {
                if (equals(elem, siblings[i]))
                    break;
                if (adapter.isTag(siblings[i])) {
                    pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    "nth-last-child": function (next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
        return function nthLastChild(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = siblings.length - 1; i >= 0; i--) {
                if (equals(elem, siblings[i]))
                    break;
                if (adapter.isTag(siblings[i])) {
                    pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    "nth-of-type": function (next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
        return function nthOfType(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = 0; i < siblings.length; i++) {
                var currentSibling = siblings[i];
                if (equals(elem, currentSibling))
                    break;
                if (adapter.isTag(currentSibling) &&
                    adapter.getName(currentSibling) === adapter.getName(elem)) {
                    pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    "nth-last-of-type": function (next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
        return function nthLastOfType(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = siblings.length - 1; i >= 0; i--) {
                var currentSibling = siblings[i];
                if (equals(elem, currentSibling))
                    break;
                if (adapter.isTag(currentSibling) &&
                    adapter.getName(currentSibling) === adapter.getName(elem)) {
                    pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    // TODO determine the actual root element
    root: function (next, _rule, _a) {
        var adapter = _a.adapter;
        return function (elem) {
            var parent = adapter.getParent(elem);
            return (parent == null || !adapter.isTag(parent)) && next(elem);
        };
    },
    scope: function (next, rule, options, context) {
        var equals = options.equals;
        if (!context || context.length === 0) {
            // Equivalent to :root
            return exports.filters.root(next, rule, options);
        }
        if (context.length === 1) {
            // NOTE: can't be unpacked, as :has uses this for side-effects
            return function (elem) { return equals(context[0], elem) && next(elem); };
        }
        return function (elem) { return context.includes(elem) && next(elem); };
    },
    hover: dynamicStatePseudo("isHovered"),
    visited: dynamicStatePseudo("isVisited"),
    active: dynamicStatePseudo("isActive"),
};
/**
 * Dynamic state pseudos. These depend on optional Adapter methods.
 *
 * @param name The name of the adapter method to call.
 * @returns Pseudo for the `filters` object.
 */
function dynamicStatePseudo(name) {
    return function dynamicPseudo(next, _rule, _a) {
        var adapter = _a.adapter;
        var func = adapter[name];
        if (typeof func !== "function") {
            return boolbase_1.falseFunc;
        }
        return function active(elem) {
            return func(elem) && next(elem);
        };
    };
}
}(filters));

var pseudos = {};

Object.defineProperty(pseudos, "__esModule", { value: true });
pseudos.verifyPseudoArgs = pseudos.pseudos = void 0;
// While filters are precompiled, pseudos get called when they are needed
pseudos.pseudos = {
    empty: function (elem, _a) {
        var adapter = _a.adapter;
        return !adapter.getChildren(elem).some(function (elem) {
            // FIXME: `getText` call is potentially expensive.
            return adapter.isTag(elem) || adapter.getText(elem) !== "";
        });
    },
    "first-child": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var firstChild = adapter
            .getSiblings(elem)
            .find(function (elem) { return adapter.isTag(elem); });
        return firstChild != null && equals(elem, firstChild);
    },
    "last-child": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
            if (equals(elem, siblings[i]))
                return true;
            if (adapter.isTag(siblings[i]))
                break;
        }
        return false;
    },
    "first-of-type": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i = 0; i < siblings.length; i++) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
                return true;
            if (adapter.isTag(currentSibling) &&
                adapter.getName(currentSibling) === elemName) {
                break;
            }
        }
        return false;
    },
    "last-of-type": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
                return true;
            if (adapter.isTag(currentSibling) &&
                adapter.getName(currentSibling) === elemName) {
                break;
            }
        }
        return false;
    },
    "only-of-type": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var elemName = adapter.getName(elem);
        return adapter
            .getSiblings(elem)
            .every(function (sibling) {
            return equals(elem, sibling) ||
                !adapter.isTag(sibling) ||
                adapter.getName(sibling) !== elemName;
        });
    },
    "only-child": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        return adapter
            .getSiblings(elem)
            .every(function (sibling) { return equals(elem, sibling) || !adapter.isTag(sibling); });
    },
};
function verifyPseudoArgs(func, name, subselect) {
    if (subselect === null) {
        if (func.length > 2) {
            throw new Error("pseudo-selector :".concat(name, " requires an argument"));
        }
    }
    else if (func.length === 2) {
        throw new Error("pseudo-selector :".concat(name, " doesn't have any arguments"));
    }
}
pseudos.verifyPseudoArgs = verifyPseudoArgs;

var aliases = {};

Object.defineProperty(aliases, "__esModule", { value: true });
aliases.aliases = void 0;
/**
 * Aliases are pseudos that are expressed as selectors.
 */
aliases.aliases = {
    // Links
    "any-link": ":is(a, area, link)[href]",
    link: ":any-link:not(:visited)",
    // Forms
    // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
    disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
    enabled: ":not(:disabled)",
    checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
    required: ":is(input, select, textarea)[required]",
    optional: ":is(input, select, textarea):not([required])",
    // JQuery extensions
    // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
    selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
    checkbox: "[type=checkbox]",
    file: "[type=file]",
    password: "[type=password]",
    radio: "[type=radio]",
    reset: "[type=reset]",
    image: "[type=image]",
    submit: "[type=submit]",
    parent: ":not(:empty)",
    header: ":is(h1, h2, h3, h4, h5, h6)",
    button: ":is(button, input[type=button])",
    input: ":is(input, textarea, select, button)",
    text: "input:is(:not([type!='']), [type=text])",
};

var subselects = {};

(function (exports) {
var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;
var boolbase_1 = boolbase;
var procedure_1 = procedure;
/** Used as a placeholder for :has. Will be replaced with the actual element. */
exports.PLACEHOLDER_ELEMENT = {};
function ensureIsTag(next, adapter) {
    if (next === boolbase_1.falseFunc)
        return boolbase_1.falseFunc;
    return function (elem) { return adapter.isTag(elem) && next(elem); };
}
exports.ensureIsTag = ensureIsTag;
function getNextSiblings(elem, adapter) {
    var siblings = adapter.getSiblings(elem);
    if (siblings.length <= 1)
        return [];
    var elemIndex = siblings.indexOf(elem);
    if (elemIndex < 0 || elemIndex === siblings.length - 1)
        return [];
    return siblings.slice(elemIndex + 1).filter(adapter.isTag);
}
exports.getNextSiblings = getNextSiblings;
var is = function (next, token, options, context, compileToken) {
    var opts = {
        xmlMode: !!options.xmlMode,
        adapter: options.adapter,
        equals: options.equals,
    };
    var func = compileToken(token, opts, context);
    return function (elem) { return func(elem) && next(elem); };
};
/*
 * :not, :has, :is, :matches and :where have to compile selectors
 * doing this in src/pseudos.ts would lead to circular dependencies,
 * so we add them here
 */
exports.subselects = {
    is: is,
    /**
     * `:matches` and `:where` are aliases for `:is`.
     */
    matches: is,
    where: is,
    not: function (next, token, options, context, compileToken) {
        var opts = {
            xmlMode: !!options.xmlMode,
            adapter: options.adapter,
            equals: options.equals,
        };
        var func = compileToken(token, opts, context);
        if (func === boolbase_1.falseFunc)
            return next;
        if (func === boolbase_1.trueFunc)
            return boolbase_1.falseFunc;
        return function not(elem) {
            return !func(elem) && next(elem);
        };
    },
    has: function (next, subselect, options, _context, compileToken) {
        var adapter = options.adapter;
        var opts = {
            xmlMode: !!options.xmlMode,
            adapter: adapter,
            equals: options.equals,
        };
        // @ts-expect-error Uses an array as a pointer to the current element (side effects)
        var context = subselect.some(function (s) {
            return s.some(procedure_1.isTraversal);
        })
            ? [exports.PLACEHOLDER_ELEMENT]
            : undefined;
        var compiled = compileToken(subselect, opts, context);
        if (compiled === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (compiled === boolbase_1.trueFunc) {
            return function (elem) {
                return adapter.getChildren(elem).some(adapter.isTag) && next(elem);
            };
        }
        var hasElement = ensureIsTag(compiled, adapter);
        var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings = _a === void 0 ? false : _a;
        /*
         * `shouldTestNextSiblings` will only be true if the query starts with
         * a traversal (sibling or adjacent). That means we will always have a context.
         */
        if (context) {
            return function (elem) {
                context[0] = elem;
                var childs = adapter.getChildren(elem);
                var nextElements = shouldTestNextSiblings
                    ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;
                return (next(elem) && adapter.existsOne(hasElement, nextElements));
            };
        }
        return function (elem) {
            return next(elem) &&
                adapter.existsOne(hasElement, adapter.getChildren(elem));
        };
    },
};
}(subselects));

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = void 0;
/*
 * Pseudo selectors
 *
 * Pseudo selectors are available in three forms:
 *
 * 1. Filters are called when the selector is compiled and return a function
 *  that has to return either false, or the results of `next()`.
 * 2. Pseudos are called on execution. They have to return a boolean.
 * 3. Subselects work like filters, but have an embedded selector that will be run separately.
 *
 * Filters are great if you want to do some pre-processing, or change the call order
 * of `next()` and your code.
 * Pseudos should be used to implement simple checks.
 */
var boolbase_1 = boolbase;
var css_what_1 = lib$a;
var filters_1 = filters;
Object.defineProperty(exports, "filters", { enumerable: true, get: function () { return filters_1.filters; } });
var pseudos_1 = pseudos;
Object.defineProperty(exports, "pseudos", { enumerable: true, get: function () { return pseudos_1.pseudos; } });
var aliases_1 = aliases;
Object.defineProperty(exports, "aliases", { enumerable: true, get: function () { return aliases_1.aliases; } });
var subselects_1 = subselects;
function compilePseudoSelector(next, selector, options, context, compileToken) {
    var name = selector.name, data = selector.data;
    if (Array.isArray(data)) {
        return subselects_1.subselects[name](next, data, options, context, compileToken);
    }
    if (name in aliases_1.aliases) {
        if (data != null) {
            throw new Error("Pseudo ".concat(name, " doesn't have any arguments"));
        }
        // The alias has to be parsed here, to make sure options are respected.
        var alias = (0, css_what_1.parse)(aliases_1.aliases[name], options);
        return subselects_1.subselects.is(next, alias, options, context, compileToken);
    }
    if (name in filters_1.filters) {
        return filters_1.filters[name](next, data, options, context);
    }
    if (name in pseudos_1.pseudos) {
        var pseudo_1 = pseudos_1.pseudos[name];
        (0, pseudos_1.verifyPseudoArgs)(pseudo_1, name, data);
        return pseudo_1 === boolbase_1.falseFunc
            ? boolbase_1.falseFunc
            : next === boolbase_1.trueFunc
                ? function (elem) { return pseudo_1(elem, options, data); }
                : function (elem) { return pseudo_1(elem, options, data) && next(elem); };
    }
    throw new Error("unmatched pseudo-class :".concat(name));
}
exports.compilePseudoSelector = compilePseudoSelector;
}(pseudoSelectors));

Object.defineProperty(general, "__esModule", { value: true });
general.compileGeneralSelector = void 0;
var attributes_1 = attributes$1;
var pseudo_selectors_1 = pseudoSelectors;
/*
 * All available rules
 */
function compileGeneralSelector(next, selector, options, context, compileToken) {
    var adapter = options.adapter, equals = options.equals;
    switch (selector.type) {
        case "pseudo-element":
            throw new Error("Pseudo-elements are not supported by css-select");
        case "attribute":
            return attributes_1.attributeRules[selector.action](next, selector, options);
        case "pseudo":
            return (0, pseudo_selectors_1.compilePseudoSelector)(next, selector, options, context, compileToken);
        // Tags
        case "tag":
            return function tag(elem) {
                return adapter.getName(elem) === selector.name && next(elem);
            };
        // Traversal
        case "descendant":
            if (options.cacheResults === false ||
                typeof WeakSet === "undefined") {
                return function descendant(elem) {
                    var current = elem;
                    while ((current = adapter.getParent(current))) {
                        if (adapter.isTag(current) && next(current)) {
                            return true;
                        }
                    }
                    return false;
                };
            }
            // @ts-expect-error `ElementNode` is not extending object
            // eslint-disable-next-line no-case-declarations
            var isFalseCache_1 = new WeakSet();
            return function cachedDescendant(elem) {
                var current = elem;
                while ((current = adapter.getParent(current))) {
                    if (!isFalseCache_1.has(current)) {
                        if (adapter.isTag(current) && next(current)) {
                            return true;
                        }
                        isFalseCache_1.add(current);
                    }
                }
                return false;
            };
        case "_flexibleDescendant":
            // Include element itself, only used while querying an array
            return function flexibleDescendant(elem) {
                var current = elem;
                do {
                    if (adapter.isTag(current) && next(current))
                        return true;
                } while ((current = adapter.getParent(current)));
                return false;
            };
        case "parent":
            return function parent(elem) {
                return adapter
                    .getChildren(elem)
                    .some(function (elem) { return adapter.isTag(elem) && next(elem); });
            };
        case "child":
            return function child(elem) {
                var parent = adapter.getParent(elem);
                return parent != null && adapter.isTag(parent) && next(parent);
            };
        case "sibling":
            return function sibling(elem) {
                var siblings = adapter.getSiblings(elem);
                for (var i = 0; i < siblings.length; i++) {
                    var currentSibling = siblings[i];
                    if (equals(elem, currentSibling))
                        break;
                    if (adapter.isTag(currentSibling) && next(currentSibling)) {
                        return true;
                    }
                }
                return false;
            };
        case "adjacent":
            return function adjacent(elem) {
                var siblings = adapter.getSiblings(elem);
                var lastElement;
                for (var i = 0; i < siblings.length; i++) {
                    var currentSibling = siblings[i];
                    if (equals(elem, currentSibling))
                        break;
                    if (adapter.isTag(currentSibling)) {
                        lastElement = currentSibling;
                    }
                }
                return !!lastElement && next(lastElement);
            };
        case "universal":
            return next;
    }
}
general.compileGeneralSelector = compileGeneralSelector;

var __importDefault$3 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(compile$5, "__esModule", { value: true });
compile$5.compileToken = compile$5.compileUnsafe = compile$5.compile = void 0;
var css_what_1 = lib$a;
var boolbase_1 = boolbase;
var sort_1 = __importDefault$3(sort);
var procedure_1 = procedure;
var general_1 = general;
var subselects_1 = subselects;
/**
 * Compiles a selector to an executable function.
 *
 * @param selector Selector to compile.
 * @param options Compilation options.
 * @param context Optional context for the selector.
 */
function compile$2(selector, options, context) {
    var next = compileUnsafe(selector, options, context);
    return (0, subselects_1.ensureIsTag)(next, options.adapter);
}
compile$5.compile = compile$2;
function compileUnsafe(selector, options, context) {
    var token = typeof selector === "string" ? (0, css_what_1.parse)(selector, options) : selector;
    return compileToken(token, options, context);
}
compile$5.compileUnsafe = compileUnsafe;
function includesScopePseudo(t) {
    return (t.type === "pseudo" &&
        (t.name === "scope" ||
            (Array.isArray(t.data) &&
                t.data.some(function (data) { return data.some(includesScopePseudo); }))));
}
var DESCENDANT_TOKEN = { type: "descendant" };
var FLEXIBLE_DESCENDANT_TOKEN = {
    type: "_flexibleDescendant",
};
var SCOPE_TOKEN = { type: "pseudo", name: "scope", data: null };
/*
 * CSS 4 Spec (Draft): 3.3.1. Absolutizing a Scope-relative Selector
 * http://www.w3.org/TR/selectors4/#absolutizing
 */
function absolutize(token, _a, context) {
    var adapter = _a.adapter;
    // TODO Use better check if the context is a document
    var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function (e) {
        var parent = adapter.isTag(e) && adapter.getParent(e);
        return e === subselects_1.PLACEHOLDER_ELEMENT || (parent && adapter.isTag(parent));
    }));
    for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
        var t = token_1[_i];
        if (t.length > 0 && (0, procedure_1.isTraversal)(t[0]) && t[0].type !== "descendant") ;
        else if (hasContext && !t.some(includesScopePseudo)) {
            t.unshift(DESCENDANT_TOKEN);
        }
        else {
            continue;
        }
        t.unshift(SCOPE_TOKEN);
    }
}
function compileToken(token, options, context) {
    var _a;
    token = token.filter(function (t) { return t.length > 0; });
    token.forEach(sort_1.default);
    context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
    var isArrayContext = Array.isArray(context);
    var finalContext = context && (Array.isArray(context) ? context : [context]);
    absolutize(token, options, finalContext);
    var shouldTestNextSiblings = false;
    var query = token
        .map(function (rules) {
        if (rules.length >= 2) {
            var first = rules[0], second = rules[1];
            if (first.type !== "pseudo" || first.name !== "scope") ;
            else if (isArrayContext && second.type === "descendant") {
                rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
            }
            else if (second.type === "adjacent" ||
                second.type === "sibling") {
                shouldTestNextSiblings = true;
            }
        }
        return compileRules(rules, options, finalContext);
    })
        .reduce(reduceRules, boolbase_1.falseFunc);
    query.shouldTestNextSiblings = shouldTestNextSiblings;
    return query;
}
compile$5.compileToken = compileToken;
function compileRules(rules, options, context) {
    var _a;
    return rules.reduce(function (previous, rule) {
        return previous === boolbase_1.falseFunc
            ? boolbase_1.falseFunc
            : (0, general_1.compileGeneralSelector)(previous, rule, options, context, compileToken);
    }, (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.trueFunc);
}
function reduceRules(a, b) {
    if (b === boolbase_1.falseFunc || a === boolbase_1.trueFunc) {
        return a;
    }
    if (a === boolbase_1.falseFunc || b === boolbase_1.trueFunc) {
        return b;
    }
    return function combine(elem) {
        return a(elem) || b(elem);
    };
}

(function (exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.aliases = exports.pseudos = exports.filters = exports.is = exports.selectOne = exports.selectAll = exports.prepareContext = exports._compileToken = exports._compileUnsafe = exports.compile = void 0;
var DomUtils = __importStar(lib$8);
var boolbase_1 = boolbase;
var compile_1 = compile$5;
var subselects_1 = subselects;
var defaultEquals = function (a, b) { return a === b; };
var defaultOptions = {
    adapter: DomUtils,
    equals: defaultEquals,
};
function convertOptionFormats(options) {
    var _a, _b, _c, _d;
    /*
     * We force one format of options to the other one.
     */
    // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.
    var opts = options !== null && options !== void 0 ? options : defaultOptions;
    // @ts-expect-error Same as above.
    (_a = opts.adapter) !== null && _a !== void 0 ? _a : (opts.adapter = DomUtils);
    // @ts-expect-error `equals` does not exist on `Options`
    (_b = opts.equals) !== null && _b !== void 0 ? _b : (opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals);
    return opts;
}
function wrapCompile(func) {
    return function addAdapter(selector, options, context) {
        var opts = convertOptionFormats(options);
        return func(selector, opts, context);
    };
}
/**
 * Compiles the query, returns a function.
 */
exports.compile = wrapCompile(compile_1.compile);
exports._compileUnsafe = wrapCompile(compile_1.compileUnsafe);
exports._compileToken = wrapCompile(compile_1.compileToken);
function getSelectorFunc(searchFunc) {
    return function select(query, elements, options) {
        var opts = convertOptionFormats(options);
        if (typeof query !== "function") {
            query = (0, compile_1.compileUnsafe)(query, opts, elements);
        }
        var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
        return searchFunc(query, filteredElements, opts);
    };
}
function prepareContext(elems, adapter, shouldTestNextSiblings) {
    if (shouldTestNextSiblings === void 0) { shouldTestNextSiblings = false; }
    /*
     * Add siblings if the query requires them.
     * See https://github.com/fb55/css-select/pull/43#issuecomment-225414692
     */
    if (shouldTestNextSiblings) {
        elems = appendNextSiblings(elems, adapter);
    }
    return Array.isArray(elems)
        ? adapter.removeSubsets(elems)
        : adapter.getChildren(elems);
}
exports.prepareContext = prepareContext;
function appendNextSiblings(elem, adapter) {
    // Order matters because jQuery seems to check the children before the siblings
    var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
    var elemsLength = elems.length;
    for (var i = 0; i < elemsLength; i++) {
        var nextSiblings = (0, subselects_1.getNextSiblings)(elems[i], adapter);
        elems.push.apply(elems, nextSiblings);
    }
    return elems;
}
/**
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elems Elements to query. If it is an element, its children will be queried..
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns All matching elements.
 *
 */
exports.selectAll = getSelectorFunc(function (query, elems, options) {
    return query === boolbase_1.falseFunc || !elems || elems.length === 0
        ? []
        : options.adapter.findAll(query, elems);
});
/**
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elems Elements to query. If it is an element, its children will be queried..
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns the first match, or null if there was no match.
 */
exports.selectOne = getSelectorFunc(function (query, elems, options) {
    return query === boolbase_1.falseFunc || !elems || elems.length === 0
        ? null
        : options.adapter.findOne(query, elems);
});
/**
 * Tests whether or not an element is matched by query.
 *
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elem The element to test if it matches the query.
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns
 */
function is(elem, query, options) {
    var opts = convertOptionFormats(options);
    return (typeof query === "function" ? query : (0, compile_1.compile)(query, opts))(elem);
}
exports.is = is;
/**
 * Alias for selectAll(query, elems, options).
 * @see [compile] for supported selector queries.
 */
exports.default = exports.selectAll;
// Export filters, pseudos and aliases to allow users to supply their own.
var pseudo_selectors_1 = pseudoSelectors;
Object.defineProperty(exports, "filters", { enumerable: true, get: function () { return pseudo_selectors_1.filters; } });
Object.defineProperty(exports, "pseudos", { enumerable: true, get: function () { return pseudo_selectors_1.pseudos; } });
Object.defineProperty(exports, "aliases", { enumerable: true, get: function () { return pseudo_selectors_1.aliases; } });
}(lib$9));

var helpers = {};

var positionals = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLimit = exports.isFilter = exports.filterNames = void 0;
exports.filterNames = new Set([
    "first",
    "last",
    "eq",
    "gt",
    "nth",
    "lt",
    "even",
    "odd",
]);
function isFilter(s) {
    if (s.type !== "pseudo")
        return false;
    if (exports.filterNames.has(s.name))
        return true;
    if (s.name === "not" && Array.isArray(s.data)) {
        // Only consider `:not` with embedded filters
        return s.data.some(function (s) { return s.some(isFilter); });
    }
    return false;
}
exports.isFilter = isFilter;
function getLimit(filter, data) {
    var num = data != null ? parseInt(data, 10) : NaN;
    switch (filter) {
        case "first":
            return 1;
        case "nth":
        case "eq":
            return isFinite(num) ? (num >= 0 ? num + 1 : Infinity) : 0;
        case "lt":
            return isFinite(num) ? (num >= 0 ? num : Infinity) : 0;
        case "gt":
            return isFinite(num) ? Infinity : 0;
        default:
            return Infinity;
    }
}
exports.getLimit = getLimit;
}(positionals));

Object.defineProperty(helpers, "__esModule", { value: true });
helpers.groupSelectors = helpers.getDocumentRoot = void 0;
var positionals_1 = positionals;
function getDocumentRoot(node) {
    while (node.parent)
        node = node.parent;
    return node;
}
helpers.getDocumentRoot = getDocumentRoot;
function groupSelectors(selectors) {
    var filteredSelectors = [];
    var plainSelectors = [];
    for (var _i = 0, selectors_1 = selectors; _i < selectors_1.length; _i++) {
        var selector = selectors_1[_i];
        if (selector.some(positionals_1.isFilter)) {
            filteredSelectors.push(selector);
        }
        else {
            plainSelectors.push(selector);
        }
    }
    return [plainSelectors, filteredSelectors];
}
helpers.groupSelectors = groupSelectors;

(function (exports) {
var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.select = exports.filter = exports.some = exports.is = exports.aliases = exports.pseudos = exports.filters = void 0;
var css_what_1 = lib$a;
var css_select_1 = lib$9;
var DomUtils = __importStar(lib$8);
var helpers_1 = helpers;
var positionals_1 = positionals;
// Re-export pseudo extension points
var css_select_2 = lib$9;
Object.defineProperty(exports, "filters", { enumerable: true, get: function () { return css_select_2.filters; } });
Object.defineProperty(exports, "pseudos", { enumerable: true, get: function () { return css_select_2.pseudos; } });
Object.defineProperty(exports, "aliases", { enumerable: true, get: function () { return css_select_2.aliases; } });
/** Used to indicate a scope should be filtered. Might be ignored when filtering. */
var SCOPE_PSEUDO = {
    type: "pseudo",
    name: "scope",
    data: null,
};
/** Used for actually filtering for scope. */
var CUSTOM_SCOPE_PSEUDO = __assign({}, SCOPE_PSEUDO);
var UNIVERSAL_SELECTOR = { type: "universal", namespace: null };
function is(element, selector, options) {
    if (options === void 0) { options = {}; }
    return some([element], selector, options);
}
exports.is = is;
function some(elements, selector, options) {
    if (options === void 0) { options = {}; }
    if (typeof selector === "function")
        return elements.some(selector);
    var _a = helpers_1.groupSelectors(css_what_1.parse(selector, options)), plain = _a[0], filtered = _a[1];
    return ((plain.length > 0 && elements.some(css_select_1._compileToken(plain, options))) ||
        filtered.some(function (sel) { return filterBySelector(sel, elements, options).length > 0; }));
}
exports.some = some;
function filterByPosition(filter, elems, data, options) {
    var num = typeof data === "string" ? parseInt(data, 10) : NaN;
    switch (filter) {
        case "first":
        case "lt":
            // Already done in `getLimit`
            return elems;
        case "last":
            return elems.length > 0 ? [elems[elems.length - 1]] : elems;
        case "nth":
        case "eq":
            return isFinite(num) && Math.abs(num) < elems.length
                ? [num < 0 ? elems[elems.length + num] : elems[num]]
                : [];
        case "gt":
            return isFinite(num) ? elems.slice(num + 1) : [];
        case "even":
            return elems.filter(function (_, i) { return i % 2 === 0; });
        case "odd":
            return elems.filter(function (_, i) { return i % 2 === 1; });
        case "not": {
            var filtered_1 = new Set(filterParsed(data, elems, options));
            return elems.filter(function (e) { return !filtered_1.has(e); });
        }
    }
}
function filter(selector, elements, options) {
    if (options === void 0) { options = {}; }
    return filterParsed(css_what_1.parse(selector, options), elements, options);
}
exports.filter = filter;
/**
 * Filter a set of elements by a selector.
 *
 * Will return elements in the original order.
 *
 * @param selector Selector to filter by.
 * @param elements Elements to filter.
 * @param options Options for selector.
 */
function filterParsed(selector, elements, options) {
    if (elements.length === 0)
        return [];
    var _a = helpers_1.groupSelectors(selector), plainSelectors = _a[0], filteredSelectors = _a[1];
    var found;
    if (plainSelectors.length) {
        var filtered = filterElements(elements, plainSelectors, options);
        // If there are no filters, just return
        if (filteredSelectors.length === 0) {
            return filtered;
        }
        // Otherwise, we have to do some filtering
        if (filtered.length) {
            found = new Set(filtered);
        }
    }
    for (var i = 0; i < filteredSelectors.length && (found === null || found === void 0 ? void 0 : found.size) !== elements.length; i++) {
        var filteredSelector = filteredSelectors[i];
        var missing = found
            ? elements.filter(function (e) { return DomUtils.isTag(e) && !found.has(e); })
            : elements;
        if (missing.length === 0)
            break;
        var filtered = filterBySelector(filteredSelector, elements, options);
        if (filtered.length) {
            if (!found) {
                /*
                 * If we haven't found anything before the last selector,
                 * just return what we found now.
                 */
                if (i === filteredSelectors.length - 1) {
                    return filtered;
                }
                found = new Set(filtered);
            }
            else {
                filtered.forEach(function (el) { return found.add(el); });
            }
        }
    }
    return typeof found !== "undefined"
        ? (found.size === elements.length
            ? elements
            : // Filter elements to preserve order
                elements.filter(function (el) {
                    return found.has(el);
                }))
        : [];
}
function filterBySelector(selector, elements, options) {
    var _a;
    if (selector.some(css_what_1.isTraversal)) {
        /*
         * Get root node, run selector with the scope
         * set to all of our nodes.
         */
        var root = (_a = options.root) !== null && _a !== void 0 ? _a : helpers_1.getDocumentRoot(elements[0]);
        var sel = __spreadArray(__spreadArray([], selector), [CUSTOM_SCOPE_PSEUDO]);
        return findFilterElements(root, sel, options, true, elements);
    }
    // Performance optimization: If we don't have to traverse, just filter set.
    return findFilterElements(elements, selector, options, false);
}
function select(selector, root, options) {
    if (options === void 0) { options = {}; }
    if (typeof selector === "function") {
        return find(root, selector);
    }
    var _a = helpers_1.groupSelectors(css_what_1.parse(selector, options)), plain = _a[0], filtered = _a[1];
    var results = filtered.map(function (sel) {
        return findFilterElements(root, sel, options, true);
    });
    // Plain selectors can be queried in a single go
    if (plain.length) {
        results.push(findElements(root, plain, options, Infinity));
    }
    // If there was only a single selector, just return the result
    if (results.length === 1) {
        return results[0];
    }
    // Sort results, filtering for duplicates
    return DomUtils.uniqueSort(results.reduce(function (a, b) { return __spreadArray(__spreadArray([], a), b); }));
}
exports.select = select;
// Traversals that are treated differently in css-select.
var specialTraversal = new Set(["descendant", "adjacent"]);
function includesScopePseudo(t) {
    return (t !== SCOPE_PSEUDO &&
        t.type === "pseudo" &&
        (t.name === "scope" ||
            (Array.isArray(t.data) &&
                t.data.some(function (data) { return data.some(includesScopePseudo); }))));
}
function addContextIfScope(selector, options, scopeContext) {
    return scopeContext && selector.some(includesScopePseudo)
        ? __assign(__assign({}, options), { context: scopeContext }) : options;
}
/**
 *
 * @param root Element(s) to search from.
 * @param selector Selector to look for.
 * @param options Options for querying.
 * @param queryForSelector Query multiple levels deep for the initial selector, even if it doesn't contain a traversal.
 * @param scopeContext Optional context for a :scope.
 */
function findFilterElements(root, selector, options, queryForSelector, scopeContext) {
    var filterIndex = selector.findIndex(positionals_1.isFilter);
    var sub = selector.slice(0, filterIndex);
    var filter = selector[filterIndex];
    /*
     * Set the number of elements to retrieve.
     * Eg. for :first, we only have to get a single element.
     */
    var limit = positionals_1.getLimit(filter.name, filter.data);
    if (limit === 0)
        return [];
    var subOpts = addContextIfScope(sub, options, scopeContext);
    /*
     * Skip `findElements` call if our selector starts with a positional
     * pseudo.
     */
    var elemsNoLimit = sub.length === 0 && !Array.isArray(root)
        ? DomUtils.getChildren(root).filter(DomUtils.isTag)
        : sub.length === 0 || (sub.length === 1 && sub[0] === SCOPE_PSEUDO)
            ? (Array.isArray(root) ? root : [root]).filter(DomUtils.isTag)
            : queryForSelector || sub.some(css_what_1.isTraversal)
                ? findElements(root, [sub], subOpts, limit)
                : filterElements(root, [sub], subOpts);
    var elems = elemsNoLimit.slice(0, limit);
    var result = filterByPosition(filter.name, elems, filter.data, options);
    if (result.length === 0 || selector.length === filterIndex + 1) {
        return result;
    }
    var remainingSelector = selector.slice(filterIndex + 1);
    var remainingHasTraversal = remainingSelector.some(css_what_1.isTraversal);
    var remainingOpts = addContextIfScope(remainingSelector, options, scopeContext);
    if (remainingHasTraversal) {
        /*
         * Some types of traversals have special logic when they start a selector
         * in css-select. If this is the case, add a universal selector in front of
         * the selector to avoid this behavior.
         */
        if (specialTraversal.has(remainingSelector[0].type)) {
            remainingSelector.unshift(UNIVERSAL_SELECTOR);
        }
        /*
         * Add a scope token in front of the remaining selector,
         * to make sure traversals don't match elements that aren't a
         * part of the considered tree.
         */
        remainingSelector.unshift(SCOPE_PSEUDO);
    }
    /*
     * If we have another filter, recursively call `findFilterElements`,
     * with the `recursive` flag disabled. We only have to look for more
     * elements when we see a traversal.
     *
     * Otherwise,
     */
    return remainingSelector.some(positionals_1.isFilter)
        ? findFilterElements(result, remainingSelector, options, false, scopeContext)
        : remainingHasTraversal
            ? // Query existing elements to resolve traversal.
                findElements(result, [remainingSelector], remainingOpts, Infinity)
            : // If we don't have any more traversals, simply filter elements.
                filterElements(result, [remainingSelector], remainingOpts);
}
function findElements(root, sel, options, limit) {
    if (limit === 0)
        return [];
    var query = css_select_1._compileToken(sel, options, root);
    return find(root, query, limit);
}
function find(root, query, limit) {
    if (limit === void 0) { limit = Infinity; }
    var elems = css_select_1.prepareContext(root, DomUtils, query.shouldTestNextSiblings);
    return DomUtils.find(function (node) { return DomUtils.isTag(node) && query(node); }, elems, true, limit);
}
function filterElements(elements, sel, options) {
    var els = (Array.isArray(elements) ? elements : [elements]).filter(DomUtils.isTag);
    if (els.length === 0)
        return els;
    var query = css_select_1._compileToken(sel, options);
    return els.filter(query);
}
}(lib$b));

var lib$2 = {};

var Parser$3 = {};

var Tokenizer$6 = {};

var __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(Tokenizer$6, "__esModule", { value: true });
var decode_codepoint_1 = __importDefault$2(decode_codepoint);
var entities_json_1 = __importDefault$2(require$$1);
var legacy_json_1 = __importDefault$2(require$$2);
var xml_json_1 = __importDefault$2(require$$3);
function whitespace(c) {
    return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}
function isASCIIAlpha(c) {
    return (c >= "a" && c <= "z") || (c >= "A" && c <= "Z");
}
function ifElseState(upper, SUCCESS, FAILURE) {
    var lower = upper.toLowerCase();
    if (upper === lower) {
        return function (t, c) {
            if (c === lower) {
                t._state = SUCCESS;
            }
            else {
                t._state = FAILURE;
                t._index--;
            }
        };
    }
    return function (t, c) {
        if (c === lower || c === upper) {
            t._state = SUCCESS;
        }
        else {
            t._state = FAILURE;
            t._index--;
        }
    };
}
function consumeSpecialNameChar(upper, NEXT_STATE) {
    var lower = upper.toLowerCase();
    return function (t, c) {
        if (c === lower || c === upper) {
            t._state = NEXT_STATE;
        }
        else {
            t._state = 3 /* InTagName */;
            t._index--; // Consume the token again
        }
    };
}
var stateBeforeCdata1 = ifElseState("C", 24 /* BeforeCdata2 */, 16 /* InDeclaration */);
var stateBeforeCdata2 = ifElseState("D", 25 /* BeforeCdata3 */, 16 /* InDeclaration */);
var stateBeforeCdata3 = ifElseState("A", 26 /* BeforeCdata4 */, 16 /* InDeclaration */);
var stateBeforeCdata4 = ifElseState("T", 27 /* BeforeCdata5 */, 16 /* InDeclaration */);
var stateBeforeCdata5 = ifElseState("A", 28 /* BeforeCdata6 */, 16 /* InDeclaration */);
var stateBeforeScript1 = consumeSpecialNameChar("R", 35 /* BeforeScript2 */);
var stateBeforeScript2 = consumeSpecialNameChar("I", 36 /* BeforeScript3 */);
var stateBeforeScript3 = consumeSpecialNameChar("P", 37 /* BeforeScript4 */);
var stateBeforeScript4 = consumeSpecialNameChar("T", 38 /* BeforeScript5 */);
var stateAfterScript1 = ifElseState("R", 40 /* AfterScript2 */, 1 /* Text */);
var stateAfterScript2 = ifElseState("I", 41 /* AfterScript3 */, 1 /* Text */);
var stateAfterScript3 = ifElseState("P", 42 /* AfterScript4 */, 1 /* Text */);
var stateAfterScript4 = ifElseState("T", 43 /* AfterScript5 */, 1 /* Text */);
var stateBeforeStyle1 = consumeSpecialNameChar("Y", 45 /* BeforeStyle2 */);
var stateBeforeStyle2 = consumeSpecialNameChar("L", 46 /* BeforeStyle3 */);
var stateBeforeStyle3 = consumeSpecialNameChar("E", 47 /* BeforeStyle4 */);
var stateAfterStyle1 = ifElseState("Y", 49 /* AfterStyle2 */, 1 /* Text */);
var stateAfterStyle2 = ifElseState("L", 50 /* AfterStyle3 */, 1 /* Text */);
var stateAfterStyle3 = ifElseState("E", 51 /* AfterStyle4 */, 1 /* Text */);
var stateBeforeSpecialT = consumeSpecialNameChar("I", 54 /* BeforeTitle1 */);
var stateBeforeTitle1 = consumeSpecialNameChar("T", 55 /* BeforeTitle2 */);
var stateBeforeTitle2 = consumeSpecialNameChar("L", 56 /* BeforeTitle3 */);
var stateBeforeTitle3 = consumeSpecialNameChar("E", 57 /* BeforeTitle4 */);
var stateAfterSpecialTEnd = ifElseState("I", 58 /* AfterTitle1 */, 1 /* Text */);
var stateAfterTitle1 = ifElseState("T", 59 /* AfterTitle2 */, 1 /* Text */);
var stateAfterTitle2 = ifElseState("L", 60 /* AfterTitle3 */, 1 /* Text */);
var stateAfterTitle3 = ifElseState("E", 61 /* AfterTitle4 */, 1 /* Text */);
var stateBeforeEntity = ifElseState("#", 63 /* BeforeNumericEntity */, 64 /* InNamedEntity */);
var stateBeforeNumericEntity = ifElseState("X", 66 /* InHexEntity */, 65 /* InNumericEntity */);
var Tokenizer$5 = /** @class */ (function () {
    function Tokenizer(options, cbs) {
        var _a;
        /** The current state the tokenizer is in. */
        this._state = 1 /* Text */;
        /** The read buffer. */
        this.buffer = "";
        /** The beginning of the section that is currently being read. */
        this.sectionStart = 0;
        /** The index within the buffer that we are currently looking at. */
        this._index = 0;
        /**
         * Data that has already been processed will be removed from the buffer occasionally.
         * `_bufferOffset` keeps track of how many characters have been removed, to make sure position information is accurate.
         */
        this.bufferOffset = 0;
        /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
        this.baseState = 1 /* Text */;
        /** For special parsing behavior inside of script and style tags. */
        this.special = 1 /* None */;
        /** Indicates whether the tokenizer has been paused. */
        this.running = true;
        /** Indicates whether the tokenizer has finished running / `.end` has been called. */
        this.ended = false;
        this.cbs = cbs;
        this.xmlMode = !!(options === null || options === void 0 ? void 0 : options.xmlMode);
        this.decodeEntities = (_a = options === null || options === void 0 ? void 0 : options.decodeEntities) !== null && _a !== void 0 ? _a : true;
    }
    Tokenizer.prototype.reset = function () {
        this._state = 1 /* Text */;
        this.buffer = "";
        this.sectionStart = 0;
        this._index = 0;
        this.bufferOffset = 0;
        this.baseState = 1 /* Text */;
        this.special = 1 /* None */;
        this.running = true;
        this.ended = false;
    };
    Tokenizer.prototype.write = function (chunk) {
        if (this.ended)
            this.cbs.onerror(Error(".write() after done!"));
        this.buffer += chunk;
        this.parse();
    };
    Tokenizer.prototype.end = function (chunk) {
        if (this.ended)
            this.cbs.onerror(Error(".end() after done!"));
        if (chunk)
            this.write(chunk);
        this.ended = true;
        if (this.running)
            this.finish();
    };
    Tokenizer.prototype.pause = function () {
        this.running = false;
    };
    Tokenizer.prototype.resume = function () {
        this.running = true;
        if (this._index < this.buffer.length) {
            this.parse();
        }
        if (this.ended) {
            this.finish();
        }
    };
    /**
     * The current index within all of the written data.
     */
    Tokenizer.prototype.getAbsoluteIndex = function () {
        return this.bufferOffset + this._index;
    };
    Tokenizer.prototype.stateText = function (c) {
        if (c === "<") {
            if (this._index > this.sectionStart) {
                this.cbs.ontext(this.getSection());
            }
            this._state = 2 /* BeforeTagName */;
            this.sectionStart = this._index;
        }
        else if (this.decodeEntities &&
            c === "&" &&
            (this.special === 1 /* None */ || this.special === 4 /* Title */)) {
            if (this._index > this.sectionStart) {
                this.cbs.ontext(this.getSection());
            }
            this.baseState = 1 /* Text */;
            this._state = 62 /* BeforeEntity */;
            this.sectionStart = this._index;
        }
    };
    /**
     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
     *
     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
     * We allow anything that wouldn't end the tag.
     */
    Tokenizer.prototype.isTagStartChar = function (c) {
        return (isASCIIAlpha(c) ||
            (this.xmlMode && !whitespace(c) && c !== "/" && c !== ">"));
    };
    Tokenizer.prototype.stateBeforeTagName = function (c) {
        if (c === "/") {
            this._state = 5 /* BeforeClosingTagName */;
        }
        else if (c === "<") {
            this.cbs.ontext(this.getSection());
            this.sectionStart = this._index;
        }
        else if (c === ">" ||
            this.special !== 1 /* None */ ||
            whitespace(c)) {
            this._state = 1 /* Text */;
        }
        else if (c === "!") {
            this._state = 15 /* BeforeDeclaration */;
            this.sectionStart = this._index + 1;
        }
        else if (c === "?") {
            this._state = 17 /* InProcessingInstruction */;
            this.sectionStart = this._index + 1;
        }
        else if (!this.isTagStartChar(c)) {
            this._state = 1 /* Text */;
        }
        else {
            this._state =
                !this.xmlMode && (c === "s" || c === "S")
                    ? 32 /* BeforeSpecialS */
                    : !this.xmlMode && (c === "t" || c === "T")
                        ? 52 /* BeforeSpecialT */
                        : 3 /* InTagName */;
            this.sectionStart = this._index;
        }
    };
    Tokenizer.prototype.stateInTagName = function (c) {
        if (c === "/" || c === ">" || whitespace(c)) {
            this.emitToken("onopentagname");
            this._state = 8 /* BeforeAttributeName */;
            this._index--;
        }
    };
    Tokenizer.prototype.stateBeforeClosingTagName = function (c) {
        if (whitespace(c)) ;
        else if (c === ">") {
            this._state = 1 /* Text */;
        }
        else if (this.special !== 1 /* None */) {
            if (this.special !== 4 /* Title */ && (c === "s" || c === "S")) {
                this._state = 33 /* BeforeSpecialSEnd */;
            }
            else if (this.special === 4 /* Title */ &&
                (c === "t" || c === "T")) {
                this._state = 53 /* BeforeSpecialTEnd */;
            }
            else {
                this._state = 1 /* Text */;
                this._index--;
            }
        }
        else if (!this.isTagStartChar(c)) {
            this._state = 20 /* InSpecialComment */;
            this.sectionStart = this._index;
        }
        else {
            this._state = 6 /* InClosingTagName */;
            this.sectionStart = this._index;
        }
    };
    Tokenizer.prototype.stateInClosingTagName = function (c) {
        if (c === ">" || whitespace(c)) {
            this.emitToken("onclosetag");
            this._state = 7 /* AfterClosingTagName */;
            this._index--;
        }
    };
    Tokenizer.prototype.stateAfterClosingTagName = function (c) {
        // Skip everything until ">"
        if (c === ">") {
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
    };
    Tokenizer.prototype.stateBeforeAttributeName = function (c) {
        if (c === ">") {
            this.cbs.onopentagend();
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
        else if (c === "/") {
            this._state = 4 /* InSelfClosingTag */;
        }
        else if (!whitespace(c)) {
            this._state = 9 /* InAttributeName */;
            this.sectionStart = this._index;
        }
    };
    Tokenizer.prototype.stateInSelfClosingTag = function (c) {
        if (c === ">") {
            this.cbs.onselfclosingtag();
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
            this.special = 1 /* None */; // Reset special state, in case of self-closing special tags
        }
        else if (!whitespace(c)) {
            this._state = 8 /* BeforeAttributeName */;
            this._index--;
        }
    };
    Tokenizer.prototype.stateInAttributeName = function (c) {
        if (c === "=" || c === "/" || c === ">" || whitespace(c)) {
            this.cbs.onattribname(this.getSection());
            this.sectionStart = -1;
            this._state = 10 /* AfterAttributeName */;
            this._index--;
        }
    };
    Tokenizer.prototype.stateAfterAttributeName = function (c) {
        if (c === "=") {
            this._state = 11 /* BeforeAttributeValue */;
        }
        else if (c === "/" || c === ">") {
            this.cbs.onattribend(undefined);
            this._state = 8 /* BeforeAttributeName */;
            this._index--;
        }
        else if (!whitespace(c)) {
            this.cbs.onattribend(undefined);
            this._state = 9 /* InAttributeName */;
            this.sectionStart = this._index;
        }
    };
    Tokenizer.prototype.stateBeforeAttributeValue = function (c) {
        if (c === '"') {
            this._state = 12 /* InAttributeValueDq */;
            this.sectionStart = this._index + 1;
        }
        else if (c === "'") {
            this._state = 13 /* InAttributeValueSq */;
            this.sectionStart = this._index + 1;
        }
        else if (!whitespace(c)) {
            this._state = 14 /* InAttributeValueNq */;
            this.sectionStart = this._index;
            this._index--; // Reconsume token
        }
    };
    Tokenizer.prototype.handleInAttributeValue = function (c, quote) {
        if (c === quote) {
            this.emitToken("onattribdata");
            this.cbs.onattribend(quote);
            this._state = 8 /* BeforeAttributeName */;
        }
        else if (this.decodeEntities && c === "&") {
            this.emitToken("onattribdata");
            this.baseState = this._state;
            this._state = 62 /* BeforeEntity */;
            this.sectionStart = this._index;
        }
    };
    Tokenizer.prototype.stateInAttributeValueDoubleQuotes = function (c) {
        this.handleInAttributeValue(c, '"');
    };
    Tokenizer.prototype.stateInAttributeValueSingleQuotes = function (c) {
        this.handleInAttributeValue(c, "'");
    };
    Tokenizer.prototype.stateInAttributeValueNoQuotes = function (c) {
        if (whitespace(c) || c === ">") {
            this.emitToken("onattribdata");
            this.cbs.onattribend(null);
            this._state = 8 /* BeforeAttributeName */;
            this._index--;
        }
        else if (this.decodeEntities && c === "&") {
            this.emitToken("onattribdata");
            this.baseState = this._state;
            this._state = 62 /* BeforeEntity */;
            this.sectionStart = this._index;
        }
    };
    Tokenizer.prototype.stateBeforeDeclaration = function (c) {
        this._state =
            c === "["
                ? 23 /* BeforeCdata1 */
                : c === "-"
                    ? 18 /* BeforeComment */
                    : 16 /* InDeclaration */;
    };
    Tokenizer.prototype.stateInDeclaration = function (c) {
        if (c === ">") {
            this.cbs.ondeclaration(this.getSection());
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
    };
    Tokenizer.prototype.stateInProcessingInstruction = function (c) {
        if (c === ">") {
            this.cbs.onprocessinginstruction(this.getSection());
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
    };
    Tokenizer.prototype.stateBeforeComment = function (c) {
        if (c === "-") {
            this._state = 19 /* InComment */;
            this.sectionStart = this._index + 1;
        }
        else {
            this._state = 16 /* InDeclaration */;
        }
    };
    Tokenizer.prototype.stateInComment = function (c) {
        if (c === "-")
            this._state = 21 /* AfterComment1 */;
    };
    Tokenizer.prototype.stateInSpecialComment = function (c) {
        if (c === ">") {
            this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index));
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
    };
    Tokenizer.prototype.stateAfterComment1 = function (c) {
        if (c === "-") {
            this._state = 22 /* AfterComment2 */;
        }
        else {
            this._state = 19 /* InComment */;
        }
    };
    Tokenizer.prototype.stateAfterComment2 = function (c) {
        if (c === ">") {
            // Remove 2 trailing chars
            this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index - 2));
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
        else if (c !== "-") {
            this._state = 19 /* InComment */;
        }
        // Else: stay in AFTER_COMMENT_2 (`--->`)
    };
    Tokenizer.prototype.stateBeforeCdata6 = function (c) {
        if (c === "[") {
            this._state = 29 /* InCdata */;
            this.sectionStart = this._index + 1;
        }
        else {
            this._state = 16 /* InDeclaration */;
            this._index--;
        }
    };
    Tokenizer.prototype.stateInCdata = function (c) {
        if (c === "]")
            this._state = 30 /* AfterCdata1 */;
    };
    Tokenizer.prototype.stateAfterCdata1 = function (c) {
        if (c === "]")
            this._state = 31 /* AfterCdata2 */;
        else
            this._state = 29 /* InCdata */;
    };
    Tokenizer.prototype.stateAfterCdata2 = function (c) {
        if (c === ">") {
            // Remove 2 trailing chars
            this.cbs.oncdata(this.buffer.substring(this.sectionStart, this._index - 2));
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
        else if (c !== "]") {
            this._state = 29 /* InCdata */;
        }
        // Else: stay in AFTER_CDATA_2 (`]]]>`)
    };
    Tokenizer.prototype.stateBeforeSpecialS = function (c) {
        if (c === "c" || c === "C") {
            this._state = 34 /* BeforeScript1 */;
        }
        else if (c === "t" || c === "T") {
            this._state = 44 /* BeforeStyle1 */;
        }
        else {
            this._state = 3 /* InTagName */;
            this._index--; // Consume the token again
        }
    };
    Tokenizer.prototype.stateBeforeSpecialSEnd = function (c) {
        if (this.special === 2 /* Script */ && (c === "c" || c === "C")) {
            this._state = 39 /* AfterScript1 */;
        }
        else if (this.special === 3 /* Style */ && (c === "t" || c === "T")) {
            this._state = 48 /* AfterStyle1 */;
        }
        else
            this._state = 1 /* Text */;
    };
    Tokenizer.prototype.stateBeforeSpecialLast = function (c, special) {
        if (c === "/" || c === ">" || whitespace(c)) {
            this.special = special;
        }
        this._state = 3 /* InTagName */;
        this._index--; // Consume the token again
    };
    Tokenizer.prototype.stateAfterSpecialLast = function (c, sectionStartOffset) {
        if (c === ">" || whitespace(c)) {
            this.special = 1 /* None */;
            this._state = 6 /* InClosingTagName */;
            this.sectionStart = this._index - sectionStartOffset;
            this._index--; // Reconsume the token
        }
        else
            this._state = 1 /* Text */;
    };
    // For entities terminated with a semicolon
    Tokenizer.prototype.parseFixedEntity = function (map) {
        if (map === void 0) { map = this.xmlMode ? xml_json_1.default : entities_json_1.default; }
        // Offset = 1
        if (this.sectionStart + 1 < this._index) {
            var entity = this.buffer.substring(this.sectionStart + 1, this._index);
            if (Object.prototype.hasOwnProperty.call(map, entity)) {
                this.emitPartial(map[entity]);
                this.sectionStart = this._index + 1;
            }
        }
    };
    // Parses legacy entities (without trailing semicolon)
    Tokenizer.prototype.parseLegacyEntity = function () {
        var start = this.sectionStart + 1;
        // The max length of legacy entities is 6
        var limit = Math.min(this._index - start, 6);
        while (limit >= 2) {
            // The min length of legacy entities is 2
            var entity = this.buffer.substr(start, limit);
            if (Object.prototype.hasOwnProperty.call(legacy_json_1.default, entity)) {
                this.emitPartial(legacy_json_1.default[entity]);
                this.sectionStart += limit + 1;
                return;
            }
            limit--;
        }
    };
    Tokenizer.prototype.stateInNamedEntity = function (c) {
        if (c === ";") {
            this.parseFixedEntity();
            // Retry as legacy entity if entity wasn't parsed
            if (this.baseState === 1 /* Text */ &&
                this.sectionStart + 1 < this._index &&
                !this.xmlMode) {
                this.parseLegacyEntity();
            }
            this._state = this.baseState;
        }
        else if ((c < "0" || c > "9") && !isASCIIAlpha(c)) {
            if (this.xmlMode || this.sectionStart + 1 === this._index) ;
            else if (this.baseState !== 1 /* Text */) {
                if (c !== "=") {
                    // Parse as legacy entity, without allowing additional characters.
                    this.parseFixedEntity(legacy_json_1.default);
                }
            }
            else {
                this.parseLegacyEntity();
            }
            this._state = this.baseState;
            this._index--;
        }
    };
    Tokenizer.prototype.decodeNumericEntity = function (offset, base, strict) {
        var sectionStart = this.sectionStart + offset;
        if (sectionStart !== this._index) {
            // Parse entity
            var entity = this.buffer.substring(sectionStart, this._index);
            var parsed = parseInt(entity, base);
            this.emitPartial(decode_codepoint_1.default(parsed));
            this.sectionStart = strict ? this._index + 1 : this._index;
        }
        this._state = this.baseState;
    };
    Tokenizer.prototype.stateInNumericEntity = function (c) {
        if (c === ";") {
            this.decodeNumericEntity(2, 10, true);
        }
        else if (c < "0" || c > "9") {
            if (!this.xmlMode) {
                this.decodeNumericEntity(2, 10, false);
            }
            else {
                this._state = this.baseState;
            }
            this._index--;
        }
    };
    Tokenizer.prototype.stateInHexEntity = function (c) {
        if (c === ";") {
            this.decodeNumericEntity(3, 16, true);
        }
        else if ((c < "a" || c > "f") &&
            (c < "A" || c > "F") &&
            (c < "0" || c > "9")) {
            if (!this.xmlMode) {
                this.decodeNumericEntity(3, 16, false);
            }
            else {
                this._state = this.baseState;
            }
            this._index--;
        }
    };
    Tokenizer.prototype.cleanup = function () {
        if (this.sectionStart < 0) {
            this.buffer = "";
            this.bufferOffset += this._index;
            this._index = 0;
        }
        else if (this.running) {
            if (this._state === 1 /* Text */) {
                if (this.sectionStart !== this._index) {
                    this.cbs.ontext(this.buffer.substr(this.sectionStart));
                }
                this.buffer = "";
                this.bufferOffset += this._index;
                this._index = 0;
            }
            else if (this.sectionStart === this._index) {
                // The section just started
                this.buffer = "";
                this.bufferOffset += this._index;
                this._index = 0;
            }
            else {
                // Remove everything unnecessary
                this.buffer = this.buffer.substr(this.sectionStart);
                this._index -= this.sectionStart;
                this.bufferOffset += this.sectionStart;
            }
            this.sectionStart = 0;
        }
    };
    /**
     * Iterates through the buffer, calling the function corresponding to the current state.
     *
     * States that are more likely to be hit are higher up, as a performance improvement.
     */
    Tokenizer.prototype.parse = function () {
        while (this._index < this.buffer.length && this.running) {
            var c = this.buffer.charAt(this._index);
            if (this._state === 1 /* Text */) {
                this.stateText(c);
            }
            else if (this._state === 12 /* InAttributeValueDq */) {
                this.stateInAttributeValueDoubleQuotes(c);
            }
            else if (this._state === 9 /* InAttributeName */) {
                this.stateInAttributeName(c);
            }
            else if (this._state === 19 /* InComment */) {
                this.stateInComment(c);
            }
            else if (this._state === 20 /* InSpecialComment */) {
                this.stateInSpecialComment(c);
            }
            else if (this._state === 8 /* BeforeAttributeName */) {
                this.stateBeforeAttributeName(c);
            }
            else if (this._state === 3 /* InTagName */) {
                this.stateInTagName(c);
            }
            else if (this._state === 6 /* InClosingTagName */) {
                this.stateInClosingTagName(c);
            }
            else if (this._state === 2 /* BeforeTagName */) {
                this.stateBeforeTagName(c);
            }
            else if (this._state === 10 /* AfterAttributeName */) {
                this.stateAfterAttributeName(c);
            }
            else if (this._state === 13 /* InAttributeValueSq */) {
                this.stateInAttributeValueSingleQuotes(c);
            }
            else if (this._state === 11 /* BeforeAttributeValue */) {
                this.stateBeforeAttributeValue(c);
            }
            else if (this._state === 5 /* BeforeClosingTagName */) {
                this.stateBeforeClosingTagName(c);
            }
            else if (this._state === 7 /* AfterClosingTagName */) {
                this.stateAfterClosingTagName(c);
            }
            else if (this._state === 32 /* BeforeSpecialS */) {
                this.stateBeforeSpecialS(c);
            }
            else if (this._state === 21 /* AfterComment1 */) {
                this.stateAfterComment1(c);
            }
            else if (this._state === 14 /* InAttributeValueNq */) {
                this.stateInAttributeValueNoQuotes(c);
            }
            else if (this._state === 4 /* InSelfClosingTag */) {
                this.stateInSelfClosingTag(c);
            }
            else if (this._state === 16 /* InDeclaration */) {
                this.stateInDeclaration(c);
            }
            else if (this._state === 15 /* BeforeDeclaration */) {
                this.stateBeforeDeclaration(c);
            }
            else if (this._state === 22 /* AfterComment2 */) {
                this.stateAfterComment2(c);
            }
            else if (this._state === 18 /* BeforeComment */) {
                this.stateBeforeComment(c);
            }
            else if (this._state === 33 /* BeforeSpecialSEnd */) {
                this.stateBeforeSpecialSEnd(c);
            }
            else if (this._state === 53 /* BeforeSpecialTEnd */) {
                stateAfterSpecialTEnd(this, c);
            }
            else if (this._state === 39 /* AfterScript1 */) {
                stateAfterScript1(this, c);
            }
            else if (this._state === 40 /* AfterScript2 */) {
                stateAfterScript2(this, c);
            }
            else if (this._state === 41 /* AfterScript3 */) {
                stateAfterScript3(this, c);
            }
            else if (this._state === 34 /* BeforeScript1 */) {
                stateBeforeScript1(this, c);
            }
            else if (this._state === 35 /* BeforeScript2 */) {
                stateBeforeScript2(this, c);
            }
            else if (this._state === 36 /* BeforeScript3 */) {
                stateBeforeScript3(this, c);
            }
            else if (this._state === 37 /* BeforeScript4 */) {
                stateBeforeScript4(this, c);
            }
            else if (this._state === 38 /* BeforeScript5 */) {
                this.stateBeforeSpecialLast(c, 2 /* Script */);
            }
            else if (this._state === 42 /* AfterScript4 */) {
                stateAfterScript4(this, c);
            }
            else if (this._state === 43 /* AfterScript5 */) {
                this.stateAfterSpecialLast(c, 6);
            }
            else if (this._state === 44 /* BeforeStyle1 */) {
                stateBeforeStyle1(this, c);
            }
            else if (this._state === 29 /* InCdata */) {
                this.stateInCdata(c);
            }
            else if (this._state === 45 /* BeforeStyle2 */) {
                stateBeforeStyle2(this, c);
            }
            else if (this._state === 46 /* BeforeStyle3 */) {
                stateBeforeStyle3(this, c);
            }
            else if (this._state === 47 /* BeforeStyle4 */) {
                this.stateBeforeSpecialLast(c, 3 /* Style */);
            }
            else if (this._state === 48 /* AfterStyle1 */) {
                stateAfterStyle1(this, c);
            }
            else if (this._state === 49 /* AfterStyle2 */) {
                stateAfterStyle2(this, c);
            }
            else if (this._state === 50 /* AfterStyle3 */) {
                stateAfterStyle3(this, c);
            }
            else if (this._state === 51 /* AfterStyle4 */) {
                this.stateAfterSpecialLast(c, 5);
            }
            else if (this._state === 52 /* BeforeSpecialT */) {
                stateBeforeSpecialT(this, c);
            }
            else if (this._state === 54 /* BeforeTitle1 */) {
                stateBeforeTitle1(this, c);
            }
            else if (this._state === 55 /* BeforeTitle2 */) {
                stateBeforeTitle2(this, c);
            }
            else if (this._state === 56 /* BeforeTitle3 */) {
                stateBeforeTitle3(this, c);
            }
            else if (this._state === 57 /* BeforeTitle4 */) {
                this.stateBeforeSpecialLast(c, 4 /* Title */);
            }
            else if (this._state === 58 /* AfterTitle1 */) {
                stateAfterTitle1(this, c);
            }
            else if (this._state === 59 /* AfterTitle2 */) {
                stateAfterTitle2(this, c);
            }
            else if (this._state === 60 /* AfterTitle3 */) {
                stateAfterTitle3(this, c);
            }
            else if (this._state === 61 /* AfterTitle4 */) {
                this.stateAfterSpecialLast(c, 5);
            }
            else if (this._state === 17 /* InProcessingInstruction */) {
                this.stateInProcessingInstruction(c);
            }
            else if (this._state === 64 /* InNamedEntity */) {
                this.stateInNamedEntity(c);
            }
            else if (this._state === 23 /* BeforeCdata1 */) {
                stateBeforeCdata1(this, c);
            }
            else if (this._state === 62 /* BeforeEntity */) {
                stateBeforeEntity(this, c);
            }
            else if (this._state === 24 /* BeforeCdata2 */) {
                stateBeforeCdata2(this, c);
            }
            else if (this._state === 25 /* BeforeCdata3 */) {
                stateBeforeCdata3(this, c);
            }
            else if (this._state === 30 /* AfterCdata1 */) {
                this.stateAfterCdata1(c);
            }
            else if (this._state === 31 /* AfterCdata2 */) {
                this.stateAfterCdata2(c);
            }
            else if (this._state === 26 /* BeforeCdata4 */) {
                stateBeforeCdata4(this, c);
            }
            else if (this._state === 27 /* BeforeCdata5 */) {
                stateBeforeCdata5(this, c);
            }
            else if (this._state === 28 /* BeforeCdata6 */) {
                this.stateBeforeCdata6(c);
            }
            else if (this._state === 66 /* InHexEntity */) {
                this.stateInHexEntity(c);
            }
            else if (this._state === 65 /* InNumericEntity */) {
                this.stateInNumericEntity(c);
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            }
            else if (this._state === 63 /* BeforeNumericEntity */) {
                stateBeforeNumericEntity(this, c);
            }
            else {
                this.cbs.onerror(Error("unknown _state"), this._state);
            }
            this._index++;
        }
        this.cleanup();
    };
    Tokenizer.prototype.finish = function () {
        // If there is remaining data, emit it in a reasonable way
        if (this.sectionStart < this._index) {
            this.handleTrailingData();
        }
        this.cbs.onend();
    };
    Tokenizer.prototype.handleTrailingData = function () {
        var data = this.buffer.substr(this.sectionStart);
        if (this._state === 29 /* InCdata */ ||
            this._state === 30 /* AfterCdata1 */ ||
            this._state === 31 /* AfterCdata2 */) {
            this.cbs.oncdata(data);
        }
        else if (this._state === 19 /* InComment */ ||
            this._state === 21 /* AfterComment1 */ ||
            this._state === 22 /* AfterComment2 */) {
            this.cbs.oncomment(data);
        }
        else if (this._state === 64 /* InNamedEntity */ && !this.xmlMode) {
            this.parseLegacyEntity();
            if (this.sectionStart < this._index) {
                this._state = this.baseState;
                this.handleTrailingData();
            }
        }
        else if (this._state === 65 /* InNumericEntity */ && !this.xmlMode) {
            this.decodeNumericEntity(2, 10, false);
            if (this.sectionStart < this._index) {
                this._state = this.baseState;
                this.handleTrailingData();
            }
        }
        else if (this._state === 66 /* InHexEntity */ && !this.xmlMode) {
            this.decodeNumericEntity(3, 16, false);
            if (this.sectionStart < this._index) {
                this._state = this.baseState;
                this.handleTrailingData();
            }
        }
        else if (this._state !== 3 /* InTagName */ &&
            this._state !== 8 /* BeforeAttributeName */ &&
            this._state !== 11 /* BeforeAttributeValue */ &&
            this._state !== 10 /* AfterAttributeName */ &&
            this._state !== 9 /* InAttributeName */ &&
            this._state !== 13 /* InAttributeValueSq */ &&
            this._state !== 12 /* InAttributeValueDq */ &&
            this._state !== 14 /* InAttributeValueNq */ &&
            this._state !== 6 /* InClosingTagName */) {
            this.cbs.ontext(data);
        }
        /*
         * Else, ignore remaining data
         * TODO add a way to remove current tag
         */
    };
    Tokenizer.prototype.getSection = function () {
        return this.buffer.substring(this.sectionStart, this._index);
    };
    Tokenizer.prototype.emitToken = function (name) {
        this.cbs[name](this.getSection());
        this.sectionStart = -1;
    };
    Tokenizer.prototype.emitPartial = function (value) {
        if (this.baseState !== 1 /* Text */) {
            this.cbs.onattribdata(value); // TODO implement the new event
        }
        else {
            this.cbs.ontext(value);
        }
    };
    return Tokenizer;
}());
Tokenizer$6.default = Tokenizer$5;

var __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(Parser$3, "__esModule", { value: true });
Parser$3.Parser = void 0;
var Tokenizer_1 = __importDefault$1(Tokenizer$6);
var formTags = new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea",
]);
var pTag = new Set(["p"]);
var openImpliesClose = {
    tr: new Set(["tr", "th", "td"]),
    th: new Set(["th"]),
    td: new Set(["thead", "th", "td"]),
    body: new Set(["head", "link", "script"]),
    li: new Set(["li"]),
    p: pTag,
    h1: pTag,
    h2: pTag,
    h3: pTag,
    h4: pTag,
    h5: pTag,
    h6: pTag,
    select: formTags,
    input: formTags,
    output: formTags,
    button: formTags,
    datalist: formTags,
    textarea: formTags,
    option: new Set(["option"]),
    optgroup: new Set(["optgroup", "option"]),
    dd: new Set(["dt", "dd"]),
    dt: new Set(["dt", "dd"]),
    address: pTag,
    article: pTag,
    aside: pTag,
    blockquote: pTag,
    details: pTag,
    div: pTag,
    dl: pTag,
    fieldset: pTag,
    figcaption: pTag,
    figure: pTag,
    footer: pTag,
    form: pTag,
    header: pTag,
    hr: pTag,
    main: pTag,
    nav: pTag,
    ol: pTag,
    pre: pTag,
    section: pTag,
    table: pTag,
    ul: pTag,
    rt: new Set(["rt", "rp"]),
    rp: new Set(["rt", "rp"]),
    tbody: new Set(["thead", "tbody"]),
    tfoot: new Set(["thead", "tbody"]),
};
var voidElements = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr",
]);
var foreignContextElements = new Set(["math", "svg"]);
var htmlIntegrationElements = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title",
]);
var reNameEnd = /\s|\//;
var Parser$2 = /** @class */ (function () {
    function Parser(cbs, options) {
        if (options === void 0) { options = {}; }
        var _a, _b, _c, _d, _e;
        /** The start index of the last event. */
        this.startIndex = 0;
        /** The end index of the last event. */
        this.endIndex = null;
        this.tagname = "";
        this.attribname = "";
        this.attribvalue = "";
        this.attribs = null;
        this.stack = [];
        this.foreignContext = [];
        this.options = options;
        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
        this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
        this.lowerCaseAttributeNames =
            (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
        this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_1.default)(this.options, this);
        (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
    }
    Parser.prototype.updatePosition = function (initialOffset) {
        if (this.endIndex === null) {
            if (this.tokenizer.sectionStart <= initialOffset) {
                this.startIndex = 0;
            }
            else {
                this.startIndex = this.tokenizer.sectionStart - initialOffset;
            }
        }
        else {
            this.startIndex = this.endIndex + 1;
        }
        this.endIndex = this.tokenizer.getAbsoluteIndex();
    };
    // Tokenizer event handlers
    Parser.prototype.ontext = function (data) {
        var _a, _b;
        this.updatePosition(1);
        this.endIndex--;
        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
    };
    Parser.prototype.onopentagname = function (name) {
        var _a, _b;
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        this.tagname = name;
        if (!this.options.xmlMode &&
            Object.prototype.hasOwnProperty.call(openImpliesClose, name)) {
            var el = void 0;
            while (this.stack.length > 0 &&
                openImpliesClose[name].has((el = this.stack[this.stack.length - 1]))) {
                this.onclosetag(el);
            }
        }
        if (this.options.xmlMode || !voidElements.has(name)) {
            this.stack.push(name);
            if (foreignContextElements.has(name)) {
                this.foreignContext.push(true);
            }
            else if (htmlIntegrationElements.has(name)) {
                this.foreignContext.push(false);
            }
        }
        (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, name);
        if (this.cbs.onopentag)
            this.attribs = {};
    };
    Parser.prototype.onopentagend = function () {
        var _a, _b;
        this.updatePosition(1);
        if (this.attribs) {
            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs);
            this.attribs = null;
        }
        if (!this.options.xmlMode &&
            this.cbs.onclosetag &&
            voidElements.has(this.tagname)) {
            this.cbs.onclosetag(this.tagname);
        }
        this.tagname = "";
    };
    Parser.prototype.onclosetag = function (name) {
        this.updatePosition(1);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        if (foreignContextElements.has(name) ||
            htmlIntegrationElements.has(name)) {
            this.foreignContext.pop();
        }
        if (this.stack.length &&
            (this.options.xmlMode || !voidElements.has(name))) {
            var pos = this.stack.lastIndexOf(name);
            if (pos !== -1) {
                if (this.cbs.onclosetag) {
                    pos = this.stack.length - pos;
                    while (pos--) {
                        // We know the stack has sufficient elements.
                        this.cbs.onclosetag(this.stack.pop());
                    }
                }
                else
                    this.stack.length = pos;
            }
            else if (name === "p" && !this.options.xmlMode) {
                this.onopentagname(name);
                this.closeCurrentTag();
            }
        }
        else if (!this.options.xmlMode && (name === "br" || name === "p")) {
            this.onopentagname(name);
            this.closeCurrentTag();
        }
    };
    Parser.prototype.onselfclosingtag = function () {
        if (this.options.xmlMode ||
            this.options.recognizeSelfClosing ||
            this.foreignContext[this.foreignContext.length - 1]) {
            this.closeCurrentTag();
        }
        else {
            this.onopentagend();
        }
    };
    Parser.prototype.closeCurrentTag = function () {
        var _a, _b;
        var name = this.tagname;
        this.onopentagend();
        /*
         * Self-closing tags will be on the top of the stack
         * (cheaper check than in onclosetag)
         */
        if (this.stack[this.stack.length - 1] === name) {
            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name);
            this.stack.pop();
        }
    };
    Parser.prototype.onattribname = function (name) {
        if (this.lowerCaseAttributeNames) {
            name = name.toLowerCase();
        }
        this.attribname = name;
    };
    Parser.prototype.onattribdata = function (value) {
        this.attribvalue += value;
    };
    Parser.prototype.onattribend = function (quote) {
        var _a, _b;
        (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote);
        if (this.attribs &&
            !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
            this.attribs[this.attribname] = this.attribvalue;
        }
        this.attribname = "";
        this.attribvalue = "";
    };
    Parser.prototype.getInstructionName = function (value) {
        var idx = value.search(reNameEnd);
        var name = idx < 0 ? value : value.substr(0, idx);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        return name;
    };
    Parser.prototype.ondeclaration = function (value) {
        if (this.cbs.onprocessinginstruction) {
            var name_1 = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("!" + name_1, "!" + value);
        }
    };
    Parser.prototype.onprocessinginstruction = function (value) {
        if (this.cbs.onprocessinginstruction) {
            var name_2 = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("?" + name_2, "?" + value);
        }
    };
    Parser.prototype.oncomment = function (value) {
        var _a, _b, _c, _d;
        this.updatePosition(4);
        (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, value);
        (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
    };
    Parser.prototype.oncdata = function (value) {
        var _a, _b, _c, _d, _e, _f;
        this.updatePosition(1);
        if (this.options.xmlMode || this.options.recognizeCDATA) {
            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
        }
        else {
            this.oncomment("[CDATA[" + value + "]]");
        }
    };
    Parser.prototype.onerror = function (err) {
        var _a, _b;
        (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    Parser.prototype.onend = function () {
        var _a, _b;
        if (this.cbs.onclosetag) {
            for (var i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i]))
                ;
        }
        (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    /**
     * Resets the parser to a blank state, ready to parse a new HTML document
     */
    Parser.prototype.reset = function () {
        var _a, _b, _c, _d;
        (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.tokenizer.reset();
        this.tagname = "";
        this.attribname = "";
        this.attribs = null;
        this.stack = [];
        (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
    };
    /**
     * Resets the parser, then parses a complete document and
     * pushes it to the handler.
     *
     * @param data Document to parse.
     */
    Parser.prototype.parseComplete = function (data) {
        this.reset();
        this.end(data);
    };
    /**
     * Parses a chunk of data and calls the corresponding callbacks.
     *
     * @param chunk Chunk to parse.
     */
    Parser.prototype.write = function (chunk) {
        this.tokenizer.write(chunk);
    };
    /**
     * Parses the end of the buffer and clears the stack, calls onend.
     *
     * @param chunk Optional final chunk to parse.
     */
    Parser.prototype.end = function (chunk) {
        this.tokenizer.end(chunk);
    };
    /**
     * Pauses parsing. The parser won't emit events until `resume` is called.
     */
    Parser.prototype.pause = function () {
        this.tokenizer.pause();
    };
    /**
     * Resumes parsing after `pause` was called.
     */
    Parser.prototype.resume = function () {
        this.tokenizer.resume();
    };
    /**
     * Alias of `write`, for backwards compatibility.
     *
     * @param chunk Chunk to parse.
     * @deprecated
     */
    Parser.prototype.parseChunk = function (chunk) {
        this.write(chunk);
    };
    /**
     * Alias of `end`, for backwards compatibility.
     *
     * @param chunk Optional final chunk to parse.
     * @deprecated
     */
    Parser.prototype.done = function (chunk) {
        this.end(chunk);
    };
    return Parser;
}());
Parser$3.Parser = Parser$2;

var FeedHandler$1 = {};

var __extends$3 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(FeedHandler$1, "__esModule", { value: true });
FeedHandler$1.parseFeed = FeedHandler$1.FeedHandler = void 0;
var domhandler_1$5 = __importDefault(lib$7);
var DomUtils = __importStar(lib$8);
var Parser_1 = Parser$3;
var FeedItemMediaMedium;
(function (FeedItemMediaMedium) {
    FeedItemMediaMedium[FeedItemMediaMedium["image"] = 0] = "image";
    FeedItemMediaMedium[FeedItemMediaMedium["audio"] = 1] = "audio";
    FeedItemMediaMedium[FeedItemMediaMedium["video"] = 2] = "video";
    FeedItemMediaMedium[FeedItemMediaMedium["document"] = 3] = "document";
    FeedItemMediaMedium[FeedItemMediaMedium["executable"] = 4] = "executable";
})(FeedItemMediaMedium || (FeedItemMediaMedium = {}));
var FeedItemMediaExpression;
(function (FeedItemMediaExpression) {
    FeedItemMediaExpression[FeedItemMediaExpression["sample"] = 0] = "sample";
    FeedItemMediaExpression[FeedItemMediaExpression["full"] = 1] = "full";
    FeedItemMediaExpression[FeedItemMediaExpression["nonstop"] = 2] = "nonstop";
})(FeedItemMediaExpression || (FeedItemMediaExpression = {}));
// TODO: Consume data as it is coming in
var FeedHandler = /** @class */ (function (_super) {
    __extends$3(FeedHandler, _super);
    /**
     *
     * @param callback
     * @param options
     */
    function FeedHandler(callback, options) {
        var _this = this;
        if (typeof callback === "object") {
            callback = undefined;
            options = callback;
        }
        _this = _super.call(this, callback, options) || this;
        return _this;
    }
    FeedHandler.prototype.onend = function () {
        var _a, _b;
        var feedRoot = getOneElement(isValidFeed, this.dom);
        if (!feedRoot) {
            this.handleCallback(new Error("couldn't find root of feed"));
            return;
        }
        var feed = {};
        if (feedRoot.name === "feed") {
            var childs = feedRoot.children;
            feed.type = "atom";
            addConditionally(feed, "id", "id", childs);
            addConditionally(feed, "title", "title", childs);
            var href = getAttribute("href", getOneElement("link", childs));
            if (href) {
                feed.link = href;
            }
            addConditionally(feed, "description", "subtitle", childs);
            var updated = fetch("updated", childs);
            if (updated) {
                feed.updated = new Date(updated);
            }
            addConditionally(feed, "author", "email", childs, true);
            feed.items = getElements("entry", childs).map(function (item) {
                var entry = {};
                var children = item.children;
                addConditionally(entry, "id", "id", children);
                addConditionally(entry, "title", "title", children);
                var href = getAttribute("href", getOneElement("link", children));
                if (href) {
                    entry.link = href;
                }
                var description = fetch("summary", children) || fetch("content", children);
                if (description) {
                    entry.description = description;
                }
                var pubDate = fetch("updated", children);
                if (pubDate) {
                    entry.pubDate = new Date(pubDate);
                }
                entry.media = getMediaElements(children);
                return entry;
            });
        }
        else {
            var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
            feed.type = feedRoot.name.substr(0, 3);
            feed.id = "";
            addConditionally(feed, "title", "title", childs);
            addConditionally(feed, "link", "link", childs);
            addConditionally(feed, "description", "description", childs);
            var updated = fetch("lastBuildDate", childs);
            if (updated) {
                feed.updated = new Date(updated);
            }
            addConditionally(feed, "author", "managingEditor", childs, true);
            feed.items = getElements("item", feedRoot.children).map(function (item) {
                var entry = {};
                var children = item.children;
                addConditionally(entry, "id", "guid", children);
                addConditionally(entry, "title", "title", children);
                addConditionally(entry, "link", "link", children);
                addConditionally(entry, "description", "description", children);
                var pubDate = fetch("pubDate", children);
                if (pubDate)
                    entry.pubDate = new Date(pubDate);
                entry.media = getMediaElements(children);
                return entry;
            });
        }
        this.feed = feed;
        this.handleCallback(null);
    };
    return FeedHandler;
}(domhandler_1$5.default));
FeedHandler$1.FeedHandler = FeedHandler;
function getMediaElements(where) {
    return getElements("media:content", where).map(function (elem) {
        var media = {
            medium: elem.attribs.medium,
            isDefault: !!elem.attribs.isDefault,
        };
        if (elem.attribs.url) {
            media.url = elem.attribs.url;
        }
        if (elem.attribs.fileSize) {
            media.fileSize = parseInt(elem.attribs.fileSize, 10);
        }
        if (elem.attribs.type) {
            media.type = elem.attribs.type;
        }
        if (elem.attribs.expression) {
            media.expression = elem.attribs
                .expression;
        }
        if (elem.attribs.bitrate) {
            media.bitrate = parseInt(elem.attribs.bitrate, 10);
        }
        if (elem.attribs.framerate) {
            media.framerate = parseInt(elem.attribs.framerate, 10);
        }
        if (elem.attribs.samplingrate) {
            media.samplingrate = parseInt(elem.attribs.samplingrate, 10);
        }
        if (elem.attribs.channels) {
            media.channels = parseInt(elem.attribs.channels, 10);
        }
        if (elem.attribs.duration) {
            media.duration = parseInt(elem.attribs.duration, 10);
        }
        if (elem.attribs.height) {
            media.height = parseInt(elem.attribs.height, 10);
        }
        if (elem.attribs.width) {
            media.width = parseInt(elem.attribs.width, 10);
        }
        if (elem.attribs.lang) {
            media.lang = elem.attribs.lang;
        }
        return media;
    });
}
function getElements(tagName, where) {
    return DomUtils.getElementsByTagName(tagName, where, true);
}
function getOneElement(tagName, node) {
    return DomUtils.getElementsByTagName(tagName, node, true, 1)[0];
}
function fetch(tagName, where, recurse) {
    if (recurse === void 0) { recurse = false; }
    return DomUtils.getText(DomUtils.getElementsByTagName(tagName, where, recurse, 1)).trim();
}
function getAttribute(name, elem) {
    if (!elem) {
        return null;
    }
    var attribs = elem.attribs;
    return attribs[name];
}
function addConditionally(obj, prop, what, where, recurse) {
    if (recurse === void 0) { recurse = false; }
    var tmp = fetch(what, where, recurse);
    if (tmp)
        obj[prop] = tmp;
}
function isValidFeed(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
}
/**
 * Parse a feed.
 *
 * @param feed The feed that should be parsed, as a string.
 * @param options Optionally, options for parsing. When using this option, you should set `xmlMode` to `true`.
 */
function parseFeed(feed, options) {
    if (options === void 0) { options = { xmlMode: true }; }
    var handler = new FeedHandler(options);
    new Parser_1.Parser(handler, options).end(feed);
    return handler.feed;
}
FeedHandler$1.parseFeed = parseFeed;

(function (exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RssHandler = exports.DefaultHandler = exports.DomUtils = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.parseDocument = exports.DomHandler = exports.Parser = void 0;
var Parser_1 = Parser$3;
Object.defineProperty(exports, "Parser", { enumerable: true, get: function () { return Parser_1.Parser; } });
var domhandler_1 = lib$7;
Object.defineProperty(exports, "DomHandler", { enumerable: true, get: function () { return domhandler_1.DomHandler; } });
Object.defineProperty(exports, "DefaultHandler", { enumerable: true, get: function () { return domhandler_1.DomHandler; } });
// Helper methods
/**
 * Parses the data, returns the resulting document.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 */
function parseDocument(data, options) {
    var handler = new domhandler_1.DomHandler(undefined, options);
    new Parser_1.Parser(handler, options).end(data);
    return handler.root;
}
exports.parseDocument = parseDocument;
/**
 * Parses data, returns an array of the root nodes.
 *
 * Note that the root nodes still have a `Document` node as their parent.
 * Use `parseDocument` to get the `Document` node instead.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 * @deprecated Use `parseDocument` instead.
 */
function parseDOM(data, options) {
    return parseDocument(data, options).children;
}
exports.parseDOM = parseDOM;
/**
 * Creates a parser instance, with an attached DOM handler.
 *
 * @param cb A callback that will be called once parsing has been completed.
 * @param options Optional options for the parser and DOM builder.
 * @param elementCb An optional callback that will be called every time a tag has been completed inside of the DOM.
 */
function createDomStream(cb, options, elementCb) {
    var handler = new domhandler_1.DomHandler(cb, options, elementCb);
    return new Parser_1.Parser(handler, options);
}
exports.createDomStream = createDomStream;
var Tokenizer_1 = Tokenizer$6;
Object.defineProperty(exports, "Tokenizer", { enumerable: true, get: function () { return __importDefault(Tokenizer_1).default; } });
var ElementType = __importStar(lib$6);
exports.ElementType = ElementType;
/*
 * All of the following exports exist for backwards-compatibility.
 * They should probably be removed eventually.
 */
__exportStar(FeedHandler$1, exports);
exports.DomUtils = __importStar(lib$8);
var FeedHandler_1 = FeedHandler$1;
Object.defineProperty(exports, "RssHandler", { enumerable: true, get: function () { return FeedHandler_1.FeedHandler; } });
}(lib$2));

var parse5Adapter = {};

var lib$1 = {};

var unicode$3 = {};

const UNDEFINED_CODE_POINTS = [
    0xfffe,
    0xffff,
    0x1fffe,
    0x1ffff,
    0x2fffe,
    0x2ffff,
    0x3fffe,
    0x3ffff,
    0x4fffe,
    0x4ffff,
    0x5fffe,
    0x5ffff,
    0x6fffe,
    0x6ffff,
    0x7fffe,
    0x7ffff,
    0x8fffe,
    0x8ffff,
    0x9fffe,
    0x9ffff,
    0xafffe,
    0xaffff,
    0xbfffe,
    0xbffff,
    0xcfffe,
    0xcffff,
    0xdfffe,
    0xdffff,
    0xefffe,
    0xeffff,
    0xffffe,
    0xfffff,
    0x10fffe,
    0x10ffff
];

unicode$3.REPLACEMENT_CHARACTER = '\uFFFD';

unicode$3.CODE_POINTS = {
    EOF: -1,
    NULL: 0x00,
    TABULATION: 0x09,
    CARRIAGE_RETURN: 0x0d,
    LINE_FEED: 0x0a,
    FORM_FEED: 0x0c,
    SPACE: 0x20,
    EXCLAMATION_MARK: 0x21,
    QUOTATION_MARK: 0x22,
    NUMBER_SIGN: 0x23,
    AMPERSAND: 0x26,
    APOSTROPHE: 0x27,
    HYPHEN_MINUS: 0x2d,
    SOLIDUS: 0x2f,
    DIGIT_0: 0x30,
    DIGIT_9: 0x39,
    SEMICOLON: 0x3b,
    LESS_THAN_SIGN: 0x3c,
    EQUALS_SIGN: 0x3d,
    GREATER_THAN_SIGN: 0x3e,
    QUESTION_MARK: 0x3f,
    LATIN_CAPITAL_A: 0x41,
    LATIN_CAPITAL_F: 0x46,
    LATIN_CAPITAL_X: 0x58,
    LATIN_CAPITAL_Z: 0x5a,
    RIGHT_SQUARE_BRACKET: 0x5d,
    GRAVE_ACCENT: 0x60,
    LATIN_SMALL_A: 0x61,
    LATIN_SMALL_F: 0x66,
    LATIN_SMALL_X: 0x78,
    LATIN_SMALL_Z: 0x7a,
    REPLACEMENT_CHARACTER: 0xfffd
};

unicode$3.CODE_POINT_SEQUENCES = {
    DASH_DASH_STRING: [0x2d, 0x2d], //--
    DOCTYPE_STRING: [0x44, 0x4f, 0x43, 0x54, 0x59, 0x50, 0x45], //DOCTYPE
    CDATA_START_STRING: [0x5b, 0x43, 0x44, 0x41, 0x54, 0x41, 0x5b], //[CDATA[
    SCRIPT_STRING: [0x73, 0x63, 0x72, 0x69, 0x70, 0x74], //script
    PUBLIC_STRING: [0x50, 0x55, 0x42, 0x4c, 0x49, 0x43], //PUBLIC
    SYSTEM_STRING: [0x53, 0x59, 0x53, 0x54, 0x45, 0x4d] //SYSTEM
};

//Surrogates
unicode$3.isSurrogate = function(cp) {
    return cp >= 0xd800 && cp <= 0xdfff;
};

unicode$3.isSurrogatePair = function(cp) {
    return cp >= 0xdc00 && cp <= 0xdfff;
};

unicode$3.getSurrogatePairCodePoint = function(cp1, cp2) {
    return (cp1 - 0xd800) * 0x400 + 0x2400 + cp2;
};

//NOTE: excluding NULL and ASCII whitespace
unicode$3.isControlCodePoint = function(cp) {
    return (
        (cp !== 0x20 && cp !== 0x0a && cp !== 0x0d && cp !== 0x09 && cp !== 0x0c && cp >= 0x01 && cp <= 0x1f) ||
        (cp >= 0x7f && cp <= 0x9f)
    );
};

unicode$3.isUndefinedCodePoint = function(cp) {
    return (cp >= 0xfdd0 && cp <= 0xfdef) || UNDEFINED_CODE_POINTS.indexOf(cp) > -1;
};

var errorCodes = {
    controlCharacterInInputStream: 'control-character-in-input-stream',
    noncharacterInInputStream: 'noncharacter-in-input-stream',
    surrogateInInputStream: 'surrogate-in-input-stream',
    nonVoidHtmlElementStartTagWithTrailingSolidus: 'non-void-html-element-start-tag-with-trailing-solidus',
    endTagWithAttributes: 'end-tag-with-attributes',
    endTagWithTrailingSolidus: 'end-tag-with-trailing-solidus',
    unexpectedSolidusInTag: 'unexpected-solidus-in-tag',
    unexpectedNullCharacter: 'unexpected-null-character',
    unexpectedQuestionMarkInsteadOfTagName: 'unexpected-question-mark-instead-of-tag-name',
    invalidFirstCharacterOfTagName: 'invalid-first-character-of-tag-name',
    unexpectedEqualsSignBeforeAttributeName: 'unexpected-equals-sign-before-attribute-name',
    missingEndTagName: 'missing-end-tag-name',
    unexpectedCharacterInAttributeName: 'unexpected-character-in-attribute-name',
    unknownNamedCharacterReference: 'unknown-named-character-reference',
    missingSemicolonAfterCharacterReference: 'missing-semicolon-after-character-reference',
    unexpectedCharacterAfterDoctypeSystemIdentifier: 'unexpected-character-after-doctype-system-identifier',
    unexpectedCharacterInUnquotedAttributeValue: 'unexpected-character-in-unquoted-attribute-value',
    eofBeforeTagName: 'eof-before-tag-name',
    eofInTag: 'eof-in-tag',
    missingAttributeValue: 'missing-attribute-value',
    missingWhitespaceBetweenAttributes: 'missing-whitespace-between-attributes',
    missingWhitespaceAfterDoctypePublicKeyword: 'missing-whitespace-after-doctype-public-keyword',
    missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers:
        'missing-whitespace-between-doctype-public-and-system-identifiers',
    missingWhitespaceAfterDoctypeSystemKeyword: 'missing-whitespace-after-doctype-system-keyword',
    missingQuoteBeforeDoctypePublicIdentifier: 'missing-quote-before-doctype-public-identifier',
    missingQuoteBeforeDoctypeSystemIdentifier: 'missing-quote-before-doctype-system-identifier',
    missingDoctypePublicIdentifier: 'missing-doctype-public-identifier',
    missingDoctypeSystemIdentifier: 'missing-doctype-system-identifier',
    abruptDoctypePublicIdentifier: 'abrupt-doctype-public-identifier',
    abruptDoctypeSystemIdentifier: 'abrupt-doctype-system-identifier',
    cdataInHtmlContent: 'cdata-in-html-content',
    incorrectlyOpenedComment: 'incorrectly-opened-comment',
    eofInScriptHtmlCommentLikeText: 'eof-in-script-html-comment-like-text',
    eofInDoctype: 'eof-in-doctype',
    nestedComment: 'nested-comment',
    abruptClosingOfEmptyComment: 'abrupt-closing-of-empty-comment',
    eofInComment: 'eof-in-comment',
    incorrectlyClosedComment: 'incorrectly-closed-comment',
    eofInCdata: 'eof-in-cdata',
    absenceOfDigitsInNumericCharacterReference: 'absence-of-digits-in-numeric-character-reference',
    nullCharacterReference: 'null-character-reference',
    surrogateCharacterReference: 'surrogate-character-reference',
    characterReferenceOutsideUnicodeRange: 'character-reference-outside-unicode-range',
    controlCharacterReference: 'control-character-reference',
    noncharacterCharacterReference: 'noncharacter-character-reference',
    missingWhitespaceBeforeDoctypeName: 'missing-whitespace-before-doctype-name',
    missingDoctypeName: 'missing-doctype-name',
    invalidCharacterSequenceAfterDoctypeName: 'invalid-character-sequence-after-doctype-name',
    duplicateAttribute: 'duplicate-attribute',
    nonConformingDoctype: 'non-conforming-doctype',
    missingDoctype: 'missing-doctype',
    misplacedDoctype: 'misplaced-doctype',
    endTagWithoutMatchingOpenElement: 'end-tag-without-matching-open-element',
    closingOfElementWithOpenChildElements: 'closing-of-element-with-open-child-elements',
    disallowedContentInNoscriptInHead: 'disallowed-content-in-noscript-in-head',
    openElementsLeftAfterEof: 'open-elements-left-after-eof',
    abandonedHeadElementChild: 'abandoned-head-element-child',
    misplacedStartTagForHeadElement: 'misplaced-start-tag-for-head-element',
    nestedNoscriptInHead: 'nested-noscript-in-head',
    eofInElementThatCanContainOnlyText: 'eof-in-element-that-can-contain-only-text'
};

const unicode$2 = unicode$3;
const ERR$2 = errorCodes;

//Aliases
const $$7 = unicode$2.CODE_POINTS;

//Const
const DEFAULT_BUFFER_WATERLINE = 1 << 16;

//Preprocessor
//NOTE: HTML input preprocessing
//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)
class Preprocessor$1 {
    constructor() {
        this.html = null;

        this.pos = -1;
        this.lastGapPos = -1;
        this.lastCharPos = -1;

        this.gapStack = [];

        this.skipNextNewLine = false;

        this.lastChunkWritten = false;
        this.endOfChunkHit = false;
        this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
    }

    _err() {
        // NOTE: err reporting is noop by default. Enabled by mixin.
    }

    _addGap() {
        this.gapStack.push(this.lastGapPos);
        this.lastGapPos = this.pos;
    }

    _processSurrogate(cp) {
        //NOTE: try to peek a surrogate pair
        if (this.pos !== this.lastCharPos) {
            const nextCp = this.html.charCodeAt(this.pos + 1);

            if (unicode$2.isSurrogatePair(nextCp)) {
                //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.
                this.pos++;

                //NOTE: add gap that should be avoided during retreat
                this._addGap();

                return unicode$2.getSurrogatePairCodePoint(cp, nextCp);
            }
        }

        //NOTE: we are at the end of a chunk, therefore we can't infer surrogate pair yet.
        else if (!this.lastChunkWritten) {
            this.endOfChunkHit = true;
            return $$7.EOF;
        }

        //NOTE: isolated surrogate
        this._err(ERR$2.surrogateInInputStream);

        return cp;
    }

    dropParsedChunk() {
        if (this.pos > this.bufferWaterline) {
            this.lastCharPos -= this.pos;
            this.html = this.html.substring(this.pos);
            this.pos = 0;
            this.lastGapPos = -1;
            this.gapStack = [];
        }
    }

    write(chunk, isLastChunk) {
        if (this.html) {
            this.html += chunk;
        } else {
            this.html = chunk;
        }

        this.lastCharPos = this.html.length - 1;
        this.endOfChunkHit = false;
        this.lastChunkWritten = isLastChunk;
    }

    insertHtmlAtCurrentPos(chunk) {
        this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1, this.html.length);

        this.lastCharPos = this.html.length - 1;
        this.endOfChunkHit = false;
    }

    advance() {
        this.pos++;

        if (this.pos > this.lastCharPos) {
            this.endOfChunkHit = !this.lastChunkWritten;
            return $$7.EOF;
        }

        let cp = this.html.charCodeAt(this.pos);

        //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character
        //must be ignored.
        if (this.skipNextNewLine && cp === $$7.LINE_FEED) {
            this.skipNextNewLine = false;
            this._addGap();
            return this.advance();
        }

        //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters
        if (cp === $$7.CARRIAGE_RETURN) {
            this.skipNextNewLine = true;
            return $$7.LINE_FEED;
        }

        this.skipNextNewLine = false;

        if (unicode$2.isSurrogate(cp)) {
            cp = this._processSurrogate(cp);
        }

        //OPTIMIZATION: first check if code point is in the common allowed
        //range (ASCII alphanumeric, whitespaces, big chunk of BMP)
        //before going into detailed performance cost validation.
        const isCommonValidRange =
            (cp > 0x1f && cp < 0x7f) || cp === $$7.LINE_FEED || cp === $$7.CARRIAGE_RETURN || (cp > 0x9f && cp < 0xfdd0);

        if (!isCommonValidRange) {
            this._checkForProblematicCharacters(cp);
        }

        return cp;
    }

    _checkForProblematicCharacters(cp) {
        if (unicode$2.isControlCodePoint(cp)) {
            this._err(ERR$2.controlCharacterInInputStream);
        } else if (unicode$2.isUndefinedCodePoint(cp)) {
            this._err(ERR$2.noncharacterInInputStream);
        }
    }

    retreat() {
        if (this.pos === this.lastGapPos) {
            this.lastGapPos = this.gapStack.pop();
            this.pos--;
        }

        this.pos--;
    }
}

var preprocessor = Preprocessor$1;

//NOTE: this file contains auto-generated array mapped radix tree that is used for the named entity references consumption
//(details: https://github.com/inikulin/parse5/tree/master/scripts/generate-named-entity-data/README.md)
var namedEntityData = new Uint16Array([4,52,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,106,303,412,810,1432,1701,1796,1987,2114,2360,2420,2484,3170,3251,4140,4393,4575,4610,5106,5512,5728,6117,6274,6315,6345,6427,6516,7002,7910,8733,9323,9870,10170,10631,10893,11318,11386,11467,12773,13092,14474,14922,15448,15542,16419,17666,18166,18611,19004,19095,19298,19397,4,16,69,77,97,98,99,102,103,108,109,110,111,112,114,115,116,117,140,150,158,169,176,194,199,210,216,222,226,242,256,266,283,294,108,105,103,5,198,1,59,148,1,198,80,5,38,1,59,156,1,38,99,117,116,101,5,193,1,59,167,1,193,114,101,118,101,59,1,258,4,2,105,121,182,191,114,99,5,194,1,59,189,1,194,59,1,1040,114,59,3,55349,56580,114,97,118,101,5,192,1,59,208,1,192,112,104,97,59,1,913,97,99,114,59,1,256,100,59,1,10835,4,2,103,112,232,237,111,110,59,1,260,102,59,3,55349,56632,112,108,121,70,117,110,99,116,105,111,110,59,1,8289,105,110,103,5,197,1,59,264,1,197,4,2,99,115,272,277,114,59,3,55349,56476,105,103,110,59,1,8788,105,108,100,101,5,195,1,59,292,1,195,109,108,5,196,1,59,301,1,196,4,8,97,99,101,102,111,114,115,117,321,350,354,383,388,394,400,405,4,2,99,114,327,336,107,115,108,97,115,104,59,1,8726,4,2,118,119,342,345,59,1,10983,101,100,59,1,8966,121,59,1,1041,4,3,99,114,116,362,369,379,97,117,115,101,59,1,8757,110,111,117,108,108,105,115,59,1,8492,97,59,1,914,114,59,3,55349,56581,112,102,59,3,55349,56633,101,118,101,59,1,728,99,114,59,1,8492,109,112,101,113,59,1,8782,4,14,72,79,97,99,100,101,102,104,105,108,111,114,115,117,442,447,456,504,542,547,569,573,577,616,678,784,790,796,99,121,59,1,1063,80,89,5,169,1,59,454,1,169,4,3,99,112,121,464,470,497,117,116,101,59,1,262,4,2,59,105,476,478,1,8914,116,97,108,68,105,102,102,101,114,101,110,116,105,97,108,68,59,1,8517,108,101,121,115,59,1,8493,4,4,97,101,105,111,514,520,530,535,114,111,110,59,1,268,100,105,108,5,199,1,59,528,1,199,114,99,59,1,264,110,105,110,116,59,1,8752,111,116,59,1,266,4,2,100,110,553,560,105,108,108,97,59,1,184,116,101,114,68,111,116,59,1,183,114,59,1,8493,105,59,1,935,114,99,108,101,4,4,68,77,80,84,591,596,603,609,111,116,59,1,8857,105,110,117,115,59,1,8854,108,117,115,59,1,8853,105,109,101,115,59,1,8855,111,4,2,99,115,623,646,107,119,105,115,101,67,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8754,101,67,117,114,108,121,4,2,68,81,658,671,111,117,98,108,101,81,117,111,116,101,59,1,8221,117,111,116,101,59,1,8217,4,4,108,110,112,117,688,701,736,753,111,110,4,2,59,101,696,698,1,8759,59,1,10868,4,3,103,105,116,709,717,722,114,117,101,110,116,59,1,8801,110,116,59,1,8751,111,117,114,73,110,116,101,103,114,97,108,59,1,8750,4,2,102,114,742,745,59,1,8450,111,100,117,99,116,59,1,8720,110,116,101,114,67,108,111,99,107,119,105,115,101,67,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8755,111,115,115,59,1,10799,99,114,59,3,55349,56478,112,4,2,59,67,803,805,1,8915,97,112,59,1,8781,4,11,68,74,83,90,97,99,101,102,105,111,115,834,850,855,860,865,888,903,916,921,1011,1415,4,2,59,111,840,842,1,8517,116,114,97,104,100,59,1,10513,99,121,59,1,1026,99,121,59,1,1029,99,121,59,1,1039,4,3,103,114,115,873,879,883,103,101,114,59,1,8225,114,59,1,8609,104,118,59,1,10980,4,2,97,121,894,900,114,111,110,59,1,270,59,1,1044,108,4,2,59,116,910,912,1,8711,97,59,1,916,114,59,3,55349,56583,4,2,97,102,927,998,4,2,99,109,933,992,114,105,116,105,99,97,108,4,4,65,68,71,84,950,957,978,985,99,117,116,101,59,1,180,111,4,2,116,117,964,967,59,1,729,98,108,101,65,99,117,116,101,59,1,733,114,97,118,101,59,1,96,105,108,100,101,59,1,732,111,110,100,59,1,8900,102,101,114,101,110,116,105,97,108,68,59,1,8518,4,4,112,116,117,119,1021,1026,1048,1249,102,59,3,55349,56635,4,3,59,68,69,1034,1036,1041,1,168,111,116,59,1,8412,113,117,97,108,59,1,8784,98,108,101,4,6,67,68,76,82,85,86,1065,1082,1101,1189,1211,1236,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8751,111,4,2,116,119,1089,1092,59,1,168,110,65,114,114,111,119,59,1,8659,4,2,101,111,1107,1141,102,116,4,3,65,82,84,1117,1124,1136,114,114,111,119,59,1,8656,105,103,104,116,65,114,114,111,119,59,1,8660,101,101,59,1,10980,110,103,4,2,76,82,1149,1177,101,102,116,4,2,65,82,1158,1165,114,114,111,119,59,1,10232,105,103,104,116,65,114,114,111,119,59,1,10234,105,103,104,116,65,114,114,111,119,59,1,10233,105,103,104,116,4,2,65,84,1199,1206,114,114,111,119,59,1,8658,101,101,59,1,8872,112,4,2,65,68,1218,1225,114,114,111,119,59,1,8657,111,119,110,65,114,114,111,119,59,1,8661,101,114,116,105,99,97,108,66,97,114,59,1,8741,110,4,6,65,66,76,82,84,97,1264,1292,1299,1352,1391,1408,114,114,111,119,4,3,59,66,85,1276,1278,1283,1,8595,97,114,59,1,10515,112,65,114,114,111,119,59,1,8693,114,101,118,101,59,1,785,101,102,116,4,3,82,84,86,1310,1323,1334,105,103,104,116,86,101,99,116,111,114,59,1,10576,101,101,86,101,99,116,111,114,59,1,10590,101,99,116,111,114,4,2,59,66,1345,1347,1,8637,97,114,59,1,10582,105,103,104,116,4,2,84,86,1362,1373,101,101,86,101,99,116,111,114,59,1,10591,101,99,116,111,114,4,2,59,66,1384,1386,1,8641,97,114,59,1,10583,101,101,4,2,59,65,1399,1401,1,8868,114,114,111,119,59,1,8615,114,114,111,119,59,1,8659,4,2,99,116,1421,1426,114,59,3,55349,56479,114,111,107,59,1,272,4,16,78,84,97,99,100,102,103,108,109,111,112,113,115,116,117,120,1466,1470,1478,1489,1515,1520,1525,1536,1544,1593,1609,1617,1650,1664,1668,1677,71,59,1,330,72,5,208,1,59,1476,1,208,99,117,116,101,5,201,1,59,1487,1,201,4,3,97,105,121,1497,1503,1512,114,111,110,59,1,282,114,99,5,202,1,59,1510,1,202,59,1,1069,111,116,59,1,278,114,59,3,55349,56584,114,97,118,101,5,200,1,59,1534,1,200,101,109,101,110,116,59,1,8712,4,2,97,112,1550,1555,99,114,59,1,274,116,121,4,2,83,86,1563,1576,109,97,108,108,83,113,117,97,114,101,59,1,9723,101,114,121,83,109,97,108,108,83,113,117,97,114,101,59,1,9643,4,2,103,112,1599,1604,111,110,59,1,280,102,59,3,55349,56636,115,105,108,111,110,59,1,917,117,4,2,97,105,1624,1640,108,4,2,59,84,1631,1633,1,10869,105,108,100,101,59,1,8770,108,105,98,114,105,117,109,59,1,8652,4,2,99,105,1656,1660,114,59,1,8496,109,59,1,10867,97,59,1,919,109,108,5,203,1,59,1675,1,203,4,2,105,112,1683,1689,115,116,115,59,1,8707,111,110,101,110,116,105,97,108,69,59,1,8519,4,5,99,102,105,111,115,1713,1717,1722,1762,1791,121,59,1,1060,114,59,3,55349,56585,108,108,101,100,4,2,83,86,1732,1745,109,97,108,108,83,113,117,97,114,101,59,1,9724,101,114,121,83,109,97,108,108,83,113,117,97,114,101,59,1,9642,4,3,112,114,117,1770,1775,1781,102,59,3,55349,56637,65,108,108,59,1,8704,114,105,101,114,116,114,102,59,1,8497,99,114,59,1,8497,4,12,74,84,97,98,99,100,102,103,111,114,115,116,1822,1827,1834,1848,1855,1877,1882,1887,1890,1896,1978,1984,99,121,59,1,1027,5,62,1,59,1832,1,62,109,109,97,4,2,59,100,1843,1845,1,915,59,1,988,114,101,118,101,59,1,286,4,3,101,105,121,1863,1869,1874,100,105,108,59,1,290,114,99,59,1,284,59,1,1043,111,116,59,1,288,114,59,3,55349,56586,59,1,8921,112,102,59,3,55349,56638,101,97,116,101,114,4,6,69,70,71,76,83,84,1915,1933,1944,1953,1959,1971,113,117,97,108,4,2,59,76,1925,1927,1,8805,101,115,115,59,1,8923,117,108,108,69,113,117,97,108,59,1,8807,114,101,97,116,101,114,59,1,10914,101,115,115,59,1,8823,108,97,110,116,69,113,117,97,108,59,1,10878,105,108,100,101,59,1,8819,99,114,59,3,55349,56482,59,1,8811,4,8,65,97,99,102,105,111,115,117,2005,2012,2026,2032,2036,2049,2073,2089,82,68,99,121,59,1,1066,4,2,99,116,2018,2023,101,107,59,1,711,59,1,94,105,114,99,59,1,292,114,59,1,8460,108,98,101,114,116,83,112,97,99,101,59,1,8459,4,2,112,114,2055,2059,102,59,1,8461,105,122,111,110,116,97,108,76,105,110,101,59,1,9472,4,2,99,116,2079,2083,114,59,1,8459,114,111,107,59,1,294,109,112,4,2,68,69,2097,2107,111,119,110,72,117,109,112,59,1,8782,113,117,97,108,59,1,8783,4,14,69,74,79,97,99,100,102,103,109,110,111,115,116,117,2144,2149,2155,2160,2171,2189,2194,2198,2209,2245,2307,2329,2334,2341,99,121,59,1,1045,108,105,103,59,1,306,99,121,59,1,1025,99,117,116,101,5,205,1,59,2169,1,205,4,2,105,121,2177,2186,114,99,5,206,1,59,2184,1,206,59,1,1048,111,116,59,1,304,114,59,1,8465,114,97,118,101,5,204,1,59,2207,1,204,4,3,59,97,112,2217,2219,2238,1,8465,4,2,99,103,2225,2229,114,59,1,298,105,110,97,114,121,73,59,1,8520,108,105,101,115,59,1,8658,4,2,116,118,2251,2281,4,2,59,101,2257,2259,1,8748,4,2,103,114,2265,2271,114,97,108,59,1,8747,115,101,99,116,105,111,110,59,1,8898,105,115,105,98,108,101,4,2,67,84,2293,2300,111,109,109,97,59,1,8291,105,109,101,115,59,1,8290,4,3,103,112,116,2315,2320,2325,111,110,59,1,302,102,59,3,55349,56640,97,59,1,921,99,114,59,1,8464,105,108,100,101,59,1,296,4,2,107,109,2347,2352,99,121,59,1,1030,108,5,207,1,59,2358,1,207,4,5,99,102,111,115,117,2372,2386,2391,2397,2414,4,2,105,121,2378,2383,114,99,59,1,308,59,1,1049,114,59,3,55349,56589,112,102,59,3,55349,56641,4,2,99,101,2403,2408,114,59,3,55349,56485,114,99,121,59,1,1032,107,99,121,59,1,1028,4,7,72,74,97,99,102,111,115,2436,2441,2446,2452,2467,2472,2478,99,121,59,1,1061,99,121,59,1,1036,112,112,97,59,1,922,4,2,101,121,2458,2464,100,105,108,59,1,310,59,1,1050,114,59,3,55349,56590,112,102,59,3,55349,56642,99,114,59,3,55349,56486,4,11,74,84,97,99,101,102,108,109,111,115,116,2508,2513,2520,2562,2585,2981,2986,3004,3011,3146,3167,99,121,59,1,1033,5,60,1,59,2518,1,60,4,5,99,109,110,112,114,2532,2538,2544,2548,2558,117,116,101,59,1,313,98,100,97,59,1,923,103,59,1,10218,108,97,99,101,116,114,102,59,1,8466,114,59,1,8606,4,3,97,101,121,2570,2576,2582,114,111,110,59,1,317,100,105,108,59,1,315,59,1,1051,4,2,102,115,2591,2907,116,4,10,65,67,68,70,82,84,85,86,97,114,2614,2663,2672,2728,2735,2760,2820,2870,2888,2895,4,2,110,114,2620,2633,103,108,101,66,114,97,99,107,101,116,59,1,10216,114,111,119,4,3,59,66,82,2644,2646,2651,1,8592,97,114,59,1,8676,105,103,104,116,65,114,114,111,119,59,1,8646,101,105,108,105,110,103,59,1,8968,111,4,2,117,119,2679,2692,98,108,101,66,114,97,99,107,101,116,59,1,10214,110,4,2,84,86,2699,2710,101,101,86,101,99,116,111,114,59,1,10593,101,99,116,111,114,4,2,59,66,2721,2723,1,8643,97,114,59,1,10585,108,111,111,114,59,1,8970,105,103,104,116,4,2,65,86,2745,2752,114,114,111,119,59,1,8596,101,99,116,111,114,59,1,10574,4,2,101,114,2766,2792,101,4,3,59,65,86,2775,2777,2784,1,8867,114,114,111,119,59,1,8612,101,99,116,111,114,59,1,10586,105,97,110,103,108,101,4,3,59,66,69,2806,2808,2813,1,8882,97,114,59,1,10703,113,117,97,108,59,1,8884,112,4,3,68,84,86,2829,2841,2852,111,119,110,86,101,99,116,111,114,59,1,10577,101,101,86,101,99,116,111,114,59,1,10592,101,99,116,111,114,4,2,59,66,2863,2865,1,8639,97,114,59,1,10584,101,99,116,111,114,4,2,59,66,2881,2883,1,8636,97,114,59,1,10578,114,114,111,119,59,1,8656,105,103,104,116,97,114,114,111,119,59,1,8660,115,4,6,69,70,71,76,83,84,2922,2936,2947,2956,2962,2974,113,117,97,108,71,114,101,97,116,101,114,59,1,8922,117,108,108,69,113,117,97,108,59,1,8806,114,101,97,116,101,114,59,1,8822,101,115,115,59,1,10913,108,97,110,116,69,113,117,97,108,59,1,10877,105,108,100,101,59,1,8818,114,59,3,55349,56591,4,2,59,101,2992,2994,1,8920,102,116,97,114,114,111,119,59,1,8666,105,100,111,116,59,1,319,4,3,110,112,119,3019,3110,3115,103,4,4,76,82,108,114,3030,3058,3070,3098,101,102,116,4,2,65,82,3039,3046,114,114,111,119,59,1,10229,105,103,104,116,65,114,114,111,119,59,1,10231,105,103,104,116,65,114,114,111,119,59,1,10230,101,102,116,4,2,97,114,3079,3086,114,114,111,119,59,1,10232,105,103,104,116,97,114,114,111,119,59,1,10234,105,103,104,116,97,114,114,111,119,59,1,10233,102,59,3,55349,56643,101,114,4,2,76,82,3123,3134,101,102,116,65,114,114,111,119,59,1,8601,105,103,104,116,65,114,114,111,119,59,1,8600,4,3,99,104,116,3154,3158,3161,114,59,1,8466,59,1,8624,114,111,107,59,1,321,59,1,8810,4,8,97,99,101,102,105,111,115,117,3188,3192,3196,3222,3227,3237,3243,3248,112,59,1,10501,121,59,1,1052,4,2,100,108,3202,3213,105,117,109,83,112,97,99,101,59,1,8287,108,105,110,116,114,102,59,1,8499,114,59,3,55349,56592,110,117,115,80,108,117,115,59,1,8723,112,102,59,3,55349,56644,99,114,59,1,8499,59,1,924,4,9,74,97,99,101,102,111,115,116,117,3271,3276,3283,3306,3422,3427,4120,4126,4137,99,121,59,1,1034,99,117,116,101,59,1,323,4,3,97,101,121,3291,3297,3303,114,111,110,59,1,327,100,105,108,59,1,325,59,1,1053,4,3,103,115,119,3314,3380,3415,97,116,105,118,101,4,3,77,84,86,3327,3340,3365,101,100,105,117,109,83,112,97,99,101,59,1,8203,104,105,4,2,99,110,3348,3357,107,83,112,97,99,101,59,1,8203,83,112,97,99,101,59,1,8203,101,114,121,84,104,105,110,83,112,97,99,101,59,1,8203,116,101,100,4,2,71,76,3389,3405,114,101,97,116,101,114,71,114,101,97,116,101,114,59,1,8811,101,115,115,76,101,115,115,59,1,8810,76,105,110,101,59,1,10,114,59,3,55349,56593,4,4,66,110,112,116,3437,3444,3460,3464,114,101,97,107,59,1,8288,66,114,101,97,107,105,110,103,83,112,97,99,101,59,1,160,102,59,1,8469,4,13,59,67,68,69,71,72,76,78,80,82,83,84,86,3492,3494,3517,3536,3578,3657,3685,3784,3823,3860,3915,4066,4107,1,10988,4,2,111,117,3500,3510,110,103,114,117,101,110,116,59,1,8802,112,67,97,112,59,1,8813,111,117,98,108,101,86,101,114,116,105,99,97,108,66,97,114,59,1,8742,4,3,108,113,120,3544,3552,3571,101,109,101,110,116,59,1,8713,117,97,108,4,2,59,84,3561,3563,1,8800,105,108,100,101,59,3,8770,824,105,115,116,115,59,1,8708,114,101,97,116,101,114,4,7,59,69,70,71,76,83,84,3600,3602,3609,3621,3631,3637,3650,1,8815,113,117,97,108,59,1,8817,117,108,108,69,113,117,97,108,59,3,8807,824,114,101,97,116,101,114,59,3,8811,824,101,115,115,59,1,8825,108,97,110,116,69,113,117,97,108,59,3,10878,824,105,108,100,101,59,1,8821,117,109,112,4,2,68,69,3666,3677,111,119,110,72,117,109,112,59,3,8782,824,113,117,97,108,59,3,8783,824,101,4,2,102,115,3692,3724,116,84,114,105,97,110,103,108,101,4,3,59,66,69,3709,3711,3717,1,8938,97,114,59,3,10703,824,113,117,97,108,59,1,8940,115,4,6,59,69,71,76,83,84,3739,3741,3748,3757,3764,3777,1,8814,113,117,97,108,59,1,8816,114,101,97,116,101,114,59,1,8824,101,115,115,59,3,8810,824,108,97,110,116,69,113,117,97,108,59,3,10877,824,105,108,100,101,59,1,8820,101,115,116,101,100,4,2,71,76,3795,3812,114,101,97,116,101,114,71,114,101,97,116,101,114,59,3,10914,824,101,115,115,76,101,115,115,59,3,10913,824,114,101,99,101,100,101,115,4,3,59,69,83,3838,3840,3848,1,8832,113,117,97,108,59,3,10927,824,108,97,110,116,69,113,117,97,108,59,1,8928,4,2,101,105,3866,3881,118,101,114,115,101,69,108,101,109,101,110,116,59,1,8716,103,104,116,84,114,105,97,110,103,108,101,4,3,59,66,69,3900,3902,3908,1,8939,97,114,59,3,10704,824,113,117,97,108,59,1,8941,4,2,113,117,3921,3973,117,97,114,101,83,117,4,2,98,112,3933,3952,115,101,116,4,2,59,69,3942,3945,3,8847,824,113,117,97,108,59,1,8930,101,114,115,101,116,4,2,59,69,3963,3966,3,8848,824,113,117,97,108,59,1,8931,4,3,98,99,112,3981,4000,4045,115,101,116,4,2,59,69,3990,3993,3,8834,8402,113,117,97,108,59,1,8840,99,101,101,100,115,4,4,59,69,83,84,4015,4017,4025,4037,1,8833,113,117,97,108,59,3,10928,824,108,97,110,116,69,113,117,97,108,59,1,8929,105,108,100,101,59,3,8831,824,101,114,115,101,116,4,2,59,69,4056,4059,3,8835,8402,113,117,97,108,59,1,8841,105,108,100,101,4,4,59,69,70,84,4080,4082,4089,4100,1,8769,113,117,97,108,59,1,8772,117,108,108,69,113,117,97,108,59,1,8775,105,108,100,101,59,1,8777,101,114,116,105,99,97,108,66,97,114,59,1,8740,99,114,59,3,55349,56489,105,108,100,101,5,209,1,59,4135,1,209,59,1,925,4,14,69,97,99,100,102,103,109,111,112,114,115,116,117,118,4170,4176,4187,4205,4212,4217,4228,4253,4259,4292,4295,4316,4337,4346,108,105,103,59,1,338,99,117,116,101,5,211,1,59,4185,1,211,4,2,105,121,4193,4202,114,99,5,212,1,59,4200,1,212,59,1,1054,98,108,97,99,59,1,336,114,59,3,55349,56594,114,97,118,101,5,210,1,59,4226,1,210,4,3,97,101,105,4236,4241,4246,99,114,59,1,332,103,97,59,1,937,99,114,111,110,59,1,927,112,102,59,3,55349,56646,101,110,67,117,114,108,121,4,2,68,81,4272,4285,111,117,98,108,101,81,117,111,116,101,59,1,8220,117,111,116,101,59,1,8216,59,1,10836,4,2,99,108,4301,4306,114,59,3,55349,56490,97,115,104,5,216,1,59,4314,1,216,105,4,2,108,109,4323,4332,100,101,5,213,1,59,4330,1,213,101,115,59,1,10807,109,108,5,214,1,59,4344,1,214,101,114,4,2,66,80,4354,4380,4,2,97,114,4360,4364,114,59,1,8254,97,99,4,2,101,107,4372,4375,59,1,9182,101,116,59,1,9140,97,114,101,110,116,104,101,115,105,115,59,1,9180,4,9,97,99,102,104,105,108,111,114,115,4413,4422,4426,4431,4435,4438,4448,4471,4561,114,116,105,97,108,68,59,1,8706,121,59,1,1055,114,59,3,55349,56595,105,59,1,934,59,1,928,117,115,77,105,110,117,115,59,1,177,4,2,105,112,4454,4467,110,99,97,114,101,112,108,97,110,101,59,1,8460,102,59,1,8473,4,4,59,101,105,111,4481,4483,4526,4531,1,10939,99,101,100,101,115,4,4,59,69,83,84,4498,4500,4507,4519,1,8826,113,117,97,108,59,1,10927,108,97,110,116,69,113,117,97,108,59,1,8828,105,108,100,101,59,1,8830,109,101,59,1,8243,4,2,100,112,4537,4543,117,99,116,59,1,8719,111,114,116,105,111,110,4,2,59,97,4555,4557,1,8759,108,59,1,8733,4,2,99,105,4567,4572,114,59,3,55349,56491,59,1,936,4,4,85,102,111,115,4585,4594,4599,4604,79,84,5,34,1,59,4592,1,34,114,59,3,55349,56596,112,102,59,1,8474,99,114,59,3,55349,56492,4,12,66,69,97,99,101,102,104,105,111,114,115,117,4636,4642,4650,4681,4704,4763,4767,4771,5047,5069,5081,5094,97,114,114,59,1,10512,71,5,174,1,59,4648,1,174,4,3,99,110,114,4658,4664,4668,117,116,101,59,1,340,103,59,1,10219,114,4,2,59,116,4675,4677,1,8608,108,59,1,10518,4,3,97,101,121,4689,4695,4701,114,111,110,59,1,344,100,105,108,59,1,342,59,1,1056,4,2,59,118,4710,4712,1,8476,101,114,115,101,4,2,69,85,4722,4748,4,2,108,113,4728,4736,101,109,101,110,116,59,1,8715,117,105,108,105,98,114,105,117,109,59,1,8651,112,69,113,117,105,108,105,98,114,105,117,109,59,1,10607,114,59,1,8476,111,59,1,929,103,104,116,4,8,65,67,68,70,84,85,86,97,4792,4840,4849,4905,4912,4972,5022,5040,4,2,110,114,4798,4811,103,108,101,66,114,97,99,107,101,116,59,1,10217,114,111,119,4,3,59,66,76,4822,4824,4829,1,8594,97,114,59,1,8677,101,102,116,65,114,114,111,119,59,1,8644,101,105,108,105,110,103,59,1,8969,111,4,2,117,119,4856,4869,98,108,101,66,114,97,99,107,101,116,59,1,10215,110,4,2,84,86,4876,4887,101,101,86,101,99,116,111,114,59,1,10589,101,99,116,111,114,4,2,59,66,4898,4900,1,8642,97,114,59,1,10581,108,111,111,114,59,1,8971,4,2,101,114,4918,4944,101,4,3,59,65,86,4927,4929,4936,1,8866,114,114,111,119,59,1,8614,101,99,116,111,114,59,1,10587,105,97,110,103,108,101,4,3,59,66,69,4958,4960,4965,1,8883,97,114,59,1,10704,113,117,97,108,59,1,8885,112,4,3,68,84,86,4981,4993,5004,111,119,110,86,101,99,116,111,114,59,1,10575,101,101,86,101,99,116,111,114,59,1,10588,101,99,116,111,114,4,2,59,66,5015,5017,1,8638,97,114,59,1,10580,101,99,116,111,114,4,2,59,66,5033,5035,1,8640,97,114,59,1,10579,114,114,111,119,59,1,8658,4,2,112,117,5053,5057,102,59,1,8477,110,100,73,109,112,108,105,101,115,59,1,10608,105,103,104,116,97,114,114,111,119,59,1,8667,4,2,99,104,5087,5091,114,59,1,8475,59,1,8625,108,101,68,101,108,97,121,101,100,59,1,10740,4,13,72,79,97,99,102,104,105,109,111,113,115,116,117,5134,5150,5157,5164,5198,5203,5259,5265,5277,5283,5374,5380,5385,4,2,67,99,5140,5146,72,99,121,59,1,1065,121,59,1,1064,70,84,99,121,59,1,1068,99,117,116,101,59,1,346,4,5,59,97,101,105,121,5176,5178,5184,5190,5195,1,10940,114,111,110,59,1,352,100,105,108,59,1,350,114,99,59,1,348,59,1,1057,114,59,3,55349,56598,111,114,116,4,4,68,76,82,85,5216,5227,5238,5250,111,119,110,65,114,114,111,119,59,1,8595,101,102,116,65,114,114,111,119,59,1,8592,105,103,104,116,65,114,114,111,119,59,1,8594,112,65,114,114,111,119,59,1,8593,103,109,97,59,1,931,97,108,108,67,105,114,99,108,101,59,1,8728,112,102,59,3,55349,56650,4,2,114,117,5289,5293,116,59,1,8730,97,114,101,4,4,59,73,83,85,5306,5308,5322,5367,1,9633,110,116,101,114,115,101,99,116,105,111,110,59,1,8851,117,4,2,98,112,5329,5347,115,101,116,4,2,59,69,5338,5340,1,8847,113,117,97,108,59,1,8849,101,114,115,101,116,4,2,59,69,5358,5360,1,8848,113,117,97,108,59,1,8850,110,105,111,110,59,1,8852,99,114,59,3,55349,56494,97,114,59,1,8902,4,4,98,99,109,112,5395,5420,5475,5478,4,2,59,115,5401,5403,1,8912,101,116,4,2,59,69,5411,5413,1,8912,113,117,97,108,59,1,8838,4,2,99,104,5426,5468,101,101,100,115,4,4,59,69,83,84,5440,5442,5449,5461,1,8827,113,117,97,108,59,1,10928,108,97,110,116,69,113,117,97,108,59,1,8829,105,108,100,101,59,1,8831,84,104,97,116,59,1,8715,59,1,8721,4,3,59,101,115,5486,5488,5507,1,8913,114,115,101,116,4,2,59,69,5498,5500,1,8835,113,117,97,108,59,1,8839,101,116,59,1,8913,4,11,72,82,83,97,99,102,104,105,111,114,115,5536,5546,5552,5567,5579,5602,5607,5655,5695,5701,5711,79,82,78,5,222,1,59,5544,1,222,65,68,69,59,1,8482,4,2,72,99,5558,5563,99,121,59,1,1035,121,59,1,1062,4,2,98,117,5573,5576,59,1,9,59,1,932,4,3,97,101,121,5587,5593,5599,114,111,110,59,1,356,100,105,108,59,1,354,59,1,1058,114,59,3,55349,56599,4,2,101,105,5613,5631,4,2,114,116,5619,5627,101,102,111,114,101,59,1,8756,97,59,1,920,4,2,99,110,5637,5647,107,83,112,97,99,101,59,3,8287,8202,83,112,97,99,101,59,1,8201,108,100,101,4,4,59,69,70,84,5668,5670,5677,5688,1,8764,113,117,97,108,59,1,8771,117,108,108,69,113,117,97,108,59,1,8773,105,108,100,101,59,1,8776,112,102,59,3,55349,56651,105,112,108,101,68,111,116,59,1,8411,4,2,99,116,5717,5722,114,59,3,55349,56495,114,111,107,59,1,358,4,14,97,98,99,100,102,103,109,110,111,112,114,115,116,117,5758,5789,5805,5823,5830,5835,5846,5852,5921,5937,6089,6095,6101,6108,4,2,99,114,5764,5774,117,116,101,5,218,1,59,5772,1,218,114,4,2,59,111,5781,5783,1,8607,99,105,114,59,1,10569,114,4,2,99,101,5796,5800,121,59,1,1038,118,101,59,1,364,4,2,105,121,5811,5820,114,99,5,219,1,59,5818,1,219,59,1,1059,98,108,97,99,59,1,368,114,59,3,55349,56600,114,97,118,101,5,217,1,59,5844,1,217,97,99,114,59,1,362,4,2,100,105,5858,5905,101,114,4,2,66,80,5866,5892,4,2,97,114,5872,5876,114,59,1,95,97,99,4,2,101,107,5884,5887,59,1,9183,101,116,59,1,9141,97,114,101,110,116,104,101,115,105,115,59,1,9181,111,110,4,2,59,80,5913,5915,1,8899,108,117,115,59,1,8846,4,2,103,112,5927,5932,111,110,59,1,370,102,59,3,55349,56652,4,8,65,68,69,84,97,100,112,115,5955,5985,5996,6009,6026,6033,6044,6075,114,114,111,119,4,3,59,66,68,5967,5969,5974,1,8593,97,114,59,1,10514,111,119,110,65,114,114,111,119,59,1,8645,111,119,110,65,114,114,111,119,59,1,8597,113,117,105,108,105,98,114,105,117,109,59,1,10606,101,101,4,2,59,65,6017,6019,1,8869,114,114,111,119,59,1,8613,114,114,111,119,59,1,8657,111,119,110,97,114,114,111,119,59,1,8661,101,114,4,2,76,82,6052,6063,101,102,116,65,114,114,111,119,59,1,8598,105,103,104,116,65,114,114,111,119,59,1,8599,105,4,2,59,108,6082,6084,1,978,111,110,59,1,933,105,110,103,59,1,366,99,114,59,3,55349,56496,105,108,100,101,59,1,360,109,108,5,220,1,59,6115,1,220,4,9,68,98,99,100,101,102,111,115,118,6137,6143,6148,6152,6166,6250,6255,6261,6267,97,115,104,59,1,8875,97,114,59,1,10987,121,59,1,1042,97,115,104,4,2,59,108,6161,6163,1,8873,59,1,10982,4,2,101,114,6172,6175,59,1,8897,4,3,98,116,121,6183,6188,6238,97,114,59,1,8214,4,2,59,105,6194,6196,1,8214,99,97,108,4,4,66,76,83,84,6209,6214,6220,6231,97,114,59,1,8739,105,110,101,59,1,124,101,112,97,114,97,116,111,114,59,1,10072,105,108,100,101,59,1,8768,84,104,105,110,83,112,97,99,101,59,1,8202,114,59,3,55349,56601,112,102,59,3,55349,56653,99,114,59,3,55349,56497,100,97,115,104,59,1,8874,4,5,99,101,102,111,115,6286,6292,6298,6303,6309,105,114,99,59,1,372,100,103,101,59,1,8896,114,59,3,55349,56602,112,102,59,3,55349,56654,99,114,59,3,55349,56498,4,4,102,105,111,115,6325,6330,6333,6339,114,59,3,55349,56603,59,1,926,112,102,59,3,55349,56655,99,114,59,3,55349,56499,4,9,65,73,85,97,99,102,111,115,117,6365,6370,6375,6380,6391,6405,6410,6416,6422,99,121,59,1,1071,99,121,59,1,1031,99,121,59,1,1070,99,117,116,101,5,221,1,59,6389,1,221,4,2,105,121,6397,6402,114,99,59,1,374,59,1,1067,114,59,3,55349,56604,112,102,59,3,55349,56656,99,114,59,3,55349,56500,109,108,59,1,376,4,8,72,97,99,100,101,102,111,115,6445,6450,6457,6472,6477,6501,6505,6510,99,121,59,1,1046,99,117,116,101,59,1,377,4,2,97,121,6463,6469,114,111,110,59,1,381,59,1,1047,111,116,59,1,379,4,2,114,116,6483,6497,111,87,105,100,116,104,83,112,97,99,101,59,1,8203,97,59,1,918,114,59,1,8488,112,102,59,1,8484,99,114,59,3,55349,56501,4,16,97,98,99,101,102,103,108,109,110,111,112,114,115,116,117,119,6550,6561,6568,6612,6622,6634,6645,6672,6699,6854,6870,6923,6933,6963,6974,6983,99,117,116,101,5,225,1,59,6559,1,225,114,101,118,101,59,1,259,4,6,59,69,100,105,117,121,6582,6584,6588,6591,6600,6609,1,8766,59,3,8766,819,59,1,8767,114,99,5,226,1,59,6598,1,226,116,101,5,180,1,59,6607,1,180,59,1,1072,108,105,103,5,230,1,59,6620,1,230,4,2,59,114,6628,6630,1,8289,59,3,55349,56606,114,97,118,101,5,224,1,59,6643,1,224,4,2,101,112,6651,6667,4,2,102,112,6657,6663,115,121,109,59,1,8501,104,59,1,8501,104,97,59,1,945,4,2,97,112,6678,6692,4,2,99,108,6684,6688,114,59,1,257,103,59,1,10815,5,38,1,59,6697,1,38,4,2,100,103,6705,6737,4,5,59,97,100,115,118,6717,6719,6724,6727,6734,1,8743,110,100,59,1,10837,59,1,10844,108,111,112,101,59,1,10840,59,1,10842,4,7,59,101,108,109,114,115,122,6753,6755,6758,6762,6814,6835,6848,1,8736,59,1,10660,101,59,1,8736,115,100,4,2,59,97,6770,6772,1,8737,4,8,97,98,99,100,101,102,103,104,6790,6793,6796,6799,6802,6805,6808,6811,59,1,10664,59,1,10665,59,1,10666,59,1,10667,59,1,10668,59,1,10669,59,1,10670,59,1,10671,116,4,2,59,118,6821,6823,1,8735,98,4,2,59,100,6830,6832,1,8894,59,1,10653,4,2,112,116,6841,6845,104,59,1,8738,59,1,197,97,114,114,59,1,9084,4,2,103,112,6860,6865,111,110,59,1,261,102,59,3,55349,56658,4,7,59,69,97,101,105,111,112,6886,6888,6891,6897,6900,6904,6908,1,8776,59,1,10864,99,105,114,59,1,10863,59,1,8778,100,59,1,8779,115,59,1,39,114,111,120,4,2,59,101,6917,6919,1,8776,113,59,1,8778,105,110,103,5,229,1,59,6931,1,229,4,3,99,116,121,6941,6946,6949,114,59,3,55349,56502,59,1,42,109,112,4,2,59,101,6957,6959,1,8776,113,59,1,8781,105,108,100,101,5,227,1,59,6972,1,227,109,108,5,228,1,59,6981,1,228,4,2,99,105,6989,6997,111,110,105,110,116,59,1,8755,110,116,59,1,10769,4,16,78,97,98,99,100,101,102,105,107,108,110,111,112,114,115,117,7036,7041,7119,7135,7149,7155,7219,7224,7347,7354,7463,7489,7786,7793,7814,7866,111,116,59,1,10989,4,2,99,114,7047,7094,107,4,4,99,101,112,115,7058,7064,7073,7080,111,110,103,59,1,8780,112,115,105,108,111,110,59,1,1014,114,105,109,101,59,1,8245,105,109,4,2,59,101,7088,7090,1,8765,113,59,1,8909,4,2,118,119,7100,7105,101,101,59,1,8893,101,100,4,2,59,103,7113,7115,1,8965,101,59,1,8965,114,107,4,2,59,116,7127,7129,1,9141,98,114,107,59,1,9142,4,2,111,121,7141,7146,110,103,59,1,8780,59,1,1073,113,117,111,59,1,8222,4,5,99,109,112,114,116,7167,7181,7188,7193,7199,97,117,115,4,2,59,101,7176,7178,1,8757,59,1,8757,112,116,121,118,59,1,10672,115,105,59,1,1014,110,111,117,59,1,8492,4,3,97,104,119,7207,7210,7213,59,1,946,59,1,8502,101,101,110,59,1,8812,114,59,3,55349,56607,103,4,7,99,111,115,116,117,118,119,7241,7262,7288,7305,7328,7335,7340,4,3,97,105,117,7249,7253,7258,112,59,1,8898,114,99,59,1,9711,112,59,1,8899,4,3,100,112,116,7270,7275,7281,111,116,59,1,10752,108,117,115,59,1,10753,105,109,101,115,59,1,10754,4,2,113,116,7294,7300,99,117,112,59,1,10758,97,114,59,1,9733,114,105,97,110,103,108,101,4,2,100,117,7318,7324,111,119,110,59,1,9661,112,59,1,9651,112,108,117,115,59,1,10756,101,101,59,1,8897,101,100,103,101,59,1,8896,97,114,111,119,59,1,10509,4,3,97,107,111,7362,7436,7458,4,2,99,110,7368,7432,107,4,3,108,115,116,7377,7386,7394,111,122,101,110,103,101,59,1,10731,113,117,97,114,101,59,1,9642,114,105,97,110,103,108,101,4,4,59,100,108,114,7411,7413,7419,7425,1,9652,111,119,110,59,1,9662,101,102,116,59,1,9666,105,103,104,116,59,1,9656,107,59,1,9251,4,2,49,51,7442,7454,4,2,50,52,7448,7451,59,1,9618,59,1,9617,52,59,1,9619,99,107,59,1,9608,4,2,101,111,7469,7485,4,2,59,113,7475,7478,3,61,8421,117,105,118,59,3,8801,8421,116,59,1,8976,4,4,112,116,119,120,7499,7504,7517,7523,102,59,3,55349,56659,4,2,59,116,7510,7512,1,8869,111,109,59,1,8869,116,105,101,59,1,8904,4,12,68,72,85,86,98,100,104,109,112,116,117,118,7549,7571,7597,7619,7655,7660,7682,7708,7715,7721,7728,7750,4,4,76,82,108,114,7559,7562,7565,7568,59,1,9559,59,1,9556,59,1,9558,59,1,9555,4,5,59,68,85,100,117,7583,7585,7588,7591,7594,1,9552,59,1,9574,59,1,9577,59,1,9572,59,1,9575,4,4,76,82,108,114,7607,7610,7613,7616,59,1,9565,59,1,9562,59,1,9564,59,1,9561,4,7,59,72,76,82,104,108,114,7635,7637,7640,7643,7646,7649,7652,1,9553,59,1,9580,59,1,9571,59,1,9568,59,1,9579,59,1,9570,59,1,9567,111,120,59,1,10697,4,4,76,82,108,114,7670,7673,7676,7679,59,1,9557,59,1,9554,59,1,9488,59,1,9484,4,5,59,68,85,100,117,7694,7696,7699,7702,7705,1,9472,59,1,9573,59,1,9576,59,1,9516,59,1,9524,105,110,117,115,59,1,8863,108,117,115,59,1,8862,105,109,101,115,59,1,8864,4,4,76,82,108,114,7738,7741,7744,7747,59,1,9563,59,1,9560,59,1,9496,59,1,9492,4,7,59,72,76,82,104,108,114,7766,7768,7771,7774,7777,7780,7783,1,9474,59,1,9578,59,1,9569,59,1,9566,59,1,9532,59,1,9508,59,1,9500,114,105,109,101,59,1,8245,4,2,101,118,7799,7804,118,101,59,1,728,98,97,114,5,166,1,59,7812,1,166,4,4,99,101,105,111,7824,7829,7834,7846,114,59,3,55349,56503,109,105,59,1,8271,109,4,2,59,101,7841,7843,1,8765,59,1,8909,108,4,3,59,98,104,7855,7857,7860,1,92,59,1,10693,115,117,98,59,1,10184,4,2,108,109,7872,7885,108,4,2,59,101,7879,7881,1,8226,116,59,1,8226,112,4,3,59,69,101,7894,7896,7899,1,8782,59,1,10926,4,2,59,113,7905,7907,1,8783,59,1,8783,4,15,97,99,100,101,102,104,105,108,111,114,115,116,117,119,121,7942,8021,8075,8080,8121,8126,8157,8279,8295,8430,8446,8485,8491,8707,8726,4,3,99,112,114,7950,7956,8007,117,116,101,59,1,263,4,6,59,97,98,99,100,115,7970,7972,7977,7984,7998,8003,1,8745,110,100,59,1,10820,114,99,117,112,59,1,10825,4,2,97,117,7990,7994,112,59,1,10827,112,59,1,10823,111,116,59,1,10816,59,3,8745,65024,4,2,101,111,8013,8017,116,59,1,8257,110,59,1,711,4,4,97,101,105,117,8031,8046,8056,8061,4,2,112,114,8037,8041,115,59,1,10829,111,110,59,1,269,100,105,108,5,231,1,59,8054,1,231,114,99,59,1,265,112,115,4,2,59,115,8069,8071,1,10828,109,59,1,10832,111,116,59,1,267,4,3,100,109,110,8088,8097,8104,105,108,5,184,1,59,8095,1,184,112,116,121,118,59,1,10674,116,5,162,2,59,101,8112,8114,1,162,114,100,111,116,59,1,183,114,59,3,55349,56608,4,3,99,101,105,8134,8138,8154,121,59,1,1095,99,107,4,2,59,109,8146,8148,1,10003,97,114,107,59,1,10003,59,1,967,114,4,7,59,69,99,101,102,109,115,8174,8176,8179,8258,8261,8268,8273,1,9675,59,1,10691,4,3,59,101,108,8187,8189,8193,1,710,113,59,1,8791,101,4,2,97,100,8200,8223,114,114,111,119,4,2,108,114,8210,8216,101,102,116,59,1,8634,105,103,104,116,59,1,8635,4,5,82,83,97,99,100,8235,8238,8241,8246,8252,59,1,174,59,1,9416,115,116,59,1,8859,105,114,99,59,1,8858,97,115,104,59,1,8861,59,1,8791,110,105,110,116,59,1,10768,105,100,59,1,10991,99,105,114,59,1,10690,117,98,115,4,2,59,117,8288,8290,1,9827,105,116,59,1,9827,4,4,108,109,110,112,8305,8326,8376,8400,111,110,4,2,59,101,8313,8315,1,58,4,2,59,113,8321,8323,1,8788,59,1,8788,4,2,109,112,8332,8344,97,4,2,59,116,8339,8341,1,44,59,1,64,4,3,59,102,108,8352,8354,8358,1,8705,110,59,1,8728,101,4,2,109,120,8365,8371,101,110,116,59,1,8705,101,115,59,1,8450,4,2,103,105,8382,8395,4,2,59,100,8388,8390,1,8773,111,116,59,1,10861,110,116,59,1,8750,4,3,102,114,121,8408,8412,8417,59,3,55349,56660,111,100,59,1,8720,5,169,2,59,115,8424,8426,1,169,114,59,1,8471,4,2,97,111,8436,8441,114,114,59,1,8629,115,115,59,1,10007,4,2,99,117,8452,8457,114,59,3,55349,56504,4,2,98,112,8463,8474,4,2,59,101,8469,8471,1,10959,59,1,10961,4,2,59,101,8480,8482,1,10960,59,1,10962,100,111,116,59,1,8943,4,7,100,101,108,112,114,118,119,8507,8522,8536,8550,8600,8697,8702,97,114,114,4,2,108,114,8516,8519,59,1,10552,59,1,10549,4,2,112,115,8528,8532,114,59,1,8926,99,59,1,8927,97,114,114,4,2,59,112,8545,8547,1,8630,59,1,10557,4,6,59,98,99,100,111,115,8564,8566,8573,8587,8592,8596,1,8746,114,99,97,112,59,1,10824,4,2,97,117,8579,8583,112,59,1,10822,112,59,1,10826,111,116,59,1,8845,114,59,1,10821,59,3,8746,65024,4,4,97,108,114,118,8610,8623,8663,8672,114,114,4,2,59,109,8618,8620,1,8631,59,1,10556,121,4,3,101,118,119,8632,8651,8656,113,4,2,112,115,8639,8645,114,101,99,59,1,8926,117,99,99,59,1,8927,101,101,59,1,8910,101,100,103,101,59,1,8911,101,110,5,164,1,59,8670,1,164,101,97,114,114,111,119,4,2,108,114,8684,8690,101,102,116,59,1,8630,105,103,104,116,59,1,8631,101,101,59,1,8910,101,100,59,1,8911,4,2,99,105,8713,8721,111,110,105,110,116,59,1,8754,110,116,59,1,8753,108,99,116,121,59,1,9005,4,19,65,72,97,98,99,100,101,102,104,105,106,108,111,114,115,116,117,119,122,8773,8778,8783,8821,8839,8854,8887,8914,8930,8944,9036,9041,9058,9197,9227,9258,9281,9297,9305,114,114,59,1,8659,97,114,59,1,10597,4,4,103,108,114,115,8793,8799,8805,8809,103,101,114,59,1,8224,101,116,104,59,1,8504,114,59,1,8595,104,4,2,59,118,8816,8818,1,8208,59,1,8867,4,2,107,108,8827,8834,97,114,111,119,59,1,10511,97,99,59,1,733,4,2,97,121,8845,8851,114,111,110,59,1,271,59,1,1076,4,3,59,97,111,8862,8864,8880,1,8518,4,2,103,114,8870,8876,103,101,114,59,1,8225,114,59,1,8650,116,115,101,113,59,1,10871,4,3,103,108,109,8895,8902,8907,5,176,1,59,8900,1,176,116,97,59,1,948,112,116,121,118,59,1,10673,4,2,105,114,8920,8926,115,104,116,59,1,10623,59,3,55349,56609,97,114,4,2,108,114,8938,8941,59,1,8643,59,1,8642,4,5,97,101,103,115,118,8956,8986,8989,8996,9001,109,4,3,59,111,115,8965,8967,8983,1,8900,110,100,4,2,59,115,8975,8977,1,8900,117,105,116,59,1,9830,59,1,9830,59,1,168,97,109,109,97,59,1,989,105,110,59,1,8946,4,3,59,105,111,9009,9011,9031,1,247,100,101,5,247,2,59,111,9020,9022,1,247,110,116,105,109,101,115,59,1,8903,110,120,59,1,8903,99,121,59,1,1106,99,4,2,111,114,9048,9053,114,110,59,1,8990,111,112,59,1,8973,4,5,108,112,116,117,119,9070,9076,9081,9130,9144,108,97,114,59,1,36,102,59,3,55349,56661,4,5,59,101,109,112,115,9093,9095,9109,9116,9122,1,729,113,4,2,59,100,9102,9104,1,8784,111,116,59,1,8785,105,110,117,115,59,1,8760,108,117,115,59,1,8724,113,117,97,114,101,59,1,8865,98,108,101,98,97,114,119,101,100,103,101,59,1,8966,110,4,3,97,100,104,9153,9160,9172,114,114,111,119,59,1,8595,111,119,110,97,114,114,111,119,115,59,1,8650,97,114,112,111,111,110,4,2,108,114,9184,9190,101,102,116,59,1,8643,105,103,104,116,59,1,8642,4,2,98,99,9203,9211,107,97,114,111,119,59,1,10512,4,2,111,114,9217,9222,114,110,59,1,8991,111,112,59,1,8972,4,3,99,111,116,9235,9248,9252,4,2,114,121,9241,9245,59,3,55349,56505,59,1,1109,108,59,1,10742,114,111,107,59,1,273,4,2,100,114,9264,9269,111,116,59,1,8945,105,4,2,59,102,9276,9278,1,9663,59,1,9662,4,2,97,104,9287,9292,114,114,59,1,8693,97,114,59,1,10607,97,110,103,108,101,59,1,10662,4,2,99,105,9311,9315,121,59,1,1119,103,114,97,114,114,59,1,10239,4,18,68,97,99,100,101,102,103,108,109,110,111,112,113,114,115,116,117,120,9361,9376,9398,9439,9444,9447,9462,9495,9531,9585,9598,9614,9659,9755,9771,9792,9808,9826,4,2,68,111,9367,9372,111,116,59,1,10871,116,59,1,8785,4,2,99,115,9382,9392,117,116,101,5,233,1,59,9390,1,233,116,101,114,59,1,10862,4,4,97,105,111,121,9408,9414,9430,9436,114,111,110,59,1,283,114,4,2,59,99,9421,9423,1,8790,5,234,1,59,9428,1,234,108,111,110,59,1,8789,59,1,1101,111,116,59,1,279,59,1,8519,4,2,68,114,9453,9458,111,116,59,1,8786,59,3,55349,56610,4,3,59,114,115,9470,9472,9482,1,10906,97,118,101,5,232,1,59,9480,1,232,4,2,59,100,9488,9490,1,10902,111,116,59,1,10904,4,4,59,105,108,115,9505,9507,9515,9518,1,10905,110,116,101,114,115,59,1,9191,59,1,8467,4,2,59,100,9524,9526,1,10901,111,116,59,1,10903,4,3,97,112,115,9539,9544,9564,99,114,59,1,275,116,121,4,3,59,115,118,9554,9556,9561,1,8709,101,116,59,1,8709,59,1,8709,112,4,2,49,59,9571,9583,4,2,51,52,9577,9580,59,1,8196,59,1,8197,1,8195,4,2,103,115,9591,9594,59,1,331,112,59,1,8194,4,2,103,112,9604,9609,111,110,59,1,281,102,59,3,55349,56662,4,3,97,108,115,9622,9635,9640,114,4,2,59,115,9629,9631,1,8917,108,59,1,10723,117,115,59,1,10865,105,4,3,59,108,118,9649,9651,9656,1,949,111,110,59,1,949,59,1,1013,4,4,99,115,117,118,9669,9686,9716,9747,4,2,105,111,9675,9680,114,99,59,1,8790,108,111,110,59,1,8789,4,2,105,108,9692,9696,109,59,1,8770,97,110,116,4,2,103,108,9705,9710,116,114,59,1,10902,101,115,115,59,1,10901,4,3,97,101,105,9724,9729,9734,108,115,59,1,61,115,116,59,1,8799,118,4,2,59,68,9741,9743,1,8801,68,59,1,10872,112,97,114,115,108,59,1,10725,4,2,68,97,9761,9766,111,116,59,1,8787,114,114,59,1,10609,4,3,99,100,105,9779,9783,9788,114,59,1,8495,111,116,59,1,8784,109,59,1,8770,4,2,97,104,9798,9801,59,1,951,5,240,1,59,9806,1,240,4,2,109,114,9814,9822,108,5,235,1,59,9820,1,235,111,59,1,8364,4,3,99,105,112,9834,9838,9843,108,59,1,33,115,116,59,1,8707,4,2,101,111,9849,9859,99,116,97,116,105,111,110,59,1,8496,110,101,110,116,105,97,108,101,59,1,8519,4,12,97,99,101,102,105,106,108,110,111,112,114,115,9896,9910,9914,9921,9954,9960,9967,9989,9994,10027,10036,10164,108,108,105,110,103,100,111,116,115,101,113,59,1,8786,121,59,1,1092,109,97,108,101,59,1,9792,4,3,105,108,114,9929,9935,9950,108,105,103,59,1,64259,4,2,105,108,9941,9945,103,59,1,64256,105,103,59,1,64260,59,3,55349,56611,108,105,103,59,1,64257,108,105,103,59,3,102,106,4,3,97,108,116,9975,9979,9984,116,59,1,9837,105,103,59,1,64258,110,115,59,1,9649,111,102,59,1,402,4,2,112,114,10000,10005,102,59,3,55349,56663,4,2,97,107,10011,10016,108,108,59,1,8704,4,2,59,118,10022,10024,1,8916,59,1,10969,97,114,116,105,110,116,59,1,10765,4,2,97,111,10042,10159,4,2,99,115,10048,10155,4,6,49,50,51,52,53,55,10062,10102,10114,10135,10139,10151,4,6,50,51,52,53,54,56,10076,10083,10086,10093,10096,10099,5,189,1,59,10081,1,189,59,1,8531,5,188,1,59,10091,1,188,59,1,8533,59,1,8537,59,1,8539,4,2,51,53,10108,10111,59,1,8532,59,1,8534,4,3,52,53,56,10122,10129,10132,5,190,1,59,10127,1,190,59,1,8535,59,1,8540,53,59,1,8536,4,2,54,56,10145,10148,59,1,8538,59,1,8541,56,59,1,8542,108,59,1,8260,119,110,59,1,8994,99,114,59,3,55349,56507,4,17,69,97,98,99,100,101,102,103,105,106,108,110,111,114,115,116,118,10206,10217,10247,10254,10268,10273,10358,10363,10374,10380,10385,10406,10458,10464,10470,10497,10610,4,2,59,108,10212,10214,1,8807,59,1,10892,4,3,99,109,112,10225,10231,10244,117,116,101,59,1,501,109,97,4,2,59,100,10239,10241,1,947,59,1,989,59,1,10886,114,101,118,101,59,1,287,4,2,105,121,10260,10265,114,99,59,1,285,59,1,1075,111,116,59,1,289,4,4,59,108,113,115,10283,10285,10288,10308,1,8805,59,1,8923,4,3,59,113,115,10296,10298,10301,1,8805,59,1,8807,108,97,110,116,59,1,10878,4,4,59,99,100,108,10318,10320,10324,10345,1,10878,99,59,1,10921,111,116,4,2,59,111,10332,10334,1,10880,4,2,59,108,10340,10342,1,10882,59,1,10884,4,2,59,101,10351,10354,3,8923,65024,115,59,1,10900,114,59,3,55349,56612,4,2,59,103,10369,10371,1,8811,59,1,8921,109,101,108,59,1,8503,99,121,59,1,1107,4,4,59,69,97,106,10395,10397,10400,10403,1,8823,59,1,10898,59,1,10917,59,1,10916,4,4,69,97,101,115,10416,10419,10434,10453,59,1,8809,112,4,2,59,112,10426,10428,1,10890,114,111,120,59,1,10890,4,2,59,113,10440,10442,1,10888,4,2,59,113,10448,10450,1,10888,59,1,8809,105,109,59,1,8935,112,102,59,3,55349,56664,97,118,101,59,1,96,4,2,99,105,10476,10480,114,59,1,8458,109,4,3,59,101,108,10489,10491,10494,1,8819,59,1,10894,59,1,10896,5,62,6,59,99,100,108,113,114,10512,10514,10527,10532,10538,10545,1,62,4,2,99,105,10520,10523,59,1,10919,114,59,1,10874,111,116,59,1,8919,80,97,114,59,1,10645,117,101,115,116,59,1,10876,4,5,97,100,101,108,115,10557,10574,10579,10599,10605,4,2,112,114,10563,10570,112,114,111,120,59,1,10886,114,59,1,10616,111,116,59,1,8919,113,4,2,108,113,10586,10592,101,115,115,59,1,8923,108,101,115,115,59,1,10892,101,115,115,59,1,8823,105,109,59,1,8819,4,2,101,110,10616,10626,114,116,110,101,113,113,59,3,8809,65024,69,59,3,8809,65024,4,10,65,97,98,99,101,102,107,111,115,121,10653,10658,10713,10718,10724,10760,10765,10786,10850,10875,114,114,59,1,8660,4,4,105,108,109,114,10668,10674,10678,10684,114,115,112,59,1,8202,102,59,1,189,105,108,116,59,1,8459,4,2,100,114,10690,10695,99,121,59,1,1098,4,3,59,99,119,10703,10705,10710,1,8596,105,114,59,1,10568,59,1,8621,97,114,59,1,8463,105,114,99,59,1,293,4,3,97,108,114,10732,10748,10754,114,116,115,4,2,59,117,10741,10743,1,9829,105,116,59,1,9829,108,105,112,59,1,8230,99,111,110,59,1,8889,114,59,3,55349,56613,115,4,2,101,119,10772,10779,97,114,111,119,59,1,10533,97,114,111,119,59,1,10534,4,5,97,109,111,112,114,10798,10803,10809,10839,10844,114,114,59,1,8703,116,104,116,59,1,8763,107,4,2,108,114,10816,10827,101,102,116,97,114,114,111,119,59,1,8617,105,103,104,116,97,114,114,111,119,59,1,8618,102,59,3,55349,56665,98,97,114,59,1,8213,4,3,99,108,116,10858,10863,10869,114,59,3,55349,56509,97,115,104,59,1,8463,114,111,107,59,1,295,4,2,98,112,10881,10887,117,108,108,59,1,8259,104,101,110,59,1,8208,4,15,97,99,101,102,103,105,106,109,110,111,112,113,115,116,117,10925,10936,10958,10977,10990,11001,11039,11045,11101,11192,11220,11226,11237,11285,11299,99,117,116,101,5,237,1,59,10934,1,237,4,3,59,105,121,10944,10946,10955,1,8291,114,99,5,238,1,59,10953,1,238,59,1,1080,4,2,99,120,10964,10968,121,59,1,1077,99,108,5,161,1,59,10975,1,161,4,2,102,114,10983,10986,59,1,8660,59,3,55349,56614,114,97,118,101,5,236,1,59,10999,1,236,4,4,59,105,110,111,11011,11013,11028,11034,1,8520,4,2,105,110,11019,11024,110,116,59,1,10764,116,59,1,8749,102,105,110,59,1,10716,116,97,59,1,8489,108,105,103,59,1,307,4,3,97,111,112,11053,11092,11096,4,3,99,103,116,11061,11065,11088,114,59,1,299,4,3,101,108,112,11073,11076,11082,59,1,8465,105,110,101,59,1,8464,97,114,116,59,1,8465,104,59,1,305,102,59,1,8887,101,100,59,1,437,4,5,59,99,102,111,116,11113,11115,11121,11136,11142,1,8712,97,114,101,59,1,8453,105,110,4,2,59,116,11129,11131,1,8734,105,101,59,1,10717,100,111,116,59,1,305,4,5,59,99,101,108,112,11154,11156,11161,11179,11186,1,8747,97,108,59,1,8890,4,2,103,114,11167,11173,101,114,115,59,1,8484,99,97,108,59,1,8890,97,114,104,107,59,1,10775,114,111,100,59,1,10812,4,4,99,103,112,116,11202,11206,11211,11216,121,59,1,1105,111,110,59,1,303,102,59,3,55349,56666,97,59,1,953,114,111,100,59,1,10812,117,101,115,116,5,191,1,59,11235,1,191,4,2,99,105,11243,11248,114,59,3,55349,56510,110,4,5,59,69,100,115,118,11261,11263,11266,11271,11282,1,8712,59,1,8953,111,116,59,1,8949,4,2,59,118,11277,11279,1,8948,59,1,8947,59,1,8712,4,2,59,105,11291,11293,1,8290,108,100,101,59,1,297,4,2,107,109,11305,11310,99,121,59,1,1110,108,5,239,1,59,11316,1,239,4,6,99,102,109,111,115,117,11332,11346,11351,11357,11363,11380,4,2,105,121,11338,11343,114,99,59,1,309,59,1,1081,114,59,3,55349,56615,97,116,104,59,1,567,112,102,59,3,55349,56667,4,2,99,101,11369,11374,114,59,3,55349,56511,114,99,121,59,1,1112,107,99,121,59,1,1108,4,8,97,99,102,103,104,106,111,115,11404,11418,11433,11438,11445,11450,11455,11461,112,112,97,4,2,59,118,11413,11415,1,954,59,1,1008,4,2,101,121,11424,11430,100,105,108,59,1,311,59,1,1082,114,59,3,55349,56616,114,101,101,110,59,1,312,99,121,59,1,1093,99,121,59,1,1116,112,102,59,3,55349,56668,99,114,59,3,55349,56512,4,23,65,66,69,72,97,98,99,100,101,102,103,104,106,108,109,110,111,112,114,115,116,117,118,11515,11538,11544,11555,11560,11721,11780,11818,11868,12136,12160,12171,12203,12208,12246,12275,12327,12509,12523,12569,12641,12732,12752,4,3,97,114,116,11523,11528,11532,114,114,59,1,8666,114,59,1,8656,97,105,108,59,1,10523,97,114,114,59,1,10510,4,2,59,103,11550,11552,1,8806,59,1,10891,97,114,59,1,10594,4,9,99,101,103,109,110,112,113,114,116,11580,11586,11594,11600,11606,11624,11627,11636,11694,117,116,101,59,1,314,109,112,116,121,118,59,1,10676,114,97,110,59,1,8466,98,100,97,59,1,955,103,4,3,59,100,108,11615,11617,11620,1,10216,59,1,10641,101,59,1,10216,59,1,10885,117,111,5,171,1,59,11634,1,171,114,4,8,59,98,102,104,108,112,115,116,11655,11657,11669,11673,11677,11681,11685,11690,1,8592,4,2,59,102,11663,11665,1,8676,115,59,1,10527,115,59,1,10525,107,59,1,8617,112,59,1,8619,108,59,1,10553,105,109,59,1,10611,108,59,1,8610,4,3,59,97,101,11702,11704,11709,1,10923,105,108,59,1,10521,4,2,59,115,11715,11717,1,10925,59,3,10925,65024,4,3,97,98,114,11729,11734,11739,114,114,59,1,10508,114,107,59,1,10098,4,2,97,107,11745,11758,99,4,2,101,107,11752,11755,59,1,123,59,1,91,4,2,101,115,11764,11767,59,1,10635,108,4,2,100,117,11774,11777,59,1,10639,59,1,10637,4,4,97,101,117,121,11790,11796,11811,11815,114,111,110,59,1,318,4,2,100,105,11802,11807,105,108,59,1,316,108,59,1,8968,98,59,1,123,59,1,1083,4,4,99,113,114,115,11828,11832,11845,11864,97,59,1,10550,117,111,4,2,59,114,11840,11842,1,8220,59,1,8222,4,2,100,117,11851,11857,104,97,114,59,1,10599,115,104,97,114,59,1,10571,104,59,1,8626,4,5,59,102,103,113,115,11880,11882,12008,12011,12031,1,8804,116,4,5,97,104,108,114,116,11895,11913,11935,11947,11996,114,114,111,119,4,2,59,116,11905,11907,1,8592,97,105,108,59,1,8610,97,114,112,111,111,110,4,2,100,117,11925,11931,111,119,110,59,1,8637,112,59,1,8636,101,102,116,97,114,114,111,119,115,59,1,8647,105,103,104,116,4,3,97,104,115,11959,11974,11984,114,114,111,119,4,2,59,115,11969,11971,1,8596,59,1,8646,97,114,112,111,111,110,115,59,1,8651,113,117,105,103,97,114,114,111,119,59,1,8621,104,114,101,101,116,105,109,101,115,59,1,8907,59,1,8922,4,3,59,113,115,12019,12021,12024,1,8804,59,1,8806,108,97,110,116,59,1,10877,4,5,59,99,100,103,115,12043,12045,12049,12070,12083,1,10877,99,59,1,10920,111,116,4,2,59,111,12057,12059,1,10879,4,2,59,114,12065,12067,1,10881,59,1,10883,4,2,59,101,12076,12079,3,8922,65024,115,59,1,10899,4,5,97,100,101,103,115,12095,12103,12108,12126,12131,112,112,114,111,120,59,1,10885,111,116,59,1,8918,113,4,2,103,113,12115,12120,116,114,59,1,8922,103,116,114,59,1,10891,116,114,59,1,8822,105,109,59,1,8818,4,3,105,108,114,12144,12150,12156,115,104,116,59,1,10620,111,111,114,59,1,8970,59,3,55349,56617,4,2,59,69,12166,12168,1,8822,59,1,10897,4,2,97,98,12177,12198,114,4,2,100,117,12184,12187,59,1,8637,4,2,59,108,12193,12195,1,8636,59,1,10602,108,107,59,1,9604,99,121,59,1,1113,4,5,59,97,99,104,116,12220,12222,12227,12235,12241,1,8810,114,114,59,1,8647,111,114,110,101,114,59,1,8990,97,114,100,59,1,10603,114,105,59,1,9722,4,2,105,111,12252,12258,100,111,116,59,1,320,117,115,116,4,2,59,97,12267,12269,1,9136,99,104,101,59,1,9136,4,4,69,97,101,115,12285,12288,12303,12322,59,1,8808,112,4,2,59,112,12295,12297,1,10889,114,111,120,59,1,10889,4,2,59,113,12309,12311,1,10887,4,2,59,113,12317,12319,1,10887,59,1,8808,105,109,59,1,8934,4,8,97,98,110,111,112,116,119,122,12345,12359,12364,12421,12446,12467,12474,12490,4,2,110,114,12351,12355,103,59,1,10220,114,59,1,8701,114,107,59,1,10214,103,4,3,108,109,114,12373,12401,12409,101,102,116,4,2,97,114,12382,12389,114,114,111,119,59,1,10229,105,103,104,116,97,114,114,111,119,59,1,10231,97,112,115,116,111,59,1,10236,105,103,104,116,97,114,114,111,119,59,1,10230,112,97,114,114,111,119,4,2,108,114,12433,12439,101,102,116,59,1,8619,105,103,104,116,59,1,8620,4,3,97,102,108,12454,12458,12462,114,59,1,10629,59,3,55349,56669,117,115,59,1,10797,105,109,101,115,59,1,10804,4,2,97,98,12480,12485,115,116,59,1,8727,97,114,59,1,95,4,3,59,101,102,12498,12500,12506,1,9674,110,103,101,59,1,9674,59,1,10731,97,114,4,2,59,108,12517,12519,1,40,116,59,1,10643,4,5,97,99,104,109,116,12535,12540,12548,12561,12564,114,114,59,1,8646,111,114,110,101,114,59,1,8991,97,114,4,2,59,100,12556,12558,1,8651,59,1,10605,59,1,8206,114,105,59,1,8895,4,6,97,99,104,105,113,116,12583,12589,12594,12597,12614,12635,113,117,111,59,1,8249,114,59,3,55349,56513,59,1,8624,109,4,3,59,101,103,12606,12608,12611,1,8818,59,1,10893,59,1,10895,4,2,98,117,12620,12623,59,1,91,111,4,2,59,114,12630,12632,1,8216,59,1,8218,114,111,107,59,1,322,5,60,8,59,99,100,104,105,108,113,114,12660,12662,12675,12680,12686,12692,12698,12705,1,60,4,2,99,105,12668,12671,59,1,10918,114,59,1,10873,111,116,59,1,8918,114,101,101,59,1,8907,109,101,115,59,1,8905,97,114,114,59,1,10614,117,101,115,116,59,1,10875,4,2,80,105,12711,12716,97,114,59,1,10646,4,3,59,101,102,12724,12726,12729,1,9667,59,1,8884,59,1,9666,114,4,2,100,117,12739,12746,115,104,97,114,59,1,10570,104,97,114,59,1,10598,4,2,101,110,12758,12768,114,116,110,101,113,113,59,3,8808,65024,69,59,3,8808,65024,4,14,68,97,99,100,101,102,104,105,108,110,111,112,115,117,12803,12809,12893,12908,12914,12928,12933,12937,13011,13025,13032,13049,13052,13069,68,111,116,59,1,8762,4,4,99,108,112,114,12819,12827,12849,12887,114,5,175,1,59,12825,1,175,4,2,101,116,12833,12836,59,1,9794,4,2,59,101,12842,12844,1,10016,115,101,59,1,10016,4,2,59,115,12855,12857,1,8614,116,111,4,4,59,100,108,117,12869,12871,12877,12883,1,8614,111,119,110,59,1,8615,101,102,116,59,1,8612,112,59,1,8613,107,101,114,59,1,9646,4,2,111,121,12899,12905,109,109,97,59,1,10793,59,1,1084,97,115,104,59,1,8212,97,115,117,114,101,100,97,110,103,108,101,59,1,8737,114,59,3,55349,56618,111,59,1,8487,4,3,99,100,110,12945,12954,12985,114,111,5,181,1,59,12952,1,181,4,4,59,97,99,100,12964,12966,12971,12976,1,8739,115,116,59,1,42,105,114,59,1,10992,111,116,5,183,1,59,12983,1,183,117,115,4,3,59,98,100,12995,12997,13000,1,8722,59,1,8863,4,2,59,117,13006,13008,1,8760,59,1,10794,4,2,99,100,13017,13021,112,59,1,10971,114,59,1,8230,112,108,117,115,59,1,8723,4,2,100,112,13038,13044,101,108,115,59,1,8871,102,59,3,55349,56670,59,1,8723,4,2,99,116,13058,13063,114,59,3,55349,56514,112,111,115,59,1,8766,4,3,59,108,109,13077,13079,13087,1,956,116,105,109,97,112,59,1,8888,97,112,59,1,8888,4,24,71,76,82,86,97,98,99,100,101,102,103,104,105,106,108,109,111,112,114,115,116,117,118,119,13142,13165,13217,13229,13247,13330,13359,13414,13420,13508,13513,13579,13602,13626,13631,13762,13767,13855,13936,13995,14214,14285,14312,14432,4,2,103,116,13148,13152,59,3,8921,824,4,2,59,118,13158,13161,3,8811,8402,59,3,8811,824,4,3,101,108,116,13173,13200,13204,102,116,4,2,97,114,13181,13188,114,114,111,119,59,1,8653,105,103,104,116,97,114,114,111,119,59,1,8654,59,3,8920,824,4,2,59,118,13210,13213,3,8810,8402,59,3,8810,824,105,103,104,116,97,114,114,111,119,59,1,8655,4,2,68,100,13235,13241,97,115,104,59,1,8879,97,115,104,59,1,8878,4,5,98,99,110,112,116,13259,13264,13270,13275,13308,108,97,59,1,8711,117,116,101,59,1,324,103,59,3,8736,8402,4,5,59,69,105,111,112,13287,13289,13293,13298,13302,1,8777,59,3,10864,824,100,59,3,8779,824,115,59,1,329,114,111,120,59,1,8777,117,114,4,2,59,97,13316,13318,1,9838,108,4,2,59,115,13325,13327,1,9838,59,1,8469,4,2,115,117,13336,13344,112,5,160,1,59,13342,1,160,109,112,4,2,59,101,13352,13355,3,8782,824,59,3,8783,824,4,5,97,101,111,117,121,13371,13385,13391,13407,13411,4,2,112,114,13377,13380,59,1,10819,111,110,59,1,328,100,105,108,59,1,326,110,103,4,2,59,100,13399,13401,1,8775,111,116,59,3,10861,824,112,59,1,10818,59,1,1085,97,115,104,59,1,8211,4,7,59,65,97,100,113,115,120,13436,13438,13443,13466,13472,13478,13494,1,8800,114,114,59,1,8663,114,4,2,104,114,13450,13454,107,59,1,10532,4,2,59,111,13460,13462,1,8599,119,59,1,8599,111,116,59,3,8784,824,117,105,118,59,1,8802,4,2,101,105,13484,13489,97,114,59,1,10536,109,59,3,8770,824,105,115,116,4,2,59,115,13503,13505,1,8708,59,1,8708,114,59,3,55349,56619,4,4,69,101,115,116,13523,13527,13563,13568,59,3,8807,824,4,3,59,113,115,13535,13537,13559,1,8817,4,3,59,113,115,13545,13547,13551,1,8817,59,3,8807,824,108,97,110,116,59,3,10878,824,59,3,10878,824,105,109,59,1,8821,4,2,59,114,13574,13576,1,8815,59,1,8815,4,3,65,97,112,13587,13592,13597,114,114,59,1,8654,114,114,59,1,8622,97,114,59,1,10994,4,3,59,115,118,13610,13612,13623,1,8715,4,2,59,100,13618,13620,1,8956,59,1,8954,59,1,8715,99,121,59,1,1114,4,7,65,69,97,100,101,115,116,13647,13652,13656,13661,13665,13737,13742,114,114,59,1,8653,59,3,8806,824,114,114,59,1,8602,114,59,1,8229,4,4,59,102,113,115,13675,13677,13703,13725,1,8816,116,4,2,97,114,13684,13691,114,114,111,119,59,1,8602,105,103,104,116,97,114,114,111,119,59,1,8622,4,3,59,113,115,13711,13713,13717,1,8816,59,3,8806,824,108,97,110,116,59,3,10877,824,4,2,59,115,13731,13734,3,10877,824,59,1,8814,105,109,59,1,8820,4,2,59,114,13748,13750,1,8814,105,4,2,59,101,13757,13759,1,8938,59,1,8940,105,100,59,1,8740,4,2,112,116,13773,13778,102,59,3,55349,56671,5,172,3,59,105,110,13787,13789,13829,1,172,110,4,4,59,69,100,118,13800,13802,13806,13812,1,8713,59,3,8953,824,111,116,59,3,8949,824,4,3,97,98,99,13820,13823,13826,59,1,8713,59,1,8951,59,1,8950,105,4,2,59,118,13836,13838,1,8716,4,3,97,98,99,13846,13849,13852,59,1,8716,59,1,8958,59,1,8957,4,3,97,111,114,13863,13892,13899,114,4,4,59,97,115,116,13874,13876,13883,13888,1,8742,108,108,101,108,59,1,8742,108,59,3,11005,8421,59,3,8706,824,108,105,110,116,59,1,10772,4,3,59,99,101,13907,13909,13914,1,8832,117,101,59,1,8928,4,2,59,99,13920,13923,3,10927,824,4,2,59,101,13929,13931,1,8832,113,59,3,10927,824,4,4,65,97,105,116,13946,13951,13971,13982,114,114,59,1,8655,114,114,4,3,59,99,119,13961,13963,13967,1,8603,59,3,10547,824,59,3,8605,824,103,104,116,97,114,114,111,119,59,1,8603,114,105,4,2,59,101,13990,13992,1,8939,59,1,8941,4,7,99,104,105,109,112,113,117,14011,14036,14060,14080,14085,14090,14106,4,4,59,99,101,114,14021,14023,14028,14032,1,8833,117,101,59,1,8929,59,3,10928,824,59,3,55349,56515,111,114,116,4,2,109,112,14045,14050,105,100,59,1,8740,97,114,97,108,108,101,108,59,1,8742,109,4,2,59,101,14067,14069,1,8769,4,2,59,113,14075,14077,1,8772,59,1,8772,105,100,59,1,8740,97,114,59,1,8742,115,117,4,2,98,112,14098,14102,101,59,1,8930,101,59,1,8931,4,3,98,99,112,14114,14157,14171,4,4,59,69,101,115,14124,14126,14130,14133,1,8836,59,3,10949,824,59,1,8840,101,116,4,2,59,101,14141,14144,3,8834,8402,113,4,2,59,113,14151,14153,1,8840,59,3,10949,824,99,4,2,59,101,14164,14166,1,8833,113,59,3,10928,824,4,4,59,69,101,115,14181,14183,14187,14190,1,8837,59,3,10950,824,59,1,8841,101,116,4,2,59,101,14198,14201,3,8835,8402,113,4,2,59,113,14208,14210,1,8841,59,3,10950,824,4,4,103,105,108,114,14224,14228,14238,14242,108,59,1,8825,108,100,101,5,241,1,59,14236,1,241,103,59,1,8824,105,97,110,103,108,101,4,2,108,114,14254,14269,101,102,116,4,2,59,101,14263,14265,1,8938,113,59,1,8940,105,103,104,116,4,2,59,101,14279,14281,1,8939,113,59,1,8941,4,2,59,109,14291,14293,1,957,4,3,59,101,115,14301,14303,14308,1,35,114,111,59,1,8470,112,59,1,8199,4,9,68,72,97,100,103,105,108,114,115,14332,14338,14344,14349,14355,14369,14376,14408,14426,97,115,104,59,1,8877,97,114,114,59,1,10500,112,59,3,8781,8402,97,115,104,59,1,8876,4,2,101,116,14361,14365,59,3,8805,8402,59,3,62,8402,110,102,105,110,59,1,10718,4,3,65,101,116,14384,14389,14393,114,114,59,1,10498,59,3,8804,8402,4,2,59,114,14399,14402,3,60,8402,105,101,59,3,8884,8402,4,2,65,116,14414,14419,114,114,59,1,10499,114,105,101,59,3,8885,8402,105,109,59,3,8764,8402,4,3,65,97,110,14440,14445,14468,114,114,59,1,8662,114,4,2,104,114,14452,14456,107,59,1,10531,4,2,59,111,14462,14464,1,8598,119,59,1,8598,101,97,114,59,1,10535,4,18,83,97,99,100,101,102,103,104,105,108,109,111,112,114,115,116,117,118,14512,14515,14535,14560,14597,14603,14618,14643,14657,14662,14701,14741,14747,14769,14851,14877,14907,14916,59,1,9416,4,2,99,115,14521,14531,117,116,101,5,243,1,59,14529,1,243,116,59,1,8859,4,2,105,121,14541,14557,114,4,2,59,99,14548,14550,1,8858,5,244,1,59,14555,1,244,59,1,1086,4,5,97,98,105,111,115,14572,14577,14583,14587,14591,115,104,59,1,8861,108,97,99,59,1,337,118,59,1,10808,116,59,1,8857,111,108,100,59,1,10684,108,105,103,59,1,339,4,2,99,114,14609,14614,105,114,59,1,10687,59,3,55349,56620,4,3,111,114,116,14626,14630,14640,110,59,1,731,97,118,101,5,242,1,59,14638,1,242,59,1,10689,4,2,98,109,14649,14654,97,114,59,1,10677,59,1,937,110,116,59,1,8750,4,4,97,99,105,116,14672,14677,14693,14698,114,114,59,1,8634,4,2,105,114,14683,14687,114,59,1,10686,111,115,115,59,1,10683,110,101,59,1,8254,59,1,10688,4,3,97,101,105,14709,14714,14719,99,114,59,1,333,103,97,59,1,969,4,3,99,100,110,14727,14733,14736,114,111,110,59,1,959,59,1,10678,117,115,59,1,8854,112,102,59,3,55349,56672,4,3,97,101,108,14755,14759,14764,114,59,1,10679,114,112,59,1,10681,117,115,59,1,8853,4,7,59,97,100,105,111,115,118,14785,14787,14792,14831,14837,14841,14848,1,8744,114,114,59,1,8635,4,4,59,101,102,109,14802,14804,14817,14824,1,10845,114,4,2,59,111,14811,14813,1,8500,102,59,1,8500,5,170,1,59,14822,1,170,5,186,1,59,14829,1,186,103,111,102,59,1,8886,114,59,1,10838,108,111,112,101,59,1,10839,59,1,10843,4,3,99,108,111,14859,14863,14873,114,59,1,8500,97,115,104,5,248,1,59,14871,1,248,108,59,1,8856,105,4,2,108,109,14884,14893,100,101,5,245,1,59,14891,1,245,101,115,4,2,59,97,14901,14903,1,8855,115,59,1,10806,109,108,5,246,1,59,14914,1,246,98,97,114,59,1,9021,4,12,97,99,101,102,104,105,108,109,111,114,115,117,14948,14992,14996,15033,15038,15068,15090,15189,15192,15222,15427,15441,114,4,4,59,97,115,116,14959,14961,14976,14989,1,8741,5,182,2,59,108,14968,14970,1,182,108,101,108,59,1,8741,4,2,105,108,14982,14986,109,59,1,10995,59,1,11005,59,1,8706,121,59,1,1087,114,4,5,99,105,109,112,116,15009,15014,15019,15024,15027,110,116,59,1,37,111,100,59,1,46,105,108,59,1,8240,59,1,8869,101,110,107,59,1,8241,114,59,3,55349,56621,4,3,105,109,111,15046,15057,15063,4,2,59,118,15052,15054,1,966,59,1,981,109,97,116,59,1,8499,110,101,59,1,9742,4,3,59,116,118,15076,15078,15087,1,960,99,104,102,111,114,107,59,1,8916,59,1,982,4,2,97,117,15096,15119,110,4,2,99,107,15103,15115,107,4,2,59,104,15110,15112,1,8463,59,1,8462,118,59,1,8463,115,4,9,59,97,98,99,100,101,109,115,116,15140,15142,15148,15151,15156,15168,15171,15179,15184,1,43,99,105,114,59,1,10787,59,1,8862,105,114,59,1,10786,4,2,111,117,15162,15165,59,1,8724,59,1,10789,59,1,10866,110,5,177,1,59,15177,1,177,105,109,59,1,10790,119,111,59,1,10791,59,1,177,4,3,105,112,117,15200,15208,15213,110,116,105,110,116,59,1,10773,102,59,3,55349,56673,110,100,5,163,1,59,15220,1,163,4,10,59,69,97,99,101,105,110,111,115,117,15244,15246,15249,15253,15258,15334,15347,15367,15416,15421,1,8826,59,1,10931,112,59,1,10935,117,101,59,1,8828,4,2,59,99,15264,15266,1,10927,4,6,59,97,99,101,110,115,15280,15282,15290,15299,15303,15329,1,8826,112,112,114,111,120,59,1,10935,117,114,108,121,101,113,59,1,8828,113,59,1,10927,4,3,97,101,115,15311,15319,15324,112,112,114,111,120,59,1,10937,113,113,59,1,10933,105,109,59,1,8936,105,109,59,1,8830,109,101,4,2,59,115,15342,15344,1,8242,59,1,8473,4,3,69,97,115,15355,15358,15362,59,1,10933,112,59,1,10937,105,109,59,1,8936,4,3,100,102,112,15375,15378,15404,59,1,8719,4,3,97,108,115,15386,15392,15398,108,97,114,59,1,9006,105,110,101,59,1,8978,117,114,102,59,1,8979,4,2,59,116,15410,15412,1,8733,111,59,1,8733,105,109,59,1,8830,114,101,108,59,1,8880,4,2,99,105,15433,15438,114,59,3,55349,56517,59,1,968,110,99,115,112,59,1,8200,4,6,102,105,111,112,115,117,15462,15467,15472,15478,15485,15491,114,59,3,55349,56622,110,116,59,1,10764,112,102,59,3,55349,56674,114,105,109,101,59,1,8279,99,114,59,3,55349,56518,4,3,97,101,111,15499,15520,15534,116,4,2,101,105,15506,15515,114,110,105,111,110,115,59,1,8461,110,116,59,1,10774,115,116,4,2,59,101,15528,15530,1,63,113,59,1,8799,116,5,34,1,59,15540,1,34,4,21,65,66,72,97,98,99,100,101,102,104,105,108,109,110,111,112,114,115,116,117,120,15586,15609,15615,15620,15796,15855,15893,15931,15977,16001,16039,16183,16204,16222,16228,16285,16312,16318,16363,16408,16416,4,3,97,114,116,15594,15599,15603,114,114,59,1,8667,114,59,1,8658,97,105,108,59,1,10524,97,114,114,59,1,10511,97,114,59,1,10596,4,7,99,100,101,110,113,114,116,15636,15651,15656,15664,15687,15696,15770,4,2,101,117,15642,15646,59,3,8765,817,116,101,59,1,341,105,99,59,1,8730,109,112,116,121,118,59,1,10675,103,4,4,59,100,101,108,15675,15677,15680,15683,1,10217,59,1,10642,59,1,10661,101,59,1,10217,117,111,5,187,1,59,15694,1,187,114,4,11,59,97,98,99,102,104,108,112,115,116,119,15721,15723,15727,15739,15742,15746,15750,15754,15758,15763,15767,1,8594,112,59,1,10613,4,2,59,102,15733,15735,1,8677,115,59,1,10528,59,1,10547,115,59,1,10526,107,59,1,8618,112,59,1,8620,108,59,1,10565,105,109,59,1,10612,108,59,1,8611,59,1,8605,4,2,97,105,15776,15781,105,108,59,1,10522,111,4,2,59,110,15788,15790,1,8758,97,108,115,59,1,8474,4,3,97,98,114,15804,15809,15814,114,114,59,1,10509,114,107,59,1,10099,4,2,97,107,15820,15833,99,4,2,101,107,15827,15830,59,1,125,59,1,93,4,2,101,115,15839,15842,59,1,10636,108,4,2,100,117,15849,15852,59,1,10638,59,1,10640,4,4,97,101,117,121,15865,15871,15886,15890,114,111,110,59,1,345,4,2,100,105,15877,15882,105,108,59,1,343,108,59,1,8969,98,59,1,125,59,1,1088,4,4,99,108,113,115,15903,15907,15914,15927,97,59,1,10551,100,104,97,114,59,1,10601,117,111,4,2,59,114,15922,15924,1,8221,59,1,8221,104,59,1,8627,4,3,97,99,103,15939,15966,15970,108,4,4,59,105,112,115,15950,15952,15957,15963,1,8476,110,101,59,1,8475,97,114,116,59,1,8476,59,1,8477,116,59,1,9645,5,174,1,59,15975,1,174,4,3,105,108,114,15985,15991,15997,115,104,116,59,1,10621,111,111,114,59,1,8971,59,3,55349,56623,4,2,97,111,16007,16028,114,4,2,100,117,16014,16017,59,1,8641,4,2,59,108,16023,16025,1,8640,59,1,10604,4,2,59,118,16034,16036,1,961,59,1,1009,4,3,103,110,115,16047,16167,16171,104,116,4,6,97,104,108,114,115,116,16063,16081,16103,16130,16143,16155,114,114,111,119,4,2,59,116,16073,16075,1,8594,97,105,108,59,1,8611,97,114,112,111,111,110,4,2,100,117,16093,16099,111,119,110,59,1,8641,112,59,1,8640,101,102,116,4,2,97,104,16112,16120,114,114,111,119,115,59,1,8644,97,114,112,111,111,110,115,59,1,8652,105,103,104,116,97,114,114,111,119,115,59,1,8649,113,117,105,103,97,114,114,111,119,59,1,8605,104,114,101,101,116,105,109,101,115,59,1,8908,103,59,1,730,105,110,103,100,111,116,115,101,113,59,1,8787,4,3,97,104,109,16191,16196,16201,114,114,59,1,8644,97,114,59,1,8652,59,1,8207,111,117,115,116,4,2,59,97,16214,16216,1,9137,99,104,101,59,1,9137,109,105,100,59,1,10990,4,4,97,98,112,116,16238,16252,16257,16278,4,2,110,114,16244,16248,103,59,1,10221,114,59,1,8702,114,107,59,1,10215,4,3,97,102,108,16265,16269,16273,114,59,1,10630,59,3,55349,56675,117,115,59,1,10798,105,109,101,115,59,1,10805,4,2,97,112,16291,16304,114,4,2,59,103,16298,16300,1,41,116,59,1,10644,111,108,105,110,116,59,1,10770,97,114,114,59,1,8649,4,4,97,99,104,113,16328,16334,16339,16342,113,117,111,59,1,8250,114,59,3,55349,56519,59,1,8625,4,2,98,117,16348,16351,59,1,93,111,4,2,59,114,16358,16360,1,8217,59,1,8217,4,3,104,105,114,16371,16377,16383,114,101,101,59,1,8908,109,101,115,59,1,8906,105,4,4,59,101,102,108,16394,16396,16399,16402,1,9657,59,1,8885,59,1,9656,116,114,105,59,1,10702,108,117,104,97,114,59,1,10600,59,1,8478,4,19,97,98,99,100,101,102,104,105,108,109,111,112,113,114,115,116,117,119,122,16459,16466,16472,16572,16590,16672,16687,16746,16844,16850,16924,16963,16988,17115,17121,17154,17206,17614,17656,99,117,116,101,59,1,347,113,117,111,59,1,8218,4,10,59,69,97,99,101,105,110,112,115,121,16494,16496,16499,16513,16518,16531,16536,16556,16564,16569,1,8827,59,1,10932,4,2,112,114,16505,16508,59,1,10936,111,110,59,1,353,117,101,59,1,8829,4,2,59,100,16524,16526,1,10928,105,108,59,1,351,114,99,59,1,349,4,3,69,97,115,16544,16547,16551,59,1,10934,112,59,1,10938,105,109,59,1,8937,111,108,105,110,116,59,1,10771,105,109,59,1,8831,59,1,1089,111,116,4,3,59,98,101,16582,16584,16587,1,8901,59,1,8865,59,1,10854,4,7,65,97,99,109,115,116,120,16606,16611,16634,16642,16646,16652,16668,114,114,59,1,8664,114,4,2,104,114,16618,16622,107,59,1,10533,4,2,59,111,16628,16630,1,8600,119,59,1,8600,116,5,167,1,59,16640,1,167,105,59,1,59,119,97,114,59,1,10537,109,4,2,105,110,16659,16665,110,117,115,59,1,8726,59,1,8726,116,59,1,10038,114,4,2,59,111,16679,16682,3,55349,56624,119,110,59,1,8994,4,4,97,99,111,121,16697,16702,16716,16739,114,112,59,1,9839,4,2,104,121,16708,16713,99,121,59,1,1097,59,1,1096,114,116,4,2,109,112,16724,16729,105,100,59,1,8739,97,114,97,108,108,101,108,59,1,8741,5,173,1,59,16744,1,173,4,2,103,109,16752,16770,109,97,4,3,59,102,118,16762,16764,16767,1,963,59,1,962,59,1,962,4,8,59,100,101,103,108,110,112,114,16788,16790,16795,16806,16817,16828,16832,16838,1,8764,111,116,59,1,10858,4,2,59,113,16801,16803,1,8771,59,1,8771,4,2,59,69,16812,16814,1,10910,59,1,10912,4,2,59,69,16823,16825,1,10909,59,1,10911,101,59,1,8774,108,117,115,59,1,10788,97,114,114,59,1,10610,97,114,114,59,1,8592,4,4,97,101,105,116,16860,16883,16891,16904,4,2,108,115,16866,16878,108,115,101,116,109,105,110,117,115,59,1,8726,104,112,59,1,10803,112,97,114,115,108,59,1,10724,4,2,100,108,16897,16900,59,1,8739,101,59,1,8995,4,2,59,101,16910,16912,1,10922,4,2,59,115,16918,16920,1,10924,59,3,10924,65024,4,3,102,108,112,16932,16938,16958,116,99,121,59,1,1100,4,2,59,98,16944,16946,1,47,4,2,59,97,16952,16954,1,10692,114,59,1,9023,102,59,3,55349,56676,97,4,2,100,114,16970,16985,101,115,4,2,59,117,16978,16980,1,9824,105,116,59,1,9824,59,1,8741,4,3,99,115,117,16996,17028,17089,4,2,97,117,17002,17015,112,4,2,59,115,17009,17011,1,8851,59,3,8851,65024,112,4,2,59,115,17022,17024,1,8852,59,3,8852,65024,117,4,2,98,112,17035,17062,4,3,59,101,115,17043,17045,17048,1,8847,59,1,8849,101,116,4,2,59,101,17056,17058,1,8847,113,59,1,8849,4,3,59,101,115,17070,17072,17075,1,8848,59,1,8850,101,116,4,2,59,101,17083,17085,1,8848,113,59,1,8850,4,3,59,97,102,17097,17099,17112,1,9633,114,4,2,101,102,17106,17109,59,1,9633,59,1,9642,59,1,9642,97,114,114,59,1,8594,4,4,99,101,109,116,17131,17136,17142,17148,114,59,3,55349,56520,116,109,110,59,1,8726,105,108,101,59,1,8995,97,114,102,59,1,8902,4,2,97,114,17160,17172,114,4,2,59,102,17167,17169,1,9734,59,1,9733,4,2,97,110,17178,17202,105,103,104,116,4,2,101,112,17188,17197,112,115,105,108,111,110,59,1,1013,104,105,59,1,981,115,59,1,175,4,5,98,99,109,110,112,17218,17351,17420,17423,17427,4,9,59,69,100,101,109,110,112,114,115,17238,17240,17243,17248,17261,17267,17279,17285,17291,1,8834,59,1,10949,111,116,59,1,10941,4,2,59,100,17254,17256,1,8838,111,116,59,1,10947,117,108,116,59,1,10945,4,2,69,101,17273,17276,59,1,10955,59,1,8842,108,117,115,59,1,10943,97,114,114,59,1,10617,4,3,101,105,117,17299,17335,17339,116,4,3,59,101,110,17308,17310,17322,1,8834,113,4,2,59,113,17317,17319,1,8838,59,1,10949,101,113,4,2,59,113,17330,17332,1,8842,59,1,10955,109,59,1,10951,4,2,98,112,17345,17348,59,1,10965,59,1,10963,99,4,6,59,97,99,101,110,115,17366,17368,17376,17385,17389,17415,1,8827,112,112,114,111,120,59,1,10936,117,114,108,121,101,113,59,1,8829,113,59,1,10928,4,3,97,101,115,17397,17405,17410,112,112,114,111,120,59,1,10938,113,113,59,1,10934,105,109,59,1,8937,105,109,59,1,8831,59,1,8721,103,59,1,9834,4,13,49,50,51,59,69,100,101,104,108,109,110,112,115,17455,17462,17469,17476,17478,17481,17496,17509,17524,17530,17536,17548,17554,5,185,1,59,17460,1,185,5,178,1,59,17467,1,178,5,179,1,59,17474,1,179,1,8835,59,1,10950,4,2,111,115,17487,17491,116,59,1,10942,117,98,59,1,10968,4,2,59,100,17502,17504,1,8839,111,116,59,1,10948,115,4,2,111,117,17516,17520,108,59,1,10185,98,59,1,10967,97,114,114,59,1,10619,117,108,116,59,1,10946,4,2,69,101,17542,17545,59,1,10956,59,1,8843,108,117,115,59,1,10944,4,3,101,105,117,17562,17598,17602,116,4,3,59,101,110,17571,17573,17585,1,8835,113,4,2,59,113,17580,17582,1,8839,59,1,10950,101,113,4,2,59,113,17593,17595,1,8843,59,1,10956,109,59,1,10952,4,2,98,112,17608,17611,59,1,10964,59,1,10966,4,3,65,97,110,17622,17627,17650,114,114,59,1,8665,114,4,2,104,114,17634,17638,107,59,1,10534,4,2,59,111,17644,17646,1,8601,119,59,1,8601,119,97,114,59,1,10538,108,105,103,5,223,1,59,17664,1,223,4,13,97,98,99,100,101,102,104,105,111,112,114,115,119,17694,17709,17714,17737,17742,17749,17754,17860,17905,17957,17964,18090,18122,4,2,114,117,17700,17706,103,101,116,59,1,8982,59,1,964,114,107,59,1,9140,4,3,97,101,121,17722,17728,17734,114,111,110,59,1,357,100,105,108,59,1,355,59,1,1090,111,116,59,1,8411,108,114,101,99,59,1,8981,114,59,3,55349,56625,4,4,101,105,107,111,17764,17805,17836,17851,4,2,114,116,17770,17786,101,4,2,52,102,17777,17780,59,1,8756,111,114,101,59,1,8756,97,4,3,59,115,118,17795,17797,17802,1,952,121,109,59,1,977,59,1,977,4,2,99,110,17811,17831,107,4,2,97,115,17818,17826,112,112,114,111,120,59,1,8776,105,109,59,1,8764,115,112,59,1,8201,4,2,97,115,17842,17846,112,59,1,8776,105,109,59,1,8764,114,110,5,254,1,59,17858,1,254,4,3,108,109,110,17868,17873,17901,100,101,59,1,732,101,115,5,215,3,59,98,100,17884,17886,17898,1,215,4,2,59,97,17892,17894,1,8864,114,59,1,10801,59,1,10800,116,59,1,8749,4,3,101,112,115,17913,17917,17953,97,59,1,10536,4,4,59,98,99,102,17927,17929,17934,17939,1,8868,111,116,59,1,9014,105,114,59,1,10993,4,2,59,111,17945,17948,3,55349,56677,114,107,59,1,10970,97,59,1,10537,114,105,109,101,59,1,8244,4,3,97,105,112,17972,17977,18082,100,101,59,1,8482,4,7,97,100,101,109,112,115,116,17993,18051,18056,18059,18066,18072,18076,110,103,108,101,4,5,59,100,108,113,114,18009,18011,18017,18032,18035,1,9653,111,119,110,59,1,9663,101,102,116,4,2,59,101,18026,18028,1,9667,113,59,1,8884,59,1,8796,105,103,104,116,4,2,59,101,18045,18047,1,9657,113,59,1,8885,111,116,59,1,9708,59,1,8796,105,110,117,115,59,1,10810,108,117,115,59,1,10809,98,59,1,10701,105,109,101,59,1,10811,101,122,105,117,109,59,1,9186,4,3,99,104,116,18098,18111,18116,4,2,114,121,18104,18108,59,3,55349,56521,59,1,1094,99,121,59,1,1115,114,111,107,59,1,359,4,2,105,111,18128,18133,120,116,59,1,8812,104,101,97,100,4,2,108,114,18143,18154,101,102,116,97,114,114,111,119,59,1,8606,105,103,104,116,97,114,114,111,119,59,1,8608,4,18,65,72,97,98,99,100,102,103,104,108,109,111,112,114,115,116,117,119,18204,18209,18214,18234,18250,18268,18292,18308,18319,18343,18379,18397,18413,18504,18547,18553,18584,18603,114,114,59,1,8657,97,114,59,1,10595,4,2,99,114,18220,18230,117,116,101,5,250,1,59,18228,1,250,114,59,1,8593,114,4,2,99,101,18241,18245,121,59,1,1118,118,101,59,1,365,4,2,105,121,18256,18265,114,99,5,251,1,59,18263,1,251,59,1,1091,4,3,97,98,104,18276,18281,18287,114,114,59,1,8645,108,97,99,59,1,369,97,114,59,1,10606,4,2,105,114,18298,18304,115,104,116,59,1,10622,59,3,55349,56626,114,97,118,101,5,249,1,59,18317,1,249,4,2,97,98,18325,18338,114,4,2,108,114,18332,18335,59,1,8639,59,1,8638,108,107,59,1,9600,4,2,99,116,18349,18374,4,2,111,114,18355,18369,114,110,4,2,59,101,18363,18365,1,8988,114,59,1,8988,111,112,59,1,8975,114,105,59,1,9720,4,2,97,108,18385,18390,99,114,59,1,363,5,168,1,59,18395,1,168,4,2,103,112,18403,18408,111,110,59,1,371,102,59,3,55349,56678,4,6,97,100,104,108,115,117,18427,18434,18445,18470,18475,18494,114,114,111,119,59,1,8593,111,119,110,97,114,114,111,119,59,1,8597,97,114,112,111,111,110,4,2,108,114,18457,18463,101,102,116,59,1,8639,105,103,104,116,59,1,8638,117,115,59,1,8846,105,4,3,59,104,108,18484,18486,18489,1,965,59,1,978,111,110,59,1,965,112,97,114,114,111,119,115,59,1,8648,4,3,99,105,116,18512,18537,18542,4,2,111,114,18518,18532,114,110,4,2,59,101,18526,18528,1,8989,114,59,1,8989,111,112,59,1,8974,110,103,59,1,367,114,105,59,1,9721,99,114,59,3,55349,56522,4,3,100,105,114,18561,18566,18572,111,116,59,1,8944,108,100,101,59,1,361,105,4,2,59,102,18579,18581,1,9653,59,1,9652,4,2,97,109,18590,18595,114,114,59,1,8648,108,5,252,1,59,18601,1,252,97,110,103,108,101,59,1,10663,4,15,65,66,68,97,99,100,101,102,108,110,111,112,114,115,122,18643,18648,18661,18667,18847,18851,18857,18904,18909,18915,18931,18937,18943,18949,18996,114,114,59,1,8661,97,114,4,2,59,118,18656,18658,1,10984,59,1,10985,97,115,104,59,1,8872,4,2,110,114,18673,18679,103,114,116,59,1,10652,4,7,101,107,110,112,114,115,116,18695,18704,18711,18720,18742,18754,18810,112,115,105,108,111,110,59,1,1013,97,112,112,97,59,1,1008,111,116,104,105,110,103,59,1,8709,4,3,104,105,114,18728,18732,18735,105,59,1,981,59,1,982,111,112,116,111,59,1,8733,4,2,59,104,18748,18750,1,8597,111,59,1,1009,4,2,105,117,18760,18766,103,109,97,59,1,962,4,2,98,112,18772,18791,115,101,116,110,101,113,4,2,59,113,18784,18787,3,8842,65024,59,3,10955,65024,115,101,116,110,101,113,4,2,59,113,18803,18806,3,8843,65024,59,3,10956,65024,4,2,104,114,18816,18822,101,116,97,59,1,977,105,97,110,103,108,101,4,2,108,114,18834,18840,101,102,116,59,1,8882,105,103,104,116,59,1,8883,121,59,1,1074,97,115,104,59,1,8866,4,3,101,108,114,18865,18884,18890,4,3,59,98,101,18873,18875,18880,1,8744,97,114,59,1,8891,113,59,1,8794,108,105,112,59,1,8942,4,2,98,116,18896,18901,97,114,59,1,124,59,1,124,114,59,3,55349,56627,116,114,105,59,1,8882,115,117,4,2,98,112,18923,18927,59,3,8834,8402,59,3,8835,8402,112,102,59,3,55349,56679,114,111,112,59,1,8733,116,114,105,59,1,8883,4,2,99,117,18955,18960,114,59,3,55349,56523,4,2,98,112,18966,18981,110,4,2,69,101,18973,18977,59,3,10955,65024,59,3,8842,65024,110,4,2,69,101,18988,18992,59,3,10956,65024,59,3,8843,65024,105,103,122,97,103,59,1,10650,4,7,99,101,102,111,112,114,115,19020,19026,19061,19066,19072,19075,19089,105,114,99,59,1,373,4,2,100,105,19032,19055,4,2,98,103,19038,19043,97,114,59,1,10847,101,4,2,59,113,19050,19052,1,8743,59,1,8793,101,114,112,59,1,8472,114,59,3,55349,56628,112,102,59,3,55349,56680,59,1,8472,4,2,59,101,19081,19083,1,8768,97,116,104,59,1,8768,99,114,59,3,55349,56524,4,14,99,100,102,104,105,108,109,110,111,114,115,117,118,119,19125,19146,19152,19157,19173,19176,19192,19197,19202,19236,19252,19269,19286,19291,4,3,97,105,117,19133,19137,19142,112,59,1,8898,114,99,59,1,9711,112,59,1,8899,116,114,105,59,1,9661,114,59,3,55349,56629,4,2,65,97,19163,19168,114,114,59,1,10234,114,114,59,1,10231,59,1,958,4,2,65,97,19182,19187,114,114,59,1,10232,114,114,59,1,10229,97,112,59,1,10236,105,115,59,1,8955,4,3,100,112,116,19210,19215,19230,111,116,59,1,10752,4,2,102,108,19221,19225,59,3,55349,56681,117,115,59,1,10753,105,109,101,59,1,10754,4,2,65,97,19242,19247,114,114,59,1,10233,114,114,59,1,10230,4,2,99,113,19258,19263,114,59,3,55349,56525,99,117,112,59,1,10758,4,2,112,116,19275,19281,108,117,115,59,1,10756,114,105,59,1,9651,101,101,59,1,8897,101,100,103,101,59,1,8896,4,8,97,99,101,102,105,111,115,117,19316,19335,19349,19357,19362,19367,19373,19379,99,4,2,117,121,19323,19332,116,101,5,253,1,59,19330,1,253,59,1,1103,4,2,105,121,19341,19346,114,99,59,1,375,59,1,1099,110,5,165,1,59,19355,1,165,114,59,3,55349,56630,99,121,59,1,1111,112,102,59,3,55349,56682,99,114,59,3,55349,56526,4,2,99,109,19385,19389,121,59,1,1102,108,5,255,1,59,19395,1,255,4,10,97,99,100,101,102,104,105,111,115,119,19419,19426,19441,19446,19462,19467,19472,19480,19486,19492,99,117,116,101,59,1,378,4,2,97,121,19432,19438,114,111,110,59,1,382,59,1,1079,111,116,59,1,380,4,2,101,116,19452,19458,116,114,102,59,1,8488,97,59,1,950,114,59,3,55349,56631,99,121,59,1,1078,103,114,97,114,114,59,1,8669,112,102,59,3,55349,56683,99,114,59,3,55349,56527,4,2,106,110,19498,19501,59,1,8205,106,59,1,8204]);

const Preprocessor = preprocessor;
const unicode$1 = unicode$3;
const neTree = namedEntityData;
const ERR$1 = errorCodes;

//Aliases
const $$6 = unicode$1.CODE_POINTS;
const $$ = unicode$1.CODE_POINT_SEQUENCES;

//C1 Unicode control character reference replacements
const C1_CONTROLS_REFERENCE_REPLACEMENTS = {
    0x80: 0x20ac,
    0x82: 0x201a,
    0x83: 0x0192,
    0x84: 0x201e,
    0x85: 0x2026,
    0x86: 0x2020,
    0x87: 0x2021,
    0x88: 0x02c6,
    0x89: 0x2030,
    0x8a: 0x0160,
    0x8b: 0x2039,
    0x8c: 0x0152,
    0x8e: 0x017d,
    0x91: 0x2018,
    0x92: 0x2019,
    0x93: 0x201c,
    0x94: 0x201d,
    0x95: 0x2022,
    0x96: 0x2013,
    0x97: 0x2014,
    0x98: 0x02dc,
    0x99: 0x2122,
    0x9a: 0x0161,
    0x9b: 0x203a,
    0x9c: 0x0153,
    0x9e: 0x017e,
    0x9f: 0x0178
};

// Named entity tree flags
const HAS_DATA_FLAG = 1 << 0;
const DATA_DUPLET_FLAG = 1 << 1;
const HAS_BRANCHES_FLAG = 1 << 2;
const MAX_BRANCH_MARKER_VALUE = HAS_DATA_FLAG | DATA_DUPLET_FLAG | HAS_BRANCHES_FLAG;

//States
const DATA_STATE = 'DATA_STATE';
const RCDATA_STATE = 'RCDATA_STATE';
const RAWTEXT_STATE = 'RAWTEXT_STATE';
const SCRIPT_DATA_STATE = 'SCRIPT_DATA_STATE';
const PLAINTEXT_STATE = 'PLAINTEXT_STATE';
const TAG_OPEN_STATE = 'TAG_OPEN_STATE';
const END_TAG_OPEN_STATE = 'END_TAG_OPEN_STATE';
const TAG_NAME_STATE = 'TAG_NAME_STATE';
const RCDATA_LESS_THAN_SIGN_STATE = 'RCDATA_LESS_THAN_SIGN_STATE';
const RCDATA_END_TAG_OPEN_STATE = 'RCDATA_END_TAG_OPEN_STATE';
const RCDATA_END_TAG_NAME_STATE = 'RCDATA_END_TAG_NAME_STATE';
const RAWTEXT_LESS_THAN_SIGN_STATE = 'RAWTEXT_LESS_THAN_SIGN_STATE';
const RAWTEXT_END_TAG_OPEN_STATE = 'RAWTEXT_END_TAG_OPEN_STATE';
const RAWTEXT_END_TAG_NAME_STATE = 'RAWTEXT_END_TAG_NAME_STATE';
const SCRIPT_DATA_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_LESS_THAN_SIGN_STATE';
const SCRIPT_DATA_END_TAG_OPEN_STATE = 'SCRIPT_DATA_END_TAG_OPEN_STATE';
const SCRIPT_DATA_END_TAG_NAME_STATE = 'SCRIPT_DATA_END_TAG_NAME_STATE';
const SCRIPT_DATA_ESCAPE_START_STATE = 'SCRIPT_DATA_ESCAPE_START_STATE';
const SCRIPT_DATA_ESCAPE_START_DASH_STATE = 'SCRIPT_DATA_ESCAPE_START_DASH_STATE';
const SCRIPT_DATA_ESCAPED_STATE = 'SCRIPT_DATA_ESCAPED_STATE';
const SCRIPT_DATA_ESCAPED_DASH_STATE = 'SCRIPT_DATA_ESCAPED_DASH_STATE';
const SCRIPT_DATA_ESCAPED_DASH_DASH_STATE = 'SCRIPT_DATA_ESCAPED_DASH_DASH_STATE';
const SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE';
const SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE = 'SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE';
const SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE = 'SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE';
const SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE';
const SCRIPT_DATA_DOUBLE_ESCAPED_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_STATE';
const SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE';
const SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE';
const SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE';
const SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE';
const BEFORE_ATTRIBUTE_NAME_STATE = 'BEFORE_ATTRIBUTE_NAME_STATE';
const ATTRIBUTE_NAME_STATE = 'ATTRIBUTE_NAME_STATE';
const AFTER_ATTRIBUTE_NAME_STATE = 'AFTER_ATTRIBUTE_NAME_STATE';
const BEFORE_ATTRIBUTE_VALUE_STATE = 'BEFORE_ATTRIBUTE_VALUE_STATE';
const ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE = 'ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE';
const ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE = 'ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE';
const ATTRIBUTE_VALUE_UNQUOTED_STATE = 'ATTRIBUTE_VALUE_UNQUOTED_STATE';
const AFTER_ATTRIBUTE_VALUE_QUOTED_STATE = 'AFTER_ATTRIBUTE_VALUE_QUOTED_STATE';
const SELF_CLOSING_START_TAG_STATE = 'SELF_CLOSING_START_TAG_STATE';
const BOGUS_COMMENT_STATE = 'BOGUS_COMMENT_STATE';
const MARKUP_DECLARATION_OPEN_STATE = 'MARKUP_DECLARATION_OPEN_STATE';
const COMMENT_START_STATE = 'COMMENT_START_STATE';
const COMMENT_START_DASH_STATE = 'COMMENT_START_DASH_STATE';
const COMMENT_STATE = 'COMMENT_STATE';
const COMMENT_LESS_THAN_SIGN_STATE = 'COMMENT_LESS_THAN_SIGN_STATE';
const COMMENT_LESS_THAN_SIGN_BANG_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_STATE';
const COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE';
const COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE';
const COMMENT_END_DASH_STATE = 'COMMENT_END_DASH_STATE';
const COMMENT_END_STATE = 'COMMENT_END_STATE';
const COMMENT_END_BANG_STATE = 'COMMENT_END_BANG_STATE';
const DOCTYPE_STATE = 'DOCTYPE_STATE';
const BEFORE_DOCTYPE_NAME_STATE = 'BEFORE_DOCTYPE_NAME_STATE';
const DOCTYPE_NAME_STATE = 'DOCTYPE_NAME_STATE';
const AFTER_DOCTYPE_NAME_STATE = 'AFTER_DOCTYPE_NAME_STATE';
const AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE = 'AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE';
const BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE = 'BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE';
const DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE = 'DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE';
const DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE = 'DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE';
const AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE = 'AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE';
const BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE = 'BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE';
const AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE = 'AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE';
const BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE = 'BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE';
const DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE = 'DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE';
const DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE = 'DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE';
const AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE = 'AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE';
const BOGUS_DOCTYPE_STATE = 'BOGUS_DOCTYPE_STATE';
const CDATA_SECTION_STATE = 'CDATA_SECTION_STATE';
const CDATA_SECTION_BRACKET_STATE = 'CDATA_SECTION_BRACKET_STATE';
const CDATA_SECTION_END_STATE = 'CDATA_SECTION_END_STATE';
const CHARACTER_REFERENCE_STATE = 'CHARACTER_REFERENCE_STATE';
const NAMED_CHARACTER_REFERENCE_STATE = 'NAMED_CHARACTER_REFERENCE_STATE';
const AMBIGUOUS_AMPERSAND_STATE = 'AMBIGUOS_AMPERSAND_STATE';
const NUMERIC_CHARACTER_REFERENCE_STATE = 'NUMERIC_CHARACTER_REFERENCE_STATE';
const HEXADEMICAL_CHARACTER_REFERENCE_START_STATE = 'HEXADEMICAL_CHARACTER_REFERENCE_START_STATE';
const DECIMAL_CHARACTER_REFERENCE_START_STATE = 'DECIMAL_CHARACTER_REFERENCE_START_STATE';
const HEXADEMICAL_CHARACTER_REFERENCE_STATE = 'HEXADEMICAL_CHARACTER_REFERENCE_STATE';
const DECIMAL_CHARACTER_REFERENCE_STATE = 'DECIMAL_CHARACTER_REFERENCE_STATE';
const NUMERIC_CHARACTER_REFERENCE_END_STATE = 'NUMERIC_CHARACTER_REFERENCE_END_STATE';

//Utils

//OPTIMIZATION: these utility functions should not be moved out of this module. V8 Crankshaft will not inline
//this functions if they will be situated in another module due to context switch.
//Always perform inlining check before modifying this functions ('node --trace-inlining').
function isWhitespace(cp) {
    return cp === $$6.SPACE || cp === $$6.LINE_FEED || cp === $$6.TABULATION || cp === $$6.FORM_FEED;
}

function isAsciiDigit(cp) {
    return cp >= $$6.DIGIT_0 && cp <= $$6.DIGIT_9;
}

function isAsciiUpper(cp) {
    return cp >= $$6.LATIN_CAPITAL_A && cp <= $$6.LATIN_CAPITAL_Z;
}

function isAsciiLower(cp) {
    return cp >= $$6.LATIN_SMALL_A && cp <= $$6.LATIN_SMALL_Z;
}

function isAsciiLetter(cp) {
    return isAsciiLower(cp) || isAsciiUpper(cp);
}

function isAsciiAlphaNumeric(cp) {
    return isAsciiLetter(cp) || isAsciiDigit(cp);
}

function isAsciiUpperHexDigit(cp) {
    return cp >= $$6.LATIN_CAPITAL_A && cp <= $$6.LATIN_CAPITAL_F;
}

function isAsciiLowerHexDigit(cp) {
    return cp >= $$6.LATIN_SMALL_A && cp <= $$6.LATIN_SMALL_F;
}

function isAsciiHexDigit(cp) {
    return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);
}

function toAsciiLowerCodePoint(cp) {
    return cp + 0x0020;
}

//NOTE: String.fromCharCode() function can handle only characters from BMP subset.
//So, we need to workaround this manually.
//(see: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/fromCharCode#Getting_it_to_work_with_higher_values)
function toChar(cp) {
    if (cp <= 0xffff) {
        return String.fromCharCode(cp);
    }

    cp -= 0x10000;
    return String.fromCharCode(((cp >>> 10) & 0x3ff) | 0xd800) + String.fromCharCode(0xdc00 | (cp & 0x3ff));
}

function toAsciiLowerChar(cp) {
    return String.fromCharCode(toAsciiLowerCodePoint(cp));
}

function findNamedEntityTreeBranch(nodeIx, cp) {
    const branchCount = neTree[++nodeIx];
    let lo = ++nodeIx;
    let hi = lo + branchCount - 1;

    while (lo <= hi) {
        const mid = (lo + hi) >>> 1;
        const midCp = neTree[mid];

        if (midCp < cp) {
            lo = mid + 1;
        } else if (midCp > cp) {
            hi = mid - 1;
        } else {
            return neTree[mid + branchCount];
        }
    }

    return -1;
}

//Tokenizer
class Tokenizer$4 {
    constructor() {
        this.preprocessor = new Preprocessor();

        this.tokenQueue = [];

        this.allowCDATA = false;

        this.state = DATA_STATE;
        this.returnState = '';

        this.charRefCode = -1;
        this.tempBuff = [];
        this.lastStartTagName = '';

        this.consumedAfterSnapshot = -1;
        this.active = false;

        this.currentCharacterToken = null;
        this.currentToken = null;
        this.currentAttr = null;
    }

    //Errors
    _err() {
        // NOTE: err reporting is noop by default. Enabled by mixin.
    }

    _errOnNextCodePoint(err) {
        this._consume();
        this._err(err);
        this._unconsume();
    }

    //API
    getNextToken() {
        while (!this.tokenQueue.length && this.active) {
            this.consumedAfterSnapshot = 0;

            const cp = this._consume();

            if (!this._ensureHibernation()) {
                this[this.state](cp);
            }
        }

        return this.tokenQueue.shift();
    }

    write(chunk, isLastChunk) {
        this.active = true;
        this.preprocessor.write(chunk, isLastChunk);
    }

    insertHtmlAtCurrentPos(chunk) {
        this.active = true;
        this.preprocessor.insertHtmlAtCurrentPos(chunk);
    }

    //Hibernation
    _ensureHibernation() {
        if (this.preprocessor.endOfChunkHit) {
            for (; this.consumedAfterSnapshot > 0; this.consumedAfterSnapshot--) {
                this.preprocessor.retreat();
            }

            this.active = false;
            this.tokenQueue.push({ type: Tokenizer$4.HIBERNATION_TOKEN });

            return true;
        }

        return false;
    }

    //Consumption
    _consume() {
        this.consumedAfterSnapshot++;
        return this.preprocessor.advance();
    }

    _unconsume() {
        this.consumedAfterSnapshot--;
        this.preprocessor.retreat();
    }

    _reconsumeInState(state) {
        this.state = state;
        this._unconsume();
    }

    _consumeSequenceIfMatch(pattern, startCp, caseSensitive) {
        let consumedCount = 0;
        let isMatch = true;
        const patternLength = pattern.length;
        let patternPos = 0;
        let cp = startCp;
        let patternCp = void 0;

        for (; patternPos < patternLength; patternPos++) {
            if (patternPos > 0) {
                cp = this._consume();
                consumedCount++;
            }

            if (cp === $$6.EOF) {
                isMatch = false;
                break;
            }

            patternCp = pattern[patternPos];

            if (cp !== patternCp && (caseSensitive || cp !== toAsciiLowerCodePoint(patternCp))) {
                isMatch = false;
                break;
            }
        }

        if (!isMatch) {
            while (consumedCount--) {
                this._unconsume();
            }
        }

        return isMatch;
    }

    //Temp buffer
    _isTempBufferEqualToScriptString() {
        if (this.tempBuff.length !== $$.SCRIPT_STRING.length) {
            return false;
        }

        for (let i = 0; i < this.tempBuff.length; i++) {
            if (this.tempBuff[i] !== $$.SCRIPT_STRING[i]) {
                return false;
            }
        }

        return true;
    }

    //Token creation
    _createStartTagToken() {
        this.currentToken = {
            type: Tokenizer$4.START_TAG_TOKEN,
            tagName: '',
            selfClosing: false,
            ackSelfClosing: false,
            attrs: []
        };
    }

    _createEndTagToken() {
        this.currentToken = {
            type: Tokenizer$4.END_TAG_TOKEN,
            tagName: '',
            selfClosing: false,
            attrs: []
        };
    }

    _createCommentToken() {
        this.currentToken = {
            type: Tokenizer$4.COMMENT_TOKEN,
            data: ''
        };
    }

    _createDoctypeToken(initialName) {
        this.currentToken = {
            type: Tokenizer$4.DOCTYPE_TOKEN,
            name: initialName,
            forceQuirks: false,
            publicId: null,
            systemId: null
        };
    }

    _createCharacterToken(type, ch) {
        this.currentCharacterToken = {
            type: type,
            chars: ch
        };
    }

    _createEOFToken() {
        this.currentToken = { type: Tokenizer$4.EOF_TOKEN };
    }

    //Tag attributes
    _createAttr(attrNameFirstCh) {
        this.currentAttr = {
            name: attrNameFirstCh,
            value: ''
        };
    }

    _leaveAttrName(toState) {
        if (Tokenizer$4.getTokenAttr(this.currentToken, this.currentAttr.name) === null) {
            this.currentToken.attrs.push(this.currentAttr);
        } else {
            this._err(ERR$1.duplicateAttribute);
        }

        this.state = toState;
    }

    _leaveAttrValue(toState) {
        this.state = toState;
    }

    //Token emission
    _emitCurrentToken() {
        this._emitCurrentCharacterToken();

        const ct = this.currentToken;

        this.currentToken = null;

        //NOTE: store emited start tag's tagName to determine is the following end tag token is appropriate.
        if (ct.type === Tokenizer$4.START_TAG_TOKEN) {
            this.lastStartTagName = ct.tagName;
        } else if (ct.type === Tokenizer$4.END_TAG_TOKEN) {
            if (ct.attrs.length > 0) {
                this._err(ERR$1.endTagWithAttributes);
            }

            if (ct.selfClosing) {
                this._err(ERR$1.endTagWithTrailingSolidus);
            }
        }

        this.tokenQueue.push(ct);
    }

    _emitCurrentCharacterToken() {
        if (this.currentCharacterToken) {
            this.tokenQueue.push(this.currentCharacterToken);
            this.currentCharacterToken = null;
        }
    }

    _emitEOFToken() {
        this._createEOFToken();
        this._emitCurrentToken();
    }

    //Characters emission

    //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
    //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
    //If we have a sequence of characters that belong to the same group, parser can process it
    //as a single solid character token.
    //So, there are 3 types of character tokens in parse5:
    //1)NULL_CHARACTER_TOKEN - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
    //2)WHITESPACE_CHARACTER_TOKEN - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
    //3)CHARACTER_TOKEN - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
    _appendCharToCurrentCharacterToken(type, ch) {
        if (this.currentCharacterToken && this.currentCharacterToken.type !== type) {
            this._emitCurrentCharacterToken();
        }

        if (this.currentCharacterToken) {
            this.currentCharacterToken.chars += ch;
        } else {
            this._createCharacterToken(type, ch);
        }
    }

    _emitCodePoint(cp) {
        let type = Tokenizer$4.CHARACTER_TOKEN;

        if (isWhitespace(cp)) {
            type = Tokenizer$4.WHITESPACE_CHARACTER_TOKEN;
        } else if (cp === $$6.NULL) {
            type = Tokenizer$4.NULL_CHARACTER_TOKEN;
        }

        this._appendCharToCurrentCharacterToken(type, toChar(cp));
    }

    _emitSeveralCodePoints(codePoints) {
        for (let i = 0; i < codePoints.length; i++) {
            this._emitCodePoint(codePoints[i]);
        }
    }

    //NOTE: used then we emit character explicitly. This is always a non-whitespace and a non-null character.
    //So we can avoid additional checks here.
    _emitChars(ch) {
        this._appendCharToCurrentCharacterToken(Tokenizer$4.CHARACTER_TOKEN, ch);
    }

    // Character reference helpers
    _matchNamedCharacterReference(startCp) {
        let result = null;
        let excess = 1;
        let i = findNamedEntityTreeBranch(0, startCp);

        this.tempBuff.push(startCp);

        while (i > -1) {
            const current = neTree[i];
            const inNode = current < MAX_BRANCH_MARKER_VALUE;
            const nodeWithData = inNode && current & HAS_DATA_FLAG;

            if (nodeWithData) {
                //NOTE: we use greedy search, so we continue lookup at this point
                result = current & DATA_DUPLET_FLAG ? [neTree[++i], neTree[++i]] : [neTree[++i]];
                excess = 0;
            }

            const cp = this._consume();

            this.tempBuff.push(cp);
            excess++;

            if (cp === $$6.EOF) {
                break;
            }

            if (inNode) {
                i = current & HAS_BRANCHES_FLAG ? findNamedEntityTreeBranch(i, cp) : -1;
            } else {
                i = cp === current ? ++i : -1;
            }
        }

        while (excess--) {
            this.tempBuff.pop();
            this._unconsume();
        }

        return result;
    }

    _isCharacterReferenceInAttribute() {
        return (
            this.returnState === ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE ||
            this.returnState === ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE ||
            this.returnState === ATTRIBUTE_VALUE_UNQUOTED_STATE
        );
    }

    _isCharacterReferenceAttributeQuirk(withSemicolon) {
        if (!withSemicolon && this._isCharacterReferenceInAttribute()) {
            const nextCp = this._consume();

            this._unconsume();

            return nextCp === $$6.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp);
        }

        return false;
    }

    _flushCodePointsConsumedAsCharacterReference() {
        if (this._isCharacterReferenceInAttribute()) {
            for (let i = 0; i < this.tempBuff.length; i++) {
                this.currentAttr.value += toChar(this.tempBuff[i]);
            }
        } else {
            this._emitSeveralCodePoints(this.tempBuff);
        }

        this.tempBuff = [];
    }

    // State machine

    // Data state
    //------------------------------------------------------------------
    [DATA_STATE](cp) {
        this.preprocessor.dropParsedChunk();

        if (cp === $$6.LESS_THAN_SIGN) {
            this.state = TAG_OPEN_STATE;
        } else if (cp === $$6.AMPERSAND) {
            this.returnState = DATA_STATE;
            this.state = CHARACTER_REFERENCE_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this._emitCodePoint(cp);
        } else if (cp === $$6.EOF) {
            this._emitEOFToken();
        } else {
            this._emitCodePoint(cp);
        }
    }

    //  RCDATA state
    //------------------------------------------------------------------
    [RCDATA_STATE](cp) {
        this.preprocessor.dropParsedChunk();

        if (cp === $$6.AMPERSAND) {
            this.returnState = RCDATA_STATE;
            this.state = CHARACTER_REFERENCE_STATE;
        } else if (cp === $$6.LESS_THAN_SIGN) {
            this.state = RCDATA_LESS_THAN_SIGN_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$6.EOF) {
            this._emitEOFToken();
        } else {
            this._emitCodePoint(cp);
        }
    }

    // RAWTEXT state
    //------------------------------------------------------------------
    [RAWTEXT_STATE](cp) {
        this.preprocessor.dropParsedChunk();

        if (cp === $$6.LESS_THAN_SIGN) {
            this.state = RAWTEXT_LESS_THAN_SIGN_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$6.EOF) {
            this._emitEOFToken();
        } else {
            this._emitCodePoint(cp);
        }
    }

    // Script data state
    //------------------------------------------------------------------
    [SCRIPT_DATA_STATE](cp) {
        this.preprocessor.dropParsedChunk();

        if (cp === $$6.LESS_THAN_SIGN) {
            this.state = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$6.EOF) {
            this._emitEOFToken();
        } else {
            this._emitCodePoint(cp);
        }
    }

    // PLAINTEXT state
    //------------------------------------------------------------------
    [PLAINTEXT_STATE](cp) {
        this.preprocessor.dropParsedChunk();

        if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$6.EOF) {
            this._emitEOFToken();
        } else {
            this._emitCodePoint(cp);
        }
    }

    // Tag open state
    //------------------------------------------------------------------
    [TAG_OPEN_STATE](cp) {
        if (cp === $$6.EXCLAMATION_MARK) {
            this.state = MARKUP_DECLARATION_OPEN_STATE;
        } else if (cp === $$6.SOLIDUS) {
            this.state = END_TAG_OPEN_STATE;
        } else if (isAsciiLetter(cp)) {
            this._createStartTagToken();
            this._reconsumeInState(TAG_NAME_STATE);
        } else if (cp === $$6.QUESTION_MARK) {
            this._err(ERR$1.unexpectedQuestionMarkInsteadOfTagName);
            this._createCommentToken();
            this._reconsumeInState(BOGUS_COMMENT_STATE);
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofBeforeTagName);
            this._emitChars('<');
            this._emitEOFToken();
        } else {
            this._err(ERR$1.invalidFirstCharacterOfTagName);
            this._emitChars('<');
            this._reconsumeInState(DATA_STATE);
        }
    }

    // End tag open state
    //------------------------------------------------------------------
    [END_TAG_OPEN_STATE](cp) {
        if (isAsciiLetter(cp)) {
            this._createEndTagToken();
            this._reconsumeInState(TAG_NAME_STATE);
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.missingEndTagName);
            this.state = DATA_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofBeforeTagName);
            this._emitChars('</');
            this._emitEOFToken();
        } else {
            this._err(ERR$1.invalidFirstCharacterOfTagName);
            this._createCommentToken();
            this._reconsumeInState(BOGUS_COMMENT_STATE);
        }
    }

    // Tag name state
    //------------------------------------------------------------------
    [TAG_NAME_STATE](cp) {
        if (isWhitespace(cp)) {
            this.state = BEFORE_ATTRIBUTE_NAME_STATE;
        } else if (cp === $$6.SOLIDUS) {
            this.state = SELF_CLOSING_START_TAG_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (isAsciiUpper(cp)) {
            this.currentToken.tagName += toAsciiLowerChar(cp);
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentToken.tagName += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInTag);
            this._emitEOFToken();
        } else {
            this.currentToken.tagName += toChar(cp);
        }
    }

    // RCDATA less-than sign state
    //------------------------------------------------------------------
    [RCDATA_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $$6.SOLIDUS) {
            this.tempBuff = [];
            this.state = RCDATA_END_TAG_OPEN_STATE;
        } else {
            this._emitChars('<');
            this._reconsumeInState(RCDATA_STATE);
        }
    }

    // RCDATA end tag open state
    //------------------------------------------------------------------
    [RCDATA_END_TAG_OPEN_STATE](cp) {
        if (isAsciiLetter(cp)) {
            this._createEndTagToken();
            this._reconsumeInState(RCDATA_END_TAG_NAME_STATE);
        } else {
            this._emitChars('</');
            this._reconsumeInState(RCDATA_STATE);
        }
    }

    // RCDATA end tag name state
    //------------------------------------------------------------------
    [RCDATA_END_TAG_NAME_STATE](cp) {
        if (isAsciiUpper(cp)) {
            this.currentToken.tagName += toAsciiLowerChar(cp);
            this.tempBuff.push(cp);
        } else if (isAsciiLower(cp)) {
            this.currentToken.tagName += toChar(cp);
            this.tempBuff.push(cp);
        } else {
            if (this.lastStartTagName === this.currentToken.tagName) {
                if (isWhitespace(cp)) {
                    this.state = BEFORE_ATTRIBUTE_NAME_STATE;
                    return;
                }

                if (cp === $$6.SOLIDUS) {
                    this.state = SELF_CLOSING_START_TAG_STATE;
                    return;
                }

                if (cp === $$6.GREATER_THAN_SIGN) {
                    this.state = DATA_STATE;
                    this._emitCurrentToken();
                    return;
                }
            }

            this._emitChars('</');
            this._emitSeveralCodePoints(this.tempBuff);
            this._reconsumeInState(RCDATA_STATE);
        }
    }

    // RAWTEXT less-than sign state
    //------------------------------------------------------------------
    [RAWTEXT_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $$6.SOLIDUS) {
            this.tempBuff = [];
            this.state = RAWTEXT_END_TAG_OPEN_STATE;
        } else {
            this._emitChars('<');
            this._reconsumeInState(RAWTEXT_STATE);
        }
    }

    // RAWTEXT end tag open state
    //------------------------------------------------------------------
    [RAWTEXT_END_TAG_OPEN_STATE](cp) {
        if (isAsciiLetter(cp)) {
            this._createEndTagToken();
            this._reconsumeInState(RAWTEXT_END_TAG_NAME_STATE);
        } else {
            this._emitChars('</');
            this._reconsumeInState(RAWTEXT_STATE);
        }
    }

    // RAWTEXT end tag name state
    //------------------------------------------------------------------
    [RAWTEXT_END_TAG_NAME_STATE](cp) {
        if (isAsciiUpper(cp)) {
            this.currentToken.tagName += toAsciiLowerChar(cp);
            this.tempBuff.push(cp);
        } else if (isAsciiLower(cp)) {
            this.currentToken.tagName += toChar(cp);
            this.tempBuff.push(cp);
        } else {
            if (this.lastStartTagName === this.currentToken.tagName) {
                if (isWhitespace(cp)) {
                    this.state = BEFORE_ATTRIBUTE_NAME_STATE;
                    return;
                }

                if (cp === $$6.SOLIDUS) {
                    this.state = SELF_CLOSING_START_TAG_STATE;
                    return;
                }

                if (cp === $$6.GREATER_THAN_SIGN) {
                    this._emitCurrentToken();
                    this.state = DATA_STATE;
                    return;
                }
            }

            this._emitChars('</');
            this._emitSeveralCodePoints(this.tempBuff);
            this._reconsumeInState(RAWTEXT_STATE);
        }
    }

    // Script data less-than sign state
    //------------------------------------------------------------------
    [SCRIPT_DATA_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $$6.SOLIDUS) {
            this.tempBuff = [];
            this.state = SCRIPT_DATA_END_TAG_OPEN_STATE;
        } else if (cp === $$6.EXCLAMATION_MARK) {
            this.state = SCRIPT_DATA_ESCAPE_START_STATE;
            this._emitChars('<!');
        } else {
            this._emitChars('<');
            this._reconsumeInState(SCRIPT_DATA_STATE);
        }
    }

    // Script data end tag open state
    //------------------------------------------------------------------
    [SCRIPT_DATA_END_TAG_OPEN_STATE](cp) {
        if (isAsciiLetter(cp)) {
            this._createEndTagToken();
            this._reconsumeInState(SCRIPT_DATA_END_TAG_NAME_STATE);
        } else {
            this._emitChars('</');
            this._reconsumeInState(SCRIPT_DATA_STATE);
        }
    }

    // Script data end tag name state
    //------------------------------------------------------------------
    [SCRIPT_DATA_END_TAG_NAME_STATE](cp) {
        if (isAsciiUpper(cp)) {
            this.currentToken.tagName += toAsciiLowerChar(cp);
            this.tempBuff.push(cp);
        } else if (isAsciiLower(cp)) {
            this.currentToken.tagName += toChar(cp);
            this.tempBuff.push(cp);
        } else {
            if (this.lastStartTagName === this.currentToken.tagName) {
                if (isWhitespace(cp)) {
                    this.state = BEFORE_ATTRIBUTE_NAME_STATE;
                    return;
                } else if (cp === $$6.SOLIDUS) {
                    this.state = SELF_CLOSING_START_TAG_STATE;
                    return;
                } else if (cp === $$6.GREATER_THAN_SIGN) {
                    this._emitCurrentToken();
                    this.state = DATA_STATE;
                    return;
                }
            }

            this._emitChars('</');
            this._emitSeveralCodePoints(this.tempBuff);
            this._reconsumeInState(SCRIPT_DATA_STATE);
        }
    }

    // Script data escape start state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPE_START_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = SCRIPT_DATA_ESCAPE_START_DASH_STATE;
            this._emitChars('-');
        } else {
            this._reconsumeInState(SCRIPT_DATA_STATE);
        }
    }

    // Script data escape start dash state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPE_START_DASH_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
            this._emitChars('-');
        } else {
            this._reconsumeInState(SCRIPT_DATA_STATE);
        }
    }

    // Script data escaped state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = SCRIPT_DATA_ESCAPED_DASH_STATE;
            this._emitChars('-');
        } else if (cp === $$6.LESS_THAN_SIGN) {
            this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInScriptHtmlCommentLikeText);
            this._emitEOFToken();
        } else {
            this._emitCodePoint(cp);
        }
    }

    // Script data escaped dash state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_DASH_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
            this._emitChars('-');
        } else if (cp === $$6.LESS_THAN_SIGN) {
            this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.state = SCRIPT_DATA_ESCAPED_STATE;
            this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInScriptHtmlCommentLikeText);
            this._emitEOFToken();
        } else {
            this.state = SCRIPT_DATA_ESCAPED_STATE;
            this._emitCodePoint(cp);
        }
    }

    // Script data escaped dash dash state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_DASH_DASH_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this._emitChars('-');
        } else if (cp === $$6.LESS_THAN_SIGN) {
            this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this.state = SCRIPT_DATA_STATE;
            this._emitChars('>');
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.state = SCRIPT_DATA_ESCAPED_STATE;
            this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInScriptHtmlCommentLikeText);
            this._emitEOFToken();
        } else {
            this.state = SCRIPT_DATA_ESCAPED_STATE;
            this._emitCodePoint(cp);
        }
    }

    // Script data escaped less-than sign state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $$6.SOLIDUS) {
            this.tempBuff = [];
            this.state = SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE;
        } else if (isAsciiLetter(cp)) {
            this.tempBuff = [];
            this._emitChars('<');
            this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE);
        } else {
            this._emitChars('<');
            this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
        }
    }

    // Script data escaped end tag open state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE](cp) {
        if (isAsciiLetter(cp)) {
            this._createEndTagToken();
            this._reconsumeInState(SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE);
        } else {
            this._emitChars('</');
            this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
        }
    }

    // Script data escaped end tag name state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE](cp) {
        if (isAsciiUpper(cp)) {
            this.currentToken.tagName += toAsciiLowerChar(cp);
            this.tempBuff.push(cp);
        } else if (isAsciiLower(cp)) {
            this.currentToken.tagName += toChar(cp);
            this.tempBuff.push(cp);
        } else {
            if (this.lastStartTagName === this.currentToken.tagName) {
                if (isWhitespace(cp)) {
                    this.state = BEFORE_ATTRIBUTE_NAME_STATE;
                    return;
                }

                if (cp === $$6.SOLIDUS) {
                    this.state = SELF_CLOSING_START_TAG_STATE;
                    return;
                }

                if (cp === $$6.GREATER_THAN_SIGN) {
                    this._emitCurrentToken();
                    this.state = DATA_STATE;
                    return;
                }
            }

            this._emitChars('</');
            this._emitSeveralCodePoints(this.tempBuff);
            this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
        }
    }

    // Script data double escape start state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE](cp) {
        if (isWhitespace(cp) || cp === $$6.SOLIDUS || cp === $$6.GREATER_THAN_SIGN) {
            this.state = this._isTempBufferEqualToScriptString()
                ? SCRIPT_DATA_DOUBLE_ESCAPED_STATE
                : SCRIPT_DATA_ESCAPED_STATE;
            this._emitCodePoint(cp);
        } else if (isAsciiUpper(cp)) {
            this.tempBuff.push(toAsciiLowerCodePoint(cp));
            this._emitCodePoint(cp);
        } else if (isAsciiLower(cp)) {
            this.tempBuff.push(cp);
            this._emitCodePoint(cp);
        } else {
            this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
        }
    }

    // Script data double escaped state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPED_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;
            this._emitChars('-');
        } else if (cp === $$6.LESS_THAN_SIGN) {
            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
            this._emitChars('<');
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInScriptHtmlCommentLikeText);
            this._emitEOFToken();
        } else {
            this._emitCodePoint(cp);
        }
    }

    // Script data double escaped dash state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE;
            this._emitChars('-');
        } else if (cp === $$6.LESS_THAN_SIGN) {
            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
            this._emitChars('<');
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
            this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInScriptHtmlCommentLikeText);
            this._emitEOFToken();
        } else {
            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
            this._emitCodePoint(cp);
        }
    }

    // Script data double escaped dash dash state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this._emitChars('-');
        } else if (cp === $$6.LESS_THAN_SIGN) {
            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
            this._emitChars('<');
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this.state = SCRIPT_DATA_STATE;
            this._emitChars('>');
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
            this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInScriptHtmlCommentLikeText);
            this._emitEOFToken();
        } else {
            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
            this._emitCodePoint(cp);
        }
    }

    // Script data double escaped less-than sign state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $$6.SOLIDUS) {
            this.tempBuff = [];
            this.state = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
            this._emitChars('/');
        } else {
            this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
        }
    }

    // Script data double escape end state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE](cp) {
        if (isWhitespace(cp) || cp === $$6.SOLIDUS || cp === $$6.GREATER_THAN_SIGN) {
            this.state = this._isTempBufferEqualToScriptString()
                ? SCRIPT_DATA_ESCAPED_STATE
                : SCRIPT_DATA_DOUBLE_ESCAPED_STATE;

            this._emitCodePoint(cp);
        } else if (isAsciiUpper(cp)) {
            this.tempBuff.push(toAsciiLowerCodePoint(cp));
            this._emitCodePoint(cp);
        } else if (isAsciiLower(cp)) {
            this.tempBuff.push(cp);
            this._emitCodePoint(cp);
        } else {
            this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
        }
    }

    // Before attribute name state
    //------------------------------------------------------------------
    [BEFORE_ATTRIBUTE_NAME_STATE](cp) {
        if (isWhitespace(cp)) {
            return;
        }

        if (cp === $$6.SOLIDUS || cp === $$6.GREATER_THAN_SIGN || cp === $$6.EOF) {
            this._reconsumeInState(AFTER_ATTRIBUTE_NAME_STATE);
        } else if (cp === $$6.EQUALS_SIGN) {
            this._err(ERR$1.unexpectedEqualsSignBeforeAttributeName);
            this._createAttr('=');
            this.state = ATTRIBUTE_NAME_STATE;
        } else {
            this._createAttr('');
            this._reconsumeInState(ATTRIBUTE_NAME_STATE);
        }
    }

    // Attribute name state
    //------------------------------------------------------------------
    [ATTRIBUTE_NAME_STATE](cp) {
        if (isWhitespace(cp) || cp === $$6.SOLIDUS || cp === $$6.GREATER_THAN_SIGN || cp === $$6.EOF) {
            this._leaveAttrName(AFTER_ATTRIBUTE_NAME_STATE);
            this._unconsume();
        } else if (cp === $$6.EQUALS_SIGN) {
            this._leaveAttrName(BEFORE_ATTRIBUTE_VALUE_STATE);
        } else if (isAsciiUpper(cp)) {
            this.currentAttr.name += toAsciiLowerChar(cp);
        } else if (cp === $$6.QUOTATION_MARK || cp === $$6.APOSTROPHE || cp === $$6.LESS_THAN_SIGN) {
            this._err(ERR$1.unexpectedCharacterInAttributeName);
            this.currentAttr.name += toChar(cp);
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentAttr.name += unicode$1.REPLACEMENT_CHARACTER;
        } else {
            this.currentAttr.name += toChar(cp);
        }
    }

    // After attribute name state
    //------------------------------------------------------------------
    [AFTER_ATTRIBUTE_NAME_STATE](cp) {
        if (isWhitespace(cp)) {
            return;
        }

        if (cp === $$6.SOLIDUS) {
            this.state = SELF_CLOSING_START_TAG_STATE;
        } else if (cp === $$6.EQUALS_SIGN) {
            this.state = BEFORE_ATTRIBUTE_VALUE_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInTag);
            this._emitEOFToken();
        } else {
            this._createAttr('');
            this._reconsumeInState(ATTRIBUTE_NAME_STATE);
        }
    }

    // Before attribute value state
    //------------------------------------------------------------------
    [BEFORE_ATTRIBUTE_VALUE_STATE](cp) {
        if (isWhitespace(cp)) {
            return;
        }

        if (cp === $$6.QUOTATION_MARK) {
            this.state = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
        } else if (cp === $$6.APOSTROPHE) {
            this.state = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.missingAttributeValue);
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else {
            this._reconsumeInState(ATTRIBUTE_VALUE_UNQUOTED_STATE);
        }
    }

    // Attribute value (double-quoted) state
    //------------------------------------------------------------------
    [ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE](cp) {
        if (cp === $$6.QUOTATION_MARK) {
            this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
        } else if (cp === $$6.AMPERSAND) {
            this.returnState = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
            this.state = CHARACTER_REFERENCE_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentAttr.value += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInTag);
            this._emitEOFToken();
        } else {
            this.currentAttr.value += toChar(cp);
        }
    }

    // Attribute value (single-quoted) state
    //------------------------------------------------------------------
    [ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE](cp) {
        if (cp === $$6.APOSTROPHE) {
            this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
        } else if (cp === $$6.AMPERSAND) {
            this.returnState = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
            this.state = CHARACTER_REFERENCE_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentAttr.value += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInTag);
            this._emitEOFToken();
        } else {
            this.currentAttr.value += toChar(cp);
        }
    }

    // Attribute value (unquoted) state
    //------------------------------------------------------------------
    [ATTRIBUTE_VALUE_UNQUOTED_STATE](cp) {
        if (isWhitespace(cp)) {
            this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
        } else if (cp === $$6.AMPERSAND) {
            this.returnState = ATTRIBUTE_VALUE_UNQUOTED_STATE;
            this.state = CHARACTER_REFERENCE_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._leaveAttrValue(DATA_STATE);
            this._emitCurrentToken();
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentAttr.value += unicode$1.REPLACEMENT_CHARACTER;
        } else if (
            cp === $$6.QUOTATION_MARK ||
            cp === $$6.APOSTROPHE ||
            cp === $$6.LESS_THAN_SIGN ||
            cp === $$6.EQUALS_SIGN ||
            cp === $$6.GRAVE_ACCENT
        ) {
            this._err(ERR$1.unexpectedCharacterInUnquotedAttributeValue);
            this.currentAttr.value += toChar(cp);
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInTag);
            this._emitEOFToken();
        } else {
            this.currentAttr.value += toChar(cp);
        }
    }

    // After attribute value (quoted) state
    //------------------------------------------------------------------
    [AFTER_ATTRIBUTE_VALUE_QUOTED_STATE](cp) {
        if (isWhitespace(cp)) {
            this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
        } else if (cp === $$6.SOLIDUS) {
            this._leaveAttrValue(SELF_CLOSING_START_TAG_STATE);
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._leaveAttrValue(DATA_STATE);
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInTag);
            this._emitEOFToken();
        } else {
            this._err(ERR$1.missingWhitespaceBetweenAttributes);
            this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
        }
    }

    // Self-closing start tag state
    //------------------------------------------------------------------
    [SELF_CLOSING_START_TAG_STATE](cp) {
        if (cp === $$6.GREATER_THAN_SIGN) {
            this.currentToken.selfClosing = true;
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInTag);
            this._emitEOFToken();
        } else {
            this._err(ERR$1.unexpectedSolidusInTag);
            this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
        }
    }

    // Bogus comment state
    //------------------------------------------------------------------
    [BOGUS_COMMENT_STATE](cp) {
        if (cp === $$6.GREATER_THAN_SIGN) {
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._emitCurrentToken();
            this._emitEOFToken();
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentToken.data += unicode$1.REPLACEMENT_CHARACTER;
        } else {
            this.currentToken.data += toChar(cp);
        }
    }

    // Markup declaration open state
    //------------------------------------------------------------------
    [MARKUP_DECLARATION_OPEN_STATE](cp) {
        if (this._consumeSequenceIfMatch($$.DASH_DASH_STRING, cp, true)) {
            this._createCommentToken();
            this.state = COMMENT_START_STATE;
        } else if (this._consumeSequenceIfMatch($$.DOCTYPE_STRING, cp, false)) {
            this.state = DOCTYPE_STATE;
        } else if (this._consumeSequenceIfMatch($$.CDATA_START_STRING, cp, true)) {
            if (this.allowCDATA) {
                this.state = CDATA_SECTION_STATE;
            } else {
                this._err(ERR$1.cdataInHtmlContent);
                this._createCommentToken();
                this.currentToken.data = '[CDATA[';
                this.state = BOGUS_COMMENT_STATE;
            }
        }

        //NOTE: sequence lookup can be abrupted by hibernation. In that case lookup
        //results are no longer valid and we will need to start over.
        else if (!this._ensureHibernation()) {
            this._err(ERR$1.incorrectlyOpenedComment);
            this._createCommentToken();
            this._reconsumeInState(BOGUS_COMMENT_STATE);
        }
    }

    // Comment start state
    //------------------------------------------------------------------
    [COMMENT_START_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = COMMENT_START_DASH_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.abruptClosingOfEmptyComment);
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else {
            this._reconsumeInState(COMMENT_STATE);
        }
    }

    // Comment start dash state
    //------------------------------------------------------------------
    [COMMENT_START_DASH_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = COMMENT_END_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.abruptClosingOfEmptyComment);
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInComment);
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this.currentToken.data += '-';
            this._reconsumeInState(COMMENT_STATE);
        }
    }

    // Comment state
    //------------------------------------------------------------------
    [COMMENT_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = COMMENT_END_DASH_STATE;
        } else if (cp === $$6.LESS_THAN_SIGN) {
            this.currentToken.data += '<';
            this.state = COMMENT_LESS_THAN_SIGN_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentToken.data += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInComment);
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this.currentToken.data += toChar(cp);
        }
    }

    // Comment less-than sign state
    //------------------------------------------------------------------
    [COMMENT_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $$6.EXCLAMATION_MARK) {
            this.currentToken.data += '!';
            this.state = COMMENT_LESS_THAN_SIGN_BANG_STATE;
        } else if (cp === $$6.LESS_THAN_SIGN) {
            this.currentToken.data += '!';
        } else {
            this._reconsumeInState(COMMENT_STATE);
        }
    }

    // Comment less-than sign bang state
    //------------------------------------------------------------------
    [COMMENT_LESS_THAN_SIGN_BANG_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE;
        } else {
            this._reconsumeInState(COMMENT_STATE);
        }
    }

    // Comment less-than sign bang dash state
    //------------------------------------------------------------------
    [COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE;
        } else {
            this._reconsumeInState(COMMENT_END_DASH_STATE);
        }
    }

    // Comment less-than sign bang dash dash state
    //------------------------------------------------------------------
    [COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE](cp) {
        if (cp !== $$6.GREATER_THAN_SIGN && cp !== $$6.EOF) {
            this._err(ERR$1.nestedComment);
        }

        this._reconsumeInState(COMMENT_END_STATE);
    }

    // Comment end dash state
    //------------------------------------------------------------------
    [COMMENT_END_DASH_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = COMMENT_END_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInComment);
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this.currentToken.data += '-';
            this._reconsumeInState(COMMENT_STATE);
        }
    }

    // Comment end state
    //------------------------------------------------------------------
    [COMMENT_END_STATE](cp) {
        if (cp === $$6.GREATER_THAN_SIGN) {
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EXCLAMATION_MARK) {
            this.state = COMMENT_END_BANG_STATE;
        } else if (cp === $$6.HYPHEN_MINUS) {
            this.currentToken.data += '-';
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInComment);
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this.currentToken.data += '--';
            this._reconsumeInState(COMMENT_STATE);
        }
    }

    // Comment end bang state
    //------------------------------------------------------------------
    [COMMENT_END_BANG_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.currentToken.data += '--!';
            this.state = COMMENT_END_DASH_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.incorrectlyClosedComment);
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInComment);
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this.currentToken.data += '--!';
            this._reconsumeInState(COMMENT_STATE);
        }
    }

    // DOCTYPE state
    //------------------------------------------------------------------
    [DOCTYPE_STATE](cp) {
        if (isWhitespace(cp)) {
            this.state = BEFORE_DOCTYPE_NAME_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this._createDoctypeToken(null);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this._err(ERR$1.missingWhitespaceBeforeDoctypeName);
            this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
        }
    }

    // Before DOCTYPE name state
    //------------------------------------------------------------------
    [BEFORE_DOCTYPE_NAME_STATE](cp) {
        if (isWhitespace(cp)) {
            return;
        }

        if (isAsciiUpper(cp)) {
            this._createDoctypeToken(toAsciiLowerChar(cp));
            this.state = DOCTYPE_NAME_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this._createDoctypeToken(unicode$1.REPLACEMENT_CHARACTER);
            this.state = DOCTYPE_NAME_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.missingDoctypeName);
            this._createDoctypeToken(null);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this.state = DATA_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this._createDoctypeToken(null);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this._createDoctypeToken(toChar(cp));
            this.state = DOCTYPE_NAME_STATE;
        }
    }

    // DOCTYPE name state
    //------------------------------------------------------------------
    [DOCTYPE_NAME_STATE](cp) {
        if (isWhitespace(cp)) {
            this.state = AFTER_DOCTYPE_NAME_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (isAsciiUpper(cp)) {
            this.currentToken.name += toAsciiLowerChar(cp);
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentToken.name += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this.currentToken.name += toChar(cp);
        }
    }

    // After DOCTYPE name state
    //------------------------------------------------------------------
    [AFTER_DOCTYPE_NAME_STATE](cp) {
        if (isWhitespace(cp)) {
            return;
        }

        if (cp === $$6.GREATER_THAN_SIGN) {
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else if (this._consumeSequenceIfMatch($$.PUBLIC_STRING, cp, false)) {
            this.state = AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE;
        } else if (this._consumeSequenceIfMatch($$.SYSTEM_STRING, cp, false)) {
            this.state = AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE;
        }
        //NOTE: sequence lookup can be abrupted by hibernation. In that case lookup
        //results are no longer valid and we will need to start over.
        else if (!this._ensureHibernation()) {
            this._err(ERR$1.invalidCharacterSequenceAfterDoctypeName);
            this.currentToken.forceQuirks = true;
            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
    }

    // After DOCTYPE public keyword state
    //------------------------------------------------------------------
    [AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE](cp) {
        if (isWhitespace(cp)) {
            this.state = BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
        } else if (cp === $$6.QUOTATION_MARK) {
            this._err(ERR$1.missingWhitespaceAfterDoctypePublicKeyword);
            this.currentToken.publicId = '';
            this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $$6.APOSTROPHE) {
            this._err(ERR$1.missingWhitespaceAfterDoctypePublicKeyword);
            this.currentToken.publicId = '';
            this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.missingDoctypePublicIdentifier);
            this.currentToken.forceQuirks = true;
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this._err(ERR$1.missingQuoteBeforeDoctypePublicIdentifier);
            this.currentToken.forceQuirks = true;
            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
    }

    // Before DOCTYPE public identifier state
    //------------------------------------------------------------------
    [BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
        if (isWhitespace(cp)) {
            return;
        }

        if (cp === $$6.QUOTATION_MARK) {
            this.currentToken.publicId = '';
            this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $$6.APOSTROPHE) {
            this.currentToken.publicId = '';
            this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.missingDoctypePublicIdentifier);
            this.currentToken.forceQuirks = true;
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this._err(ERR$1.missingQuoteBeforeDoctypePublicIdentifier);
            this.currentToken.forceQuirks = true;
            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
    }

    // DOCTYPE public identifier (double-quoted) state
    //------------------------------------------------------------------
    [DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
        if (cp === $$6.QUOTATION_MARK) {
            this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentToken.publicId += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.abruptDoctypePublicIdentifier);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this.state = DATA_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this.currentToken.publicId += toChar(cp);
        }
    }

    // DOCTYPE public identifier (single-quoted) state
    //------------------------------------------------------------------
    [DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
        if (cp === $$6.APOSTROPHE) {
            this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentToken.publicId += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.abruptDoctypePublicIdentifier);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this.state = DATA_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this.currentToken.publicId += toChar(cp);
        }
    }

    // After DOCTYPE public identifier state
    //------------------------------------------------------------------
    [AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
        if (isWhitespace(cp)) {
            this.state = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.QUOTATION_MARK) {
            this._err(ERR$1.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
            this.currentToken.systemId = '';
            this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $$6.APOSTROPHE) {
            this._err(ERR$1.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
            this.currentToken.systemId = '';
            this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
            this.currentToken.forceQuirks = true;
            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
    }

    // Between DOCTYPE public and system identifiers state
    //------------------------------------------------------------------
    [BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE](cp) {
        if (isWhitespace(cp)) {
            return;
        }

        if (cp === $$6.GREATER_THAN_SIGN) {
            this._emitCurrentToken();
            this.state = DATA_STATE;
        } else if (cp === $$6.QUOTATION_MARK) {
            this.currentToken.systemId = '';
            this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $$6.APOSTROPHE) {
            this.currentToken.systemId = '';
            this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
            this.currentToken.forceQuirks = true;
            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
    }

    // After DOCTYPE system keyword state
    //------------------------------------------------------------------
    [AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE](cp) {
        if (isWhitespace(cp)) {
            this.state = BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
        } else if (cp === $$6.QUOTATION_MARK) {
            this._err(ERR$1.missingWhitespaceAfterDoctypeSystemKeyword);
            this.currentToken.systemId = '';
            this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $$6.APOSTROPHE) {
            this._err(ERR$1.missingWhitespaceAfterDoctypeSystemKeyword);
            this.currentToken.systemId = '';
            this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.missingDoctypeSystemIdentifier);
            this.currentToken.forceQuirks = true;
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
            this.currentToken.forceQuirks = true;
            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
    }

    // Before DOCTYPE system identifier state
    //------------------------------------------------------------------
    [BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
        if (isWhitespace(cp)) {
            return;
        }

        if (cp === $$6.QUOTATION_MARK) {
            this.currentToken.systemId = '';
            this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $$6.APOSTROPHE) {
            this.currentToken.systemId = '';
            this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.missingDoctypeSystemIdentifier);
            this.currentToken.forceQuirks = true;
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
            this.currentToken.forceQuirks = true;
            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
    }

    // DOCTYPE system identifier (double-quoted) state
    //------------------------------------------------------------------
    [DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
        if (cp === $$6.QUOTATION_MARK) {
            this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentToken.systemId += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.abruptDoctypeSystemIdentifier);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this.state = DATA_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this.currentToken.systemId += toChar(cp);
        }
    }

    // DOCTYPE system identifier (single-quoted) state
    //------------------------------------------------------------------
    [DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
        if (cp === $$6.APOSTROPHE) {
            this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentToken.systemId += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.abruptDoctypeSystemIdentifier);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this.state = DATA_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this.currentToken.systemId += toChar(cp);
        }
    }

    // After DOCTYPE system identifier state
    //------------------------------------------------------------------
    [AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
        if (isWhitespace(cp)) {
            return;
        }

        if (cp === $$6.GREATER_THAN_SIGN) {
            this._emitCurrentToken();
            this.state = DATA_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this._err(ERR$1.unexpectedCharacterAfterDoctypeSystemIdentifier);
            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
    }

    // Bogus DOCTYPE state
    //------------------------------------------------------------------
    [BOGUS_DOCTYPE_STATE](cp) {
        if (cp === $$6.GREATER_THAN_SIGN) {
            this._emitCurrentToken();
            this.state = DATA_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
        } else if (cp === $$6.EOF) {
            this._emitCurrentToken();
            this._emitEOFToken();
        }
    }

    // CDATA section state
    //------------------------------------------------------------------
    [CDATA_SECTION_STATE](cp) {
        if (cp === $$6.RIGHT_SQUARE_BRACKET) {
            this.state = CDATA_SECTION_BRACKET_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInCdata);
            this._emitEOFToken();
        } else {
            this._emitCodePoint(cp);
        }
    }

    // CDATA section bracket state
    //------------------------------------------------------------------
    [CDATA_SECTION_BRACKET_STATE](cp) {
        if (cp === $$6.RIGHT_SQUARE_BRACKET) {
            this.state = CDATA_SECTION_END_STATE;
        } else {
            this._emitChars(']');
            this._reconsumeInState(CDATA_SECTION_STATE);
        }
    }

    // CDATA section end state
    //------------------------------------------------------------------
    [CDATA_SECTION_END_STATE](cp) {
        if (cp === $$6.GREATER_THAN_SIGN) {
            this.state = DATA_STATE;
        } else if (cp === $$6.RIGHT_SQUARE_BRACKET) {
            this._emitChars(']');
        } else {
            this._emitChars(']]');
            this._reconsumeInState(CDATA_SECTION_STATE);
        }
    }

    // Character reference state
    //------------------------------------------------------------------
    [CHARACTER_REFERENCE_STATE](cp) {
        this.tempBuff = [$$6.AMPERSAND];

        if (cp === $$6.NUMBER_SIGN) {
            this.tempBuff.push(cp);
            this.state = NUMERIC_CHARACTER_REFERENCE_STATE;
        } else if (isAsciiAlphaNumeric(cp)) {
            this._reconsumeInState(NAMED_CHARACTER_REFERENCE_STATE);
        } else {
            this._flushCodePointsConsumedAsCharacterReference();
            this._reconsumeInState(this.returnState);
        }
    }

    // Named character reference state
    //------------------------------------------------------------------
    [NAMED_CHARACTER_REFERENCE_STATE](cp) {
        const matchResult = this._matchNamedCharacterReference(cp);

        //NOTE: matching can be abrupted by hibernation. In that case match
        //results are no longer valid and we will need to start over.
        if (this._ensureHibernation()) {
            this.tempBuff = [$$6.AMPERSAND];
        } else if (matchResult) {
            const withSemicolon = this.tempBuff[this.tempBuff.length - 1] === $$6.SEMICOLON;

            if (!this._isCharacterReferenceAttributeQuirk(withSemicolon)) {
                if (!withSemicolon) {
                    this._errOnNextCodePoint(ERR$1.missingSemicolonAfterCharacterReference);
                }

                this.tempBuff = matchResult;
            }

            this._flushCodePointsConsumedAsCharacterReference();
            this.state = this.returnState;
        } else {
            this._flushCodePointsConsumedAsCharacterReference();
            this.state = AMBIGUOUS_AMPERSAND_STATE;
        }
    }

    // Ambiguos ampersand state
    //------------------------------------------------------------------
    [AMBIGUOUS_AMPERSAND_STATE](cp) {
        if (isAsciiAlphaNumeric(cp)) {
            if (this._isCharacterReferenceInAttribute()) {
                this.currentAttr.value += toChar(cp);
            } else {
                this._emitCodePoint(cp);
            }
        } else {
            if (cp === $$6.SEMICOLON) {
                this._err(ERR$1.unknownNamedCharacterReference);
            }

            this._reconsumeInState(this.returnState);
        }
    }

    // Numeric character reference state
    //------------------------------------------------------------------
    [NUMERIC_CHARACTER_REFERENCE_STATE](cp) {
        this.charRefCode = 0;

        if (cp === $$6.LATIN_SMALL_X || cp === $$6.LATIN_CAPITAL_X) {
            this.tempBuff.push(cp);
            this.state = HEXADEMICAL_CHARACTER_REFERENCE_START_STATE;
        } else {
            this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_START_STATE);
        }
    }

    // Hexademical character reference start state
    //------------------------------------------------------------------
    [HEXADEMICAL_CHARACTER_REFERENCE_START_STATE](cp) {
        if (isAsciiHexDigit(cp)) {
            this._reconsumeInState(HEXADEMICAL_CHARACTER_REFERENCE_STATE);
        } else {
            this._err(ERR$1.absenceOfDigitsInNumericCharacterReference);
            this._flushCodePointsConsumedAsCharacterReference();
            this._reconsumeInState(this.returnState);
        }
    }

    // Decimal character reference start state
    //------------------------------------------------------------------
    [DECIMAL_CHARACTER_REFERENCE_START_STATE](cp) {
        if (isAsciiDigit(cp)) {
            this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_STATE);
        } else {
            this._err(ERR$1.absenceOfDigitsInNumericCharacterReference);
            this._flushCodePointsConsumedAsCharacterReference();
            this._reconsumeInState(this.returnState);
        }
    }

    // Hexademical character reference state
    //------------------------------------------------------------------
    [HEXADEMICAL_CHARACTER_REFERENCE_STATE](cp) {
        if (isAsciiUpperHexDigit(cp)) {
            this.charRefCode = this.charRefCode * 16 + cp - 0x37;
        } else if (isAsciiLowerHexDigit(cp)) {
            this.charRefCode = this.charRefCode * 16 + cp - 0x57;
        } else if (isAsciiDigit(cp)) {
            this.charRefCode = this.charRefCode * 16 + cp - 0x30;
        } else if (cp === $$6.SEMICOLON) {
            this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
        } else {
            this._err(ERR$1.missingSemicolonAfterCharacterReference);
            this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
        }
    }

    // Decimal character reference state
    //------------------------------------------------------------------
    [DECIMAL_CHARACTER_REFERENCE_STATE](cp) {
        if (isAsciiDigit(cp)) {
            this.charRefCode = this.charRefCode * 10 + cp - 0x30;
        } else if (cp === $$6.SEMICOLON) {
            this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
        } else {
            this._err(ERR$1.missingSemicolonAfterCharacterReference);
            this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
        }
    }

    // Numeric character reference end state
    //------------------------------------------------------------------
    [NUMERIC_CHARACTER_REFERENCE_END_STATE]() {
        if (this.charRefCode === $$6.NULL) {
            this._err(ERR$1.nullCharacterReference);
            this.charRefCode = $$6.REPLACEMENT_CHARACTER;
        } else if (this.charRefCode > 0x10ffff) {
            this._err(ERR$1.characterReferenceOutsideUnicodeRange);
            this.charRefCode = $$6.REPLACEMENT_CHARACTER;
        } else if (unicode$1.isSurrogate(this.charRefCode)) {
            this._err(ERR$1.surrogateCharacterReference);
            this.charRefCode = $$6.REPLACEMENT_CHARACTER;
        } else if (unicode$1.isUndefinedCodePoint(this.charRefCode)) {
            this._err(ERR$1.noncharacterCharacterReference);
        } else if (unicode$1.isControlCodePoint(this.charRefCode) || this.charRefCode === $$6.CARRIAGE_RETURN) {
            this._err(ERR$1.controlCharacterReference);

            const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS[this.charRefCode];

            if (replacement) {
                this.charRefCode = replacement;
            }
        }

        this.tempBuff = [this.charRefCode];

        this._flushCodePointsConsumedAsCharacterReference();
        this._reconsumeInState(this.returnState);
    }
}

//Token types
Tokenizer$4.CHARACTER_TOKEN = 'CHARACTER_TOKEN';
Tokenizer$4.NULL_CHARACTER_TOKEN = 'NULL_CHARACTER_TOKEN';
Tokenizer$4.WHITESPACE_CHARACTER_TOKEN = 'WHITESPACE_CHARACTER_TOKEN';
Tokenizer$4.START_TAG_TOKEN = 'START_TAG_TOKEN';
Tokenizer$4.END_TAG_TOKEN = 'END_TAG_TOKEN';
Tokenizer$4.COMMENT_TOKEN = 'COMMENT_TOKEN';
Tokenizer$4.DOCTYPE_TOKEN = 'DOCTYPE_TOKEN';
Tokenizer$4.EOF_TOKEN = 'EOF_TOKEN';
Tokenizer$4.HIBERNATION_TOKEN = 'HIBERNATION_TOKEN';

//Tokenizer initial states for different modes
Tokenizer$4.MODE = {
    DATA: DATA_STATE,
    RCDATA: RCDATA_STATE,
    RAWTEXT: RAWTEXT_STATE,
    SCRIPT_DATA: SCRIPT_DATA_STATE,
    PLAINTEXT: PLAINTEXT_STATE
};

//Static
Tokenizer$4.getTokenAttr = function(token, attrName) {
    for (let i = token.attrs.length - 1; i >= 0; i--) {
        if (token.attrs[i].name === attrName) {
            return token.attrs[i].value;
        }
    }

    return null;
};

var tokenizer = Tokenizer$4;

var html$2 = {};

const NS$4 = (html$2.NAMESPACES = {
    HTML: 'http://www.w3.org/1999/xhtml',
    MATHML: 'http://www.w3.org/1998/Math/MathML',
    SVG: 'http://www.w3.org/2000/svg',
    XLINK: 'http://www.w3.org/1999/xlink',
    XML: 'http://www.w3.org/XML/1998/namespace',
    XMLNS: 'http://www.w3.org/2000/xmlns/'
});

html$2.ATTRS = {
    TYPE: 'type',
    ACTION: 'action',
    ENCODING: 'encoding',
    PROMPT: 'prompt',
    NAME: 'name',
    COLOR: 'color',
    FACE: 'face',
    SIZE: 'size'
};

html$2.DOCUMENT_MODE = {
    NO_QUIRKS: 'no-quirks',
    QUIRKS: 'quirks',
    LIMITED_QUIRKS: 'limited-quirks'
};

const $$5 = (html$2.TAG_NAMES = {
    A: 'a',
    ADDRESS: 'address',
    ANNOTATION_XML: 'annotation-xml',
    APPLET: 'applet',
    AREA: 'area',
    ARTICLE: 'article',
    ASIDE: 'aside',

    B: 'b',
    BASE: 'base',
    BASEFONT: 'basefont',
    BGSOUND: 'bgsound',
    BIG: 'big',
    BLOCKQUOTE: 'blockquote',
    BODY: 'body',
    BR: 'br',
    BUTTON: 'button',

    CAPTION: 'caption',
    CENTER: 'center',
    CODE: 'code',
    COL: 'col',
    COLGROUP: 'colgroup',

    DD: 'dd',
    DESC: 'desc',
    DETAILS: 'details',
    DIALOG: 'dialog',
    DIR: 'dir',
    DIV: 'div',
    DL: 'dl',
    DT: 'dt',

    EM: 'em',
    EMBED: 'embed',

    FIELDSET: 'fieldset',
    FIGCAPTION: 'figcaption',
    FIGURE: 'figure',
    FONT: 'font',
    FOOTER: 'footer',
    FOREIGN_OBJECT: 'foreignObject',
    FORM: 'form',
    FRAME: 'frame',
    FRAMESET: 'frameset',

    H1: 'h1',
    H2: 'h2',
    H3: 'h3',
    H4: 'h4',
    H5: 'h5',
    H6: 'h6',
    HEAD: 'head',
    HEADER: 'header',
    HGROUP: 'hgroup',
    HR: 'hr',
    HTML: 'html',

    I: 'i',
    IMG: 'img',
    IMAGE: 'image',
    INPUT: 'input',
    IFRAME: 'iframe',

    KEYGEN: 'keygen',

    LABEL: 'label',
    LI: 'li',
    LINK: 'link',
    LISTING: 'listing',

    MAIN: 'main',
    MALIGNMARK: 'malignmark',
    MARQUEE: 'marquee',
    MATH: 'math',
    MENU: 'menu',
    META: 'meta',
    MGLYPH: 'mglyph',
    MI: 'mi',
    MO: 'mo',
    MN: 'mn',
    MS: 'ms',
    MTEXT: 'mtext',

    NAV: 'nav',
    NOBR: 'nobr',
    NOFRAMES: 'noframes',
    NOEMBED: 'noembed',
    NOSCRIPT: 'noscript',

    OBJECT: 'object',
    OL: 'ol',
    OPTGROUP: 'optgroup',
    OPTION: 'option',

    P: 'p',
    PARAM: 'param',
    PLAINTEXT: 'plaintext',
    PRE: 'pre',

    RB: 'rb',
    RP: 'rp',
    RT: 'rt',
    RTC: 'rtc',
    RUBY: 'ruby',

    S: 's',
    SCRIPT: 'script',
    SECTION: 'section',
    SELECT: 'select',
    SOURCE: 'source',
    SMALL: 'small',
    SPAN: 'span',
    STRIKE: 'strike',
    STRONG: 'strong',
    STYLE: 'style',
    SUB: 'sub',
    SUMMARY: 'summary',
    SUP: 'sup',

    TABLE: 'table',
    TBODY: 'tbody',
    TEMPLATE: 'template',
    TEXTAREA: 'textarea',
    TFOOT: 'tfoot',
    TD: 'td',
    TH: 'th',
    THEAD: 'thead',
    TITLE: 'title',
    TR: 'tr',
    TRACK: 'track',
    TT: 'tt',

    U: 'u',
    UL: 'ul',

    SVG: 'svg',

    VAR: 'var',

    WBR: 'wbr',

    XMP: 'xmp'
});

html$2.SPECIAL_ELEMENTS = {
    [NS$4.HTML]: {
        [$$5.ADDRESS]: true,
        [$$5.APPLET]: true,
        [$$5.AREA]: true,
        [$$5.ARTICLE]: true,
        [$$5.ASIDE]: true,
        [$$5.BASE]: true,
        [$$5.BASEFONT]: true,
        [$$5.BGSOUND]: true,
        [$$5.BLOCKQUOTE]: true,
        [$$5.BODY]: true,
        [$$5.BR]: true,
        [$$5.BUTTON]: true,
        [$$5.CAPTION]: true,
        [$$5.CENTER]: true,
        [$$5.COL]: true,
        [$$5.COLGROUP]: true,
        [$$5.DD]: true,
        [$$5.DETAILS]: true,
        [$$5.DIR]: true,
        [$$5.DIV]: true,
        [$$5.DL]: true,
        [$$5.DT]: true,
        [$$5.EMBED]: true,
        [$$5.FIELDSET]: true,
        [$$5.FIGCAPTION]: true,
        [$$5.FIGURE]: true,
        [$$5.FOOTER]: true,
        [$$5.FORM]: true,
        [$$5.FRAME]: true,
        [$$5.FRAMESET]: true,
        [$$5.H1]: true,
        [$$5.H2]: true,
        [$$5.H3]: true,
        [$$5.H4]: true,
        [$$5.H5]: true,
        [$$5.H6]: true,
        [$$5.HEAD]: true,
        [$$5.HEADER]: true,
        [$$5.HGROUP]: true,
        [$$5.HR]: true,
        [$$5.HTML]: true,
        [$$5.IFRAME]: true,
        [$$5.IMG]: true,
        [$$5.INPUT]: true,
        [$$5.LI]: true,
        [$$5.LINK]: true,
        [$$5.LISTING]: true,
        [$$5.MAIN]: true,
        [$$5.MARQUEE]: true,
        [$$5.MENU]: true,
        [$$5.META]: true,
        [$$5.NAV]: true,
        [$$5.NOEMBED]: true,
        [$$5.NOFRAMES]: true,
        [$$5.NOSCRIPT]: true,
        [$$5.OBJECT]: true,
        [$$5.OL]: true,
        [$$5.P]: true,
        [$$5.PARAM]: true,
        [$$5.PLAINTEXT]: true,
        [$$5.PRE]: true,
        [$$5.SCRIPT]: true,
        [$$5.SECTION]: true,
        [$$5.SELECT]: true,
        [$$5.SOURCE]: true,
        [$$5.STYLE]: true,
        [$$5.SUMMARY]: true,
        [$$5.TABLE]: true,
        [$$5.TBODY]: true,
        [$$5.TD]: true,
        [$$5.TEMPLATE]: true,
        [$$5.TEXTAREA]: true,
        [$$5.TFOOT]: true,
        [$$5.TH]: true,
        [$$5.THEAD]: true,
        [$$5.TITLE]: true,
        [$$5.TR]: true,
        [$$5.TRACK]: true,
        [$$5.UL]: true,
        [$$5.WBR]: true,
        [$$5.XMP]: true
    },
    [NS$4.MATHML]: {
        [$$5.MI]: true,
        [$$5.MO]: true,
        [$$5.MN]: true,
        [$$5.MS]: true,
        [$$5.MTEXT]: true,
        [$$5.ANNOTATION_XML]: true
    },
    [NS$4.SVG]: {
        [$$5.TITLE]: true,
        [$$5.FOREIGN_OBJECT]: true,
        [$$5.DESC]: true
    }
};

const HTML$4 = html$2;

//Aliases
const $$4 = HTML$4.TAG_NAMES;
const NS$3 = HTML$4.NAMESPACES;

//Element utils

//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
//It's faster than using dictionary.
function isImpliedEndTagRequired(tn) {
    switch (tn.length) {
        case 1:
            return tn === $$4.P;

        case 2:
            return tn === $$4.RB || tn === $$4.RP || tn === $$4.RT || tn === $$4.DD || tn === $$4.DT || tn === $$4.LI;

        case 3:
            return tn === $$4.RTC;

        case 6:
            return tn === $$4.OPTION;

        case 8:
            return tn === $$4.OPTGROUP;
    }

    return false;
}

function isImpliedEndTagRequiredThoroughly(tn) {
    switch (tn.length) {
        case 1:
            return tn === $$4.P;

        case 2:
            return (
                tn === $$4.RB ||
                tn === $$4.RP ||
                tn === $$4.RT ||
                tn === $$4.DD ||
                tn === $$4.DT ||
                tn === $$4.LI ||
                tn === $$4.TD ||
                tn === $$4.TH ||
                tn === $$4.TR
            );

        case 3:
            return tn === $$4.RTC;

        case 5:
            return tn === $$4.TBODY || tn === $$4.TFOOT || tn === $$4.THEAD;

        case 6:
            return tn === $$4.OPTION;

        case 7:
            return tn === $$4.CAPTION;

        case 8:
            return tn === $$4.OPTGROUP || tn === $$4.COLGROUP;
    }

    return false;
}

function isScopingElement(tn, ns) {
    switch (tn.length) {
        case 2:
            if (tn === $$4.TD || tn === $$4.TH) {
                return ns === NS$3.HTML;
            } else if (tn === $$4.MI || tn === $$4.MO || tn === $$4.MN || tn === $$4.MS) {
                return ns === NS$3.MATHML;
            }

            break;

        case 4:
            if (tn === $$4.HTML) {
                return ns === NS$3.HTML;
            } else if (tn === $$4.DESC) {
                return ns === NS$3.SVG;
            }

            break;

        case 5:
            if (tn === $$4.TABLE) {
                return ns === NS$3.HTML;
            } else if (tn === $$4.MTEXT) {
                return ns === NS$3.MATHML;
            } else if (tn === $$4.TITLE) {
                return ns === NS$3.SVG;
            }

            break;

        case 6:
            return (tn === $$4.APPLET || tn === $$4.OBJECT) && ns === NS$3.HTML;

        case 7:
            return (tn === $$4.CAPTION || tn === $$4.MARQUEE) && ns === NS$3.HTML;

        case 8:
            return tn === $$4.TEMPLATE && ns === NS$3.HTML;

        case 13:
            return tn === $$4.FOREIGN_OBJECT && ns === NS$3.SVG;

        case 14:
            return tn === $$4.ANNOTATION_XML && ns === NS$3.MATHML;
    }

    return false;
}

//Stack of open elements
class OpenElementStack$1 {
    constructor(document, treeAdapter) {
        this.stackTop = -1;
        this.items = [];
        this.current = document;
        this.currentTagName = null;
        this.currentTmplContent = null;
        this.tmplCount = 0;
        this.treeAdapter = treeAdapter;
    }

    //Index of element
    _indexOf(element) {
        let idx = -1;

        for (let i = this.stackTop; i >= 0; i--) {
            if (this.items[i] === element) {
                idx = i;
                break;
            }
        }
        return idx;
    }

    //Update current element
    _isInTemplate() {
        return this.currentTagName === $$4.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS$3.HTML;
    }

    _updateCurrentElement() {
        this.current = this.items[this.stackTop];
        this.currentTagName = this.current && this.treeAdapter.getTagName(this.current);

        this.currentTmplContent = this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : null;
    }

    //Mutations
    push(element) {
        this.items[++this.stackTop] = element;
        this._updateCurrentElement();

        if (this._isInTemplate()) {
            this.tmplCount++;
        }
    }

    pop() {
        this.stackTop--;

        if (this.tmplCount > 0 && this._isInTemplate()) {
            this.tmplCount--;
        }

        this._updateCurrentElement();
    }

    replace(oldElement, newElement) {
        const idx = this._indexOf(oldElement);

        this.items[idx] = newElement;

        if (idx === this.stackTop) {
            this._updateCurrentElement();
        }
    }

    insertAfter(referenceElement, newElement) {
        const insertionIdx = this._indexOf(referenceElement) + 1;

        this.items.splice(insertionIdx, 0, newElement);

        if (insertionIdx === ++this.stackTop) {
            this._updateCurrentElement();
        }
    }

    popUntilTagNamePopped(tagName) {
        while (this.stackTop > -1) {
            const tn = this.currentTagName;
            const ns = this.treeAdapter.getNamespaceURI(this.current);

            this.pop();

            if (tn === tagName && ns === NS$3.HTML) {
                break;
            }
        }
    }

    popUntilElementPopped(element) {
        while (this.stackTop > -1) {
            const poppedElement = this.current;

            this.pop();

            if (poppedElement === element) {
                break;
            }
        }
    }

    popUntilNumberedHeaderPopped() {
        while (this.stackTop > -1) {
            const tn = this.currentTagName;
            const ns = this.treeAdapter.getNamespaceURI(this.current);

            this.pop();

            if (
                tn === $$4.H1 ||
                tn === $$4.H2 ||
                tn === $$4.H3 ||
                tn === $$4.H4 ||
                tn === $$4.H5 ||
                (tn === $$4.H6 && ns === NS$3.HTML)
            ) {
                break;
            }
        }
    }

    popUntilTableCellPopped() {
        while (this.stackTop > -1) {
            const tn = this.currentTagName;
            const ns = this.treeAdapter.getNamespaceURI(this.current);

            this.pop();

            if (tn === $$4.TD || (tn === $$4.TH && ns === NS$3.HTML)) {
                break;
            }
        }
    }

    popAllUpToHtmlElement() {
        //NOTE: here we assume that root <html> element is always first in the open element stack, so
        //we perform this fast stack clean up.
        this.stackTop = 0;
        this._updateCurrentElement();
    }

    clearBackToTableContext() {
        while (
            (this.currentTagName !== $$4.TABLE && this.currentTagName !== $$4.TEMPLATE && this.currentTagName !== $$4.HTML) ||
            this.treeAdapter.getNamespaceURI(this.current) !== NS$3.HTML
        ) {
            this.pop();
        }
    }

    clearBackToTableBodyContext() {
        while (
            (this.currentTagName !== $$4.TBODY &&
                this.currentTagName !== $$4.TFOOT &&
                this.currentTagName !== $$4.THEAD &&
                this.currentTagName !== $$4.TEMPLATE &&
                this.currentTagName !== $$4.HTML) ||
            this.treeAdapter.getNamespaceURI(this.current) !== NS$3.HTML
        ) {
            this.pop();
        }
    }

    clearBackToTableRowContext() {
        while (
            (this.currentTagName !== $$4.TR && this.currentTagName !== $$4.TEMPLATE && this.currentTagName !== $$4.HTML) ||
            this.treeAdapter.getNamespaceURI(this.current) !== NS$3.HTML
        ) {
            this.pop();
        }
    }

    remove(element) {
        for (let i = this.stackTop; i >= 0; i--) {
            if (this.items[i] === element) {
                this.items.splice(i, 1);
                this.stackTop--;
                this._updateCurrentElement();
                break;
            }
        }
    }

    //Search
    tryPeekProperlyNestedBodyElement() {
        //Properly nested <body> element (should be second element in stack).
        const element = this.items[1];

        return element && this.treeAdapter.getTagName(element) === $$4.BODY ? element : null;
    }

    contains(element) {
        return this._indexOf(element) > -1;
    }

    getCommonAncestor(element) {
        let elementIdx = this._indexOf(element);

        return --elementIdx >= 0 ? this.items[elementIdx] : null;
    }

    isRootHtmlElementCurrent() {
        return this.stackTop === 0 && this.currentTagName === $$4.HTML;
    }

    //Element in scope
    hasInScope(tagName) {
        for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.treeAdapter.getTagName(this.items[i]);
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

            if (tn === tagName && ns === NS$3.HTML) {
                return true;
            }

            if (isScopingElement(tn, ns)) {
                return false;
            }
        }

        return true;
    }

    hasNumberedHeaderInScope() {
        for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.treeAdapter.getTagName(this.items[i]);
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

            if (
                (tn === $$4.H1 || tn === $$4.H2 || tn === $$4.H3 || tn === $$4.H4 || tn === $$4.H5 || tn === $$4.H6) &&
                ns === NS$3.HTML
            ) {
                return true;
            }

            if (isScopingElement(tn, ns)) {
                return false;
            }
        }

        return true;
    }

    hasInListItemScope(tagName) {
        for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.treeAdapter.getTagName(this.items[i]);
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

            if (tn === tagName && ns === NS$3.HTML) {
                return true;
            }

            if (((tn === $$4.UL || tn === $$4.OL) && ns === NS$3.HTML) || isScopingElement(tn, ns)) {
                return false;
            }
        }

        return true;
    }

    hasInButtonScope(tagName) {
        for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.treeAdapter.getTagName(this.items[i]);
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

            if (tn === tagName && ns === NS$3.HTML) {
                return true;
            }

            if ((tn === $$4.BUTTON && ns === NS$3.HTML) || isScopingElement(tn, ns)) {
                return false;
            }
        }

        return true;
    }

    hasInTableScope(tagName) {
        for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.treeAdapter.getTagName(this.items[i]);
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

            if (ns !== NS$3.HTML) {
                continue;
            }

            if (tn === tagName) {
                return true;
            }

            if (tn === $$4.TABLE || tn === $$4.TEMPLATE || tn === $$4.HTML) {
                return false;
            }
        }

        return true;
    }

    hasTableBodyContextInTableScope() {
        for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.treeAdapter.getTagName(this.items[i]);
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

            if (ns !== NS$3.HTML) {
                continue;
            }

            if (tn === $$4.TBODY || tn === $$4.THEAD || tn === $$4.TFOOT) {
                return true;
            }

            if (tn === $$4.TABLE || tn === $$4.HTML) {
                return false;
            }
        }

        return true;
    }

    hasInSelectScope(tagName) {
        for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.treeAdapter.getTagName(this.items[i]);
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

            if (ns !== NS$3.HTML) {
                continue;
            }

            if (tn === tagName) {
                return true;
            }

            if (tn !== $$4.OPTION && tn !== $$4.OPTGROUP) {
                return false;
            }
        }

        return true;
    }

    //Implied end tags
    generateImpliedEndTags() {
        while (isImpliedEndTagRequired(this.currentTagName)) {
            this.pop();
        }
    }

    generateImpliedEndTagsThoroughly() {
        while (isImpliedEndTagRequiredThoroughly(this.currentTagName)) {
            this.pop();
        }
    }

    generateImpliedEndTagsWithExclusion(exclusionTagName) {
        while (isImpliedEndTagRequired(this.currentTagName) && this.currentTagName !== exclusionTagName) {
            this.pop();
        }
    }
}

var openElementStack = OpenElementStack$1;

//Const
const NOAH_ARK_CAPACITY = 3;

//List of formatting elements
class FormattingElementList$1 {
    constructor(treeAdapter) {
        this.length = 0;
        this.entries = [];
        this.treeAdapter = treeAdapter;
        this.bookmark = null;
    }

    //Noah Ark's condition
    //OPTIMIZATION: at first we try to find possible candidates for exclusion using
    //lightweight heuristics without thorough attributes check.
    _getNoahArkConditionCandidates(newElement) {
        const candidates = [];

        if (this.length >= NOAH_ARK_CAPACITY) {
            const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;
            const neTagName = this.treeAdapter.getTagName(newElement);
            const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);

            for (let i = this.length - 1; i >= 0; i--) {
                const entry = this.entries[i];

                if (entry.type === FormattingElementList$1.MARKER_ENTRY) {
                    break;
                }

                const element = entry.element;
                const elementAttrs = this.treeAdapter.getAttrList(element);

                const isCandidate =
                    this.treeAdapter.getTagName(element) === neTagName &&
                    this.treeAdapter.getNamespaceURI(element) === neNamespaceURI &&
                    elementAttrs.length === neAttrsLength;

                if (isCandidate) {
                    candidates.push({ idx: i, attrs: elementAttrs });
                }
            }
        }

        return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;
    }

    _ensureNoahArkCondition(newElement) {
        const candidates = this._getNoahArkConditionCandidates(newElement);
        let cLength = candidates.length;

        if (cLength) {
            const neAttrs = this.treeAdapter.getAttrList(newElement);
            const neAttrsLength = neAttrs.length;
            const neAttrsMap = Object.create(null);

            //NOTE: build attrs map for the new element so we can perform fast lookups
            for (let i = 0; i < neAttrsLength; i++) {
                const neAttr = neAttrs[i];

                neAttrsMap[neAttr.name] = neAttr.value;
            }

            for (let i = 0; i < neAttrsLength; i++) {
                for (let j = 0; j < cLength; j++) {
                    const cAttr = candidates[j].attrs[i];

                    if (neAttrsMap[cAttr.name] !== cAttr.value) {
                        candidates.splice(j, 1);
                        cLength--;
                    }

                    if (candidates.length < NOAH_ARK_CAPACITY) {
                        return;
                    }
                }
            }

            //NOTE: remove bottommost candidates until Noah's Ark condition will not be met
            for (let i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {
                this.entries.splice(candidates[i].idx, 1);
                this.length--;
            }
        }
    }

    //Mutations
    insertMarker() {
        this.entries.push({ type: FormattingElementList$1.MARKER_ENTRY });
        this.length++;
    }

    pushElement(element, token) {
        this._ensureNoahArkCondition(element);

        this.entries.push({
            type: FormattingElementList$1.ELEMENT_ENTRY,
            element: element,
            token: token
        });

        this.length++;
    }

    insertElementAfterBookmark(element, token) {
        let bookmarkIdx = this.length - 1;

        for (; bookmarkIdx >= 0; bookmarkIdx--) {
            if (this.entries[bookmarkIdx] === this.bookmark) {
                break;
            }
        }

        this.entries.splice(bookmarkIdx + 1, 0, {
            type: FormattingElementList$1.ELEMENT_ENTRY,
            element: element,
            token: token
        });

        this.length++;
    }

    removeEntry(entry) {
        for (let i = this.length - 1; i >= 0; i--) {
            if (this.entries[i] === entry) {
                this.entries.splice(i, 1);
                this.length--;
                break;
            }
        }
    }

    clearToLastMarker() {
        while (this.length) {
            const entry = this.entries.pop();

            this.length--;

            if (entry.type === FormattingElementList$1.MARKER_ENTRY) {
                break;
            }
        }
    }

    //Search
    getElementEntryInScopeWithTagName(tagName) {
        for (let i = this.length - 1; i >= 0; i--) {
            const entry = this.entries[i];

            if (entry.type === FormattingElementList$1.MARKER_ENTRY) {
                return null;
            }

            if (this.treeAdapter.getTagName(entry.element) === tagName) {
                return entry;
            }
        }

        return null;
    }

    getElementEntry(element) {
        for (let i = this.length - 1; i >= 0; i--) {
            const entry = this.entries[i];

            if (entry.type === FormattingElementList$1.ELEMENT_ENTRY && entry.element === element) {
                return entry;
            }
        }

        return null;
    }
}

//Entry types
FormattingElementList$1.MARKER_ENTRY = 'MARKER_ENTRY';
FormattingElementList$1.ELEMENT_ENTRY = 'ELEMENT_ENTRY';

var formattingElementList = FormattingElementList$1;

class Mixin$9 {
    constructor(host) {
        const originalMethods = {};
        const overriddenMethods = this._getOverriddenMethods(this, originalMethods);

        for (const key of Object.keys(overriddenMethods)) {
            if (typeof overriddenMethods[key] === 'function') {
                originalMethods[key] = host[key];
                host[key] = overriddenMethods[key];
            }
        }
    }

    _getOverriddenMethods() {
        throw new Error('Not implemented');
    }
}

Mixin$9.install = function(host, Ctor, opts) {
    if (!host.__mixins) {
        host.__mixins = [];
    }

    for (let i = 0; i < host.__mixins.length; i++) {
        if (host.__mixins[i].constructor === Ctor) {
            return host.__mixins[i];
        }
    }

    const mixin = new Ctor(host, opts);

    host.__mixins.push(mixin);

    return mixin;
};

var mixin = Mixin$9;

const Mixin$8 = mixin;

class PositionTrackingPreprocessorMixin$2 extends Mixin$8 {
    constructor(preprocessor) {
        super(preprocessor);

        this.preprocessor = preprocessor;
        this.isEol = false;
        this.lineStartPos = 0;
        this.droppedBufferSize = 0;

        this.offset = 0;
        this.col = 0;
        this.line = 1;
    }

    _getOverriddenMethods(mxn, orig) {
        return {
            advance() {
                const pos = this.pos + 1;
                const ch = this.html[pos];

                //NOTE: LF should be in the last column of the line
                if (mxn.isEol) {
                    mxn.isEol = false;
                    mxn.line++;
                    mxn.lineStartPos = pos;
                }

                if (ch === '\n' || (ch === '\r' && this.html[pos + 1] !== '\n')) {
                    mxn.isEol = true;
                }

                mxn.col = pos - mxn.lineStartPos + 1;
                mxn.offset = mxn.droppedBufferSize + pos;

                return orig.advance.call(this);
            },

            retreat() {
                orig.retreat.call(this);

                mxn.isEol = false;
                mxn.col = this.pos - mxn.lineStartPos + 1;
            },

            dropParsedChunk() {
                const prevPos = this.pos;

                orig.dropParsedChunk.call(this);

                const reduction = prevPos - this.pos;

                mxn.lineStartPos -= reduction;
                mxn.droppedBufferSize += reduction;
                mxn.offset = mxn.droppedBufferSize + this.pos;
            }
        };
    }
}

var preprocessorMixin$1 = PositionTrackingPreprocessorMixin$2;

const Mixin$7 = mixin;
const Tokenizer$3 = tokenizer;
const PositionTrackingPreprocessorMixin$1 = preprocessorMixin$1;

class LocationInfoTokenizerMixin$2 extends Mixin$7 {
    constructor(tokenizer) {
        super(tokenizer);

        this.tokenizer = tokenizer;
        this.posTracker = Mixin$7.install(tokenizer.preprocessor, PositionTrackingPreprocessorMixin$1);
        this.currentAttrLocation = null;
        this.ctLoc = null;
    }

    _getCurrentLocation() {
        return {
            startLine: this.posTracker.line,
            startCol: this.posTracker.col,
            startOffset: this.posTracker.offset,
            endLine: -1,
            endCol: -1,
            endOffset: -1
        };
    }

    _attachCurrentAttrLocationInfo() {
        this.currentAttrLocation.endLine = this.posTracker.line;
        this.currentAttrLocation.endCol = this.posTracker.col;
        this.currentAttrLocation.endOffset = this.posTracker.offset;

        const currentToken = this.tokenizer.currentToken;
        const currentAttr = this.tokenizer.currentAttr;

        if (!currentToken.location.attrs) {
            currentToken.location.attrs = Object.create(null);
        }

        currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;
    }

    _getOverriddenMethods(mxn, orig) {
        const methods = {
            _createStartTagToken() {
                orig._createStartTagToken.call(this);
                this.currentToken.location = mxn.ctLoc;
            },

            _createEndTagToken() {
                orig._createEndTagToken.call(this);
                this.currentToken.location = mxn.ctLoc;
            },

            _createCommentToken() {
                orig._createCommentToken.call(this);
                this.currentToken.location = mxn.ctLoc;
            },

            _createDoctypeToken(initialName) {
                orig._createDoctypeToken.call(this, initialName);
                this.currentToken.location = mxn.ctLoc;
            },

            _createCharacterToken(type, ch) {
                orig._createCharacterToken.call(this, type, ch);
                this.currentCharacterToken.location = mxn.ctLoc;
            },

            _createEOFToken() {
                orig._createEOFToken.call(this);
                this.currentToken.location = mxn._getCurrentLocation();
            },

            _createAttr(attrNameFirstCh) {
                orig._createAttr.call(this, attrNameFirstCh);
                mxn.currentAttrLocation = mxn._getCurrentLocation();
            },

            _leaveAttrName(toState) {
                orig._leaveAttrName.call(this, toState);
                mxn._attachCurrentAttrLocationInfo();
            },

            _leaveAttrValue(toState) {
                orig._leaveAttrValue.call(this, toState);
                mxn._attachCurrentAttrLocationInfo();
            },

            _emitCurrentToken() {
                const ctLoc = this.currentToken.location;

                //NOTE: if we have pending character token make it's end location equal to the
                //current token's start location.
                if (this.currentCharacterToken) {
                    this.currentCharacterToken.location.endLine = ctLoc.startLine;
                    this.currentCharacterToken.location.endCol = ctLoc.startCol;
                    this.currentCharacterToken.location.endOffset = ctLoc.startOffset;
                }

                if (this.currentToken.type === Tokenizer$3.EOF_TOKEN) {
                    ctLoc.endLine = ctLoc.startLine;
                    ctLoc.endCol = ctLoc.startCol;
                    ctLoc.endOffset = ctLoc.startOffset;
                } else {
                    ctLoc.endLine = mxn.posTracker.line;
                    ctLoc.endCol = mxn.posTracker.col + 1;
                    ctLoc.endOffset = mxn.posTracker.offset + 1;
                }

                orig._emitCurrentToken.call(this);
            },

            _emitCurrentCharacterToken() {
                const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location;

                //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),
                //then set it's location at the current preprocessor position.
                //We don't need to increment preprocessor position, since character token
                //emission is always forced by the start of the next character token here.
                //So, we already have advanced position.
                if (ctLoc && ctLoc.endOffset === -1) {
                    ctLoc.endLine = mxn.posTracker.line;
                    ctLoc.endCol = mxn.posTracker.col;
                    ctLoc.endOffset = mxn.posTracker.offset;
                }

                orig._emitCurrentCharacterToken.call(this);
            }
        };

        //NOTE: patch initial states for each mode to obtain token start position
        Object.keys(Tokenizer$3.MODE).forEach(modeName => {
            const state = Tokenizer$3.MODE[modeName];

            methods[state] = function(cp) {
                mxn.ctLoc = mxn._getCurrentLocation();
                orig[state].call(this, cp);
            };
        });

        return methods;
    }
}

var tokenizerMixin$1 = LocationInfoTokenizerMixin$2;

const Mixin$6 = mixin;

class LocationInfoOpenElementStackMixin$1 extends Mixin$6 {
    constructor(stack, opts) {
        super(stack);

        this.onItemPop = opts.onItemPop;
    }

    _getOverriddenMethods(mxn, orig) {
        return {
            pop() {
                mxn.onItemPop(this.current);
                orig.pop.call(this);
            },

            popAllUpToHtmlElement() {
                for (let i = this.stackTop; i > 0; i--) {
                    mxn.onItemPop(this.items[i]);
                }

                orig.popAllUpToHtmlElement.call(this);
            },

            remove(element) {
                mxn.onItemPop(this.current);
                orig.remove.call(this, element);
            }
        };
    }
}

var openElementStackMixin = LocationInfoOpenElementStackMixin$1;

const Mixin$5 = mixin;
const Tokenizer$2 = tokenizer;
const LocationInfoTokenizerMixin$1 = tokenizerMixin$1;
const LocationInfoOpenElementStackMixin = openElementStackMixin;
const HTML$3 = html$2;

//Aliases
const $$3 = HTML$3.TAG_NAMES;

class LocationInfoParserMixin$1 extends Mixin$5 {
    constructor(parser) {
        super(parser);

        this.parser = parser;
        this.treeAdapter = this.parser.treeAdapter;
        this.posTracker = null;
        this.lastStartTagToken = null;
        this.lastFosterParentingLocation = null;
        this.currentToken = null;
    }

    _setStartLocation(element) {
        let loc = null;

        if (this.lastStartTagToken) {
            loc = Object.assign({}, this.lastStartTagToken.location);
            loc.startTag = this.lastStartTagToken.location;
        }

        this.treeAdapter.setNodeSourceCodeLocation(element, loc);
    }

    _setEndLocation(element, closingToken) {
        const loc = this.treeAdapter.getNodeSourceCodeLocation(element);

        if (loc) {
            if (closingToken.location) {
                const ctLoc = closingToken.location;
                const tn = this.treeAdapter.getTagName(element);

                // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
                // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
                const isClosingEndTag = closingToken.type === Tokenizer$2.END_TAG_TOKEN && tn === closingToken.tagName;
                const endLoc = {};
                if (isClosingEndTag) {
                    endLoc.endTag = Object.assign({}, ctLoc);
                    endLoc.endLine = ctLoc.endLine;
                    endLoc.endCol = ctLoc.endCol;
                    endLoc.endOffset = ctLoc.endOffset;
                } else {
                    endLoc.endLine = ctLoc.startLine;
                    endLoc.endCol = ctLoc.startCol;
                    endLoc.endOffset = ctLoc.startOffset;
                }

                this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);
            }
        }
    }

    _getOverriddenMethods(mxn, orig) {
        return {
            _bootstrap(document, fragmentContext) {
                orig._bootstrap.call(this, document, fragmentContext);

                mxn.lastStartTagToken = null;
                mxn.lastFosterParentingLocation = null;
                mxn.currentToken = null;

                const tokenizerMixin = Mixin$5.install(this.tokenizer, LocationInfoTokenizerMixin$1);

                mxn.posTracker = tokenizerMixin.posTracker;

                Mixin$5.install(this.openElements, LocationInfoOpenElementStackMixin, {
                    onItemPop: function(element) {
                        mxn._setEndLocation(element, mxn.currentToken);
                    }
                });
            },

            _runParsingLoop(scriptHandler) {
                orig._runParsingLoop.call(this, scriptHandler);

                // NOTE: generate location info for elements
                // that remains on open element stack
                for (let i = this.openElements.stackTop; i >= 0; i--) {
                    mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);
                }
            },

            //Token processing
            _processTokenInForeignContent(token) {
                mxn.currentToken = token;
                orig._processTokenInForeignContent.call(this, token);
            },

            _processToken(token) {
                mxn.currentToken = token;
                orig._processToken.call(this, token);

                //NOTE: <body> and <html> are never popped from the stack, so we need to updated
                //their end location explicitly.
                const requireExplicitUpdate =
                    token.type === Tokenizer$2.END_TAG_TOKEN &&
                    (token.tagName === $$3.HTML || (token.tagName === $$3.BODY && this.openElements.hasInScope($$3.BODY)));

                if (requireExplicitUpdate) {
                    for (let i = this.openElements.stackTop; i >= 0; i--) {
                        const element = this.openElements.items[i];

                        if (this.treeAdapter.getTagName(element) === token.tagName) {
                            mxn._setEndLocation(element, token);
                            break;
                        }
                    }
                }
            },

            //Doctype
            _setDocumentType(token) {
                orig._setDocumentType.call(this, token);

                const documentChildren = this.treeAdapter.getChildNodes(this.document);
                const cnLength = documentChildren.length;

                for (let i = 0; i < cnLength; i++) {
                    const node = documentChildren[i];

                    if (this.treeAdapter.isDocumentTypeNode(node)) {
                        this.treeAdapter.setNodeSourceCodeLocation(node, token.location);
                        break;
                    }
                }
            },

            //Elements
            _attachElementToTree(element) {
                //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.
                //So we will use token location stored in this methods for the element.
                mxn._setStartLocation(element);
                mxn.lastStartTagToken = null;
                orig._attachElementToTree.call(this, element);
            },

            _appendElement(token, namespaceURI) {
                mxn.lastStartTagToken = token;
                orig._appendElement.call(this, token, namespaceURI);
            },

            _insertElement(token, namespaceURI) {
                mxn.lastStartTagToken = token;
                orig._insertElement.call(this, token, namespaceURI);
            },

            _insertTemplate(token) {
                mxn.lastStartTagToken = token;
                orig._insertTemplate.call(this, token);

                const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);

                this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);
            },

            _insertFakeRootElement() {
                orig._insertFakeRootElement.call(this);
                this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);
            },

            //Comments
            _appendCommentNode(token, parent) {
                orig._appendCommentNode.call(this, token, parent);

                const children = this.treeAdapter.getChildNodes(parent);
                const commentNode = children[children.length - 1];

                this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
            },

            //Text
            _findFosterParentingLocation() {
                //NOTE: store last foster parenting location, so we will be able to find inserted text
                //in case of foster parenting
                mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);

                return mxn.lastFosterParentingLocation;
            },

            _insertCharacters(token) {
                orig._insertCharacters.call(this, token);

                const hasFosterParent = this._shouldFosterParentOnInsertion();

                const parent =
                    (hasFosterParent && mxn.lastFosterParentingLocation.parent) ||
                    this.openElements.currentTmplContent ||
                    this.openElements.current;

                const siblings = this.treeAdapter.getChildNodes(parent);

                const textNodeIdx =
                    hasFosterParent && mxn.lastFosterParentingLocation.beforeElement
                        ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1
                        : siblings.length - 1;

                const textNode = siblings[textNodeIdx];

                //NOTE: if we have location assigned by another token, then just update end position
                const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);

                if (tnLoc) {
                    const { endLine, endCol, endOffset } = token.location;
                    this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
                } else {
                    this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
                }
            }
        };
    }
}

var parserMixin$1 = LocationInfoParserMixin$1;

const Mixin$4 = mixin;

class ErrorReportingMixinBase$3 extends Mixin$4 {
    constructor(host, opts) {
        super(host);

        this.posTracker = null;
        this.onParseError = opts.onParseError;
    }

    _setErrorLocation(err) {
        err.startLine = err.endLine = this.posTracker.line;
        err.startCol = err.endCol = this.posTracker.col;
        err.startOffset = err.endOffset = this.posTracker.offset;
    }

    _reportError(code) {
        const err = {
            code: code,
            startLine: -1,
            startCol: -1,
            startOffset: -1,
            endLine: -1,
            endCol: -1,
            endOffset: -1
        };

        this._setErrorLocation(err);
        this.onParseError(err);
    }

    _getOverriddenMethods(mxn) {
        return {
            _err(code) {
                mxn._reportError(code);
            }
        };
    }
}

var mixinBase = ErrorReportingMixinBase$3;

const ErrorReportingMixinBase$2 = mixinBase;
const PositionTrackingPreprocessorMixin = preprocessorMixin$1;
const Mixin$3 = mixin;

class ErrorReportingPreprocessorMixin$1 extends ErrorReportingMixinBase$2 {
    constructor(preprocessor, opts) {
        super(preprocessor, opts);

        this.posTracker = Mixin$3.install(preprocessor, PositionTrackingPreprocessorMixin);
        this.lastErrOffset = -1;
    }

    _reportError(code) {
        //NOTE: avoid reporting error twice on advance/retreat
        if (this.lastErrOffset !== this.posTracker.offset) {
            this.lastErrOffset = this.posTracker.offset;
            super._reportError(code);
        }
    }
}

var preprocessorMixin = ErrorReportingPreprocessorMixin$1;

const ErrorReportingMixinBase$1 = mixinBase;
const ErrorReportingPreprocessorMixin = preprocessorMixin;
const Mixin$2 = mixin;

class ErrorReportingTokenizerMixin$1 extends ErrorReportingMixinBase$1 {
    constructor(tokenizer, opts) {
        super(tokenizer, opts);

        const preprocessorMixin = Mixin$2.install(tokenizer.preprocessor, ErrorReportingPreprocessorMixin, opts);

        this.posTracker = preprocessorMixin.posTracker;
    }
}

var tokenizerMixin = ErrorReportingTokenizerMixin$1;

const ErrorReportingMixinBase = mixinBase;
const ErrorReportingTokenizerMixin = tokenizerMixin;
const LocationInfoTokenizerMixin = tokenizerMixin$1;
const Mixin$1 = mixin;

class ErrorReportingParserMixin$1 extends ErrorReportingMixinBase {
    constructor(parser, opts) {
        super(parser, opts);

        this.opts = opts;
        this.ctLoc = null;
        this.locBeforeToken = false;
    }

    _setErrorLocation(err) {
        if (this.ctLoc) {
            err.startLine = this.ctLoc.startLine;
            err.startCol = this.ctLoc.startCol;
            err.startOffset = this.ctLoc.startOffset;

            err.endLine = this.locBeforeToken ? this.ctLoc.startLine : this.ctLoc.endLine;
            err.endCol = this.locBeforeToken ? this.ctLoc.startCol : this.ctLoc.endCol;
            err.endOffset = this.locBeforeToken ? this.ctLoc.startOffset : this.ctLoc.endOffset;
        }
    }

    _getOverriddenMethods(mxn, orig) {
        return {
            _bootstrap(document, fragmentContext) {
                orig._bootstrap.call(this, document, fragmentContext);

                Mixin$1.install(this.tokenizer, ErrorReportingTokenizerMixin, mxn.opts);
                Mixin$1.install(this.tokenizer, LocationInfoTokenizerMixin);
            },

            _processInputToken(token) {
                mxn.ctLoc = token.location;

                orig._processInputToken.call(this, token);
            },

            _err(code, options) {
                mxn.locBeforeToken = options && options.beforeToken;
                mxn._reportError(code);
            }
        };
    }
}

var parserMixin = ErrorReportingParserMixin$1;

var _default = {};

const { DOCUMENT_MODE: DOCUMENT_MODE$2 } = html$2;

//Node construction
_default.createDocument = function() {
    return {
        nodeName: '#document',
        mode: DOCUMENT_MODE$2.NO_QUIRKS,
        childNodes: []
    };
};

_default.createDocumentFragment = function() {
    return {
        nodeName: '#document-fragment',
        childNodes: []
    };
};

_default.createElement = function(tagName, namespaceURI, attrs) {
    return {
        nodeName: tagName,
        tagName: tagName,
        attrs: attrs,
        namespaceURI: namespaceURI,
        childNodes: [],
        parentNode: null
    };
};

_default.createCommentNode = function(data) {
    return {
        nodeName: '#comment',
        data: data,
        parentNode: null
    };
};

const createTextNode$1 = function(value) {
    return {
        nodeName: '#text',
        value: value,
        parentNode: null
    };
};

//Tree mutation
const appendChild$1 = (_default.appendChild = function(parentNode, newNode) {
    parentNode.childNodes.push(newNode);
    newNode.parentNode = parentNode;
});

const insertBefore$2 = (_default.insertBefore = function(parentNode, newNode, referenceNode) {
    const insertionIdx = parentNode.childNodes.indexOf(referenceNode);

    parentNode.childNodes.splice(insertionIdx, 0, newNode);
    newNode.parentNode = parentNode;
});

_default.setTemplateContent = function(templateElement, contentElement) {
    templateElement.content = contentElement;
};

_default.getTemplateContent = function(templateElement) {
    return templateElement.content;
};

_default.setDocumentType = function(document, name, publicId, systemId) {
    let doctypeNode = null;

    for (let i = 0; i < document.childNodes.length; i++) {
        if (document.childNodes[i].nodeName === '#documentType') {
            doctypeNode = document.childNodes[i];
            break;
        }
    }

    if (doctypeNode) {
        doctypeNode.name = name;
        doctypeNode.publicId = publicId;
        doctypeNode.systemId = systemId;
    } else {
        appendChild$1(document, {
            nodeName: '#documentType',
            name: name,
            publicId: publicId,
            systemId: systemId
        });
    }
};

_default.setDocumentMode = function(document, mode) {
    document.mode = mode;
};

_default.getDocumentMode = function(document) {
    return document.mode;
};

_default.detachNode = function(node) {
    if (node.parentNode) {
        const idx = node.parentNode.childNodes.indexOf(node);

        node.parentNode.childNodes.splice(idx, 1);
        node.parentNode = null;
    }
};

_default.insertText = function(parentNode, text) {
    if (parentNode.childNodes.length) {
        const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];

        if (prevNode.nodeName === '#text') {
            prevNode.value += text;
            return;
        }
    }

    appendChild$1(parentNode, createTextNode$1(text));
};

_default.insertTextBefore = function(parentNode, text, referenceNode) {
    const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];

    if (prevNode && prevNode.nodeName === '#text') {
        prevNode.value += text;
    } else {
        insertBefore$2(parentNode, createTextNode$1(text), referenceNode);
    }
};

_default.adoptAttributes = function(recipient, attrs) {
    const recipientAttrsMap = [];

    for (let i = 0; i < recipient.attrs.length; i++) {
        recipientAttrsMap.push(recipient.attrs[i].name);
    }

    for (let j = 0; j < attrs.length; j++) {
        if (recipientAttrsMap.indexOf(attrs[j].name) === -1) {
            recipient.attrs.push(attrs[j]);
        }
    }
};

//Tree traversing
_default.getFirstChild = function(node) {
    return node.childNodes[0];
};

_default.getChildNodes = function(node) {
    return node.childNodes;
};

_default.getParentNode = function(node) {
    return node.parentNode;
};

_default.getAttrList = function(element) {
    return element.attrs;
};

//Node data
_default.getTagName = function(element) {
    return element.tagName;
};

_default.getNamespaceURI = function(element) {
    return element.namespaceURI;
};

_default.getTextNodeContent = function(textNode) {
    return textNode.value;
};

_default.getCommentNodeContent = function(commentNode) {
    return commentNode.data;
};

_default.getDocumentTypeNodeName = function(doctypeNode) {
    return doctypeNode.name;
};

_default.getDocumentTypeNodePublicId = function(doctypeNode) {
    return doctypeNode.publicId;
};

_default.getDocumentTypeNodeSystemId = function(doctypeNode) {
    return doctypeNode.systemId;
};

//Node types
_default.isTextNode = function(node) {
    return node.nodeName === '#text';
};

_default.isCommentNode = function(node) {
    return node.nodeName === '#comment';
};

_default.isDocumentTypeNode = function(node) {
    return node.nodeName === '#documentType';
};

_default.isElementNode = function(node) {
    return !!node.tagName;
};

// Source code location
_default.setNodeSourceCodeLocation = function(node, location) {
    node.sourceCodeLocation = location;
};

_default.getNodeSourceCodeLocation = function(node) {
    return node.sourceCodeLocation;
};

_default.updateNodeSourceCodeLocation = function(node, endLocation) {
    node.sourceCodeLocation = Object.assign(node.sourceCodeLocation, endLocation);
};

var mergeOptions$2 = function mergeOptions(defaults, options) {
    options = options || Object.create(null);

    return [defaults, options].reduce((merged, optObj) => {
        Object.keys(optObj).forEach(key => {
            merged[key] = optObj[key];
        });

        return merged;
    }, Object.create(null));
};

var doctype$3 = {};

const { DOCUMENT_MODE: DOCUMENT_MODE$1 } = html$2;

//Const
const VALID_DOCTYPE_NAME = 'html';
const VALID_SYSTEM_ID = 'about:legacy-compat';
const QUIRKS_MODE_SYSTEM_ID = 'http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd';

const QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
    '+//silmaril//dtd html pro v0r11 19970101//',
    '-//as//dtd html 3.0 aswedit + extensions//',
    '-//advasoft ltd//dtd html 3.0 aswedit + extensions//',
    '-//ietf//dtd html 2.0 level 1//',
    '-//ietf//dtd html 2.0 level 2//',
    '-//ietf//dtd html 2.0 strict level 1//',
    '-//ietf//dtd html 2.0 strict level 2//',
    '-//ietf//dtd html 2.0 strict//',
    '-//ietf//dtd html 2.0//',
    '-//ietf//dtd html 2.1e//',
    '-//ietf//dtd html 3.0//',
    '-//ietf//dtd html 3.2 final//',
    '-//ietf//dtd html 3.2//',
    '-//ietf//dtd html 3//',
    '-//ietf//dtd html level 0//',
    '-//ietf//dtd html level 1//',
    '-//ietf//dtd html level 2//',
    '-//ietf//dtd html level 3//',
    '-//ietf//dtd html strict level 0//',
    '-//ietf//dtd html strict level 1//',
    '-//ietf//dtd html strict level 2//',
    '-//ietf//dtd html strict level 3//',
    '-//ietf//dtd html strict//',
    '-//ietf//dtd html//',
    '-//metrius//dtd metrius presentational//',
    '-//microsoft//dtd internet explorer 2.0 html strict//',
    '-//microsoft//dtd internet explorer 2.0 html//',
    '-//microsoft//dtd internet explorer 2.0 tables//',
    '-//microsoft//dtd internet explorer 3.0 html strict//',
    '-//microsoft//dtd internet explorer 3.0 html//',
    '-//microsoft//dtd internet explorer 3.0 tables//',
    '-//netscape comm. corp.//dtd html//',
    '-//netscape comm. corp.//dtd strict html//',
    "-//o'reilly and associates//dtd html 2.0//",
    "-//o'reilly and associates//dtd html extended 1.0//",
    "-//o'reilly and associates//dtd html extended relaxed 1.0//",
    '-//sq//dtd html 2.0 hotmetal + extensions//',
    '-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//',
    '-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//',
    '-//spyglass//dtd html 2.0 extended//',
    '-//sun microsystems corp.//dtd hotjava html//',
    '-//sun microsystems corp.//dtd hotjava strict html//',
    '-//w3c//dtd html 3 1995-03-24//',
    '-//w3c//dtd html 3.2 draft//',
    '-//w3c//dtd html 3.2 final//',
    '-//w3c//dtd html 3.2//',
    '-//w3c//dtd html 3.2s draft//',
    '-//w3c//dtd html 4.0 frameset//',
    '-//w3c//dtd html 4.0 transitional//',
    '-//w3c//dtd html experimental 19960712//',
    '-//w3c//dtd html experimental 970421//',
    '-//w3c//dtd w3 html//',
    '-//w3o//dtd w3 html 3.0//',
    '-//webtechs//dtd mozilla html 2.0//',
    '-//webtechs//dtd mozilla html//'
];

const QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = QUIRKS_MODE_PUBLIC_ID_PREFIXES.concat([
    '-//w3c//dtd html 4.01 frameset//',
    '-//w3c//dtd html 4.01 transitional//'
]);

const QUIRKS_MODE_PUBLIC_IDS = ['-//w3o//dtd w3 html strict 3.0//en//', '-/w3c/dtd html 4.0 transitional/en', 'html'];
const LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ['-//w3c//dtd xhtml 1.0 frameset//', '-//w3c//dtd xhtml 1.0 transitional//'];

const LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = LIMITED_QUIRKS_PUBLIC_ID_PREFIXES.concat([
    '-//w3c//dtd html 4.01 frameset//',
    '-//w3c//dtd html 4.01 transitional//'
]);

//Utils
function enquoteDoctypeId(id) {
    const quote = id.indexOf('"') !== -1 ? "'" : '"';

    return quote + id + quote;
}

function hasPrefix(publicId, prefixes) {
    for (let i = 0; i < prefixes.length; i++) {
        if (publicId.indexOf(prefixes[i]) === 0) {
            return true;
        }
    }

    return false;
}

//API
doctype$3.isConforming = function(token) {
    return (
        token.name === VALID_DOCTYPE_NAME &&
        token.publicId === null &&
        (token.systemId === null || token.systemId === VALID_SYSTEM_ID)
    );
};

doctype$3.getDocumentMode = function(token) {
    if (token.name !== VALID_DOCTYPE_NAME) {
        return DOCUMENT_MODE$1.QUIRKS;
    }

    const systemId = token.systemId;

    if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
        return DOCUMENT_MODE$1.QUIRKS;
    }

    let publicId = token.publicId;

    if (publicId !== null) {
        publicId = publicId.toLowerCase();

        if (QUIRKS_MODE_PUBLIC_IDS.indexOf(publicId) > -1) {
            return DOCUMENT_MODE$1.QUIRKS;
        }

        let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;

        if (hasPrefix(publicId, prefixes)) {
            return DOCUMENT_MODE$1.QUIRKS;
        }

        prefixes =
            systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;

        if (hasPrefix(publicId, prefixes)) {
            return DOCUMENT_MODE$1.LIMITED_QUIRKS;
        }
    }

    return DOCUMENT_MODE$1.NO_QUIRKS;
};

doctype$3.serializeContent = function(name, publicId, systemId) {
    let str = '!DOCTYPE ';

    if (name) {
        str += name;
    }

    if (publicId) {
        str += ' PUBLIC ' + enquoteDoctypeId(publicId);
    } else if (systemId) {
        str += ' SYSTEM';
    }

    if (systemId !== null) {
        str += ' ' + enquoteDoctypeId(systemId);
    }

    return str;
};

var foreignContent$1 = {};

const Tokenizer$1 = tokenizer;
const HTML$2 = html$2;

//Aliases
const $$2 = HTML$2.TAG_NAMES;
const NS$2 = HTML$2.NAMESPACES;
const ATTRS$1 = HTML$2.ATTRS;

//MIME types
const MIME_TYPES = {
    TEXT_HTML: 'text/html',
    APPLICATION_XML: 'application/xhtml+xml'
};

//Attributes
const DEFINITION_URL_ATTR = 'definitionurl';
const ADJUSTED_DEFINITION_URL_ATTR = 'definitionURL';
const SVG_ATTRS_ADJUSTMENT_MAP = {
    attributename: 'attributeName',
    attributetype: 'attributeType',
    basefrequency: 'baseFrequency',
    baseprofile: 'baseProfile',
    calcmode: 'calcMode',
    clippathunits: 'clipPathUnits',
    diffuseconstant: 'diffuseConstant',
    edgemode: 'edgeMode',
    filterunits: 'filterUnits',
    glyphref: 'glyphRef',
    gradienttransform: 'gradientTransform',
    gradientunits: 'gradientUnits',
    kernelmatrix: 'kernelMatrix',
    kernelunitlength: 'kernelUnitLength',
    keypoints: 'keyPoints',
    keysplines: 'keySplines',
    keytimes: 'keyTimes',
    lengthadjust: 'lengthAdjust',
    limitingconeangle: 'limitingConeAngle',
    markerheight: 'markerHeight',
    markerunits: 'markerUnits',
    markerwidth: 'markerWidth',
    maskcontentunits: 'maskContentUnits',
    maskunits: 'maskUnits',
    numoctaves: 'numOctaves',
    pathlength: 'pathLength',
    patterncontentunits: 'patternContentUnits',
    patterntransform: 'patternTransform',
    patternunits: 'patternUnits',
    pointsatx: 'pointsAtX',
    pointsaty: 'pointsAtY',
    pointsatz: 'pointsAtZ',
    preservealpha: 'preserveAlpha',
    preserveaspectratio: 'preserveAspectRatio',
    primitiveunits: 'primitiveUnits',
    refx: 'refX',
    refy: 'refY',
    repeatcount: 'repeatCount',
    repeatdur: 'repeatDur',
    requiredextensions: 'requiredExtensions',
    requiredfeatures: 'requiredFeatures',
    specularconstant: 'specularConstant',
    specularexponent: 'specularExponent',
    spreadmethod: 'spreadMethod',
    startoffset: 'startOffset',
    stddeviation: 'stdDeviation',
    stitchtiles: 'stitchTiles',
    surfacescale: 'surfaceScale',
    systemlanguage: 'systemLanguage',
    tablevalues: 'tableValues',
    targetx: 'targetX',
    targety: 'targetY',
    textlength: 'textLength',
    viewbox: 'viewBox',
    viewtarget: 'viewTarget',
    xchannelselector: 'xChannelSelector',
    ychannelselector: 'yChannelSelector',
    zoomandpan: 'zoomAndPan'
};

const XML_ATTRS_ADJUSTMENT_MAP = {
    'xlink:actuate': { prefix: 'xlink', name: 'actuate', namespace: NS$2.XLINK },
    'xlink:arcrole': { prefix: 'xlink', name: 'arcrole', namespace: NS$2.XLINK },
    'xlink:href': { prefix: 'xlink', name: 'href', namespace: NS$2.XLINK },
    'xlink:role': { prefix: 'xlink', name: 'role', namespace: NS$2.XLINK },
    'xlink:show': { prefix: 'xlink', name: 'show', namespace: NS$2.XLINK },
    'xlink:title': { prefix: 'xlink', name: 'title', namespace: NS$2.XLINK },
    'xlink:type': { prefix: 'xlink', name: 'type', namespace: NS$2.XLINK },
    'xml:base': { prefix: 'xml', name: 'base', namespace: NS$2.XML },
    'xml:lang': { prefix: 'xml', name: 'lang', namespace: NS$2.XML },
    'xml:space': { prefix: 'xml', name: 'space', namespace: NS$2.XML },
    xmlns: { prefix: '', name: 'xmlns', namespace: NS$2.XMLNS },
    'xmlns:xlink': { prefix: 'xmlns', name: 'xlink', namespace: NS$2.XMLNS }
};

//SVG tag names adjustment map
const SVG_TAG_NAMES_ADJUSTMENT_MAP = (foreignContent$1.SVG_TAG_NAMES_ADJUSTMENT_MAP = {
    altglyph: 'altGlyph',
    altglyphdef: 'altGlyphDef',
    altglyphitem: 'altGlyphItem',
    animatecolor: 'animateColor',
    animatemotion: 'animateMotion',
    animatetransform: 'animateTransform',
    clippath: 'clipPath',
    feblend: 'feBlend',
    fecolormatrix: 'feColorMatrix',
    fecomponenttransfer: 'feComponentTransfer',
    fecomposite: 'feComposite',
    feconvolvematrix: 'feConvolveMatrix',
    fediffuselighting: 'feDiffuseLighting',
    fedisplacementmap: 'feDisplacementMap',
    fedistantlight: 'feDistantLight',
    feflood: 'feFlood',
    fefunca: 'feFuncA',
    fefuncb: 'feFuncB',
    fefuncg: 'feFuncG',
    fefuncr: 'feFuncR',
    fegaussianblur: 'feGaussianBlur',
    feimage: 'feImage',
    femerge: 'feMerge',
    femergenode: 'feMergeNode',
    femorphology: 'feMorphology',
    feoffset: 'feOffset',
    fepointlight: 'fePointLight',
    fespecularlighting: 'feSpecularLighting',
    fespotlight: 'feSpotLight',
    fetile: 'feTile',
    feturbulence: 'feTurbulence',
    foreignobject: 'foreignObject',
    glyphref: 'glyphRef',
    lineargradient: 'linearGradient',
    radialgradient: 'radialGradient',
    textpath: 'textPath'
});

//Tags that causes exit from foreign content
const EXITS_FOREIGN_CONTENT = {
    [$$2.B]: true,
    [$$2.BIG]: true,
    [$$2.BLOCKQUOTE]: true,
    [$$2.BODY]: true,
    [$$2.BR]: true,
    [$$2.CENTER]: true,
    [$$2.CODE]: true,
    [$$2.DD]: true,
    [$$2.DIV]: true,
    [$$2.DL]: true,
    [$$2.DT]: true,
    [$$2.EM]: true,
    [$$2.EMBED]: true,
    [$$2.H1]: true,
    [$$2.H2]: true,
    [$$2.H3]: true,
    [$$2.H4]: true,
    [$$2.H5]: true,
    [$$2.H6]: true,
    [$$2.HEAD]: true,
    [$$2.HR]: true,
    [$$2.I]: true,
    [$$2.IMG]: true,
    [$$2.LI]: true,
    [$$2.LISTING]: true,
    [$$2.MENU]: true,
    [$$2.META]: true,
    [$$2.NOBR]: true,
    [$$2.OL]: true,
    [$$2.P]: true,
    [$$2.PRE]: true,
    [$$2.RUBY]: true,
    [$$2.S]: true,
    [$$2.SMALL]: true,
    [$$2.SPAN]: true,
    [$$2.STRONG]: true,
    [$$2.STRIKE]: true,
    [$$2.SUB]: true,
    [$$2.SUP]: true,
    [$$2.TABLE]: true,
    [$$2.TT]: true,
    [$$2.U]: true,
    [$$2.UL]: true,
    [$$2.VAR]: true
};

//Check exit from foreign content
foreignContent$1.causesExit = function(startTagToken) {
    const tn = startTagToken.tagName;
    const isFontWithAttrs =
        tn === $$2.FONT &&
        (Tokenizer$1.getTokenAttr(startTagToken, ATTRS$1.COLOR) !== null ||
            Tokenizer$1.getTokenAttr(startTagToken, ATTRS$1.SIZE) !== null ||
            Tokenizer$1.getTokenAttr(startTagToken, ATTRS$1.FACE) !== null);

    return isFontWithAttrs ? true : EXITS_FOREIGN_CONTENT[tn];
};

//Token adjustments
foreignContent$1.adjustTokenMathMLAttrs = function(token) {
    for (let i = 0; i < token.attrs.length; i++) {
        if (token.attrs[i].name === DEFINITION_URL_ATTR) {
            token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
            break;
        }
    }
};

foreignContent$1.adjustTokenSVGAttrs = function(token) {
    for (let i = 0; i < token.attrs.length; i++) {
        const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];

        if (adjustedAttrName) {
            token.attrs[i].name = adjustedAttrName;
        }
    }
};

foreignContent$1.adjustTokenXMLAttrs = function(token) {
    for (let i = 0; i < token.attrs.length; i++) {
        const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];

        if (adjustedAttrEntry) {
            token.attrs[i].prefix = adjustedAttrEntry.prefix;
            token.attrs[i].name = adjustedAttrEntry.name;
            token.attrs[i].namespace = adjustedAttrEntry.namespace;
        }
    }
};

foreignContent$1.adjustTokenSVGTagName = function(token) {
    const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP[token.tagName];

    if (adjustedTagName) {
        token.tagName = adjustedTagName;
    }
};

//Integration points
function isMathMLTextIntegrationPoint(tn, ns) {
    return ns === NS$2.MATHML && (tn === $$2.MI || tn === $$2.MO || tn === $$2.MN || tn === $$2.MS || tn === $$2.MTEXT);
}

function isHtmlIntegrationPoint(tn, ns, attrs) {
    if (ns === NS$2.MATHML && tn === $$2.ANNOTATION_XML) {
        for (let i = 0; i < attrs.length; i++) {
            if (attrs[i].name === ATTRS$1.ENCODING) {
                const value = attrs[i].value.toLowerCase();

                return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
            }
        }
    }

    return ns === NS$2.SVG && (tn === $$2.FOREIGN_OBJECT || tn === $$2.DESC || tn === $$2.TITLE);
}

foreignContent$1.isIntegrationPoint = function(tn, ns, attrs, foreignNS) {
    if ((!foreignNS || foreignNS === NS$2.HTML) && isHtmlIntegrationPoint(tn, ns, attrs)) {
        return true;
    }

    if ((!foreignNS || foreignNS === NS$2.MATHML) && isMathMLTextIntegrationPoint(tn, ns)) {
        return true;
    }

    return false;
};

const Tokenizer = tokenizer;
const OpenElementStack = openElementStack;
const FormattingElementList = formattingElementList;
const LocationInfoParserMixin = parserMixin$1;
const ErrorReportingParserMixin = parserMixin;
const Mixin = mixin;
const defaultTreeAdapter$1 = _default;
const mergeOptions$1 = mergeOptions$2;
const doctype$2 = doctype$3;
const foreignContent = foreignContent$1;
const ERR = errorCodes;
const unicode = unicode$3;
const HTML$1 = html$2;

//Aliases
const $$1 = HTML$1.TAG_NAMES;
const NS$1 = HTML$1.NAMESPACES;
const ATTRS = HTML$1.ATTRS;

const DEFAULT_OPTIONS$1 = {
    scriptingEnabled: true,
    sourceCodeLocationInfo: false,
    onParseError: null,
    treeAdapter: defaultTreeAdapter$1
};

//Misc constants
const HIDDEN_INPUT_TYPE = 'hidden';

//Adoption agency loops iteration count
const AA_OUTER_LOOP_ITER = 8;
const AA_INNER_LOOP_ITER = 3;

//Insertion modes
const INITIAL_MODE = 'INITIAL_MODE';
const BEFORE_HTML_MODE = 'BEFORE_HTML_MODE';
const BEFORE_HEAD_MODE = 'BEFORE_HEAD_MODE';
const IN_HEAD_MODE = 'IN_HEAD_MODE';
const IN_HEAD_NO_SCRIPT_MODE = 'IN_HEAD_NO_SCRIPT_MODE';
const AFTER_HEAD_MODE = 'AFTER_HEAD_MODE';
const IN_BODY_MODE = 'IN_BODY_MODE';
const TEXT_MODE = 'TEXT_MODE';
const IN_TABLE_MODE = 'IN_TABLE_MODE';
const IN_TABLE_TEXT_MODE = 'IN_TABLE_TEXT_MODE';
const IN_CAPTION_MODE = 'IN_CAPTION_MODE';
const IN_COLUMN_GROUP_MODE = 'IN_COLUMN_GROUP_MODE';
const IN_TABLE_BODY_MODE = 'IN_TABLE_BODY_MODE';
const IN_ROW_MODE = 'IN_ROW_MODE';
const IN_CELL_MODE = 'IN_CELL_MODE';
const IN_SELECT_MODE = 'IN_SELECT_MODE';
const IN_SELECT_IN_TABLE_MODE = 'IN_SELECT_IN_TABLE_MODE';
const IN_TEMPLATE_MODE = 'IN_TEMPLATE_MODE';
const AFTER_BODY_MODE = 'AFTER_BODY_MODE';
const IN_FRAMESET_MODE = 'IN_FRAMESET_MODE';
const AFTER_FRAMESET_MODE = 'AFTER_FRAMESET_MODE';
const AFTER_AFTER_BODY_MODE = 'AFTER_AFTER_BODY_MODE';
const AFTER_AFTER_FRAMESET_MODE = 'AFTER_AFTER_FRAMESET_MODE';

//Insertion mode reset map
const INSERTION_MODE_RESET_MAP = {
    [$$1.TR]: IN_ROW_MODE,
    [$$1.TBODY]: IN_TABLE_BODY_MODE,
    [$$1.THEAD]: IN_TABLE_BODY_MODE,
    [$$1.TFOOT]: IN_TABLE_BODY_MODE,
    [$$1.CAPTION]: IN_CAPTION_MODE,
    [$$1.COLGROUP]: IN_COLUMN_GROUP_MODE,
    [$$1.TABLE]: IN_TABLE_MODE,
    [$$1.BODY]: IN_BODY_MODE,
    [$$1.FRAMESET]: IN_FRAMESET_MODE
};

//Template insertion mode switch map
const TEMPLATE_INSERTION_MODE_SWITCH_MAP = {
    [$$1.CAPTION]: IN_TABLE_MODE,
    [$$1.COLGROUP]: IN_TABLE_MODE,
    [$$1.TBODY]: IN_TABLE_MODE,
    [$$1.TFOOT]: IN_TABLE_MODE,
    [$$1.THEAD]: IN_TABLE_MODE,
    [$$1.COL]: IN_COLUMN_GROUP_MODE,
    [$$1.TR]: IN_TABLE_BODY_MODE,
    [$$1.TD]: IN_ROW_MODE,
    [$$1.TH]: IN_ROW_MODE
};

//Token handlers map for insertion modes
const TOKEN_HANDLERS = {
    [INITIAL_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenInInitialMode,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInInitialMode,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: doctypeInInitialMode,
        [Tokenizer.START_TAG_TOKEN]: tokenInInitialMode,
        [Tokenizer.END_TAG_TOKEN]: tokenInInitialMode,
        [Tokenizer.EOF_TOKEN]: tokenInInitialMode
    },
    [BEFORE_HTML_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHtml,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHtml,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagBeforeHtml,
        [Tokenizer.END_TAG_TOKEN]: endTagBeforeHtml,
        [Tokenizer.EOF_TOKEN]: tokenBeforeHtml
    },
    [BEFORE_HEAD_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHead,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHead,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
        [Tokenizer.START_TAG_TOKEN]: startTagBeforeHead,
        [Tokenizer.END_TAG_TOKEN]: endTagBeforeHead,
        [Tokenizer.EOF_TOKEN]: tokenBeforeHead
    },
    [IN_HEAD_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenInHead,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHead,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
        [Tokenizer.START_TAG_TOKEN]: startTagInHead,
        [Tokenizer.END_TAG_TOKEN]: endTagInHead,
        [Tokenizer.EOF_TOKEN]: tokenInHead
    },
    [IN_HEAD_NO_SCRIPT_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenInHeadNoScript,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHeadNoScript,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
        [Tokenizer.START_TAG_TOKEN]: startTagInHeadNoScript,
        [Tokenizer.END_TAG_TOKEN]: endTagInHeadNoScript,
        [Tokenizer.EOF_TOKEN]: tokenInHeadNoScript
    },
    [AFTER_HEAD_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenAfterHead,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterHead,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
        [Tokenizer.START_TAG_TOKEN]: startTagAfterHead,
        [Tokenizer.END_TAG_TOKEN]: endTagAfterHead,
        [Tokenizer.EOF_TOKEN]: tokenAfterHead
    },
    [IN_BODY_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInBody,
        [Tokenizer.END_TAG_TOKEN]: endTagInBody,
        [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [TEXT_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.NULL_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: ignoreToken,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: ignoreToken,
        [Tokenizer.END_TAG_TOKEN]: endTagInText,
        [Tokenizer.EOF_TOKEN]: eofInText
    },
    [IN_TABLE_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInTable,
        [Tokenizer.END_TAG_TOKEN]: endTagInTable,
        [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_TABLE_TEXT_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInTableText,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInTableText,
        [Tokenizer.COMMENT_TOKEN]: tokenInTableText,
        [Tokenizer.DOCTYPE_TOKEN]: tokenInTableText,
        [Tokenizer.START_TAG_TOKEN]: tokenInTableText,
        [Tokenizer.END_TAG_TOKEN]: tokenInTableText,
        [Tokenizer.EOF_TOKEN]: tokenInTableText
    },
    [IN_CAPTION_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInCaption,
        [Tokenizer.END_TAG_TOKEN]: endTagInCaption,
        [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_COLUMN_GROUP_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenInColumnGroup,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInColumnGroup,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInColumnGroup,
        [Tokenizer.END_TAG_TOKEN]: endTagInColumnGroup,
        [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_TABLE_BODY_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInTableBody,
        [Tokenizer.END_TAG_TOKEN]: endTagInTableBody,
        [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_ROW_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInRow,
        [Tokenizer.END_TAG_TOKEN]: endTagInRow,
        [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_CELL_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInCell,
        [Tokenizer.END_TAG_TOKEN]: endTagInCell,
        [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_SELECT_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInSelect,
        [Tokenizer.END_TAG_TOKEN]: endTagInSelect,
        [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_SELECT_IN_TABLE_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInSelectInTable,
        [Tokenizer.END_TAG_TOKEN]: endTagInSelectInTable,
        [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_TEMPLATE_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInTemplate,
        [Tokenizer.END_TAG_TOKEN]: endTagInTemplate,
        [Tokenizer.EOF_TOKEN]: eofInTemplate
    },
    [AFTER_BODY_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenAfterBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterBody,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendCommentToRootHtmlElement,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagAfterBody,
        [Tokenizer.END_TAG_TOKEN]: endTagAfterBody,
        [Tokenizer.EOF_TOKEN]: stopParsing
    },
    [IN_FRAMESET_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInFrameset,
        [Tokenizer.END_TAG_TOKEN]: endTagInFrameset,
        [Tokenizer.EOF_TOKEN]: stopParsing
    },
    [AFTER_FRAMESET_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagAfterFrameset,
        [Tokenizer.END_TAG_TOKEN]: endTagAfterFrameset,
        [Tokenizer.EOF_TOKEN]: stopParsing
    },
    [AFTER_AFTER_BODY_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenAfterAfterBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterAfterBody,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterBody,
        [Tokenizer.END_TAG_TOKEN]: tokenAfterAfterBody,
        [Tokenizer.EOF_TOKEN]: stopParsing
    },
    [AFTER_AFTER_FRAMESET_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterFrameset,
        [Tokenizer.END_TAG_TOKEN]: ignoreToken,
        [Tokenizer.EOF_TOKEN]: stopParsing
    }
};

//Parser
class Parser$1 {
    constructor(options) {
        this.options = mergeOptions$1(DEFAULT_OPTIONS$1, options);

        this.treeAdapter = this.options.treeAdapter;
        this.pendingScript = null;

        if (this.options.sourceCodeLocationInfo) {
            Mixin.install(this, LocationInfoParserMixin);
        }

        if (this.options.onParseError) {
            Mixin.install(this, ErrorReportingParserMixin, { onParseError: this.options.onParseError });
        }
    }

    // API
    parse(html) {
        const document = this.treeAdapter.createDocument();

        this._bootstrap(document, null);
        this.tokenizer.write(html, true);
        this._runParsingLoop(null);

        return document;
    }

    parseFragment(html, fragmentContext) {
        //NOTE: use <template> element as a fragment context if context element was not provided,
        //so we will parse in "forgiving" manner
        if (!fragmentContext) {
            fragmentContext = this.treeAdapter.createElement($$1.TEMPLATE, NS$1.HTML, []);
        }

        //NOTE: create fake element which will be used as 'document' for fragment parsing.
        //This is important for jsdom there 'document' can't be recreated, therefore
        //fragment parsing causes messing of the main `document`.
        const documentMock = this.treeAdapter.createElement('documentmock', NS$1.HTML, []);

        this._bootstrap(documentMock, fragmentContext);

        if (this.treeAdapter.getTagName(fragmentContext) === $$1.TEMPLATE) {
            this._pushTmplInsertionMode(IN_TEMPLATE_MODE);
        }

        this._initTokenizerForFragmentParsing();
        this._insertFakeRootElement();
        this._resetInsertionMode();
        this._findFormInFragmentContext();
        this.tokenizer.write(html, true);
        this._runParsingLoop(null);

        const rootElement = this.treeAdapter.getFirstChild(documentMock);
        const fragment = this.treeAdapter.createDocumentFragment();

        this._adoptNodes(rootElement, fragment);

        return fragment;
    }

    //Bootstrap parser
    _bootstrap(document, fragmentContext) {
        this.tokenizer = new Tokenizer(this.options);

        this.stopped = false;

        this.insertionMode = INITIAL_MODE;
        this.originalInsertionMode = '';

        this.document = document;
        this.fragmentContext = fragmentContext;

        this.headElement = null;
        this.formElement = null;

        this.openElements = new OpenElementStack(this.document, this.treeAdapter);
        this.activeFormattingElements = new FormattingElementList(this.treeAdapter);

        this.tmplInsertionModeStack = [];
        this.tmplInsertionModeStackTop = -1;
        this.currentTmplInsertionMode = null;

        this.pendingCharacterTokens = [];
        this.hasNonWhitespacePendingCharacterToken = false;

        this.framesetOk = true;
        this.skipNextNewLine = false;
        this.fosterParentingEnabled = false;
    }

    //Errors
    _err() {
        // NOTE: err reporting is noop by default. Enabled by mixin.
    }

    //Parsing loop
    _runParsingLoop(scriptHandler) {
        while (!this.stopped) {
            this._setupTokenizerCDATAMode();

            const token = this.tokenizer.getNextToken();

            if (token.type === Tokenizer.HIBERNATION_TOKEN) {
                break;
            }

            if (this.skipNextNewLine) {
                this.skipNextNewLine = false;

                if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN && token.chars[0] === '\n') {
                    if (token.chars.length === 1) {
                        continue;
                    }

                    token.chars = token.chars.substr(1);
                }
            }

            this._processInputToken(token);

            if (scriptHandler && this.pendingScript) {
                break;
            }
        }
    }

    runParsingLoopForCurrentChunk(writeCallback, scriptHandler) {
        this._runParsingLoop(scriptHandler);

        if (scriptHandler && this.pendingScript) {
            const script = this.pendingScript;

            this.pendingScript = null;

            scriptHandler(script);

            return;
        }

        if (writeCallback) {
            writeCallback();
        }
    }

    //Text parsing
    _setupTokenizerCDATAMode() {
        const current = this._getAdjustedCurrentElement();

        this.tokenizer.allowCDATA =
            current &&
            current !== this.document &&
            this.treeAdapter.getNamespaceURI(current) !== NS$1.HTML &&
            !this._isIntegrationPoint(current);
    }

    _switchToTextParsing(currentToken, nextTokenizerState) {
        this._insertElement(currentToken, NS$1.HTML);
        this.tokenizer.state = nextTokenizerState;
        this.originalInsertionMode = this.insertionMode;
        this.insertionMode = TEXT_MODE;
    }

    switchToPlaintextParsing() {
        this.insertionMode = TEXT_MODE;
        this.originalInsertionMode = IN_BODY_MODE;
        this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
    }

    //Fragment parsing
    _getAdjustedCurrentElement() {
        return this.openElements.stackTop === 0 && this.fragmentContext
            ? this.fragmentContext
            : this.openElements.current;
    }

    _findFormInFragmentContext() {
        let node = this.fragmentContext;

        do {
            if (this.treeAdapter.getTagName(node) === $$1.FORM) {
                this.formElement = node;
                break;
            }

            node = this.treeAdapter.getParentNode(node);
        } while (node);
    }

    _initTokenizerForFragmentParsing() {
        if (this.treeAdapter.getNamespaceURI(this.fragmentContext) === NS$1.HTML) {
            const tn = this.treeAdapter.getTagName(this.fragmentContext);

            if (tn === $$1.TITLE || tn === $$1.TEXTAREA) {
                this.tokenizer.state = Tokenizer.MODE.RCDATA;
            } else if (
                tn === $$1.STYLE ||
                tn === $$1.XMP ||
                tn === $$1.IFRAME ||
                tn === $$1.NOEMBED ||
                tn === $$1.NOFRAMES ||
                tn === $$1.NOSCRIPT
            ) {
                this.tokenizer.state = Tokenizer.MODE.RAWTEXT;
            } else if (tn === $$1.SCRIPT) {
                this.tokenizer.state = Tokenizer.MODE.SCRIPT_DATA;
            } else if (tn === $$1.PLAINTEXT) {
                this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
            }
        }
    }

    //Tree mutation
    _setDocumentType(token) {
        const name = token.name || '';
        const publicId = token.publicId || '';
        const systemId = token.systemId || '';

        this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);
    }

    _attachElementToTree(element) {
        if (this._shouldFosterParentOnInsertion()) {
            this._fosterParentElement(element);
        } else {
            const parent = this.openElements.currentTmplContent || this.openElements.current;

            this.treeAdapter.appendChild(parent, element);
        }
    }

    _appendElement(token, namespaceURI) {
        const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);

        this._attachElementToTree(element);
    }

    _insertElement(token, namespaceURI) {
        const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);

        this._attachElementToTree(element);
        this.openElements.push(element);
    }

    _insertFakeElement(tagName) {
        const element = this.treeAdapter.createElement(tagName, NS$1.HTML, []);

        this._attachElementToTree(element);
        this.openElements.push(element);
    }

    _insertTemplate(token) {
        const tmpl = this.treeAdapter.createElement(token.tagName, NS$1.HTML, token.attrs);
        const content = this.treeAdapter.createDocumentFragment();

        this.treeAdapter.setTemplateContent(tmpl, content);
        this._attachElementToTree(tmpl);
        this.openElements.push(tmpl);
    }

    _insertFakeRootElement() {
        const element = this.treeAdapter.createElement($$1.HTML, NS$1.HTML, []);

        this.treeAdapter.appendChild(this.openElements.current, element);
        this.openElements.push(element);
    }

    _appendCommentNode(token, parent) {
        const commentNode = this.treeAdapter.createCommentNode(token.data);

        this.treeAdapter.appendChild(parent, commentNode);
    }

    _insertCharacters(token) {
        if (this._shouldFosterParentOnInsertion()) {
            this._fosterParentText(token.chars);
        } else {
            const parent = this.openElements.currentTmplContent || this.openElements.current;

            this.treeAdapter.insertText(parent, token.chars);
        }
    }

    _adoptNodes(donor, recipient) {
        for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
            this.treeAdapter.detachNode(child);
            this.treeAdapter.appendChild(recipient, child);
        }
    }

    //Token processing
    _shouldProcessTokenInForeignContent(token) {
        const current = this._getAdjustedCurrentElement();

        if (!current || current === this.document) {
            return false;
        }

        const ns = this.treeAdapter.getNamespaceURI(current);

        if (ns === NS$1.HTML) {
            return false;
        }

        if (
            this.treeAdapter.getTagName(current) === $$1.ANNOTATION_XML &&
            ns === NS$1.MATHML &&
            token.type === Tokenizer.START_TAG_TOKEN &&
            token.tagName === $$1.SVG
        ) {
            return false;
        }

        const isCharacterToken =
            token.type === Tokenizer.CHARACTER_TOKEN ||
            token.type === Tokenizer.NULL_CHARACTER_TOKEN ||
            token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN;

        const isMathMLTextStartTag =
            token.type === Tokenizer.START_TAG_TOKEN && token.tagName !== $$1.MGLYPH && token.tagName !== $$1.MALIGNMARK;

        if ((isMathMLTextStartTag || isCharacterToken) && this._isIntegrationPoint(current, NS$1.MATHML)) {
            return false;
        }

        if (
            (token.type === Tokenizer.START_TAG_TOKEN || isCharacterToken) &&
            this._isIntegrationPoint(current, NS$1.HTML)
        ) {
            return false;
        }

        return token.type !== Tokenizer.EOF_TOKEN;
    }

    _processToken(token) {
        TOKEN_HANDLERS[this.insertionMode][token.type](this, token);
    }

    _processTokenInBodyMode(token) {
        TOKEN_HANDLERS[IN_BODY_MODE][token.type](this, token);
    }

    _processTokenInForeignContent(token) {
        if (token.type === Tokenizer.CHARACTER_TOKEN) {
            characterInForeignContent(this, token);
        } else if (token.type === Tokenizer.NULL_CHARACTER_TOKEN) {
            nullCharacterInForeignContent(this, token);
        } else if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN) {
            insertCharacters(this, token);
        } else if (token.type === Tokenizer.COMMENT_TOKEN) {
            appendComment(this, token);
        } else if (token.type === Tokenizer.START_TAG_TOKEN) {
            startTagInForeignContent(this, token);
        } else if (token.type === Tokenizer.END_TAG_TOKEN) {
            endTagInForeignContent(this, token);
        }
    }

    _processInputToken(token) {
        if (this._shouldProcessTokenInForeignContent(token)) {
            this._processTokenInForeignContent(token);
        } else {
            this._processToken(token);
        }

        if (token.type === Tokenizer.START_TAG_TOKEN && token.selfClosing && !token.ackSelfClosing) {
            this._err(ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
        }
    }

    //Integration points
    _isIntegrationPoint(element, foreignNS) {
        const tn = this.treeAdapter.getTagName(element);
        const ns = this.treeAdapter.getNamespaceURI(element);
        const attrs = this.treeAdapter.getAttrList(element);

        return foreignContent.isIntegrationPoint(tn, ns, attrs, foreignNS);
    }

    //Active formatting elements reconstruction
    _reconstructActiveFormattingElements() {
        const listLength = this.activeFormattingElements.length;

        if (listLength) {
            let unopenIdx = listLength;
            let entry = null;

            do {
                unopenIdx--;
                entry = this.activeFormattingElements.entries[unopenIdx];

                if (entry.type === FormattingElementList.MARKER_ENTRY || this.openElements.contains(entry.element)) {
                    unopenIdx++;
                    break;
                }
            } while (unopenIdx > 0);

            for (let i = unopenIdx; i < listLength; i++) {
                entry = this.activeFormattingElements.entries[i];
                this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
                entry.element = this.openElements.current;
            }
        }
    }

    //Close elements
    _closeTableCell() {
        this.openElements.generateImpliedEndTags();
        this.openElements.popUntilTableCellPopped();
        this.activeFormattingElements.clearToLastMarker();
        this.insertionMode = IN_ROW_MODE;
    }

    _closePElement() {
        this.openElements.generateImpliedEndTagsWithExclusion($$1.P);
        this.openElements.popUntilTagNamePopped($$1.P);
    }

    //Insertion modes
    _resetInsertionMode() {
        for (let i = this.openElements.stackTop, last = false; i >= 0; i--) {
            let element = this.openElements.items[i];

            if (i === 0) {
                last = true;

                if (this.fragmentContext) {
                    element = this.fragmentContext;
                }
            }

            const tn = this.treeAdapter.getTagName(element);
            const newInsertionMode = INSERTION_MODE_RESET_MAP[tn];

            if (newInsertionMode) {
                this.insertionMode = newInsertionMode;
                break;
            } else if (!last && (tn === $$1.TD || tn === $$1.TH)) {
                this.insertionMode = IN_CELL_MODE;
                break;
            } else if (!last && tn === $$1.HEAD) {
                this.insertionMode = IN_HEAD_MODE;
                break;
            } else if (tn === $$1.SELECT) {
                this._resetInsertionModeForSelect(i);
                break;
            } else if (tn === $$1.TEMPLATE) {
                this.insertionMode = this.currentTmplInsertionMode;
                break;
            } else if (tn === $$1.HTML) {
                this.insertionMode = this.headElement ? AFTER_HEAD_MODE : BEFORE_HEAD_MODE;
                break;
            } else if (last) {
                this.insertionMode = IN_BODY_MODE;
                break;
            }
        }
    }

    _resetInsertionModeForSelect(selectIdx) {
        if (selectIdx > 0) {
            for (let i = selectIdx - 1; i > 0; i--) {
                const ancestor = this.openElements.items[i];
                const tn = this.treeAdapter.getTagName(ancestor);

                if (tn === $$1.TEMPLATE) {
                    break;
                } else if (tn === $$1.TABLE) {
                    this.insertionMode = IN_SELECT_IN_TABLE_MODE;
                    return;
                }
            }
        }

        this.insertionMode = IN_SELECT_MODE;
    }

    _pushTmplInsertionMode(mode) {
        this.tmplInsertionModeStack.push(mode);
        this.tmplInsertionModeStackTop++;
        this.currentTmplInsertionMode = mode;
    }

    _popTmplInsertionMode() {
        this.tmplInsertionModeStack.pop();
        this.tmplInsertionModeStackTop--;
        this.currentTmplInsertionMode = this.tmplInsertionModeStack[this.tmplInsertionModeStackTop];
    }

    //Foster parenting
    _isElementCausesFosterParenting(element) {
        const tn = this.treeAdapter.getTagName(element);

        return tn === $$1.TABLE || tn === $$1.TBODY || tn === $$1.TFOOT || tn === $$1.THEAD || tn === $$1.TR;
    }

    _shouldFosterParentOnInsertion() {
        return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.current);
    }

    _findFosterParentingLocation() {
        const location = {
            parent: null,
            beforeElement: null
        };

        for (let i = this.openElements.stackTop; i >= 0; i--) {
            const openElement = this.openElements.items[i];
            const tn = this.treeAdapter.getTagName(openElement);
            const ns = this.treeAdapter.getNamespaceURI(openElement);

            if (tn === $$1.TEMPLATE && ns === NS$1.HTML) {
                location.parent = this.treeAdapter.getTemplateContent(openElement);
                break;
            } else if (tn === $$1.TABLE) {
                location.parent = this.treeAdapter.getParentNode(openElement);

                if (location.parent) {
                    location.beforeElement = openElement;
                } else {
                    location.parent = this.openElements.items[i - 1];
                }

                break;
            }
        }

        if (!location.parent) {
            location.parent = this.openElements.items[0];
        }

        return location;
    }

    _fosterParentElement(element) {
        const location = this._findFosterParentingLocation();

        if (location.beforeElement) {
            this.treeAdapter.insertBefore(location.parent, element, location.beforeElement);
        } else {
            this.treeAdapter.appendChild(location.parent, element);
        }
    }

    _fosterParentText(chars) {
        const location = this._findFosterParentingLocation();

        if (location.beforeElement) {
            this.treeAdapter.insertTextBefore(location.parent, chars, location.beforeElement);
        } else {
            this.treeAdapter.insertText(location.parent, chars);
        }
    }

    //Special elements
    _isSpecialElement(element) {
        const tn = this.treeAdapter.getTagName(element);
        const ns = this.treeAdapter.getNamespaceURI(element);

        return HTML$1.SPECIAL_ELEMENTS[ns][tn];
    }
}

var parser = Parser$1;

//Adoption agency algorithm
//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#adoptionAgency)
//------------------------------------------------------------------

//Steps 5-8 of the algorithm
function aaObtainFormattingElementEntry(p, token) {
    let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);

    if (formattingElementEntry) {
        if (!p.openElements.contains(formattingElementEntry.element)) {
            p.activeFormattingElements.removeEntry(formattingElementEntry);
            formattingElementEntry = null;
        } else if (!p.openElements.hasInScope(token.tagName)) {
            formattingElementEntry = null;
        }
    } else {
        genericEndTagInBody(p, token);
    }

    return formattingElementEntry;
}

//Steps 9 and 10 of the algorithm
function aaObtainFurthestBlock(p, formattingElementEntry) {
    let furthestBlock = null;

    for (let i = p.openElements.stackTop; i >= 0; i--) {
        const element = p.openElements.items[i];

        if (element === formattingElementEntry.element) {
            break;
        }

        if (p._isSpecialElement(element)) {
            furthestBlock = element;
        }
    }

    if (!furthestBlock) {
        p.openElements.popUntilElementPopped(formattingElementEntry.element);
        p.activeFormattingElements.removeEntry(formattingElementEntry);
    }

    return furthestBlock;
}

//Step 13 of the algorithm
function aaInnerLoop(p, furthestBlock, formattingElement) {
    let lastElement = furthestBlock;
    let nextElement = p.openElements.getCommonAncestor(furthestBlock);

    for (let i = 0, element = nextElement; element !== formattingElement; i++, element = nextElement) {
        //NOTE: store next element for the next loop iteration (it may be deleted from the stack by step 9.5)
        nextElement = p.openElements.getCommonAncestor(element);

        const elementEntry = p.activeFormattingElements.getElementEntry(element);
        const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
        const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;

        if (shouldRemoveFromOpenElements) {
            if (counterOverflow) {
                p.activeFormattingElements.removeEntry(elementEntry);
            }

            p.openElements.remove(element);
        } else {
            element = aaRecreateElementFromEntry(p, elementEntry);

            if (lastElement === furthestBlock) {
                p.activeFormattingElements.bookmark = elementEntry;
            }

            p.treeAdapter.detachNode(lastElement);
            p.treeAdapter.appendChild(element, lastElement);
            lastElement = element;
        }
    }

    return lastElement;
}

//Step 13.7 of the algorithm
function aaRecreateElementFromEntry(p, elementEntry) {
    const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);
    const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);

    p.openElements.replace(elementEntry.element, newElement);
    elementEntry.element = newElement;

    return newElement;
}

//Step 14 of the algorithm
function aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {
    if (p._isElementCausesFosterParenting(commonAncestor)) {
        p._fosterParentElement(lastElement);
    } else {
        const tn = p.treeAdapter.getTagName(commonAncestor);
        const ns = p.treeAdapter.getNamespaceURI(commonAncestor);

        if (tn === $$1.TEMPLATE && ns === NS$1.HTML) {
            commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);
        }

        p.treeAdapter.appendChild(commonAncestor, lastElement);
    }
}

//Steps 15-19 of the algorithm
function aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {
    const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);
    const token = formattingElementEntry.token;
    const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);

    p._adoptNodes(furthestBlock, newElement);
    p.treeAdapter.appendChild(furthestBlock, newElement);

    p.activeFormattingElements.insertElementAfterBookmark(newElement, formattingElementEntry.token);
    p.activeFormattingElements.removeEntry(formattingElementEntry);

    p.openElements.remove(formattingElementEntry.element);
    p.openElements.insertAfter(furthestBlock, newElement);
}

//Algorithm entry point
function callAdoptionAgency(p, token) {
    let formattingElementEntry;

    for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
        formattingElementEntry = aaObtainFormattingElementEntry(p, token);

        if (!formattingElementEntry) {
            break;
        }

        const furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);

        if (!furthestBlock) {
            break;
        }

        p.activeFormattingElements.bookmark = formattingElementEntry;

        const lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element);
        const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);

        p.treeAdapter.detachNode(lastElement);
        aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);
        aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);
    }
}

//Generic token handlers
//------------------------------------------------------------------
function ignoreToken() {
    //NOTE: do nothing =)
}

function misplacedDoctype(p) {
    p._err(ERR.misplacedDoctype);
}

function appendComment(p, token) {
    p._appendCommentNode(token, p.openElements.currentTmplContent || p.openElements.current);
}

function appendCommentToRootHtmlElement(p, token) {
    p._appendCommentNode(token, p.openElements.items[0]);
}

function appendCommentToDocument(p, token) {
    p._appendCommentNode(token, p.document);
}

function insertCharacters(p, token) {
    p._insertCharacters(token);
}

function stopParsing(p) {
    p.stopped = true;
}

// The "initial" insertion mode
//------------------------------------------------------------------
function doctypeInInitialMode(p, token) {
    p._setDocumentType(token);

    const mode = token.forceQuirks ? HTML$1.DOCUMENT_MODE.QUIRKS : doctype$2.getDocumentMode(token);

    if (!doctype$2.isConforming(token)) {
        p._err(ERR.nonConformingDoctype);
    }

    p.treeAdapter.setDocumentMode(p.document, mode);

    p.insertionMode = BEFORE_HTML_MODE;
}

function tokenInInitialMode(p, token) {
    p._err(ERR.missingDoctype, { beforeToken: true });
    p.treeAdapter.setDocumentMode(p.document, HTML$1.DOCUMENT_MODE.QUIRKS);
    p.insertionMode = BEFORE_HTML_MODE;
    p._processToken(token);
}

// The "before html" insertion mode
//------------------------------------------------------------------
function startTagBeforeHtml(p, token) {
    if (token.tagName === $$1.HTML) {
        p._insertElement(token, NS$1.HTML);
        p.insertionMode = BEFORE_HEAD_MODE;
    } else {
        tokenBeforeHtml(p, token);
    }
}

function endTagBeforeHtml(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HTML || tn === $$1.HEAD || tn === $$1.BODY || tn === $$1.BR) {
        tokenBeforeHtml(p, token);
    }
}

function tokenBeforeHtml(p, token) {
    p._insertFakeRootElement();
    p.insertionMode = BEFORE_HEAD_MODE;
    p._processToken(token);
}

// The "before head" insertion mode
//------------------------------------------------------------------
function startTagBeforeHead(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HTML) {
        startTagInBody(p, token);
    } else if (tn === $$1.HEAD) {
        p._insertElement(token, NS$1.HTML);
        p.headElement = p.openElements.current;
        p.insertionMode = IN_HEAD_MODE;
    } else {
        tokenBeforeHead(p, token);
    }
}

function endTagBeforeHead(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HEAD || tn === $$1.BODY || tn === $$1.HTML || tn === $$1.BR) {
        tokenBeforeHead(p, token);
    } else {
        p._err(ERR.endTagWithoutMatchingOpenElement);
    }
}

function tokenBeforeHead(p, token) {
    p._insertFakeElement($$1.HEAD);
    p.headElement = p.openElements.current;
    p.insertionMode = IN_HEAD_MODE;
    p._processToken(token);
}

// The "in head" insertion mode
//------------------------------------------------------------------
function startTagInHead(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HTML) {
        startTagInBody(p, token);
    } else if (tn === $$1.BASE || tn === $$1.BASEFONT || tn === $$1.BGSOUND || tn === $$1.LINK || tn === $$1.META) {
        p._appendElement(token, NS$1.HTML);
        token.ackSelfClosing = true;
    } else if (tn === $$1.TITLE) {
        p._switchToTextParsing(token, Tokenizer.MODE.RCDATA);
    } else if (tn === $$1.NOSCRIPT) {
        if (p.options.scriptingEnabled) {
            p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
        } else {
            p._insertElement(token, NS$1.HTML);
            p.insertionMode = IN_HEAD_NO_SCRIPT_MODE;
        }
    } else if (tn === $$1.NOFRAMES || tn === $$1.STYLE) {
        p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
    } else if (tn === $$1.SCRIPT) {
        p._switchToTextParsing(token, Tokenizer.MODE.SCRIPT_DATA);
    } else if (tn === $$1.TEMPLATE) {
        p._insertTemplate(token, NS$1.HTML);
        p.activeFormattingElements.insertMarker();
        p.framesetOk = false;
        p.insertionMode = IN_TEMPLATE_MODE;
        p._pushTmplInsertionMode(IN_TEMPLATE_MODE);
    } else if (tn === $$1.HEAD) {
        p._err(ERR.misplacedStartTagForHeadElement);
    } else {
        tokenInHead(p, token);
    }
}

function endTagInHead(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HEAD) {
        p.openElements.pop();
        p.insertionMode = AFTER_HEAD_MODE;
    } else if (tn === $$1.BODY || tn === $$1.BR || tn === $$1.HTML) {
        tokenInHead(p, token);
    } else if (tn === $$1.TEMPLATE) {
        if (p.openElements.tmplCount > 0) {
            p.openElements.generateImpliedEndTagsThoroughly();

            if (p.openElements.currentTagName !== $$1.TEMPLATE) {
                p._err(ERR.closingOfElementWithOpenChildElements);
            }

            p.openElements.popUntilTagNamePopped($$1.TEMPLATE);
            p.activeFormattingElements.clearToLastMarker();
            p._popTmplInsertionMode();
            p._resetInsertionMode();
        } else {
            p._err(ERR.endTagWithoutMatchingOpenElement);
        }
    } else {
        p._err(ERR.endTagWithoutMatchingOpenElement);
    }
}

function tokenInHead(p, token) {
    p.openElements.pop();
    p.insertionMode = AFTER_HEAD_MODE;
    p._processToken(token);
}

// The "in head no script" insertion mode
//------------------------------------------------------------------
function startTagInHeadNoScript(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HTML) {
        startTagInBody(p, token);
    } else if (
        tn === $$1.BASEFONT ||
        tn === $$1.BGSOUND ||
        tn === $$1.HEAD ||
        tn === $$1.LINK ||
        tn === $$1.META ||
        tn === $$1.NOFRAMES ||
        tn === $$1.STYLE
    ) {
        startTagInHead(p, token);
    } else if (tn === $$1.NOSCRIPT) {
        p._err(ERR.nestedNoscriptInHead);
    } else {
        tokenInHeadNoScript(p, token);
    }
}

function endTagInHeadNoScript(p, token) {
    const tn = token.tagName;

    if (tn === $$1.NOSCRIPT) {
        p.openElements.pop();
        p.insertionMode = IN_HEAD_MODE;
    } else if (tn === $$1.BR) {
        tokenInHeadNoScript(p, token);
    } else {
        p._err(ERR.endTagWithoutMatchingOpenElement);
    }
}

function tokenInHeadNoScript(p, token) {
    const errCode =
        token.type === Tokenizer.EOF_TOKEN ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;

    p._err(errCode);
    p.openElements.pop();
    p.insertionMode = IN_HEAD_MODE;
    p._processToken(token);
}

// The "after head" insertion mode
//------------------------------------------------------------------
function startTagAfterHead(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HTML) {
        startTagInBody(p, token);
    } else if (tn === $$1.BODY) {
        p._insertElement(token, NS$1.HTML);
        p.framesetOk = false;
        p.insertionMode = IN_BODY_MODE;
    } else if (tn === $$1.FRAMESET) {
        p._insertElement(token, NS$1.HTML);
        p.insertionMode = IN_FRAMESET_MODE;
    } else if (
        tn === $$1.BASE ||
        tn === $$1.BASEFONT ||
        tn === $$1.BGSOUND ||
        tn === $$1.LINK ||
        tn === $$1.META ||
        tn === $$1.NOFRAMES ||
        tn === $$1.SCRIPT ||
        tn === $$1.STYLE ||
        tn === $$1.TEMPLATE ||
        tn === $$1.TITLE
    ) {
        p._err(ERR.abandonedHeadElementChild);
        p.openElements.push(p.headElement);
        startTagInHead(p, token);
        p.openElements.remove(p.headElement);
    } else if (tn === $$1.HEAD) {
        p._err(ERR.misplacedStartTagForHeadElement);
    } else {
        tokenAfterHead(p, token);
    }
}

function endTagAfterHead(p, token) {
    const tn = token.tagName;

    if (tn === $$1.BODY || tn === $$1.HTML || tn === $$1.BR) {
        tokenAfterHead(p, token);
    } else if (tn === $$1.TEMPLATE) {
        endTagInHead(p, token);
    } else {
        p._err(ERR.endTagWithoutMatchingOpenElement);
    }
}

function tokenAfterHead(p, token) {
    p._insertFakeElement($$1.BODY);
    p.insertionMode = IN_BODY_MODE;
    p._processToken(token);
}

// The "in body" insertion mode
//------------------------------------------------------------------
function whitespaceCharacterInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertCharacters(token);
}

function characterInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertCharacters(token);
    p.framesetOk = false;
}

function htmlStartTagInBody(p, token) {
    if (p.openElements.tmplCount === 0) {
        p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
    }
}

function bodyStartTagInBody(p, token) {
    const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();

    if (bodyElement && p.openElements.tmplCount === 0) {
        p.framesetOk = false;
        p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
    }
}

function framesetStartTagInBody(p, token) {
    const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();

    if (p.framesetOk && bodyElement) {
        p.treeAdapter.detachNode(bodyElement);
        p.openElements.popAllUpToHtmlElement();
        p._insertElement(token, NS$1.HTML);
        p.insertionMode = IN_FRAMESET_MODE;
    }
}

function addressStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($$1.P)) {
        p._closePElement();
    }

    p._insertElement(token, NS$1.HTML);
}

function numberedHeaderStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($$1.P)) {
        p._closePElement();
    }

    const tn = p.openElements.currentTagName;

    if (tn === $$1.H1 || tn === $$1.H2 || tn === $$1.H3 || tn === $$1.H4 || tn === $$1.H5 || tn === $$1.H6) {
        p.openElements.pop();
    }

    p._insertElement(token, NS$1.HTML);
}

function preStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($$1.P)) {
        p._closePElement();
    }

    p._insertElement(token, NS$1.HTML);
    //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
    //on to the next one. (Newlines at the start of pre blocks are ignored as an authoring convenience.)
    p.skipNextNewLine = true;
    p.framesetOk = false;
}

function formStartTagInBody(p, token) {
    const inTemplate = p.openElements.tmplCount > 0;

    if (!p.formElement || inTemplate) {
        if (p.openElements.hasInButtonScope($$1.P)) {
            p._closePElement();
        }

        p._insertElement(token, NS$1.HTML);

        if (!inTemplate) {
            p.formElement = p.openElements.current;
        }
    }
}

function listItemStartTagInBody(p, token) {
    p.framesetOk = false;

    const tn = token.tagName;

    for (let i = p.openElements.stackTop; i >= 0; i--) {
        const element = p.openElements.items[i];
        const elementTn = p.treeAdapter.getTagName(element);
        let closeTn = null;

        if (tn === $$1.LI && elementTn === $$1.LI) {
            closeTn = $$1.LI;
        } else if ((tn === $$1.DD || tn === $$1.DT) && (elementTn === $$1.DD || elementTn === $$1.DT)) {
            closeTn = elementTn;
        }

        if (closeTn) {
            p.openElements.generateImpliedEndTagsWithExclusion(closeTn);
            p.openElements.popUntilTagNamePopped(closeTn);
            break;
        }

        if (elementTn !== $$1.ADDRESS && elementTn !== $$1.DIV && elementTn !== $$1.P && p._isSpecialElement(element)) {
            break;
        }
    }

    if (p.openElements.hasInButtonScope($$1.P)) {
        p._closePElement();
    }

    p._insertElement(token, NS$1.HTML);
}

function plaintextStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($$1.P)) {
        p._closePElement();
    }

    p._insertElement(token, NS$1.HTML);
    p.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
}

function buttonStartTagInBody(p, token) {
    if (p.openElements.hasInScope($$1.BUTTON)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped($$1.BUTTON);
    }

    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS$1.HTML);
    p.framesetOk = false;
}

function aStartTagInBody(p, token) {
    const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName($$1.A);

    if (activeElementEntry) {
        callAdoptionAgency(p, token);
        p.openElements.remove(activeElementEntry.element);
        p.activeFormattingElements.removeEntry(activeElementEntry);
    }

    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS$1.HTML);
    p.activeFormattingElements.pushElement(p.openElements.current, token);
}

function bStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS$1.HTML);
    p.activeFormattingElements.pushElement(p.openElements.current, token);
}

function nobrStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();

    if (p.openElements.hasInScope($$1.NOBR)) {
        callAdoptionAgency(p, token);
        p._reconstructActiveFormattingElements();
    }

    p._insertElement(token, NS$1.HTML);
    p.activeFormattingElements.pushElement(p.openElements.current, token);
}

function appletStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS$1.HTML);
    p.activeFormattingElements.insertMarker();
    p.framesetOk = false;
}

function tableStartTagInBody(p, token) {
    if (
        p.treeAdapter.getDocumentMode(p.document) !== HTML$1.DOCUMENT_MODE.QUIRKS &&
        p.openElements.hasInButtonScope($$1.P)
    ) {
        p._closePElement();
    }

    p._insertElement(token, NS$1.HTML);
    p.framesetOk = false;
    p.insertionMode = IN_TABLE_MODE;
}

function areaStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._appendElement(token, NS$1.HTML);
    p.framesetOk = false;
    token.ackSelfClosing = true;
}

function inputStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._appendElement(token, NS$1.HTML);

    const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);

    if (!inputType || inputType.toLowerCase() !== HIDDEN_INPUT_TYPE) {
        p.framesetOk = false;
    }

    token.ackSelfClosing = true;
}

function paramStartTagInBody(p, token) {
    p._appendElement(token, NS$1.HTML);
    token.ackSelfClosing = true;
}

function hrStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($$1.P)) {
        p._closePElement();
    }

    p._appendElement(token, NS$1.HTML);
    p.framesetOk = false;
    token.ackSelfClosing = true;
}

function imageStartTagInBody(p, token) {
    token.tagName = $$1.IMG;
    areaStartTagInBody(p, token);
}

function textareaStartTagInBody(p, token) {
    p._insertElement(token, NS$1.HTML);
    //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
    //on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
    p.skipNextNewLine = true;
    p.tokenizer.state = Tokenizer.MODE.RCDATA;
    p.originalInsertionMode = p.insertionMode;
    p.framesetOk = false;
    p.insertionMode = TEXT_MODE;
}

function xmpStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($$1.P)) {
        p._closePElement();
    }

    p._reconstructActiveFormattingElements();
    p.framesetOk = false;
    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
}

function iframeStartTagInBody(p, token) {
    p.framesetOk = false;
    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
}

//NOTE: here we assume that we always act as an user agent with enabled plugins, so we parse
//<noembed> as a rawtext.
function noembedStartTagInBody(p, token) {
    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
}

function selectStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS$1.HTML);
    p.framesetOk = false;

    if (
        p.insertionMode === IN_TABLE_MODE ||
        p.insertionMode === IN_CAPTION_MODE ||
        p.insertionMode === IN_TABLE_BODY_MODE ||
        p.insertionMode === IN_ROW_MODE ||
        p.insertionMode === IN_CELL_MODE
    ) {
        p.insertionMode = IN_SELECT_IN_TABLE_MODE;
    } else {
        p.insertionMode = IN_SELECT_MODE;
    }
}

function optgroupStartTagInBody(p, token) {
    if (p.openElements.currentTagName === $$1.OPTION) {
        p.openElements.pop();
    }

    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS$1.HTML);
}

function rbStartTagInBody(p, token) {
    if (p.openElements.hasInScope($$1.RUBY)) {
        p.openElements.generateImpliedEndTags();
    }

    p._insertElement(token, NS$1.HTML);
}

function rtStartTagInBody(p, token) {
    if (p.openElements.hasInScope($$1.RUBY)) {
        p.openElements.generateImpliedEndTagsWithExclusion($$1.RTC);
    }

    p._insertElement(token, NS$1.HTML);
}

function menuStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($$1.P)) {
        p._closePElement();
    }

    p._insertElement(token, NS$1.HTML);
}

function mathStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();

    foreignContent.adjustTokenMathMLAttrs(token);
    foreignContent.adjustTokenXMLAttrs(token);

    if (token.selfClosing) {
        p._appendElement(token, NS$1.MATHML);
    } else {
        p._insertElement(token, NS$1.MATHML);
    }

    token.ackSelfClosing = true;
}

function svgStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();

    foreignContent.adjustTokenSVGAttrs(token);
    foreignContent.adjustTokenXMLAttrs(token);

    if (token.selfClosing) {
        p._appendElement(token, NS$1.SVG);
    } else {
        p._insertElement(token, NS$1.SVG);
    }

    token.ackSelfClosing = true;
}

function genericStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS$1.HTML);
}

//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
//It's faster than using dictionary.
function startTagInBody(p, token) {
    const tn = token.tagName;

    switch (tn.length) {
        case 1:
            if (tn === $$1.I || tn === $$1.S || tn === $$1.B || tn === $$1.U) {
                bStartTagInBody(p, token);
            } else if (tn === $$1.P) {
                addressStartTagInBody(p, token);
            } else if (tn === $$1.A) {
                aStartTagInBody(p, token);
            } else {
                genericStartTagInBody(p, token);
            }

            break;

        case 2:
            if (tn === $$1.DL || tn === $$1.OL || tn === $$1.UL) {
                addressStartTagInBody(p, token);
            } else if (tn === $$1.H1 || tn === $$1.H2 || tn === $$1.H3 || tn === $$1.H4 || tn === $$1.H5 || tn === $$1.H6) {
                numberedHeaderStartTagInBody(p, token);
            } else if (tn === $$1.LI || tn === $$1.DD || tn === $$1.DT) {
                listItemStartTagInBody(p, token);
            } else if (tn === $$1.EM || tn === $$1.TT) {
                bStartTagInBody(p, token);
            } else if (tn === $$1.BR) {
                areaStartTagInBody(p, token);
            } else if (tn === $$1.HR) {
                hrStartTagInBody(p, token);
            } else if (tn === $$1.RB) {
                rbStartTagInBody(p, token);
            } else if (tn === $$1.RT || tn === $$1.RP) {
                rtStartTagInBody(p, token);
            } else if (tn !== $$1.TH && tn !== $$1.TD && tn !== $$1.TR) {
                genericStartTagInBody(p, token);
            }

            break;

        case 3:
            if (tn === $$1.DIV || tn === $$1.DIR || tn === $$1.NAV) {
                addressStartTagInBody(p, token);
            } else if (tn === $$1.PRE) {
                preStartTagInBody(p, token);
            } else if (tn === $$1.BIG) {
                bStartTagInBody(p, token);
            } else if (tn === $$1.IMG || tn === $$1.WBR) {
                areaStartTagInBody(p, token);
            } else if (tn === $$1.XMP) {
                xmpStartTagInBody(p, token);
            } else if (tn === $$1.SVG) {
                svgStartTagInBody(p, token);
            } else if (tn === $$1.RTC) {
                rbStartTagInBody(p, token);
            } else if (tn !== $$1.COL) {
                genericStartTagInBody(p, token);
            }

            break;

        case 4:
            if (tn === $$1.HTML) {
                htmlStartTagInBody(p, token);
            } else if (tn === $$1.BASE || tn === $$1.LINK || tn === $$1.META) {
                startTagInHead(p, token);
            } else if (tn === $$1.BODY) {
                bodyStartTagInBody(p, token);
            } else if (tn === $$1.MAIN || tn === $$1.MENU) {
                addressStartTagInBody(p, token);
            } else if (tn === $$1.FORM) {
                formStartTagInBody(p, token);
            } else if (tn === $$1.CODE || tn === $$1.FONT) {
                bStartTagInBody(p, token);
            } else if (tn === $$1.NOBR) {
                nobrStartTagInBody(p, token);
            } else if (tn === $$1.AREA) {
                areaStartTagInBody(p, token);
            } else if (tn === $$1.MATH) {
                mathStartTagInBody(p, token);
            } else if (tn === $$1.MENU) {
                menuStartTagInBody(p, token);
            } else if (tn !== $$1.HEAD) {
                genericStartTagInBody(p, token);
            }

            break;

        case 5:
            if (tn === $$1.STYLE || tn === $$1.TITLE) {
                startTagInHead(p, token);
            } else if (tn === $$1.ASIDE) {
                addressStartTagInBody(p, token);
            } else if (tn === $$1.SMALL) {
                bStartTagInBody(p, token);
            } else if (tn === $$1.TABLE) {
                tableStartTagInBody(p, token);
            } else if (tn === $$1.EMBED) {
                areaStartTagInBody(p, token);
            } else if (tn === $$1.INPUT) {
                inputStartTagInBody(p, token);
            } else if (tn === $$1.PARAM || tn === $$1.TRACK) {
                paramStartTagInBody(p, token);
            } else if (tn === $$1.IMAGE) {
                imageStartTagInBody(p, token);
            } else if (tn !== $$1.FRAME && tn !== $$1.TBODY && tn !== $$1.TFOOT && tn !== $$1.THEAD) {
                genericStartTagInBody(p, token);
            }

            break;

        case 6:
            if (tn === $$1.SCRIPT) {
                startTagInHead(p, token);
            } else if (
                tn === $$1.CENTER ||
                tn === $$1.FIGURE ||
                tn === $$1.FOOTER ||
                tn === $$1.HEADER ||
                tn === $$1.HGROUP ||
                tn === $$1.DIALOG
            ) {
                addressStartTagInBody(p, token);
            } else if (tn === $$1.BUTTON) {
                buttonStartTagInBody(p, token);
            } else if (tn === $$1.STRIKE || tn === $$1.STRONG) {
                bStartTagInBody(p, token);
            } else if (tn === $$1.APPLET || tn === $$1.OBJECT) {
                appletStartTagInBody(p, token);
            } else if (tn === $$1.KEYGEN) {
                areaStartTagInBody(p, token);
            } else if (tn === $$1.SOURCE) {
                paramStartTagInBody(p, token);
            } else if (tn === $$1.IFRAME) {
                iframeStartTagInBody(p, token);
            } else if (tn === $$1.SELECT) {
                selectStartTagInBody(p, token);
            } else if (tn === $$1.OPTION) {
                optgroupStartTagInBody(p, token);
            } else {
                genericStartTagInBody(p, token);
            }

            break;

        case 7:
            if (tn === $$1.BGSOUND) {
                startTagInHead(p, token);
            } else if (
                tn === $$1.DETAILS ||
                tn === $$1.ADDRESS ||
                tn === $$1.ARTICLE ||
                tn === $$1.SECTION ||
                tn === $$1.SUMMARY
            ) {
                addressStartTagInBody(p, token);
            } else if (tn === $$1.LISTING) {
                preStartTagInBody(p, token);
            } else if (tn === $$1.MARQUEE) {
                appletStartTagInBody(p, token);
            } else if (tn === $$1.NOEMBED) {
                noembedStartTagInBody(p, token);
            } else if (tn !== $$1.CAPTION) {
                genericStartTagInBody(p, token);
            }

            break;

        case 8:
            if (tn === $$1.BASEFONT) {
                startTagInHead(p, token);
            } else if (tn === $$1.FRAMESET) {
                framesetStartTagInBody(p, token);
            } else if (tn === $$1.FIELDSET) {
                addressStartTagInBody(p, token);
            } else if (tn === $$1.TEXTAREA) {
                textareaStartTagInBody(p, token);
            } else if (tn === $$1.TEMPLATE) {
                startTagInHead(p, token);
            } else if (tn === $$1.NOSCRIPT) {
                if (p.options.scriptingEnabled) {
                    noembedStartTagInBody(p, token);
                } else {
                    genericStartTagInBody(p, token);
                }
            } else if (tn === $$1.OPTGROUP) {
                optgroupStartTagInBody(p, token);
            } else if (tn !== $$1.COLGROUP) {
                genericStartTagInBody(p, token);
            }

            break;

        case 9:
            if (tn === $$1.PLAINTEXT) {
                plaintextStartTagInBody(p, token);
            } else {
                genericStartTagInBody(p, token);
            }

            break;

        case 10:
            if (tn === $$1.BLOCKQUOTE || tn === $$1.FIGCAPTION) {
                addressStartTagInBody(p, token);
            } else {
                genericStartTagInBody(p, token);
            }

            break;

        default:
            genericStartTagInBody(p, token);
    }
}

function bodyEndTagInBody(p) {
    if (p.openElements.hasInScope($$1.BODY)) {
        p.insertionMode = AFTER_BODY_MODE;
    }
}

function htmlEndTagInBody(p, token) {
    if (p.openElements.hasInScope($$1.BODY)) {
        p.insertionMode = AFTER_BODY_MODE;
        p._processToken(token);
    }
}

function addressEndTagInBody(p, token) {
    const tn = token.tagName;

    if (p.openElements.hasInScope(tn)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(tn);
    }
}

function formEndTagInBody(p) {
    const inTemplate = p.openElements.tmplCount > 0;
    const formElement = p.formElement;

    if (!inTemplate) {
        p.formElement = null;
    }

    if ((formElement || inTemplate) && p.openElements.hasInScope($$1.FORM)) {
        p.openElements.generateImpliedEndTags();

        if (inTemplate) {
            p.openElements.popUntilTagNamePopped($$1.FORM);
        } else {
            p.openElements.remove(formElement);
        }
    }
}

function pEndTagInBody(p) {
    if (!p.openElements.hasInButtonScope($$1.P)) {
        p._insertFakeElement($$1.P);
    }

    p._closePElement();
}

function liEndTagInBody(p) {
    if (p.openElements.hasInListItemScope($$1.LI)) {
        p.openElements.generateImpliedEndTagsWithExclusion($$1.LI);
        p.openElements.popUntilTagNamePopped($$1.LI);
    }
}

function ddEndTagInBody(p, token) {
    const tn = token.tagName;

    if (p.openElements.hasInScope(tn)) {
        p.openElements.generateImpliedEndTagsWithExclusion(tn);
        p.openElements.popUntilTagNamePopped(tn);
    }
}

function numberedHeaderEndTagInBody(p) {
    if (p.openElements.hasNumberedHeaderInScope()) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilNumberedHeaderPopped();
    }
}

function appletEndTagInBody(p, token) {
    const tn = token.tagName;

    if (p.openElements.hasInScope(tn)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(tn);
        p.activeFormattingElements.clearToLastMarker();
    }
}

function brEndTagInBody(p) {
    p._reconstructActiveFormattingElements();
    p._insertFakeElement($$1.BR);
    p.openElements.pop();
    p.framesetOk = false;
}

function genericEndTagInBody(p, token) {
    const tn = token.tagName;

    for (let i = p.openElements.stackTop; i > 0; i--) {
        const element = p.openElements.items[i];

        if (p.treeAdapter.getTagName(element) === tn) {
            p.openElements.generateImpliedEndTagsWithExclusion(tn);
            p.openElements.popUntilElementPopped(element);
            break;
        }

        if (p._isSpecialElement(element)) {
            break;
        }
    }
}

//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
//It's faster than using dictionary.
function endTagInBody(p, token) {
    const tn = token.tagName;

    switch (tn.length) {
        case 1:
            if (tn === $$1.A || tn === $$1.B || tn === $$1.I || tn === $$1.S || tn === $$1.U) {
                callAdoptionAgency(p, token);
            } else if (tn === $$1.P) {
                pEndTagInBody(p);
            } else {
                genericEndTagInBody(p, token);
            }

            break;

        case 2:
            if (tn === $$1.DL || tn === $$1.UL || tn === $$1.OL) {
                addressEndTagInBody(p, token);
            } else if (tn === $$1.LI) {
                liEndTagInBody(p);
            } else if (tn === $$1.DD || tn === $$1.DT) {
                ddEndTagInBody(p, token);
            } else if (tn === $$1.H1 || tn === $$1.H2 || tn === $$1.H3 || tn === $$1.H4 || tn === $$1.H5 || tn === $$1.H6) {
                numberedHeaderEndTagInBody(p);
            } else if (tn === $$1.BR) {
                brEndTagInBody(p);
            } else if (tn === $$1.EM || tn === $$1.TT) {
                callAdoptionAgency(p, token);
            } else {
                genericEndTagInBody(p, token);
            }

            break;

        case 3:
            if (tn === $$1.BIG) {
                callAdoptionAgency(p, token);
            } else if (tn === $$1.DIR || tn === $$1.DIV || tn === $$1.NAV || tn === $$1.PRE) {
                addressEndTagInBody(p, token);
            } else {
                genericEndTagInBody(p, token);
            }

            break;

        case 4:
            if (tn === $$1.BODY) {
                bodyEndTagInBody(p);
            } else if (tn === $$1.HTML) {
                htmlEndTagInBody(p, token);
            } else if (tn === $$1.FORM) {
                formEndTagInBody(p);
            } else if (tn === $$1.CODE || tn === $$1.FONT || tn === $$1.NOBR) {
                callAdoptionAgency(p, token);
            } else if (tn === $$1.MAIN || tn === $$1.MENU) {
                addressEndTagInBody(p, token);
            } else {
                genericEndTagInBody(p, token);
            }

            break;

        case 5:
            if (tn === $$1.ASIDE) {
                addressEndTagInBody(p, token);
            } else if (tn === $$1.SMALL) {
                callAdoptionAgency(p, token);
            } else {
                genericEndTagInBody(p, token);
            }

            break;

        case 6:
            if (
                tn === $$1.CENTER ||
                tn === $$1.FIGURE ||
                tn === $$1.FOOTER ||
                tn === $$1.HEADER ||
                tn === $$1.HGROUP ||
                tn === $$1.DIALOG
            ) {
                addressEndTagInBody(p, token);
            } else if (tn === $$1.APPLET || tn === $$1.OBJECT) {
                appletEndTagInBody(p, token);
            } else if (tn === $$1.STRIKE || tn === $$1.STRONG) {
                callAdoptionAgency(p, token);
            } else {
                genericEndTagInBody(p, token);
            }

            break;

        case 7:
            if (
                tn === $$1.ADDRESS ||
                tn === $$1.ARTICLE ||
                tn === $$1.DETAILS ||
                tn === $$1.SECTION ||
                tn === $$1.SUMMARY ||
                tn === $$1.LISTING
            ) {
                addressEndTagInBody(p, token);
            } else if (tn === $$1.MARQUEE) {
                appletEndTagInBody(p, token);
            } else {
                genericEndTagInBody(p, token);
            }

            break;

        case 8:
            if (tn === $$1.FIELDSET) {
                addressEndTagInBody(p, token);
            } else if (tn === $$1.TEMPLATE) {
                endTagInHead(p, token);
            } else {
                genericEndTagInBody(p, token);
            }

            break;

        case 10:
            if (tn === $$1.BLOCKQUOTE || tn === $$1.FIGCAPTION) {
                addressEndTagInBody(p, token);
            } else {
                genericEndTagInBody(p, token);
            }

            break;

        default:
            genericEndTagInBody(p, token);
    }
}

function eofInBody(p, token) {
    if (p.tmplInsertionModeStackTop > -1) {
        eofInTemplate(p, token);
    } else {
        p.stopped = true;
    }
}

// The "text" insertion mode
//------------------------------------------------------------------
function endTagInText(p, token) {
    if (token.tagName === $$1.SCRIPT) {
        p.pendingScript = p.openElements.current;
    }

    p.openElements.pop();
    p.insertionMode = p.originalInsertionMode;
}

function eofInText(p, token) {
    p._err(ERR.eofInElementThatCanContainOnlyText);
    p.openElements.pop();
    p.insertionMode = p.originalInsertionMode;
    p._processToken(token);
}

// The "in table" insertion mode
//------------------------------------------------------------------
function characterInTable(p, token) {
    const curTn = p.openElements.currentTagName;

    if (curTn === $$1.TABLE || curTn === $$1.TBODY || curTn === $$1.TFOOT || curTn === $$1.THEAD || curTn === $$1.TR) {
        p.pendingCharacterTokens = [];
        p.hasNonWhitespacePendingCharacterToken = false;
        p.originalInsertionMode = p.insertionMode;
        p.insertionMode = IN_TABLE_TEXT_MODE;
        p._processToken(token);
    } else {
        tokenInTable(p, token);
    }
}

function captionStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p.activeFormattingElements.insertMarker();
    p._insertElement(token, NS$1.HTML);
    p.insertionMode = IN_CAPTION_MODE;
}

function colgroupStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p._insertElement(token, NS$1.HTML);
    p.insertionMode = IN_COLUMN_GROUP_MODE;
}

function colStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p._insertFakeElement($$1.COLGROUP);
    p.insertionMode = IN_COLUMN_GROUP_MODE;
    p._processToken(token);
}

function tbodyStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p._insertElement(token, NS$1.HTML);
    p.insertionMode = IN_TABLE_BODY_MODE;
}

function tdStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p._insertFakeElement($$1.TBODY);
    p.insertionMode = IN_TABLE_BODY_MODE;
    p._processToken(token);
}

function tableStartTagInTable(p, token) {
    if (p.openElements.hasInTableScope($$1.TABLE)) {
        p.openElements.popUntilTagNamePopped($$1.TABLE);
        p._resetInsertionMode();
        p._processToken(token);
    }
}

function inputStartTagInTable(p, token) {
    const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);

    if (inputType && inputType.toLowerCase() === HIDDEN_INPUT_TYPE) {
        p._appendElement(token, NS$1.HTML);
    } else {
        tokenInTable(p, token);
    }

    token.ackSelfClosing = true;
}

function formStartTagInTable(p, token) {
    if (!p.formElement && p.openElements.tmplCount === 0) {
        p._insertElement(token, NS$1.HTML);
        p.formElement = p.openElements.current;
        p.openElements.pop();
    }
}

function startTagInTable(p, token) {
    const tn = token.tagName;

    switch (tn.length) {
        case 2:
            if (tn === $$1.TD || tn === $$1.TH || tn === $$1.TR) {
                tdStartTagInTable(p, token);
            } else {
                tokenInTable(p, token);
            }

            break;

        case 3:
            if (tn === $$1.COL) {
                colStartTagInTable(p, token);
            } else {
                tokenInTable(p, token);
            }

            break;

        case 4:
            if (tn === $$1.FORM) {
                formStartTagInTable(p, token);
            } else {
                tokenInTable(p, token);
            }

            break;

        case 5:
            if (tn === $$1.TABLE) {
                tableStartTagInTable(p, token);
            } else if (tn === $$1.STYLE) {
                startTagInHead(p, token);
            } else if (tn === $$1.TBODY || tn === $$1.TFOOT || tn === $$1.THEAD) {
                tbodyStartTagInTable(p, token);
            } else if (tn === $$1.INPUT) {
                inputStartTagInTable(p, token);
            } else {
                tokenInTable(p, token);
            }

            break;

        case 6:
            if (tn === $$1.SCRIPT) {
                startTagInHead(p, token);
            } else {
                tokenInTable(p, token);
            }

            break;

        case 7:
            if (tn === $$1.CAPTION) {
                captionStartTagInTable(p, token);
            } else {
                tokenInTable(p, token);
            }

            break;

        case 8:
            if (tn === $$1.COLGROUP) {
                colgroupStartTagInTable(p, token);
            } else if (tn === $$1.TEMPLATE) {
                startTagInHead(p, token);
            } else {
                tokenInTable(p, token);
            }

            break;

        default:
            tokenInTable(p, token);
    }
}

function endTagInTable(p, token) {
    const tn = token.tagName;

    if (tn === $$1.TABLE) {
        if (p.openElements.hasInTableScope($$1.TABLE)) {
            p.openElements.popUntilTagNamePopped($$1.TABLE);
            p._resetInsertionMode();
        }
    } else if (tn === $$1.TEMPLATE) {
        endTagInHead(p, token);
    } else if (
        tn !== $$1.BODY &&
        tn !== $$1.CAPTION &&
        tn !== $$1.COL &&
        tn !== $$1.COLGROUP &&
        tn !== $$1.HTML &&
        tn !== $$1.TBODY &&
        tn !== $$1.TD &&
        tn !== $$1.TFOOT &&
        tn !== $$1.TH &&
        tn !== $$1.THEAD &&
        tn !== $$1.TR
    ) {
        tokenInTable(p, token);
    }
}

function tokenInTable(p, token) {
    const savedFosterParentingState = p.fosterParentingEnabled;

    p.fosterParentingEnabled = true;
    p._processTokenInBodyMode(token);
    p.fosterParentingEnabled = savedFosterParentingState;
}

// The "in table text" insertion mode
//------------------------------------------------------------------
function whitespaceCharacterInTableText(p, token) {
    p.pendingCharacterTokens.push(token);
}

function characterInTableText(p, token) {
    p.pendingCharacterTokens.push(token);
    p.hasNonWhitespacePendingCharacterToken = true;
}

function tokenInTableText(p, token) {
    let i = 0;

    if (p.hasNonWhitespacePendingCharacterToken) {
        for (; i < p.pendingCharacterTokens.length; i++) {
            tokenInTable(p, p.pendingCharacterTokens[i]);
        }
    } else {
        for (; i < p.pendingCharacterTokens.length; i++) {
            p._insertCharacters(p.pendingCharacterTokens[i]);
        }
    }

    p.insertionMode = p.originalInsertionMode;
    p._processToken(token);
}

// The "in caption" insertion mode
//------------------------------------------------------------------
function startTagInCaption(p, token) {
    const tn = token.tagName;

    if (
        tn === $$1.CAPTION ||
        tn === $$1.COL ||
        tn === $$1.COLGROUP ||
        tn === $$1.TBODY ||
        tn === $$1.TD ||
        tn === $$1.TFOOT ||
        tn === $$1.TH ||
        tn === $$1.THEAD ||
        tn === $$1.TR
    ) {
        if (p.openElements.hasInTableScope($$1.CAPTION)) {
            p.openElements.generateImpliedEndTags();
            p.openElements.popUntilTagNamePopped($$1.CAPTION);
            p.activeFormattingElements.clearToLastMarker();
            p.insertionMode = IN_TABLE_MODE;
            p._processToken(token);
        }
    } else {
        startTagInBody(p, token);
    }
}

function endTagInCaption(p, token) {
    const tn = token.tagName;

    if (tn === $$1.CAPTION || tn === $$1.TABLE) {
        if (p.openElements.hasInTableScope($$1.CAPTION)) {
            p.openElements.generateImpliedEndTags();
            p.openElements.popUntilTagNamePopped($$1.CAPTION);
            p.activeFormattingElements.clearToLastMarker();
            p.insertionMode = IN_TABLE_MODE;

            if (tn === $$1.TABLE) {
                p._processToken(token);
            }
        }
    } else if (
        tn !== $$1.BODY &&
        tn !== $$1.COL &&
        tn !== $$1.COLGROUP &&
        tn !== $$1.HTML &&
        tn !== $$1.TBODY &&
        tn !== $$1.TD &&
        tn !== $$1.TFOOT &&
        tn !== $$1.TH &&
        tn !== $$1.THEAD &&
        tn !== $$1.TR
    ) {
        endTagInBody(p, token);
    }
}

// The "in column group" insertion mode
//------------------------------------------------------------------
function startTagInColumnGroup(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HTML) {
        startTagInBody(p, token);
    } else if (tn === $$1.COL) {
        p._appendElement(token, NS$1.HTML);
        token.ackSelfClosing = true;
    } else if (tn === $$1.TEMPLATE) {
        startTagInHead(p, token);
    } else {
        tokenInColumnGroup(p, token);
    }
}

function endTagInColumnGroup(p, token) {
    const tn = token.tagName;

    if (tn === $$1.COLGROUP) {
        if (p.openElements.currentTagName === $$1.COLGROUP) {
            p.openElements.pop();
            p.insertionMode = IN_TABLE_MODE;
        }
    } else if (tn === $$1.TEMPLATE) {
        endTagInHead(p, token);
    } else if (tn !== $$1.COL) {
        tokenInColumnGroup(p, token);
    }
}

function tokenInColumnGroup(p, token) {
    if (p.openElements.currentTagName === $$1.COLGROUP) {
        p.openElements.pop();
        p.insertionMode = IN_TABLE_MODE;
        p._processToken(token);
    }
}

// The "in table body" insertion mode
//------------------------------------------------------------------
function startTagInTableBody(p, token) {
    const tn = token.tagName;

    if (tn === $$1.TR) {
        p.openElements.clearBackToTableBodyContext();
        p._insertElement(token, NS$1.HTML);
        p.insertionMode = IN_ROW_MODE;
    } else if (tn === $$1.TH || tn === $$1.TD) {
        p.openElements.clearBackToTableBodyContext();
        p._insertFakeElement($$1.TR);
        p.insertionMode = IN_ROW_MODE;
        p._processToken(token);
    } else if (
        tn === $$1.CAPTION ||
        tn === $$1.COL ||
        tn === $$1.COLGROUP ||
        tn === $$1.TBODY ||
        tn === $$1.TFOOT ||
        tn === $$1.THEAD
    ) {
        if (p.openElements.hasTableBodyContextInTableScope()) {
            p.openElements.clearBackToTableBodyContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_MODE;
            p._processToken(token);
        }
    } else {
        startTagInTable(p, token);
    }
}

function endTagInTableBody(p, token) {
    const tn = token.tagName;

    if (tn === $$1.TBODY || tn === $$1.TFOOT || tn === $$1.THEAD) {
        if (p.openElements.hasInTableScope(tn)) {
            p.openElements.clearBackToTableBodyContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_MODE;
        }
    } else if (tn === $$1.TABLE) {
        if (p.openElements.hasTableBodyContextInTableScope()) {
            p.openElements.clearBackToTableBodyContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_MODE;
            p._processToken(token);
        }
    } else if (
        (tn !== $$1.BODY && tn !== $$1.CAPTION && tn !== $$1.COL && tn !== $$1.COLGROUP) ||
        (tn !== $$1.HTML && tn !== $$1.TD && tn !== $$1.TH && tn !== $$1.TR)
    ) {
        endTagInTable(p, token);
    }
}

// The "in row" insertion mode
//------------------------------------------------------------------
function startTagInRow(p, token) {
    const tn = token.tagName;

    if (tn === $$1.TH || tn === $$1.TD) {
        p.openElements.clearBackToTableRowContext();
        p._insertElement(token, NS$1.HTML);
        p.insertionMode = IN_CELL_MODE;
        p.activeFormattingElements.insertMarker();
    } else if (
        tn === $$1.CAPTION ||
        tn === $$1.COL ||
        tn === $$1.COLGROUP ||
        tn === $$1.TBODY ||
        tn === $$1.TFOOT ||
        tn === $$1.THEAD ||
        tn === $$1.TR
    ) {
        if (p.openElements.hasInTableScope($$1.TR)) {
            p.openElements.clearBackToTableRowContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_BODY_MODE;
            p._processToken(token);
        }
    } else {
        startTagInTable(p, token);
    }
}

function endTagInRow(p, token) {
    const tn = token.tagName;

    if (tn === $$1.TR) {
        if (p.openElements.hasInTableScope($$1.TR)) {
            p.openElements.clearBackToTableRowContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_BODY_MODE;
        }
    } else if (tn === $$1.TABLE) {
        if (p.openElements.hasInTableScope($$1.TR)) {
            p.openElements.clearBackToTableRowContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_BODY_MODE;
            p._processToken(token);
        }
    } else if (tn === $$1.TBODY || tn === $$1.TFOOT || tn === $$1.THEAD) {
        if (p.openElements.hasInTableScope(tn) || p.openElements.hasInTableScope($$1.TR)) {
            p.openElements.clearBackToTableRowContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_BODY_MODE;
            p._processToken(token);
        }
    } else if (
        (tn !== $$1.BODY && tn !== $$1.CAPTION && tn !== $$1.COL && tn !== $$1.COLGROUP) ||
        (tn !== $$1.HTML && tn !== $$1.TD && tn !== $$1.TH)
    ) {
        endTagInTable(p, token);
    }
}

// The "in cell" insertion mode
//------------------------------------------------------------------
function startTagInCell(p, token) {
    const tn = token.tagName;

    if (
        tn === $$1.CAPTION ||
        tn === $$1.COL ||
        tn === $$1.COLGROUP ||
        tn === $$1.TBODY ||
        tn === $$1.TD ||
        tn === $$1.TFOOT ||
        tn === $$1.TH ||
        tn === $$1.THEAD ||
        tn === $$1.TR
    ) {
        if (p.openElements.hasInTableScope($$1.TD) || p.openElements.hasInTableScope($$1.TH)) {
            p._closeTableCell();
            p._processToken(token);
        }
    } else {
        startTagInBody(p, token);
    }
}

function endTagInCell(p, token) {
    const tn = token.tagName;

    if (tn === $$1.TD || tn === $$1.TH) {
        if (p.openElements.hasInTableScope(tn)) {
            p.openElements.generateImpliedEndTags();
            p.openElements.popUntilTagNamePopped(tn);
            p.activeFormattingElements.clearToLastMarker();
            p.insertionMode = IN_ROW_MODE;
        }
    } else if (tn === $$1.TABLE || tn === $$1.TBODY || tn === $$1.TFOOT || tn === $$1.THEAD || tn === $$1.TR) {
        if (p.openElements.hasInTableScope(tn)) {
            p._closeTableCell();
            p._processToken(token);
        }
    } else if (tn !== $$1.BODY && tn !== $$1.CAPTION && tn !== $$1.COL && tn !== $$1.COLGROUP && tn !== $$1.HTML) {
        endTagInBody(p, token);
    }
}

// The "in select" insertion mode
//------------------------------------------------------------------
function startTagInSelect(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HTML) {
        startTagInBody(p, token);
    } else if (tn === $$1.OPTION) {
        if (p.openElements.currentTagName === $$1.OPTION) {
            p.openElements.pop();
        }

        p._insertElement(token, NS$1.HTML);
    } else if (tn === $$1.OPTGROUP) {
        if (p.openElements.currentTagName === $$1.OPTION) {
            p.openElements.pop();
        }

        if (p.openElements.currentTagName === $$1.OPTGROUP) {
            p.openElements.pop();
        }

        p._insertElement(token, NS$1.HTML);
    } else if (tn === $$1.INPUT || tn === $$1.KEYGEN || tn === $$1.TEXTAREA || tn === $$1.SELECT) {
        if (p.openElements.hasInSelectScope($$1.SELECT)) {
            p.openElements.popUntilTagNamePopped($$1.SELECT);
            p._resetInsertionMode();

            if (tn !== $$1.SELECT) {
                p._processToken(token);
            }
        }
    } else if (tn === $$1.SCRIPT || tn === $$1.TEMPLATE) {
        startTagInHead(p, token);
    }
}

function endTagInSelect(p, token) {
    const tn = token.tagName;

    if (tn === $$1.OPTGROUP) {
        const prevOpenElement = p.openElements.items[p.openElements.stackTop - 1];
        const prevOpenElementTn = prevOpenElement && p.treeAdapter.getTagName(prevOpenElement);

        if (p.openElements.currentTagName === $$1.OPTION && prevOpenElementTn === $$1.OPTGROUP) {
            p.openElements.pop();
        }

        if (p.openElements.currentTagName === $$1.OPTGROUP) {
            p.openElements.pop();
        }
    } else if (tn === $$1.OPTION) {
        if (p.openElements.currentTagName === $$1.OPTION) {
            p.openElements.pop();
        }
    } else if (tn === $$1.SELECT && p.openElements.hasInSelectScope($$1.SELECT)) {
        p.openElements.popUntilTagNamePopped($$1.SELECT);
        p._resetInsertionMode();
    } else if (tn === $$1.TEMPLATE) {
        endTagInHead(p, token);
    }
}

//12.2.5.4.17 The "in select in table" insertion mode
//------------------------------------------------------------------
function startTagInSelectInTable(p, token) {
    const tn = token.tagName;

    if (
        tn === $$1.CAPTION ||
        tn === $$1.TABLE ||
        tn === $$1.TBODY ||
        tn === $$1.TFOOT ||
        tn === $$1.THEAD ||
        tn === $$1.TR ||
        tn === $$1.TD ||
        tn === $$1.TH
    ) {
        p.openElements.popUntilTagNamePopped($$1.SELECT);
        p._resetInsertionMode();
        p._processToken(token);
    } else {
        startTagInSelect(p, token);
    }
}

function endTagInSelectInTable(p, token) {
    const tn = token.tagName;

    if (
        tn === $$1.CAPTION ||
        tn === $$1.TABLE ||
        tn === $$1.TBODY ||
        tn === $$1.TFOOT ||
        tn === $$1.THEAD ||
        tn === $$1.TR ||
        tn === $$1.TD ||
        tn === $$1.TH
    ) {
        if (p.openElements.hasInTableScope(tn)) {
            p.openElements.popUntilTagNamePopped($$1.SELECT);
            p._resetInsertionMode();
            p._processToken(token);
        }
    } else {
        endTagInSelect(p, token);
    }
}

// The "in template" insertion mode
//------------------------------------------------------------------
function startTagInTemplate(p, token) {
    const tn = token.tagName;

    if (
        tn === $$1.BASE ||
        tn === $$1.BASEFONT ||
        tn === $$1.BGSOUND ||
        tn === $$1.LINK ||
        tn === $$1.META ||
        tn === $$1.NOFRAMES ||
        tn === $$1.SCRIPT ||
        tn === $$1.STYLE ||
        tn === $$1.TEMPLATE ||
        tn === $$1.TITLE
    ) {
        startTagInHead(p, token);
    } else {
        const newInsertionMode = TEMPLATE_INSERTION_MODE_SWITCH_MAP[tn] || IN_BODY_MODE;

        p._popTmplInsertionMode();
        p._pushTmplInsertionMode(newInsertionMode);
        p.insertionMode = newInsertionMode;
        p._processToken(token);
    }
}

function endTagInTemplate(p, token) {
    if (token.tagName === $$1.TEMPLATE) {
        endTagInHead(p, token);
    }
}

function eofInTemplate(p, token) {
    if (p.openElements.tmplCount > 0) {
        p.openElements.popUntilTagNamePopped($$1.TEMPLATE);
        p.activeFormattingElements.clearToLastMarker();
        p._popTmplInsertionMode();
        p._resetInsertionMode();
        p._processToken(token);
    } else {
        p.stopped = true;
    }
}

// The "after body" insertion mode
//------------------------------------------------------------------
function startTagAfterBody(p, token) {
    if (token.tagName === $$1.HTML) {
        startTagInBody(p, token);
    } else {
        tokenAfterBody(p, token);
    }
}

function endTagAfterBody(p, token) {
    if (token.tagName === $$1.HTML) {
        if (!p.fragmentContext) {
            p.insertionMode = AFTER_AFTER_BODY_MODE;
        }
    } else {
        tokenAfterBody(p, token);
    }
}

function tokenAfterBody(p, token) {
    p.insertionMode = IN_BODY_MODE;
    p._processToken(token);
}

// The "in frameset" insertion mode
//------------------------------------------------------------------
function startTagInFrameset(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HTML) {
        startTagInBody(p, token);
    } else if (tn === $$1.FRAMESET) {
        p._insertElement(token, NS$1.HTML);
    } else if (tn === $$1.FRAME) {
        p._appendElement(token, NS$1.HTML);
        token.ackSelfClosing = true;
    } else if (tn === $$1.NOFRAMES) {
        startTagInHead(p, token);
    }
}

function endTagInFrameset(p, token) {
    if (token.tagName === $$1.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
        p.openElements.pop();

        if (!p.fragmentContext && p.openElements.currentTagName !== $$1.FRAMESET) {
            p.insertionMode = AFTER_FRAMESET_MODE;
        }
    }
}

// The "after frameset" insertion mode
//------------------------------------------------------------------
function startTagAfterFrameset(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HTML) {
        startTagInBody(p, token);
    } else if (tn === $$1.NOFRAMES) {
        startTagInHead(p, token);
    }
}

function endTagAfterFrameset(p, token) {
    if (token.tagName === $$1.HTML) {
        p.insertionMode = AFTER_AFTER_FRAMESET_MODE;
    }
}

// The "after after body" insertion mode
//------------------------------------------------------------------
function startTagAfterAfterBody(p, token) {
    if (token.tagName === $$1.HTML) {
        startTagInBody(p, token);
    } else {
        tokenAfterAfterBody(p, token);
    }
}

function tokenAfterAfterBody(p, token) {
    p.insertionMode = IN_BODY_MODE;
    p._processToken(token);
}

// The "after after frameset" insertion mode
//------------------------------------------------------------------
function startTagAfterAfterFrameset(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HTML) {
        startTagInBody(p, token);
    } else if (tn === $$1.NOFRAMES) {
        startTagInHead(p, token);
    }
}

// The rules for parsing tokens in foreign content
//------------------------------------------------------------------
function nullCharacterInForeignContent(p, token) {
    token.chars = unicode.REPLACEMENT_CHARACTER;
    p._insertCharacters(token);
}

function characterInForeignContent(p, token) {
    p._insertCharacters(token);
    p.framesetOk = false;
}

function startTagInForeignContent(p, token) {
    if (foreignContent.causesExit(token) && !p.fragmentContext) {
        while (
            p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS$1.HTML &&
            !p._isIntegrationPoint(p.openElements.current)
        ) {
            p.openElements.pop();
        }

        p._processToken(token);
    } else {
        const current = p._getAdjustedCurrentElement();
        const currentNs = p.treeAdapter.getNamespaceURI(current);

        if (currentNs === NS$1.MATHML) {
            foreignContent.adjustTokenMathMLAttrs(token);
        } else if (currentNs === NS$1.SVG) {
            foreignContent.adjustTokenSVGTagName(token);
            foreignContent.adjustTokenSVGAttrs(token);
        }

        foreignContent.adjustTokenXMLAttrs(token);

        if (token.selfClosing) {
            p._appendElement(token, currentNs);
        } else {
            p._insertElement(token, currentNs);
        }

        token.ackSelfClosing = true;
    }
}

function endTagInForeignContent(p, token) {
    for (let i = p.openElements.stackTop; i > 0; i--) {
        const element = p.openElements.items[i];

        if (p.treeAdapter.getNamespaceURI(element) === NS$1.HTML) {
            p._processToken(token);
            break;
        }

        if (p.treeAdapter.getTagName(element).toLowerCase() === token.tagName) {
            p.openElements.popUntilElementPopped(element);
            break;
        }
    }
}

const defaultTreeAdapter = _default;
const mergeOptions = mergeOptions$2;
const doctype$1 = doctype$3;
const HTML = html$2;

//Aliases
const $ = HTML.TAG_NAMES;
const NS = HTML.NAMESPACES;

//Default serializer options
const DEFAULT_OPTIONS = {
    treeAdapter: defaultTreeAdapter
};

//Escaping regexes
const AMP_REGEX = /&/g;
const NBSP_REGEX = /\u00a0/g;
const DOUBLE_QUOTE_REGEX = /"/g;
const LT_REGEX = /</g;
const GT_REGEX = />/g;

//Serializer
class Serializer$1 {
    constructor(node, options) {
        this.options = mergeOptions(DEFAULT_OPTIONS, options);
        this.treeAdapter = this.options.treeAdapter;

        this.html = '';
        this.startNode = node;
    }

    //API
    serialize() {
        this._serializeChildNodes(this.startNode);

        return this.html;
    }

    //Internals
    _serializeChildNodes(parentNode) {
        const childNodes = this.treeAdapter.getChildNodes(parentNode);

        if (childNodes) {
            for (let i = 0, cnLength = childNodes.length; i < cnLength; i++) {
                const currentNode = childNodes[i];

                if (this.treeAdapter.isElementNode(currentNode)) {
                    this._serializeElement(currentNode);
                } else if (this.treeAdapter.isTextNode(currentNode)) {
                    this._serializeTextNode(currentNode);
                } else if (this.treeAdapter.isCommentNode(currentNode)) {
                    this._serializeCommentNode(currentNode);
                } else if (this.treeAdapter.isDocumentTypeNode(currentNode)) {
                    this._serializeDocumentTypeNode(currentNode);
                }
            }
        }
    }

    _serializeElement(node) {
        const tn = this.treeAdapter.getTagName(node);
        const ns = this.treeAdapter.getNamespaceURI(node);

        this.html += '<' + tn;
        this._serializeAttributes(node);
        this.html += '>';

        if (
            tn !== $.AREA &&
            tn !== $.BASE &&
            tn !== $.BASEFONT &&
            tn !== $.BGSOUND &&
            tn !== $.BR &&
            tn !== $.COL &&
            tn !== $.EMBED &&
            tn !== $.FRAME &&
            tn !== $.HR &&
            tn !== $.IMG &&
            tn !== $.INPUT &&
            tn !== $.KEYGEN &&
            tn !== $.LINK &&
            tn !== $.META &&
            tn !== $.PARAM &&
            tn !== $.SOURCE &&
            tn !== $.TRACK &&
            tn !== $.WBR
        ) {
            const childNodesHolder =
                tn === $.TEMPLATE && ns === NS.HTML ? this.treeAdapter.getTemplateContent(node) : node;

            this._serializeChildNodes(childNodesHolder);
            this.html += '</' + tn + '>';
        }
    }

    _serializeAttributes(node) {
        const attrs = this.treeAdapter.getAttrList(node);

        for (let i = 0, attrsLength = attrs.length; i < attrsLength; i++) {
            const attr = attrs[i];
            const value = Serializer$1.escapeString(attr.value, true);

            this.html += ' ';

            if (!attr.namespace) {
                this.html += attr.name;
            } else if (attr.namespace === NS.XML) {
                this.html += 'xml:' + attr.name;
            } else if (attr.namespace === NS.XMLNS) {
                if (attr.name !== 'xmlns') {
                    this.html += 'xmlns:';
                }

                this.html += attr.name;
            } else if (attr.namespace === NS.XLINK) {
                this.html += 'xlink:' + attr.name;
            } else {
                this.html += attr.prefix + ':' + attr.name;
            }

            this.html += '="' + value + '"';
        }
    }

    _serializeTextNode(node) {
        const content = this.treeAdapter.getTextNodeContent(node);
        const parent = this.treeAdapter.getParentNode(node);
        let parentTn = void 0;

        if (parent && this.treeAdapter.isElementNode(parent)) {
            parentTn = this.treeAdapter.getTagName(parent);
        }

        if (
            parentTn === $.STYLE ||
            parentTn === $.SCRIPT ||
            parentTn === $.XMP ||
            parentTn === $.IFRAME ||
            parentTn === $.NOEMBED ||
            parentTn === $.NOFRAMES ||
            parentTn === $.PLAINTEXT ||
            parentTn === $.NOSCRIPT
        ) {
            this.html += content;
        } else {
            this.html += Serializer$1.escapeString(content, false);
        }
    }

    _serializeCommentNode(node) {
        this.html += '<!--' + this.treeAdapter.getCommentNodeContent(node) + '-->';
    }

    _serializeDocumentTypeNode(node) {
        const name = this.treeAdapter.getDocumentTypeNodeName(node);

        this.html += '<' + doctype$1.serializeContent(name, null, null) + '>';
    }
}

// NOTE: used in tests and by rewriting stream
Serializer$1.escapeString = function(str, attrMode) {
    str = str.replace(AMP_REGEX, '&amp;').replace(NBSP_REGEX, '&nbsp;');

    if (attrMode) {
        str = str.replace(DOUBLE_QUOTE_REGEX, '&quot;');
    } else {
        str = str.replace(LT_REGEX, '&lt;').replace(GT_REGEX, '&gt;');
    }

    return str;
};

var serializer = Serializer$1;

const Parser = parser;
const Serializer = serializer;

// Shorthands
lib$1.parse = function parse(html, options) {
    const parser = new Parser(options);

    return parser.parse(html);
};

lib$1.parseFragment = function parseFragment(fragmentContext, html, options) {
    if (typeof fragmentContext === 'string') {
        options = html;
        html = fragmentContext;
        fragmentContext = null;
    }

    const parser = new Parser(options);

    return parser.parseFragment(html, fragmentContext);
};

lib$1.serialize = function(node, options) {
    const serializer = new Serializer(node, options);

    return serializer.serialize();
};

var lib = {};

const doctype = doctype$3;
const { DOCUMENT_MODE } = html$2;

//Conversion tables for DOM Level1 structure emulation
const nodeTypes = {
    element: 1,
    text: 3,
    cdata: 4,
    comment: 8
};

const nodePropertyShorthands = {
    tagName: 'name',
    childNodes: 'children',
    parentNode: 'parent',
    previousSibling: 'prev',
    nextSibling: 'next',
    nodeValue: 'data'
};

//Node
class Node {
    constructor(props) {
        for (const key of Object.keys(props)) {
            this[key] = props[key];
        }
    }

    get firstChild() {
        const children = this.children;

        return (children && children[0]) || null;
    }

    get lastChild() {
        const children = this.children;

        return (children && children[children.length - 1]) || null;
    }

    get nodeType() {
        return nodeTypes[this.type] || nodeTypes.element;
    }
}

Object.keys(nodePropertyShorthands).forEach(key => {
    const shorthand = nodePropertyShorthands[key];

    Object.defineProperty(Node.prototype, key, {
        get: function() {
            return this[shorthand] || null;
        },
        set: function(val) {
            this[shorthand] = val;
            return val;
        }
    });
});

//Node construction
lib.createDocument = function() {
    return new Node({
        type: 'root',
        name: 'root',
        parent: null,
        prev: null,
        next: null,
        children: [],
        'x-mode': DOCUMENT_MODE.NO_QUIRKS
    });
};

lib.createDocumentFragment = function() {
    return new Node({
        type: 'root',
        name: 'root',
        parent: null,
        prev: null,
        next: null,
        children: []
    });
};

lib.createElement = function(tagName, namespaceURI, attrs) {
    const attribs = Object.create(null);
    const attribsNamespace = Object.create(null);
    const attribsPrefix = Object.create(null);

    for (let i = 0; i < attrs.length; i++) {
        const attrName = attrs[i].name;

        attribs[attrName] = attrs[i].value;
        attribsNamespace[attrName] = attrs[i].namespace;
        attribsPrefix[attrName] = attrs[i].prefix;
    }

    return new Node({
        type: tagName === 'script' || tagName === 'style' ? tagName : 'tag',
        name: tagName,
        namespace: namespaceURI,
        attribs: attribs,
        'x-attribsNamespace': attribsNamespace,
        'x-attribsPrefix': attribsPrefix,
        children: [],
        parent: null,
        prev: null,
        next: null
    });
};

lib.createCommentNode = function(data) {
    return new Node({
        type: 'comment',
        data: data,
        parent: null,
        prev: null,
        next: null
    });
};

const createTextNode = function(value) {
    return new Node({
        type: 'text',
        data: value,
        parent: null,
        prev: null,
        next: null
    });
};

//Tree mutation
const appendChild = (lib.appendChild = function(parentNode, newNode) {
    const prev = parentNode.children[parentNode.children.length - 1];

    if (prev) {
        prev.next = newNode;
        newNode.prev = prev;
    }

    parentNode.children.push(newNode);
    newNode.parent = parentNode;
});

const insertBefore$1 = (lib.insertBefore = function(parentNode, newNode, referenceNode) {
    const insertionIdx = parentNode.children.indexOf(referenceNode);
    const prev = referenceNode.prev;

    if (prev) {
        prev.next = newNode;
        newNode.prev = prev;
    }

    referenceNode.prev = newNode;
    newNode.next = referenceNode;

    parentNode.children.splice(insertionIdx, 0, newNode);
    newNode.parent = parentNode;
});

lib.setTemplateContent = function(templateElement, contentElement) {
    appendChild(templateElement, contentElement);
};

lib.getTemplateContent = function(templateElement) {
    return templateElement.children[0];
};

lib.setDocumentType = function(document, name, publicId, systemId) {
    const data = doctype.serializeContent(name, publicId, systemId);
    let doctypeNode = null;

    for (let i = 0; i < document.children.length; i++) {
        if (document.children[i].type === 'directive' && document.children[i].name === '!doctype') {
            doctypeNode = document.children[i];
            break;
        }
    }

    if (doctypeNode) {
        doctypeNode.data = data;
        doctypeNode['x-name'] = name;
        doctypeNode['x-publicId'] = publicId;
        doctypeNode['x-systemId'] = systemId;
    } else {
        appendChild(
            document,
            new Node({
                type: 'directive',
                name: '!doctype',
                data: data,
                'x-name': name,
                'x-publicId': publicId,
                'x-systemId': systemId
            })
        );
    }
};

lib.setDocumentMode = function(document, mode) {
    document['x-mode'] = mode;
};

lib.getDocumentMode = function(document) {
    return document['x-mode'];
};

lib.detachNode = function(node) {
    if (node.parent) {
        const idx = node.parent.children.indexOf(node);
        const prev = node.prev;
        const next = node.next;

        node.prev = null;
        node.next = null;

        if (prev) {
            prev.next = next;
        }

        if (next) {
            next.prev = prev;
        }

        node.parent.children.splice(idx, 1);
        node.parent = null;
    }
};

lib.insertText = function(parentNode, text) {
    const lastChild = parentNode.children[parentNode.children.length - 1];

    if (lastChild && lastChild.type === 'text') {
        lastChild.data += text;
    } else {
        appendChild(parentNode, createTextNode(text));
    }
};

lib.insertTextBefore = function(parentNode, text, referenceNode) {
    const prevNode = parentNode.children[parentNode.children.indexOf(referenceNode) - 1];

    if (prevNode && prevNode.type === 'text') {
        prevNode.data += text;
    } else {
        insertBefore$1(parentNode, createTextNode(text), referenceNode);
    }
};

lib.adoptAttributes = function(recipient, attrs) {
    for (let i = 0; i < attrs.length; i++) {
        const attrName = attrs[i].name;

        if (typeof recipient.attribs[attrName] === 'undefined') {
            recipient.attribs[attrName] = attrs[i].value;
            recipient['x-attribsNamespace'][attrName] = attrs[i].namespace;
            recipient['x-attribsPrefix'][attrName] = attrs[i].prefix;
        }
    }
};

//Tree traversing
lib.getFirstChild = function(node) {
    return node.children[0];
};

lib.getChildNodes = function(node) {
    return node.children;
};

lib.getParentNode = function(node) {
    return node.parent;
};

lib.getAttrList = function(element) {
    const attrList = [];

    for (const name in element.attribs) {
        attrList.push({
            name: name,
            value: element.attribs[name],
            namespace: element['x-attribsNamespace'][name],
            prefix: element['x-attribsPrefix'][name]
        });
    }

    return attrList;
};

//Node data
lib.getTagName = function(element) {
    return element.name;
};

lib.getNamespaceURI = function(element) {
    return element.namespace;
};

lib.getTextNodeContent = function(textNode) {
    return textNode.data;
};

lib.getCommentNodeContent = function(commentNode) {
    return commentNode.data;
};

lib.getDocumentTypeNodeName = function(doctypeNode) {
    return doctypeNode['x-name'];
};

lib.getDocumentTypeNodePublicId = function(doctypeNode) {
    return doctypeNode['x-publicId'];
};

lib.getDocumentTypeNodeSystemId = function(doctypeNode) {
    return doctypeNode['x-systemId'];
};

//Node types
lib.isTextNode = function(node) {
    return node.type === 'text';
};

lib.isCommentNode = function(node) {
    return node.type === 'comment';
};

lib.isDocumentTypeNode = function(node) {
    return node.type === 'directive' && node.name === '!doctype';
};

lib.isElementNode = function(node) {
    return !!node.attribs;
};

// Source code location
lib.setNodeSourceCodeLocation = function(node, location) {
    node.sourceCodeLocation = location;
};

lib.getNodeSourceCodeLocation = function(node) {
    return node.sourceCodeLocation;
};

lib.updateNodeSourceCodeLocation = function(node, endLocation) {
    node.sourceCodeLocation = Object.assign(node.sourceCodeLocation, endLocation);
};

Object.defineProperty(parse5Adapter, "__esModule", { value: true });
parse5Adapter.render = parse5Adapter.parse = void 0;
var tslib_1$5 = require$$0$2;
var domhandler_1$4 = lib$7;
var parse5_1 = lib$1;
var parse5_htmlparser2_tree_adapter_1 = tslib_1$5.__importDefault(lib);
function parse$b(content, options, isDocument) {
    var opts = {
        scriptingEnabled: typeof options.scriptingEnabled === 'boolean'
            ? options.scriptingEnabled
            : true,
        treeAdapter: parse5_htmlparser2_tree_adapter_1.default,
        sourceCodeLocationInfo: options.sourceCodeLocationInfo,
    };
    var context = options.context;
    // @ts-expect-error The tree adapter unfortunately doesn't return the exact types.
    return isDocument
        ? parse5_1.parse(content, opts)
        : // @ts-expect-error Same issue again.
            parse5_1.parseFragment(context, content, opts);
}
parse5Adapter.parse = parse$b;
function render$1(dom) {
    var _a;
    /*
     * `dom-serializer` passes over the special "root" node and renders the
     * node's children in its place. To mimic this behavior with `parse5`, an
     * equivalent operation must be applied to the input array.
     */
    var nodes = 'length' in dom ? dom : [dom];
    for (var index = 0; index < nodes.length; index += 1) {
        var node = nodes[index];
        if (domhandler_1$4.isDocument(node)) {
            (_a = Array.prototype.splice).call.apply(_a, tslib_1$5.__spreadArray([nodes, index, 1], node.children));
        }
    }
    // @ts-expect-error Types don't align here either.
    return parse5_1.serialize({ children: nodes }, { treeAdapter: parse5_htmlparser2_tree_adapter_1.default });
}
parse5Adapter.render = render$1;

var htmlparser2Adapter = {};

(function (exports) {
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.render = exports.parse = void 0;
var htmlparser2_1 = lib$2;
Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return htmlparser2_1.parseDocument; } });
var dom_serializer_1 = lib$5;
Object.defineProperty(exports, "render", { enumerable: true, get: function () { return __importDefault(dom_serializer_1).default; } });
}(htmlparser2Adapter));

Object.defineProperty(_static, "__esModule", { value: true });
_static.merge = _static.contains = _static.root = _static.parseHTML = _static.text = _static.xml = _static.html = void 0;
var tslib_1$4 = require$$0$2;
var options_1$2 = tslib_1$4.__importStar(options);
var cheerio_select_1 = lib$b;
var htmlparser2_1$4 = lib$2;
var parse5_adapter_1$1 = parse5Adapter;
var htmlparser2_adapter_1$1 = htmlparser2Adapter;
/**
 * Helper function to render a DOM.
 *
 * @param that - Cheerio instance to render.
 * @param dom - The DOM to render. Defaults to `that`'s root.
 * @param options - Options for rendering.
 * @returns The rendered document.
 */
function render(that, dom, options) {
    var _a;
    var toRender = dom
        ? typeof dom === 'string'
            ? cheerio_select_1.select(dom, (_a = that === null || that === void 0 ? void 0 : that._root) !== null && _a !== void 0 ? _a : [], options)
            : dom
        : that === null || that === void 0 ? void 0 : that._root.children;
    if (!toRender)
        return '';
    return options.xmlMode || options._useHtmlParser2
        ? htmlparser2_adapter_1$1.render(toRender, options)
        : parse5_adapter_1$1.render(toRender);
}
/**
 * Checks if a passed object is an options object.
 *
 * @param dom - Object to check if it is an options object.
 * @returns Whether the object is an options object.
 */
function isOptions(dom) {
    return (typeof dom === 'object' &&
        dom != null &&
        !('length' in dom) &&
        !('type' in dom));
}
function html$1(dom, options) {
    /*
     * Be flexible about parameters, sometimes we call html(),
     * with options as only parameter
     * check dom argument for dom element specific properties
     * assume there is no 'length' or 'type' properties in the options object
     */
    if (!options && isOptions(dom)) {
        options = dom;
        dom = undefined;
    }
    /*
     * Sometimes `$.html()` is used without preloading html,
     * so fallback non-existing options to the default ones.
     */
    var opts = tslib_1$4.__assign(tslib_1$4.__assign(tslib_1$4.__assign({}, options_1$2.default), (this ? this._options : {})), options_1$2.flatten(options !== null && options !== void 0 ? options : {}));
    return render(this || undefined, dom, opts);
}
_static.html = html$1;
/**
 * Render the document as XML.
 *
 * @param dom - Element to render.
 * @returns THe rendered document.
 */
function xml(dom) {
    var options = tslib_1$4.__assign(tslib_1$4.__assign({}, this._options), { xmlMode: true });
    return render(this, dom, options);
}
_static.xml = xml;
/**
 * Render the document as text.
 *
 * @param elements - Elements to render.
 * @returns The rendered document.
 */
function text$1(elements) {
    var elems = elements ? elements : this ? this.root() : [];
    var ret = '';
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (htmlparser2_1$4.DomUtils.isText(elem))
            ret += elem.data;
        else if (htmlparser2_1$4.DomUtils.hasChildren(elem) &&
            elem.type !== htmlparser2_1$4.ElementType.Comment &&
            elem.type !== htmlparser2_1$4.ElementType.Script &&
            elem.type !== htmlparser2_1$4.ElementType.Style) {
            ret += text$1(elem.children);
        }
    }
    return ret;
}
_static.text = text$1;
function parseHTML$1(data, context, keepScripts) {
    if (keepScripts === void 0) { keepScripts = typeof context === 'boolean' ? context : false; }
    if (!data || typeof data !== 'string') {
        return null;
    }
    if (typeof context === 'boolean') {
        keepScripts = context;
    }
    var parsed = this.load(data, options_1$2.default, false);
    if (!keepScripts) {
        parsed('script').remove();
    }
    /*
     * The `children` array is used by Cheerio internally to group elements that
     * share the same parents. When nodes created through `parseHTML` are
     * inserted into previously-existing DOM structures, they will be removed
     * from the `children` array. The results of `parseHTML` should remain
     * constant across these operations, so a shallow copy should be returned.
     */
    return parsed.root()[0].children.slice();
}
_static.parseHTML = parseHTML$1;
/**
 * Sometimes you need to work with the top-level root element. To query it, you
 * can use `$.root()`.
 *
 * @example
 *
 * ```js
 * $.root().append('<ul id="vegetables"></ul>').html();
 * //=> <ul id="fruits">...</ul><ul id="vegetables"></ul>
 * ```
 *
 * @returns Cheerio instance wrapping the root node.
 * @alias Cheerio.root
 */
function root() {
    return this(this._root);
}
_static.root = root;
/**
 * Checks to see if the `contained` DOM element is a descendant of the
 * `container` DOM element.
 *
 * @param container - Potential parent node.
 * @param contained - Potential child node.
 * @returns Indicates if the nodes contain one another.
 * @alias Cheerio.contains
 * @see {@link https://api.jquery.com/jQuery.contains/}
 */
function contains$1(container, contained) {
    // According to the jQuery API, an element does not "contain" itself
    if (contained === container) {
        return false;
    }
    /*
     * Step up the descendants, stopping when the root element is reached
     * (signaled by `.parent` returning a reference to the same object)
     */
    var next = contained;
    while (next && next !== next.parent) {
        next = next.parent;
        if (next === container) {
            return true;
        }
    }
    return false;
}
_static.contains = contains$1;
/**
 * $.merge().
 *
 * @param arr1 - First array.
 * @param arr2 - Second array.
 * @returns `arr1`, with elements of `arr2` inserted.
 * @alias Cheerio.merge
 * @see {@link https://api.jquery.com/jQuery.merge/}
 */
function merge$1(arr1, arr2) {
    if (!isArrayLike(arr1) || !isArrayLike(arr2)) {
        return;
    }
    var newLength = arr1.length;
    var len = +arr2.length;
    for (var i = 0; i < len; i++) {
        arr1[newLength++] = arr2[i];
    }
    arr1.length = newLength;
    return arr1;
}
_static.merge = merge$1;
/**
 * @param item - Item to check.
 * @returns Indicates if the item is array-like.
 */
function isArrayLike(item) {
    if (Array.isArray(item)) {
        return true;
    }
    if (typeof item !== 'object' ||
        !Object.prototype.hasOwnProperty.call(item, 'length') ||
        typeof item.length !== 'number' ||
        item.length < 0) {
        return false;
    }
    for (var i = 0; i < item.length; i++) {
        if (!(i in item)) {
            return false;
        }
    }
    return true;
}

var cheerio = {};

var parse$a = {};

Object.defineProperty(parse$a, "__esModule", { value: true });
parse$a.update = void 0;
var htmlparser2_1$3 = lib$2;
var htmlparser2_adapter_1 = htmlparser2Adapter;
var parse5_adapter_1 = parse5Adapter;
var domhandler_1$3 = lib$7;
/*
 * Parser
 */
function parse$9(content, options, isDocument) {
    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(content)) {
        content = content.toString();
    }
    if (typeof content === 'string') {
        return options.xmlMode || options._useHtmlParser2
            ? htmlparser2_adapter_1.parse(content, options)
            : parse5_adapter_1.parse(content, options, isDocument);
    }
    var doc = content;
    if (!Array.isArray(doc) && domhandler_1$3.isDocument(doc)) {
        // If `doc` is already a root, just return it
        return doc;
    }
    // Add conent to new root element
    var root = new domhandler_1$3.Document([]);
    // Update the DOM using the root
    update(doc, root);
    return root;
}
parse$a.default = parse$9;
/**
 * Update the dom structure, for one changed layer.
 *
 * @param newChilds - The new children.
 * @param parent - The new parent.
 * @returns The parent node.
 */
function update(newChilds, parent) {
    // Normalize
    var arr = Array.isArray(newChilds) ? newChilds : [newChilds];
    // Update parent
    if (parent) {
        parent.children = arr;
    }
    else {
        parent = null;
    }
    // Update neighbors
    for (var i = 0; i < arr.length; i++) {
        var node = arr[i];
        // Cleanly remove existing nodes from their previous structures.
        if (node.parent && node.parent.children !== arr) {
            htmlparser2_1$3.DomUtils.removeElement(node);
        }
        if (parent) {
            node.prev = arr[i - 1] || null;
            node.next = arr[i + 1] || null;
        }
        else {
            node.prev = node.next = null;
        }
        node.parent = parent;
    }
    return parent;
}
parse$a.update = update;

var utils$n = {};

Object.defineProperty(utils$n, "__esModule", { value: true });
utils$n.isHtml = utils$n.cloneDom = utils$n.domEach = utils$n.cssCase = utils$n.camelCase = utils$n.isCheerio = utils$n.isTag = void 0;
var htmlparser2_1$2 = lib$2;
var domhandler_1$2 = lib$7;
/**
 * Check if the DOM element is a tag.
 *
 * `isTag(type)` includes `<script>` and `<style>` tags.
 *
 * @private
 * @category Utils
 * @param type - DOM node to check.
 * @returns Whether the node is a tag.
 */
utils$n.isTag = htmlparser2_1$2.DomUtils.isTag;
/**
 * Checks if an object is a Cheerio instance.
 *
 * @category Utils
 * @param maybeCheerio - The object to check.
 * @returns Whether the object is a Cheerio instance.
 */
function isCheerio(maybeCheerio) {
    return maybeCheerio.cheerio != null;
}
utils$n.isCheerio = isCheerio;
/**
 * Convert a string to camel case notation.
 *
 * @private
 * @category Utils
 * @param str - String to be converted.
 * @returns String in camel case notation.
 */
function camelCase(str) {
    return str.replace(/[_.-](\w|$)/g, function (_, x) { return x.toUpperCase(); });
}
utils$n.camelCase = camelCase;
/**
 * Convert a string from camel case to "CSS case", where word boundaries are
 * described by hyphens ("-") and all characters are lower-case.
 *
 * @private
 * @category Utils
 * @param str - String to be converted.
 * @returns String in "CSS case".
 */
function cssCase(str) {
    return str.replace(/[A-Z]/g, '-$&').toLowerCase();
}
utils$n.cssCase = cssCase;
/**
 * Iterate over each DOM element without creating intermediary Cheerio instances.
 *
 * This is indented for use internally to avoid otherwise unnecessary memory
 * pressure introduced by _make.
 *
 * @category Utils
 * @param array - Array to iterate over.
 * @param fn - Function to call.
 * @returns The original instance.
 */
function domEach(array, fn) {
    var len = array.length;
    for (var i = 0; i < len; i++)
        fn(array[i], i);
    return array;
}
utils$n.domEach = domEach;
/**
 * Create a deep copy of the given DOM structure. Sets the parents of the copies
 * of the passed nodes to `null`.
 *
 * @private
 * @category Utils
 * @param dom - The htmlparser2-compliant DOM structure.
 * @returns - The cloned DOM.
 */
function cloneDom(dom) {
    var clone = 'length' in dom
        ? Array.prototype.map.call(dom, function (el) { return domhandler_1$2.cloneNode(el, true); })
        : [domhandler_1$2.cloneNode(dom, true)];
    // Add a root node around the cloned nodes
    var root = new domhandler_1$2.Document(clone);
    clone.forEach(function (node) {
        node.parent = root;
    });
    return clone;
}
utils$n.cloneDom = cloneDom;
/**
 * A simple way to check for HTML strings. Tests for a `<` within a string,
 * immediate followed by a letter and eventually followed by a `>`.
 *
 * @private
 */
var quickExpr = /<[a-zA-Z][^]*>/;
/**
 * Check if string is HTML.
 *
 * @private
 * @category Utils
 * @param str - String to check.
 * @returns Indicates if `str` is HTML.
 */
function isHtml(str) {
    // Run the regex
    return quickExpr.test(str);
}
utils$n.isHtml = isHtml;

var attributes = {};

/**
 * Methods for getting and modifying attributes.
 *
 * @module cheerio/attributes
 */
Object.defineProperty(attributes, "__esModule", { value: true });
attributes.toggleClass = attributes.removeClass = attributes.addClass = attributes.hasClass = attributes.removeAttr = attributes.val = attributes.data = attributes.prop = attributes.attr = void 0;
var static_1$2 = _static;
var utils_1$5 = utils$n;
var hasOwn = Object.prototype.hasOwnProperty;
var rspace = /\s+/;
var dataAttrPrefix = 'data-';
/*
 * Lookup table for coercing string data-* attributes to their corresponding
 * JavaScript primitives
 */
var primitives = {
    null: null,
    true: true,
    false: false,
};
// Attributes that are booleans
var rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;
// Matches strings that look like JSON objects or arrays
var rbrace = /^{[^]*}$|^\[[^]*]$/;
function getAttr(elem, name, xmlMode) {
    var _a;
    if (!elem || !utils_1$5.isTag(elem))
        return undefined;
    (_a = elem.attribs) !== null && _a !== void 0 ? _a : (elem.attribs = {});
    // Return the entire attribs object if no attribute specified
    if (!name) {
        return elem.attribs;
    }
    if (hasOwn.call(elem.attribs, name)) {
        // Get the (decoded) attribute
        return !xmlMode && rboolean.test(name) ? name : elem.attribs[name];
    }
    // Mimic the DOM and return text content as value for `option's`
    if (elem.name === 'option' && name === 'value') {
        return static_1$2.text(elem.children);
    }
    // Mimic DOM with default value for radios/checkboxes
    if (elem.name === 'input' &&
        (elem.attribs.type === 'radio' || elem.attribs.type === 'checkbox') &&
        name === 'value') {
        return 'on';
    }
    return undefined;
}
/**
 * Sets the value of an attribute. The attribute will be deleted if the value is `null`.
 *
 * @private
 * @param el - The element to set the attribute on.
 * @param name - The attribute's name.
 * @param value - The attribute's value.
 */
function setAttr(el, name, value) {
    if (value === null) {
        removeAttribute(el, name);
    }
    else {
        el.attribs[name] = "" + value;
    }
}
function attr(name, value) {
    // Set the value (with attr map support)
    if (typeof name === 'object' || value !== undefined) {
        if (typeof value === 'function') {
            if (typeof name !== 'string') {
                {
                    throw new Error('Bad combination of arguments.');
                }
            }
            return utils_1$5.domEach(this, function (el, i) {
                if (utils_1$5.isTag(el))
                    setAttr(el, name, value.call(el, i, el.attribs[name]));
            });
        }
        return utils_1$5.domEach(this, function (el) {
            if (!utils_1$5.isTag(el))
                return;
            if (typeof name === 'object') {
                Object.keys(name).forEach(function (objName) {
                    var objValue = name[objName];
                    setAttr(el, objName, objValue);
                });
            }
            else {
                setAttr(el, name, value);
            }
        });
    }
    return arguments.length > 1
        ? this
        : getAttr(this[0], name, this.options.xmlMode);
}
attributes.attr = attr;
/**
 * Gets a node's prop.
 *
 * @private
 * @category Attributes
 * @param el - Elenent to get the prop of.
 * @param name - Name of the prop.
 * @returns The prop's value.
 */
function getProp(el, name, xmlMode) {
    if (!el || !utils_1$5.isTag(el))
        return;
    return name in el
        ? // @ts-expect-error TS doesn't like us accessing the value directly here.
            el[name]
        : !xmlMode && rboolean.test(name)
            ? getAttr(el, name, false) !== undefined
            : getAttr(el, name, xmlMode);
}
/**
 * Sets the value of a prop.
 *
 * @private
 * @param el - The element to set the prop on.
 * @param name - The prop's name.
 * @param value - The prop's value.
 */
function setProp(el, name, value, xmlMode) {
    if (name in el) {
        // @ts-expect-error Overriding value
        el[name] = value;
    }
    else {
        setAttr(el, name, !xmlMode && rboolean.test(name) ? (value ? '' : null) : "" + value);
    }
}
function prop(name, value) {
    var _this = this;
    if (typeof name === 'string' && value === undefined) {
        switch (name) {
            case 'style': {
                var property_1 = this.css();
                var keys = Object.keys(property_1);
                keys.forEach(function (p, i) {
                    property_1[i] = p;
                });
                property_1.length = keys.length;
                return property_1;
            }
            case 'tagName':
            case 'nodeName': {
                var el = this[0];
                return utils_1$5.isTag(el) ? el.name.toUpperCase() : undefined;
            }
            case 'outerHTML':
                return this.clone().wrap('<container />').parent().html();
            case 'innerHTML':
                return this.html();
            default:
                return getProp(this[0], name, this.options.xmlMode);
        }
    }
    if (typeof name === 'object' || value !== undefined) {
        if (typeof value === 'function') {
            if (typeof name === 'object') {
                throw new Error('Bad combination of arguments.');
            }
            return utils_1$5.domEach(this, function (el, i) {
                if (utils_1$5.isTag(el))
                    setProp(el, name, value.call(el, i, getProp(el, name, _this.options.xmlMode)), _this.options.xmlMode);
            });
        }
        return utils_1$5.domEach(this, function (el) {
            if (!utils_1$5.isTag(el))
                return;
            if (typeof name === 'object') {
                Object.keys(name).forEach(function (key) {
                    var val = name[key];
                    setProp(el, key, val, _this.options.xmlMode);
                });
            }
            else {
                setProp(el, name, value, _this.options.xmlMode);
            }
        });
    }
    return undefined;
}
attributes.prop = prop;
/**
 * Sets the value of a data attribute.
 *
 * @private
 * @param el - The element to set the data attribute on.
 * @param name - The data attribute's name.
 * @param value - The data attribute's value.
 */
function setData(el, name, value) {
    var _a;
    var elem = el;
    (_a = elem.data) !== null && _a !== void 0 ? _a : (elem.data = {});
    if (typeof name === 'object')
        Object.assign(elem.data, name);
    else if (typeof name === 'string' && value !== undefined) {
        elem.data[name] = value;
    }
}
/**
 * Read the specified attribute from the equivalent HTML5 `data-*` attribute,
 * and (if present) cache the value in the node's internal data store. If no
 * attribute name is specified, read *all* HTML5 `data-*` attributes in this manner.
 *
 * @private
 * @category Attributes
 * @param el - Elenent to get the data attribute of.
 * @param name - Name of the data attribute.
 * @returns The data attribute's value, or a map with all of the data attribute.
 */
function readData(el, name) {
    var domNames;
    var jsNames;
    var value;
    if (name == null) {
        domNames = Object.keys(el.attribs).filter(function (attrName) {
            return attrName.startsWith(dataAttrPrefix);
        });
        jsNames = domNames.map(function (domName) {
            return utils_1$5.camelCase(domName.slice(dataAttrPrefix.length));
        });
    }
    else {
        domNames = [dataAttrPrefix + utils_1$5.cssCase(name)];
        jsNames = [name];
    }
    for (var idx = 0; idx < domNames.length; ++idx) {
        var domName = domNames[idx];
        var jsName = jsNames[idx];
        if (hasOwn.call(el.attribs, domName) &&
            !hasOwn.call(el.data, jsName)) {
            value = el.attribs[domName];
            if (hasOwn.call(primitives, value)) {
                value = primitives[value];
            }
            else if (value === String(Number(value))) {
                value = Number(value);
            }
            else if (rbrace.test(value)) {
                try {
                    value = JSON.parse(value);
                }
                catch (e) {
                    /* Ignore */
                }
            }
            el.data[jsName] = value;
        }
    }
    return name == null ? el.data : value;
}
function data(name, value) {
    var _a;
    var elem = this[0];
    if (!elem || !utils_1$5.isTag(elem))
        return;
    var dataEl = elem;
    (_a = dataEl.data) !== null && _a !== void 0 ? _a : (dataEl.data = {});
    // Return the entire data object if no data specified
    if (!name) {
        return readData(dataEl);
    }
    // Set the value (with attr map support)
    if (typeof name === 'object' || value !== undefined) {
        utils_1$5.domEach(this, function (el) {
            if (utils_1$5.isTag(el))
                if (typeof name === 'object')
                    setData(el, name);
                else
                    setData(el, name, value);
        });
        return this;
    }
    if (hasOwn.call(dataEl.data, name)) {
        return dataEl.data[name];
    }
    return readData(dataEl, name);
}
attributes.data = data;
function val(value) {
    var querying = arguments.length === 0;
    var element = this[0];
    if (!element || !utils_1$5.isTag(element))
        return querying ? undefined : this;
    switch (element.name) {
        case 'textarea':
            return this.text(value);
        case 'select': {
            var option = this.find('option:selected');
            if (!querying) {
                if (this.attr('multiple') == null && typeof value === 'object') {
                    return this;
                }
                this.find('option').removeAttr('selected');
                var values = typeof value !== 'object' ? [value] : value;
                for (var i = 0; i < values.length; i++) {
                    this.find("option[value=\"" + values[i] + "\"]").attr('selected', '');
                }
                return this;
            }
            return this.attr('multiple')
                ? option.toArray().map(function (el) { return static_1$2.text(el.children); })
                : option.attr('value');
        }
        case 'input':
        case 'option':
            return querying
                ? this.attr('value')
                : this.attr('value', value);
    }
    return undefined;
}
attributes.val = val;
/**
 * Remove an attribute.
 *
 * @private
 * @param elem - Node to remove attribute from.
 * @param name - Name of the attribute to remove.
 */
function removeAttribute(elem, name) {
    if (!elem.attribs || !hasOwn.call(elem.attribs, name))
        return;
    delete elem.attribs[name];
}
/**
 * Splits a space-separated list of names to individual names.
 *
 * @category Attributes
 * @param names - Names to split.
 * @returns - Split names.
 */
function splitNames(names) {
    return names ? names.trim().split(rspace) : [];
}
/**
 * Method for removing attributes by `name`.
 *
 * @category Attributes
 * @example
 *
 * ```js
 * $('.pear').removeAttr('class').html();
 * //=> <li>Pear</li>
 *
 * $('.apple').attr('id', 'favorite');
 * $('.apple').removeAttr('id class').html();
 * //=> <li>Apple</li>
 * ```
 *
 * @param name - Name of the attribute.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/removeAttr/}
 */
function removeAttr(name) {
    var attrNames = splitNames(name);
    var _loop_1 = function (i) {
        utils_1$5.domEach(this_1, function (elem) {
            if (utils_1$5.isTag(elem))
                removeAttribute(elem, attrNames[i]);
        });
    };
    var this_1 = this;
    for (var i = 0; i < attrNames.length; i++) {
        _loop_1(i);
    }
    return this;
}
attributes.removeAttr = removeAttr;
/**
 * Check to see if *any* of the matched elements have the given `className`.
 *
 * @category Attributes
 * @example
 *
 * ```js
 * $('.pear').hasClass('pear');
 * //=> true
 *
 * $('apple').hasClass('fruit');
 * //=> false
 *
 * $('li').hasClass('pear');
 * //=> true
 * ```
 *
 * @param className - Name of the class.
 * @returns Indicates if an element has the given `className`.
 * @see {@link https://api.jquery.com/hasClass/}
 */
function hasClass(className) {
    return this.toArray().some(function (elem) {
        var clazz = utils_1$5.isTag(elem) && elem.attribs.class;
        var idx = -1;
        if (clazz && className.length) {
            while ((idx = clazz.indexOf(className, idx + 1)) > -1) {
                var end = idx + className.length;
                if ((idx === 0 || rspace.test(clazz[idx - 1])) &&
                    (end === clazz.length || rspace.test(clazz[end]))) {
                    return true;
                }
            }
        }
        return false;
    });
}
attributes.hasClass = hasClass;
/**
 * Adds class(es) to all of the matched elements. Also accepts a `function`.
 *
 * @category Attributes
 * @example
 *
 * ```js
 * $('.pear').addClass('fruit').html();
 * //=> <li class="pear fruit">Pear</li>
 *
 * $('.apple').addClass('fruit red').html();
 * //=> <li class="apple fruit red">Apple</li>
 * ```
 *
 * @param value - Name of new class.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/addClass/}
 */
function addClass(value) {
    // Support functions
    if (typeof value === 'function') {
        return utils_1$5.domEach(this, function (el, i) {
            if (utils_1$5.isTag(el)) {
                var className = el.attribs.class || '';
                addClass.call([el], value.call(el, i, className));
            }
        });
    }
    // Return if no value or not a string or function
    if (!value || typeof value !== 'string')
        return this;
    var classNames = value.split(rspace);
    var numElements = this.length;
    for (var i = 0; i < numElements; i++) {
        var el = this[i];
        // If selected element isn't a tag, move on
        if (!utils_1$5.isTag(el))
            continue;
        // If we don't already have classes — always set xmlMode to false here, as it doesn't matter for classes
        var className = getAttr(el, 'class', false);
        if (!className) {
            setAttr(el, 'class', classNames.join(' ').trim());
        }
        else {
            var setClass = " " + className + " ";
            // Check if class already exists
            for (var j = 0; j < classNames.length; j++) {
                var appendClass = classNames[j] + " ";
                if (!setClass.includes(" " + appendClass))
                    setClass += appendClass;
            }
            setAttr(el, 'class', setClass.trim());
        }
    }
    return this;
}
attributes.addClass = addClass;
/**
 * Removes one or more space-separated classes from the selected elements. If no
 * `className` is defined, all classes will be removed. Also accepts a `function`.
 *
 * @category Attributes
 * @example
 *
 * ```js
 * $('.pear').removeClass('pear').html();
 * //=> <li class="">Pear</li>
 *
 * $('.apple').addClass('red').removeClass().html();
 * //=> <li class="">Apple</li>
 * ```
 *
 * @param name - Name of the class. If not specified, removes all elements.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/removeClass/}
 */
function removeClass(name) {
    // Handle if value is a function
    if (typeof name === 'function') {
        return utils_1$5.domEach(this, function (el, i) {
            if (utils_1$5.isTag(el))
                removeClass.call([el], name.call(el, i, el.attribs.class || ''));
        });
    }
    var classes = splitNames(name);
    var numClasses = classes.length;
    var removeAll = arguments.length === 0;
    return utils_1$5.domEach(this, function (el) {
        if (!utils_1$5.isTag(el))
            return;
        if (removeAll) {
            // Short circuit the remove all case as this is the nice one
            el.attribs.class = '';
        }
        else {
            var elClasses = splitNames(el.attribs.class);
            var changed = false;
            for (var j = 0; j < numClasses; j++) {
                var index = elClasses.indexOf(classes[j]);
                if (index >= 0) {
                    elClasses.splice(index, 1);
                    changed = true;
                    /*
                     * We have to do another pass to ensure that there are not duplicate
                     * classes listed
                     */
                    j--;
                }
            }
            if (changed) {
                el.attribs.class = elClasses.join(' ');
            }
        }
    });
}
attributes.removeClass = removeClass;
/**
 * Add or remove class(es) from the matched elements, depending on either the
 * class's presence or the value of the switch argument. Also accepts a `function`.
 *
 * @category Attributes
 * @example
 *
 * ```js
 * $('.apple.green').toggleClass('fruit green red').html();
 * //=> <li class="apple fruit red">Apple</li>
 *
 * $('.apple.green').toggleClass('fruit green red', true).html();
 * //=> <li class="apple green fruit red">Apple</li>
 * ```
 *
 * @param value - Name of the class. Can also be a function.
 * @param stateVal - If specified the state of the class.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/toggleClass/}
 */
function toggleClass(value, stateVal) {
    // Support functions
    if (typeof value === 'function') {
        return utils_1$5.domEach(this, function (el, i) {
            if (utils_1$5.isTag(el)) {
                toggleClass.call([el], value.call(el, i, el.attribs.class || '', stateVal), stateVal);
            }
        });
    }
    // Return if no value or not a string or function
    if (!value || typeof value !== 'string')
        return this;
    var classNames = value.split(rspace);
    var numClasses = classNames.length;
    var state = typeof stateVal === 'boolean' ? (stateVal ? 1 : -1) : 0;
    var numElements = this.length;
    for (var i = 0; i < numElements; i++) {
        var el = this[i];
        // If selected element isn't a tag, move on
        if (!utils_1$5.isTag(el))
            continue;
        var elementClasses = splitNames(el.attribs.class);
        // Check if class already exists
        for (var j = 0; j < numClasses; j++) {
            // Check if the class name is currently defined
            var index = elementClasses.indexOf(classNames[j]);
            // Add if stateValue === true or we are toggling and there is no value
            if (state >= 0 && index < 0) {
                elementClasses.push(classNames[j]);
            }
            else if (state <= 0 && index >= 0) {
                // Otherwise remove but only if the item exists
                elementClasses.splice(index, 1);
            }
        }
        el.attribs.class = elementClasses.join(' ');
    }
    return this;
}
attributes.toggleClass = toggleClass;

var traversing = {};

/**
 * Methods for traversing the DOM structure.
 *
 * @module cheerio/traversing
 */
Object.defineProperty(traversing, "__esModule", { value: true });
traversing.addBack = traversing.add = traversing.end = traversing.slice = traversing.index = traversing.toArray = traversing.get = traversing.eq = traversing.last = traversing.first = traversing.has = traversing.not = traversing.is = traversing.filterArray = traversing.filter = traversing.map = traversing.each = traversing.contents = traversing.children = traversing.siblings = traversing.prevUntil = traversing.prevAll = traversing.prev = traversing.nextUntil = traversing.nextAll = traversing.next = traversing.closest = traversing.parentsUntil = traversing.parents = traversing.parent = traversing.find = void 0;
var tslib_1$3 = require$$0$2;
var domhandler_1$1 = lib$7;
var select = tslib_1$3.__importStar(lib$b);
var utils_1$4 = utils$n;
var static_1$1 = _static;
var htmlparser2_1$1 = lib$2;
var uniqueSort = htmlparser2_1$1.DomUtils.uniqueSort;
var reSiblingSelector = /^\s*[~+]/;
/**
 * Get the descendants of each element in the current set of matched elements,
 * filtered by a selector, jQuery object, or element.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('#fruits').find('li').length;
 * //=> 3
 * $('#fruits').find($('.apple')).length;
 * //=> 1
 * ```
 *
 * @param selectorOrHaystack - Element to look for.
 * @returns The found elements.
 * @see {@link https://api.jquery.com/find/}
 */
function find(selectorOrHaystack) {
    var _a;
    if (!selectorOrHaystack) {
        return this._make([]);
    }
    var context = this.toArray();
    if (typeof selectorOrHaystack !== 'string') {
        var haystack = utils_1$4.isCheerio(selectorOrHaystack)
            ? selectorOrHaystack.toArray()
            : [selectorOrHaystack];
        return this._make(haystack.filter(function (elem) { return context.some(function (node) { return static_1$1.contains(node, elem); }); }));
    }
    var elems = reSiblingSelector.test(selectorOrHaystack)
        ? context
        : this.children().toArray();
    var options = {
        context: context,
        root: (_a = this._root) === null || _a === void 0 ? void 0 : _a[0],
        xmlMode: this.options.xmlMode,
    };
    return this._make(select.select(selectorOrHaystack, elems, options));
}
traversing.find = find;
/**
 * Creates a matcher, using a particular mapping function. Matchers provide a
 * function that finds elements using a generating function, supporting filtering.
 *
 * @private
 * @param matchMap - Mapping function.
 * @returns - Function for wrapping generating functions.
 */
function _getMatcher(matchMap) {
    return function (fn) {
        var postFns = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            postFns[_i - 1] = arguments[_i];
        }
        return function (selector) {
            var _a;
            var matched = matchMap(fn, this);
            if (selector) {
                matched = filterArray(matched, selector, this.options.xmlMode, (_a = this._root) === null || _a === void 0 ? void 0 : _a[0]);
            }
            return this._make(
            // Post processing is only necessary if there is more than one element.
            this.length > 1 && matched.length > 1
                ? postFns.reduce(function (elems, fn) { return fn(elems); }, matched)
                : matched);
        };
    };
}
/** Matcher that adds multiple elements for each entry in the input. */
var _matcher = _getMatcher(function (fn, elems) {
    var _a;
    var ret = [];
    for (var i = 0; i < elems.length; i++) {
        var value = fn(elems[i]);
        ret.push(value);
    }
    return (_a = new Array()).concat.apply(_a, ret);
});
/** Matcher that adds at most one element for each entry in the input. */
var _singleMatcher = _getMatcher(function (fn, elems) {
    var ret = [];
    for (var i = 0; i < elems.length; i++) {
        var value = fn(elems[i]);
        if (value !== null) {
            ret.push(value);
        }
    }
    return ret;
});
/**
 * Matcher that supports traversing until a condition is met.
 *
 * @returns A function usable for `*Until` methods.
 */
function _matchUntil(nextElem) {
    var postFns = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        postFns[_i - 1] = arguments[_i];
    }
    // We use a variable here that is used from within the matcher.
    var matches = null;
    var innerMatcher = _getMatcher(function (nextElem, elems) {
        var matched = [];
        utils_1$4.domEach(elems, function (elem) {
            for (var next_1; (next_1 = nextElem(elem)); elem = next_1) {
                // FIXME: `matched` might contain duplicates here and the index is too large.
                if (matches === null || matches === void 0 ? void 0 : matches(next_1, matched.length))
                    break;
                matched.push(next_1);
            }
        });
        return matched;
    }).apply(void 0, tslib_1$3.__spreadArray([nextElem], postFns));
    return function (selector, filterSelector) {
        var _this = this;
        // Override `matches` variable with the new target.
        matches =
            typeof selector === 'string'
                ? function (elem) { return select.is(elem, selector, _this.options); }
                : selector
                    ? getFilterFn(selector)
                    : null;
        var ret = innerMatcher.call(this, filterSelector);
        // Set `matches` to `null`, so we don't waste memory.
        matches = null;
        return ret;
    };
}
function _removeDuplicates(elems) {
    return Array.from(new Set(elems));
}
/**
 * Get the parent of each element in the current set of matched elements,
 * optionally filtered by a selector.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.pear').parent().attr('id');
 * //=> fruits
 * ```
 *
 * @param selector - If specified filter for parent.
 * @returns The parents.
 * @see {@link https://api.jquery.com/parent/}
 */
traversing.parent = _singleMatcher(function (_a) {
    var parent = _a.parent;
    return (parent && !domhandler_1$1.isDocument(parent) ? parent : null);
}, _removeDuplicates);
/**
 * Get a set of parents filtered by `selector` of each element in the current
 * set of match elements.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.orange').parents().length;
 * //=> 2
 * $('.orange').parents('#fruits').length;
 * //=> 1
 * ```
 *
 * @param selector - If specified filter for parents.
 * @returns The parents.
 * @see {@link https://api.jquery.com/parents/}
 */
traversing.parents = _matcher(function (elem) {
    var matched = [];
    while (elem.parent && !domhandler_1$1.isDocument(elem.parent)) {
        matched.push(elem.parent);
        elem = elem.parent;
    }
    return matched;
}, uniqueSort, function (elems) { return elems.reverse(); });
/**
 * Get the ancestors of each element in the current set of matched elements, up
 * to but not including the element matched by the selector, DOM node, or cheerio object.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.orange').parentsUntil('#food').length;
 * //=> 1
 * ```
 *
 * @param selector - Selector for element to stop at.
 * @param filterSelector - Optional filter for parents.
 * @returns The parents.
 * @see {@link https://api.jquery.com/parentsUntil/}
 */
traversing.parentsUntil = _matchUntil(function (_a) {
    var parent = _a.parent;
    return (parent && !domhandler_1$1.isDocument(parent) ? parent : null);
}, uniqueSort, function (elems) { return elems.reverse(); });
/**
 * For each element in the set, get the first element that matches the selector
 * by testing the element itself and traversing up through its ancestors in the DOM tree.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.orange').closest();
 * //=> []
 *
 * $('.orange').closest('.apple');
 * // => []
 *
 * $('.orange').closest('li');
 * //=> [<li class="orange">Orange</li>]
 *
 * $('.orange').closest('#fruits');
 * //=> [<ul id="fruits"> ... </ul>]
 * ```
 *
 * @param selector - Selector for the element to find.
 * @returns The closest nodes.
 * @see {@link https://api.jquery.com/closest/}
 */
function closest(selector) {
    var _this = this;
    var set = [];
    if (!selector) {
        return this._make(set);
    }
    utils_1$4.domEach(this, function (elem) {
        var _a;
        while (elem && elem.type !== 'root') {
            if (!selector ||
                filterArray([elem], selector, _this.options.xmlMode, (_a = _this._root) === null || _a === void 0 ? void 0 : _a[0])
                    .length) {
                // Do not add duplicate elements to the set
                if (elem && !set.includes(elem)) {
                    set.push(elem);
                }
                break;
            }
            elem = elem.parent;
        }
    });
    return this._make(set);
}
traversing.closest = closest;
/**
 * Gets the next sibling of the first selected element, optionally filtered by a selector.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.apple').next().hasClass('orange');
 * //=> true
 * ```
 *
 * @param selector - If specified filter for sibling.
 * @returns The next nodes.
 * @see {@link https://api.jquery.com/next/}
 */
traversing.next = _singleMatcher(function (elem) { return htmlparser2_1$1.DomUtils.nextElementSibling(elem); });
/**
 * Gets all the following siblings of the first selected element, optionally
 * filtered by a selector.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.apple').nextAll();
 * //=> [<li class="orange">Orange</li>, <li class="pear">Pear</li>]
 * $('.apple').nextAll('.orange');
 * //=> [<li class="orange">Orange</li>]
 * ```
 *
 * @param selector - If specified filter for siblings.
 * @returns The next nodes.
 * @see {@link https://api.jquery.com/nextAll/}
 */
traversing.nextAll = _matcher(function (elem) {
    var matched = [];
    while (elem.next) {
        elem = elem.next;
        if (utils_1$4.isTag(elem))
            matched.push(elem);
    }
    return matched;
}, _removeDuplicates);
/**
 * Gets all the following siblings up to but not including the element matched
 * by the selector, optionally filtered by another selector.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.apple').nextUntil('.pear');
 * //=> [<li class="orange">Orange</li>]
 * ```
 *
 * @param selector - Selector for element to stop at.
 * @param filterSelector - If specified filter for siblings.
 * @returns The next nodes.
 * @see {@link https://api.jquery.com/nextUntil/}
 */
traversing.nextUntil = _matchUntil(function (el) { return htmlparser2_1$1.DomUtils.nextElementSibling(el); }, _removeDuplicates);
/**
 * Gets the previous sibling of the first selected element optionally filtered
 * by a selector.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.orange').prev().hasClass('apple');
 * //=> true
 * ```
 *
 * @param selector - If specified filter for siblings.
 * @returns The previous nodes.
 * @see {@link https://api.jquery.com/prev/}
 */
traversing.prev = _singleMatcher(function (elem) { return htmlparser2_1$1.DomUtils.prevElementSibling(elem); });
/**
 * Gets all the preceding siblings of the first selected element, optionally
 * filtered by a selector.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.pear').prevAll();
 * //=> [<li class="orange">Orange</li>, <li class="apple">Apple</li>]
 *
 * $('.pear').prevAll('.orange');
 * //=> [<li class="orange">Orange</li>]
 * ```
 *
 * @param selector - If specified filter for siblings.
 * @returns The previous nodes.
 * @see {@link https://api.jquery.com/prevAll/}
 */
traversing.prevAll = _matcher(function (elem) {
    var matched = [];
    while (elem.prev) {
        elem = elem.prev;
        if (utils_1$4.isTag(elem))
            matched.push(elem);
    }
    return matched;
}, _removeDuplicates);
/**
 * Gets all the preceding siblings up to but not including the element matched
 * by the selector, optionally filtered by another selector.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.pear').prevUntil('.apple');
 * //=> [<li class="orange">Orange</li>]
 * ```
 *
 * @param selector - Selector for element to stop at.
 * @param filterSelector - If specified filter for siblings.
 * @returns The previous nodes.
 * @see {@link https://api.jquery.com/prevUntil/}
 */
traversing.prevUntil = _matchUntil(function (el) { return htmlparser2_1$1.DomUtils.prevElementSibling(el); }, _removeDuplicates);
/**
 * Get the siblings of each element (excluding the element) in the set of
 * matched elements, optionally filtered by a selector.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.pear').siblings().length;
 * //=> 2
 *
 * $('.pear').siblings('.orange').length;
 * //=> 1
 * ```
 *
 * @param selector - If specified filter for siblings.
 * @returns The siblings.
 * @see {@link https://api.jquery.com/siblings/}
 */
traversing.siblings = _matcher(function (elem) {
    return htmlparser2_1$1.DomUtils.getSiblings(elem).filter(function (el) { return utils_1$4.isTag(el) && el !== elem; });
}, uniqueSort);
/**
 * Gets the children of the first selected element.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('#fruits').children().length;
 * //=> 3
 *
 * $('#fruits').children('.pear').text();
 * //=> Pear
 * ```
 *
 * @param selector - If specified filter for children.
 * @returns The children.
 * @see {@link https://api.jquery.com/children/}
 */
traversing.children = _matcher(function (elem) { return htmlparser2_1$1.DomUtils.getChildren(elem).filter(utils_1$4.isTag); }, _removeDuplicates);
/**
 * Gets the children of each element in the set of matched elements, including
 * text and comment nodes.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('#fruits').contents().length;
 * //=> 3
 * ```
 *
 * @returns The children.
 * @see {@link https://api.jquery.com/contents/}
 */
function contents() {
    var elems = this.toArray().reduce(function (newElems, elem) {
        return domhandler_1$1.hasChildren(elem) ? newElems.concat(elem.children) : newElems;
    }, []);
    return this._make(elems);
}
traversing.contents = contents;
/**
 * Iterates over a cheerio object, executing a function for each matched
 * element. When the callback is fired, the function is fired in the context of
 * the DOM element, so `this` refers to the current element, which is equivalent
 * to the function parameter `element`. To break out of the `each` loop early,
 * return with `false`.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * const fruits = [];
 *
 * $('li').each(function (i, elem) {
 *   fruits[i] = $(this).text();
 * });
 *
 * fruits.join(', ');
 * //=> Apple, Orange, Pear
 * ```
 *
 * @param fn - Function to execute.
 * @returns The instance itself, useful for chaining.
 * @see {@link https://api.jquery.com/each/}
 */
function each(fn) {
    var i = 0;
    var len = this.length;
    while (i < len && fn.call(this[i], i, this[i]) !== false)
        ++i;
    return this;
}
traversing.each = each;
/**
 * Pass each element in the current matched set through a function, producing a
 * new Cheerio object containing the return values. The function can return an
 * individual data item or an array of data items to be inserted into the
 * resulting set. If an array is returned, the elements inside the array are
 * inserted into the set. If the function returns null or undefined, no element
 * will be inserted.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('li')
 *   .map(function (i, el) {
 *     // this === el
 *     return $(this).text();
 *   })
 *   .toArray()
 *   .join(' ');
 * //=> "apple orange pear"
 * ```
 *
 * @param fn - Function to execute.
 * @returns The mapped elements, wrapped in a Cheerio collection.
 * @see {@link https://api.jquery.com/map/}
 */
function map(fn) {
    var elems = [];
    for (var i = 0; i < this.length; i++) {
        var el = this[i];
        var val = fn.call(el, i, el);
        if (val != null) {
            elems = elems.concat(val);
        }
    }
    return this._make(elems);
}
traversing.map = map;
/**
 * Creates a function to test if a filter is matched.
 *
 * @param match - A filter.
 * @returns A function that determines if a filter has been matched.
 */
function getFilterFn(match) {
    if (typeof match === 'function') {
        return function (el, i) { return match.call(el, i, el); };
    }
    if (utils_1$4.isCheerio(match)) {
        return function (el) { return Array.prototype.includes.call(match, el); };
    }
    return function (el) {
        return match === el;
    };
}
function filter(match) {
    var _a;
    return this._make(filterArray(this.toArray(), match, this.options.xmlMode, (_a = this._root) === null || _a === void 0 ? void 0 : _a[0]));
}
traversing.filter = filter;
function filterArray(nodes, match, xmlMode, root) {
    return typeof match === 'string'
        ? select.filter(match, nodes, { xmlMode: xmlMode, root: root })
        : nodes.filter(getFilterFn(match));
}
traversing.filterArray = filterArray;
/**
 * Checks the current list of elements and returns `true` if *any* of the
 * elements match the selector. If using an element or Cheerio selection,
 * returns `true` if *any* of the elements match. If using a predicate function,
 * the function is executed in the context of the selected element, so `this`
 * refers to the current element.
 *
 * @category Attributes
 * @param selector - Selector for the selection.
 * @returns Whether or not the selector matches an element of the instance.
 * @see {@link https://api.jquery.com/is/}
 */
function is(selector) {
    var nodes = this.toArray();
    return typeof selector === 'string'
        ? select.some(nodes.filter(utils_1$4.isTag), selector, this.options)
        : selector
            ? nodes.some(getFilterFn(selector))
            : false;
}
traversing.is = is;
/**
 * Remove elements from the set of matched elements. Given a Cheerio object that
 * represents a set of DOM elements, the `.not()` method constructs a new
 * Cheerio object from a subset of the matching elements. The supplied selector
 * is tested against each element; the elements that don't match the selector
 * will be included in the result.
 *
 * The `.not()` method can take a function as its argument in the same way that
 * `.filter()` does. Elements for which the function returns `true` are excluded
 * from the filtered set; all other elements are included.
 *
 * @category Traversing
 * @example <caption>Selector</caption>
 *
 * ```js
 * $('li').not('.apple').length;
 * //=> 2
 * ```
 *
 * @example <caption>Function</caption>
 *
 * ```js
 * $('li').not(function (i, el) {
 *   // this === el
 *   return $(this).attr('class') === 'orange';
 * }).length; //=> 2
 * ```
 *
 * @param match - Value to look for, following the rules above.
 * @param container - Optional node to filter instead.
 * @returns The filtered collection.
 * @see {@link https://api.jquery.com/not/}
 */
function not(match) {
    var nodes = this.toArray();
    if (typeof match === 'string') {
        var matches_1 = new Set(select.filter(match, nodes, this.options));
        nodes = nodes.filter(function (el) { return !matches_1.has(el); });
    }
    else {
        var filterFn_1 = getFilterFn(match);
        nodes = nodes.filter(function (el, i) { return !filterFn_1(el, i); });
    }
    return this._make(nodes);
}
traversing.not = not;
/**
 * Filters the set of matched elements to only those which have the given DOM
 * element as a descendant or which have a descendant that matches the given
 * selector. Equivalent to `.filter(':has(selector)')`.
 *
 * @category Traversing
 * @example <caption>Selector</caption>
 *
 * ```js
 * $('ul').has('.pear').attr('id');
 * //=> fruits
 * ```
 *
 * @example <caption>Element</caption>
 *
 * ```js
 * $('ul').has($('.pear')[0]).attr('id');
 * //=> fruits
 * ```
 *
 * @param selectorOrHaystack - Element to look for.
 * @returns The filtered collection.
 * @see {@link https://api.jquery.com/has/}
 */
function has(selectorOrHaystack) {
    var _this = this;
    return this.filter(typeof selectorOrHaystack === 'string'
        ? // Using the `:has` selector here short-circuits searches.
            ":has(" + selectorOrHaystack + ")"
        : function (_, el) { return _this._make(el).find(selectorOrHaystack).length > 0; });
}
traversing.has = has;
/**
 * Will select the first element of a cheerio object.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('#fruits').children().first().text();
 * //=> Apple
 * ```
 *
 * @returns The first element.
 * @see {@link https://api.jquery.com/first/}
 */
function first$2() {
    return this.length > 1 ? this._make(this[0]) : this;
}
traversing.first = first$2;
/**
 * Will select the last element of a cheerio object.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('#fruits').children().last().text();
 * //=> Pear
 * ```
 *
 * @returns The last element.
 * @see {@link https://api.jquery.com/last/}
 */
function last() {
    return this.length > 0 ? this._make(this[this.length - 1]) : this;
}
traversing.last = last;
/**
 * Reduce the set of matched elements to the one at the specified index. Use
 * `.eq(-i)` to count backwards from the last selected element.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('li').eq(0).text();
 * //=> Apple
 *
 * $('li').eq(-1).text();
 * //=> Pear
 * ```
 *
 * @param i - Index of the element to select.
 * @returns The element at the `i`th position.
 * @see {@link https://api.jquery.com/eq/}
 */
function eq(i) {
    var _a;
    i = +i;
    // Use the first identity optimization if possible
    if (i === 0 && this.length <= 1)
        return this;
    if (i < 0)
        i = this.length + i;
    return this._make((_a = this[i]) !== null && _a !== void 0 ? _a : []);
}
traversing.eq = eq;
function get(i) {
    if (i == null) {
        return this.toArray();
    }
    return this[i < 0 ? this.length + i : i];
}
traversing.get = get;
/**
 * Retrieve all the DOM elements contained in the jQuery set as an array.
 *
 * @example
 *
 * ```js
 * $('li').toArray();
 * //=> [ {...}, {...}, {...} ]
 * ```
 *
 * @returns The contained items.
 */
function toArray$4() {
    return Array.prototype.slice.call(this);
}
traversing.toArray = toArray$4;
/**
 * Search for a given element from among the matched elements.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.pear').index();
 * //=> 2 $('.orange').index('li');
 * //=> 1
 * $('.apple').index($('#fruit, li'));
 * //=> 1
 * ```
 *
 * @param selectorOrNeedle - Element to look for.
 * @returns The index of the element.
 * @see {@link https://api.jquery.com/index/}
 */
function index(selectorOrNeedle) {
    var $haystack;
    var needle;
    if (selectorOrNeedle == null) {
        $haystack = this.parent().children();
        needle = this[0];
    }
    else if (typeof selectorOrNeedle === 'string') {
        $haystack = this._make(selectorOrNeedle);
        needle = this[0];
    }
    else {
        $haystack = this;
        needle = utils_1$4.isCheerio(selectorOrNeedle)
            ? selectorOrNeedle[0]
            : selectorOrNeedle;
    }
    return Array.prototype.indexOf.call($haystack, needle);
}
traversing.index = index;
/**
 * Gets the elements matching the specified range (0-based position).
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('li').slice(1).eq(0).text();
 * //=> 'Orange'
 *
 * $('li').slice(1, 2).length;
 * //=> 1
 * ```
 *
 * @param start - An position at which the elements begin to be selected. If
 *   negative, it indicates an offset from the end of the set.
 * @param end - An position at which the elements stop being selected. If
 *   negative, it indicates an offset from the end of the set. If omitted, the
 *   range continues until the end of the set.
 * @returns The elements matching the specified range.
 * @see {@link https://api.jquery.com/slice/}
 */
function slice$2(start, end) {
    return this._make(Array.prototype.slice.call(this, start, end));
}
traversing.slice = slice$2;
/**
 * End the most recent filtering operation in the current chain and return the
 * set of matched elements to its previous state.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('li').eq(0).end().length;
 * //=> 3
 * ```
 *
 * @returns The previous state of the set of matched elements.
 * @see {@link https://api.jquery.com/end/}
 */
function end() {
    var _a;
    return (_a = this.prevObject) !== null && _a !== void 0 ? _a : this._make([]);
}
traversing.end = end;
/**
 * Add elements to the set of matched elements.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.apple').add('.orange').length;
 * //=> 2
 * ```
 *
 * @param other - Elements to add.
 * @param context - Optionally the context of the new selection.
 * @returns The combined set.
 * @see {@link https://api.jquery.com/add/}
 */
function add(other, context) {
    var selection = this._make(other, context);
    var contents = uniqueSort(tslib_1$3.__spreadArray(tslib_1$3.__spreadArray([], this.get()), selection.get()));
    return this._make(contents);
}
traversing.add = add;
/**
 * Add the previous set of elements on the stack to the current set, optionally
 * filtered by a selector.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('li').eq(0).addBack('.orange').length;
 * //=> 2
 * ```
 *
 * @param selector - Selector for the elements to add.
 * @returns The combined set.
 * @see {@link https://api.jquery.com/addBack/}
 */
function addBack(selector) {
    return this.prevObject
        ? this.add(selector ? this.prevObject.filter(selector) : this.prevObject)
        : this;
}
traversing.addBack = addBack;

var manipulation = {};

Object.defineProperty(manipulation, "__esModule", { value: true });
manipulation.clone = manipulation.text = manipulation.toString = manipulation.html = manipulation.empty = manipulation.replaceWith = manipulation.remove = manipulation.insertBefore = manipulation.before = manipulation.insertAfter = manipulation.after = manipulation.wrapAll = manipulation.unwrap = manipulation.wrapInner = manipulation.wrap = manipulation.prepend = manipulation.append = manipulation.prependTo = manipulation.appendTo = manipulation._makeDomArray = void 0;
var tslib_1$2 = require$$0$2;
var domhandler_1 = lib$7;
/**
 * Methods for modifying the DOM structure.
 *
 * @module cheerio/manipulation
 */
var domhandler_2 = lib$7;
var parse_1$4 = tslib_1$2.__importStar(parse$a);
var static_1 = _static;
var utils_1$3 = utils$n;
var htmlparser2_1 = lib$2;
/**
 * Create an array of nodes, recursing into arrays and parsing strings if necessary.
 *
 * @private
 * @category Manipulation
 * @param elem - Elements to make an array of.
 * @param clone - Optionally clone nodes.
 * @returns The array of nodes.
 */
function _makeDomArray(elem, clone) {
    var _this = this;
    if (elem == null) {
        return [];
    }
    if (utils_1$3.isCheerio(elem)) {
        return clone ? utils_1$3.cloneDom(elem.get()) : elem.get();
    }
    if (Array.isArray(elem)) {
        return elem.reduce(function (newElems, el) { return newElems.concat(_this._makeDomArray(el, clone)); }, []);
    }
    if (typeof elem === 'string') {
        return parse_1$4.default(elem, this.options, false).children;
    }
    return clone ? utils_1$3.cloneDom([elem]) : [elem];
}
manipulation._makeDomArray = _makeDomArray;
function _insert(concatenator) {
    return function () {
        var _this = this;
        var elems = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            elems[_i] = arguments[_i];
        }
        var lastIdx = this.length - 1;
        return utils_1$3.domEach(this, function (el, i) {
            if (!domhandler_1.hasChildren(el))
                return;
            var domSrc = typeof elems[0] === 'function'
                ? elems[0].call(el, i, static_1.html(el.children))
                : elems;
            var dom = _this._makeDomArray(domSrc, i < lastIdx);
            concatenator(dom, el.children, el);
        });
    };
}
/**
 * Modify an array in-place, removing some number of elements and adding new
 * elements directly following them.
 *
 * @private
 * @category Manipulation
 * @param array - Target array to splice.
 * @param spliceIdx - Index at which to begin changing the array.
 * @param spliceCount - Number of elements to remove from the array.
 * @param newElems - Elements to insert into the array.
 * @param parent - The parent of the node.
 * @returns The spliced array.
 */
function uniqueSplice(array, spliceIdx, spliceCount, newElems, parent) {
    var _a, _b;
    var spliceArgs = tslib_1$2.__spreadArray([
        spliceIdx,
        spliceCount
    ], newElems);
    var prev = array[spliceIdx - 1] || null;
    var next = array[spliceIdx + spliceCount] || null;
    /*
     * Before splicing in new elements, ensure they do not already appear in the
     * current array.
     */
    for (var idx = 0; idx < newElems.length; ++idx) {
        var node = newElems[idx];
        var oldParent = node.parent;
        if (oldParent) {
            var prevIdx = oldParent.children.indexOf(newElems[idx]);
            if (prevIdx > -1) {
                oldParent.children.splice(prevIdx, 1);
                if (parent === oldParent && spliceIdx > prevIdx) {
                    spliceArgs[0]--;
                }
            }
        }
        node.parent = parent;
        if (node.prev) {
            node.prev.next = (_a = node.next) !== null && _a !== void 0 ? _a : null;
        }
        if (node.next) {
            node.next.prev = (_b = node.prev) !== null && _b !== void 0 ? _b : null;
        }
        node.prev = newElems[idx - 1] || prev;
        node.next = newElems[idx + 1] || next;
    }
    if (prev) {
        prev.next = newElems[0];
    }
    if (next) {
        next.prev = newElems[newElems.length - 1];
    }
    return array.splice.apply(array, spliceArgs);
}
/**
 * Insert every element in the set of matched elements to the end of the target.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * $('<li class="plum">Plum</li>').appendTo('#fruits');
 * $.html();
 * //=>  <ul id="fruits">
 * //      <li class="apple">Apple</li>
 * //      <li class="orange">Orange</li>
 * //      <li class="pear">Pear</li>
 * //      <li class="plum">Plum</li>
 * //    </ul>
 * ```
 *
 * @param target - Element to append elements to.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/appendTo/}
 */
function appendTo(target) {
    var appendTarget = utils_1$3.isCheerio(target) ? target : this._make(target);
    appendTarget.append(this);
    return this;
}
manipulation.appendTo = appendTo;
/**
 * Insert every element in the set of matched elements to the beginning of the target.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * $('<li class="plum">Plum</li>').prependTo('#fruits');
 * $.html();
 * //=>  <ul id="fruits">
 * //      <li class="plum">Plum</li>
 * //      <li class="apple">Apple</li>
 * //      <li class="orange">Orange</li>
 * //      <li class="pear">Pear</li>
 * //    </ul>
 * ```
 *
 * @param target - Element to prepend elements to.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/prependTo/}
 */
function prependTo(target) {
    var prependTarget = utils_1$3.isCheerio(target) ? target : this._make(target);
    prependTarget.prepend(this);
    return this;
}
manipulation.prependTo = prependTo;
/**
 * Inserts content as the *last* child of each of the selected elements.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * $('ul').append('<li class="plum">Plum</li>');
 * $.html();
 * //=>  <ul id="fruits">
 * //      <li class="apple">Apple</li>
 * //      <li class="orange">Orange</li>
 * //      <li class="pear">Pear</li>
 * //      <li class="plum">Plum</li>
 * //    </ul>
 * ```
 *
 * @see {@link https://api.jquery.com/append/}
 */
manipulation.append = _insert(function (dom, children, parent) {
    uniqueSplice(children, children.length, 0, dom, parent);
});
/**
 * Inserts content as the *first* child of each of the selected elements.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * $('ul').prepend('<li class="plum">Plum</li>');
 * $.html();
 * //=>  <ul id="fruits">
 * //      <li class="plum">Plum</li>
 * //      <li class="apple">Apple</li>
 * //      <li class="orange">Orange</li>
 * //      <li class="pear">Pear</li>
 * //    </ul>
 * ```
 *
 * @see {@link https://api.jquery.com/prepend/}
 */
manipulation.prepend = _insert(function (dom, children, parent) {
    uniqueSplice(children, 0, 0, dom, parent);
});
function _wrap(insert) {
    return function (wrapper) {
        var lastIdx = this.length - 1;
        var lastParent = this.parents().last();
        for (var i = 0; i < this.length; i++) {
            var el = this[i];
            var wrap_1 = typeof wrapper === 'function'
                ? wrapper.call(el, i, el)
                : typeof wrapper === 'string' && !utils_1$3.isHtml(wrapper)
                    ? lastParent.find(wrapper).clone()
                    : wrapper;
            var wrapperDom = this._makeDomArray(wrap_1, i < lastIdx)[0];
            if (!wrapperDom || !htmlparser2_1.DomUtils.hasChildren(wrapperDom))
                continue;
            var elInsertLocation = wrapperDom;
            /*
             * Find the deepest child. Only consider the first tag child of each node
             * (ignore text); stop if no children are found.
             */
            var j = 0;
            while (j < elInsertLocation.children.length) {
                var child = elInsertLocation.children[j];
                if (utils_1$3.isTag(child)) {
                    elInsertLocation = child;
                    j = 0;
                }
                else {
                    j++;
                }
            }
            insert(el, elInsertLocation, [wrapperDom]);
        }
        return this;
    };
}
/**
 * The .wrap() function can take any string or object that could be passed to
 * the $() factory function to specify a DOM structure. This structure may be
 * nested several levels deep, but should contain only one inmost element. A
 * copy of this structure will be wrapped around each of the elements in the set
 * of matched elements. This method returns the original set of elements for
 * chaining purposes.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * const redFruit = $('<div class="red-fruit"></div>');
 * $('.apple').wrap(redFruit);
 *
 * //=> <ul id="fruits">
 * //     <div class="red-fruit">
 * //      <li class="apple">Apple</li>
 * //     </div>
 * //     <li class="orange">Orange</li>
 * //     <li class="plum">Plum</li>
 * //   </ul>
 *
 * const healthy = $('<div class="healthy"></div>');
 * $('li').wrap(healthy);
 *
 * //=> <ul id="fruits">
 * //     <div class="healthy">
 * //       <li class="apple">Apple</li>
 * //     </div>
 * //     <div class="healthy">
 * //       <li class="orange">Orange</li>
 * //     </div>
 * //     <div class="healthy">
 * //        <li class="plum">Plum</li>
 * //     </div>
 * //   </ul>
 * ```
 *
 * @param wrapper - The DOM structure to wrap around each element in the selection.
 * @see {@link https://api.jquery.com/wrap/}
 */
manipulation.wrap = _wrap(function (el, elInsertLocation, wrapperDom) {
    var parent = el.parent;
    if (!parent)
        return;
    var siblings = parent.children;
    var index = siblings.indexOf(el);
    parse_1$4.update([el], elInsertLocation);
    /*
     * The previous operation removed the current element from the `siblings`
     * array, so the `dom` array can be inserted without removing any
     * additional elements.
     */
    uniqueSplice(siblings, index, 0, wrapperDom, parent);
});
/**
 * The .wrapInner() function can take any string or object that could be passed
 * to the $() factory function to specify a DOM structure. This structure may be
 * nested several levels deep, but should contain only one inmost element. The
 * structure will be wrapped around the content of each of the elements in the
 * set of matched elements.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * const redFruit = $('<div class="red-fruit"></div>');
 * $('.apple').wrapInner(redFruit);
 *
 * //=> <ul id="fruits">
 * //     <li class="apple">
 * //       <div class="red-fruit">Apple</div>
 * //     </li>
 * //     <li class="orange">Orange</li>
 * //     <li class="pear">Pear</li>
 * //   </ul>
 *
 * const healthy = $('<div class="healthy"></div>');
 * $('li').wrapInner(healthy);
 *
 * //=> <ul id="fruits">
 * //     <li class="apple">
 * //       <div class="healthy">Apple</div>
 * //     </li>
 * //     <li class="orange">
 * //       <div class="healthy">Orange</div>
 * //     </li>
 * //     <li class="pear">
 * //       <div class="healthy">Pear</div>
 * //     </li>
 * //   </ul>
 * ```
 *
 * @param wrapper - The DOM structure to wrap around the content of each element
 *   in the selection.
 * @returns The instance itself, for chaining.
 * @see {@link https://api.jquery.com/wrapInner/}
 */
manipulation.wrapInner = _wrap(function (el, elInsertLocation, wrapperDom) {
    if (!domhandler_1.hasChildren(el))
        return;
    parse_1$4.update(el.children, elInsertLocation);
    parse_1$4.update(wrapperDom, el);
});
/**
 * The .unwrap() function, removes the parents of the set of matched elements
 * from the DOM, leaving the matched elements in their place.
 *
 * @category Manipulation
 * @example <caption>without selector</caption>
 *
 * ```js
 * const $ = cheerio.load(
 *   '<div id=test>\n  <div><p>Hello</p></div>\n  <div><p>World</p></div>\n</div>'
 * );
 * $('#test p').unwrap();
 *
 * //=> <div id=test>
 * //     <p>Hello</p>
 * //     <p>World</p>
 * //   </div>
 * ```
 *
 * @example <caption>with selector</caption>
 *
 * ```js
 * const $ = cheerio.load(
 *   '<div id=test>\n  <p>Hello</p>\n  <b><p>World</p></b>\n</div>'
 * );
 * $('#test p').unwrap('b');
 *
 * //=> <div id=test>
 * //     <p>Hello</p>
 * //     <p>World</p>
 * //   </div>
 * ```
 *
 * @param selector - A selector to check the parent element against. If an
 *   element's parent does not match the selector, the element won't be unwrapped.
 * @returns The instance itself, for chaining.
 * @see {@link https://api.jquery.com/unwrap/}
 */
function unwrap(selector) {
    var _this = this;
    this.parent(selector)
        .not('body')
        .each(function (_, el) {
        _this._make(el).replaceWith(el.children);
    });
    return this;
}
manipulation.unwrap = unwrap;
/**
 * The .wrapAll() function can take any string or object that could be passed to
 * the $() function to specify a DOM structure. This structure may be nested
 * several levels deep, but should contain only one inmost element. The
 * structure will be wrapped around all of the elements in the set of matched
 * elements, as a single group.
 *
 * @category Manipulation
 * @example <caption>With markup passed to `wrapAll`</caption>
 *
 * ```js
 * const $ = cheerio.load(
 *   '<div class="container"><div class="inner">First</div><div class="inner">Second</div></div>'
 * );
 * $('.inner').wrapAll("<div class='new'></div>");
 *
 * //=> <div class="container">
 * //     <div class='new'>
 * //       <div class="inner">First</div>
 * //       <div class="inner">Second</div>
 * //     </div>
 * //   </div>
 * ```
 *
 * @example <caption>With an existing cheerio instance</caption>
 *
 * ```js
 * const $ = cheerio.load(
 *   '<span>Span 1</span><strong>Strong</strong><span>Span 2</span>'
 * );
 * const wrap = $('<div><p><em><b></b></em></p></div>');
 * $('span').wrapAll(wrap);
 *
 * //=> <div>
 * //     <p>
 * //       <em>
 * //         <b>
 * //           <span>Span 1</span>
 * //           <span>Span 2</span>
 * //         </b>
 * //       </em>
 * //     </p>
 * //   </div>
 * //   <strong>Strong</strong>
 * ```
 *
 * @param wrapper - The DOM structure to wrap around all matched elements in the
 *   selection.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/wrapAll/}
 */
function wrapAll(wrapper) {
    var el = this[0];
    if (el) {
        var wrap_2 = this._make(typeof wrapper === 'function' ? wrapper.call(el, 0, el) : wrapper).insertBefore(el);
        // If html is given as wrapper, wrap may contain text elements
        var elInsertLocation = void 0;
        for (var i = 0; i < wrap_2.length; i++) {
            if (wrap_2[i].type === 'tag')
                elInsertLocation = wrap_2[i];
        }
        var j = 0;
        /*
         * Find the deepest child. Only consider the first tag child of each node
         * (ignore text); stop if no children are found.
         */
        while (elInsertLocation && j < elInsertLocation.children.length) {
            var child = elInsertLocation.children[j];
            if (child.type === 'tag') {
                elInsertLocation = child;
                j = 0;
            }
            else {
                j++;
            }
        }
        if (elInsertLocation)
            this._make(elInsertLocation).append(this);
    }
    return this;
}
manipulation.wrapAll = wrapAll;
/* eslint-disable jsdoc/check-param-names*/
/**
 * Insert content next to each element in the set of matched elements.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * $('.apple').after('<li class="plum">Plum</li>');
 * $.html();
 * //=>  <ul id="fruits">
 * //      <li class="apple">Apple</li>
 * //      <li class="plum">Plum</li>
 * //      <li class="orange">Orange</li>
 * //      <li class="pear">Pear</li>
 * //    </ul>
 * ```
 *
 * @param content - HTML string, DOM element, array of DOM elements or Cheerio
 *   to insert after each element in the set of matched elements.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/after/}
 */
function after() {
    var _this = this;
    var elems = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        elems[_i] = arguments[_i];
    }
    var lastIdx = this.length - 1;
    return utils_1$3.domEach(this, function (el, i) {
        var parent = el.parent;
        if (!htmlparser2_1.DomUtils.hasChildren(el) || !parent) {
            return;
        }
        var siblings = parent.children;
        var index = siblings.indexOf(el);
        // If not found, move on
        /* istanbul ignore next */
        if (index < 0)
            return;
        var domSrc = typeof elems[0] === 'function'
            ? elems[0].call(el, i, static_1.html(el.children))
            : elems;
        var dom = _this._makeDomArray(domSrc, i < lastIdx);
        // Add element after `this` element
        uniqueSplice(siblings, index + 1, 0, dom, parent);
    });
}
manipulation.after = after;
/* eslint-enable jsdoc/check-param-names*/
/**
 * Insert every element in the set of matched elements after the target.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * $('<li class="plum">Plum</li>').insertAfter('.apple');
 * $.html();
 * //=>  <ul id="fruits">
 * //      <li class="apple">Apple</li>
 * //      <li class="plum">Plum</li>
 * //      <li class="orange">Orange</li>
 * //      <li class="pear">Pear</li>
 * //    </ul>
 * ```
 *
 * @param target - Element to insert elements after.
 * @returns The set of newly inserted elements.
 * @see {@link https://api.jquery.com/insertAfter/}
 */
function insertAfter(target) {
    var _this = this;
    if (typeof target === 'string') {
        target = this._make(target);
    }
    this.remove();
    var clones = [];
    this._makeDomArray(target).forEach(function (el) {
        var clonedSelf = _this.clone().toArray();
        var parent = el.parent;
        if (!parent) {
            return;
        }
        var siblings = parent.children;
        var index = siblings.indexOf(el);
        // If not found, move on
        /* istanbul ignore next */
        if (index < 0)
            return;
        // Add cloned `this` element(s) after target element
        uniqueSplice(siblings, index + 1, 0, clonedSelf, parent);
        clones.push.apply(clones, clonedSelf);
    });
    return this._make(clones);
}
manipulation.insertAfter = insertAfter;
/* eslint-disable jsdoc/check-param-names*/
/**
 * Insert content previous to each element in the set of matched elements.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * $('.apple').before('<li class="plum">Plum</li>');
 * $.html();
 * //=>  <ul id="fruits">
 * //      <li class="plum">Plum</li>
 * //      <li class="apple">Apple</li>
 * //      <li class="orange">Orange</li>
 * //      <li class="pear">Pear</li>
 * //    </ul>
 * ```
 *
 * @param content - HTML string, DOM element, array of DOM elements or Cheerio
 *   to insert before each element in the set of matched elements.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/before/}
 */
function before() {
    var _this = this;
    var elems = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        elems[_i] = arguments[_i];
    }
    var lastIdx = this.length - 1;
    return utils_1$3.domEach(this, function (el, i) {
        var parent = el.parent;
        if (!htmlparser2_1.DomUtils.hasChildren(el) || !parent) {
            return;
        }
        var siblings = parent.children;
        var index = siblings.indexOf(el);
        // If not found, move on
        /* istanbul ignore next */
        if (index < 0)
            return;
        var domSrc = typeof elems[0] === 'function'
            ? elems[0].call(el, i, static_1.html(el.children))
            : elems;
        var dom = _this._makeDomArray(domSrc, i < lastIdx);
        // Add element before `el` element
        uniqueSplice(siblings, index, 0, dom, parent);
    });
}
manipulation.before = before;
/* eslint-enable jsdoc/check-param-names*/
/**
 * Insert every element in the set of matched elements before the target.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * $('<li class="plum">Plum</li>').insertBefore('.apple');
 * $.html();
 * //=>  <ul id="fruits">
 * //      <li class="plum">Plum</li>
 * //      <li class="apple">Apple</li>
 * //      <li class="orange">Orange</li>
 * //      <li class="pear">Pear</li>
 * //    </ul>
 * ```
 *
 * @param target - Element to insert elements before.
 * @returns The set of newly inserted elements.
 * @see {@link https://api.jquery.com/insertBefore/}
 */
function insertBefore(target) {
    var _this = this;
    var targetArr = this._make(target);
    this.remove();
    var clones = [];
    utils_1$3.domEach(targetArr, function (el) {
        var clonedSelf = _this.clone().toArray();
        var parent = el.parent;
        if (!parent) {
            return;
        }
        var siblings = parent.children;
        var index = siblings.indexOf(el);
        // If not found, move on
        /* istanbul ignore next */
        if (index < 0)
            return;
        // Add cloned `this` element(s) after target element
        uniqueSplice(siblings, index, 0, clonedSelf, parent);
        clones.push.apply(clones, clonedSelf);
    });
    return this._make(clones);
}
manipulation.insertBefore = insertBefore;
/**
 * Removes the set of matched elements from the DOM and all their children.
 * `selector` filters the set of matched elements to be removed.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * $('.pear').remove();
 * $.html();
 * //=>  <ul id="fruits">
 * //      <li class="apple">Apple</li>
 * //      <li class="orange">Orange</li>
 * //    </ul>
 * ```
 *
 * @param selector - Optional selector for elements to remove.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/remove/}
 */
function remove$3(selector) {
    // Filter if we have selector
    var elems = selector ? this.filter(selector) : this;
    utils_1$3.domEach(elems, function (el) {
        htmlparser2_1.DomUtils.removeElement(el);
        el.prev = el.next = el.parent = null;
    });
    return this;
}
manipulation.remove = remove$3;
/**
 * Replaces matched elements with `content`.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * const plum = $('<li class="plum">Plum</li>');
 * $('.pear').replaceWith(plum);
 * $.html();
 * //=> <ul id="fruits">
 * //     <li class="apple">Apple</li>
 * //     <li class="orange">Orange</li>
 * //     <li class="plum">Plum</li>
 * //   </ul>
 * ```
 *
 * @param content - Replacement for matched elements.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/replaceWith/}
 */
function replaceWith(content) {
    var _this = this;
    return utils_1$3.domEach(this, function (el, i) {
        var parent = el.parent;
        if (!parent) {
            return;
        }
        var siblings = parent.children;
        var cont = typeof content === 'function' ? content.call(el, i, el) : content;
        var dom = _this._makeDomArray(cont);
        /*
         * In the case that `dom` contains nodes that already exist in other
         * structures, ensure those nodes are properly removed.
         */
        parse_1$4.update(dom, null);
        var index = siblings.indexOf(el);
        // Completely remove old element
        uniqueSplice(siblings, index, 1, dom, parent);
        if (!dom.includes(el)) {
            el.parent = el.prev = el.next = null;
        }
    });
}
manipulation.replaceWith = replaceWith;
/**
 * Empties an element, removing all its children.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * $('ul').empty();
 * $.html();
 * //=>  <ul id="fruits"></ul>
 * ```
 *
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/empty/}
 */
function empty$1() {
    return utils_1$3.domEach(this, function (el) {
        if (!htmlparser2_1.DomUtils.hasChildren(el))
            return;
        el.children.forEach(function (child) {
            child.next = child.prev = child.parent = null;
        });
        el.children.length = 0;
    });
}
manipulation.empty = empty$1;
function html(str) {
    if (str === undefined) {
        var el = this[0];
        if (!el || !htmlparser2_1.DomUtils.hasChildren(el))
            return null;
        return static_1.html(el.children, this.options);
    }
    // Keep main options unchanged
    var opts = tslib_1$2.__assign(tslib_1$2.__assign({}, this.options), { context: null });
    return utils_1$3.domEach(this, function (el) {
        if (!htmlparser2_1.DomUtils.hasChildren(el))
            return;
        el.children.forEach(function (child) {
            child.next = child.prev = child.parent = null;
        });
        opts.context = el;
        var content = utils_1$3.isCheerio(str)
            ? str.toArray()
            : parse_1$4.default("" + str, opts, false).children;
        parse_1$4.update(content, el);
    });
}
manipulation.html = html;
/**
 * Turns the collection to a string. Alias for `.html()`.
 *
 * @category Manipulation
 * @returns The rendered document.
 */
function toString$2() {
    return static_1.html(this, this.options);
}
manipulation.toString = toString$2;
function text(str) {
    var _this = this;
    // If `str` is undefined, act as a "getter"
    if (str === undefined) {
        return static_1.text(this);
    }
    if (typeof str === 'function') {
        // Function support
        return utils_1$3.domEach(this, function (el, i) {
            text.call(_this._make(el), str.call(el, i, static_1.text([el])));
        });
    }
    // Append text node to each selected elements
    return utils_1$3.domEach(this, function (el) {
        if (!htmlparser2_1.DomUtils.hasChildren(el))
            return;
        el.children.forEach(function (child) {
            child.next = child.prev = child.parent = null;
        });
        var textNode = new domhandler_2.Text(str);
        parse_1$4.update(textNode, el);
    });
}
manipulation.text = text;
/**
 * Clone the cheerio object.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * const moreFruit = $('#fruits').clone();
 * ```
 *
 * @returns The cloned object.
 * @see {@link https://api.jquery.com/clone/}
 */
function clone$2() {
    return this._make(utils_1$3.cloneDom(this.get()));
}
manipulation.clone = clone$2;

var css$1 = {};

Object.defineProperty(css$1, "__esModule", { value: true });
css$1.css = void 0;
var utils_1$2 = utils$n;
function css(prop, val) {
    if ((prop != null && val != null) ||
        // When `prop` is a "plain" object
        (typeof prop === 'object' && !Array.isArray(prop))) {
        return utils_1$2.domEach(this, function (el, i) {
            if (utils_1$2.isTag(el)) {
                // `prop` can't be an array here anymore.
                setCss(el, prop, val, i);
            }
        });
    }
    return getCss(this[0], prop);
}
css$1.css = css;
/**
 * Set styles of all elements.
 *
 * @private
 * @param el - Element to set style of.
 * @param prop - Name of property.
 * @param value - Value to set property to.
 * @param idx - Optional index within the selection.
 */
function setCss(el, prop, value, idx) {
    if (typeof prop === 'string') {
        var styles = getCss(el);
        var val = typeof value === 'function' ? value.call(el, idx, styles[prop]) : value;
        if (val === '') {
            delete styles[prop];
        }
        else if (val != null) {
            styles[prop] = val;
        }
        el.attribs.style = stringify$9(styles);
    }
    else if (typeof prop === 'object') {
        Object.keys(prop).forEach(function (k, i) {
            setCss(el, k, prop[k], i);
        });
    }
}
function getCss(el, prop) {
    if (!el || !utils_1$2.isTag(el))
        return;
    var styles = parse$8(el.attribs.style);
    if (typeof prop === 'string') {
        return styles[prop];
    }
    if (Array.isArray(prop)) {
        var newStyles_1 = {};
        prop.forEach(function (item) {
            if (styles[item] != null) {
                newStyles_1[item] = styles[item];
            }
        });
        return newStyles_1;
    }
    return styles;
}
/**
 * Stringify `obj` to styles.
 *
 * @private
 * @category CSS
 * @param obj - Object to stringify.
 * @returns The serialized styles.
 */
function stringify$9(obj) {
    return Object.keys(obj).reduce(function (str, prop) { return "" + str + (str ? ' ' : '') + prop + ": " + obj[prop] + ";"; }, '');
}
/**
 * Parse `styles`.
 *
 * @private
 * @category CSS
 * @param styles - Styles to be parsed.
 * @returns The parsed styles.
 */
function parse$8(styles) {
    styles = (styles || '').trim();
    if (!styles)
        return {};
    return styles.split(';').reduce(function (obj, str) {
        var n = str.indexOf(':');
        // Skip if there is no :, or if it is the first/last character
        if (n < 1 || n === str.length - 1)
            return obj;
        obj[str.slice(0, n).trim()] = str.slice(n + 1).trim();
        return obj;
    }, {});
}

var forms = {};

Object.defineProperty(forms, "__esModule", { value: true });
forms.serializeArray = forms.serialize = void 0;
var utils_1$1 = utils$n;
/*
 * https://github.com/jquery/jquery/blob/2.1.3/src/manipulation/var/rcheckableType.js
 * https://github.com/jquery/jquery/blob/2.1.3/src/serialize.js
 */
var submittableSelector = 'input,select,textarea,keygen';
var r20 = /%20/g;
var rCRLF = /\r?\n/g;
/**
 * Encode a set of form elements as a string for submission.
 *
 * @category Forms
 * @returns The serialized form.
 * @see {@link https://api.jquery.com/serialize/}
 */
function serialize() {
    // Convert form elements into name/value objects
    var arr = this.serializeArray();
    // Serialize each element into a key/value string
    var retArr = arr.map(function (data) {
        return encodeURIComponent(data.name) + "=" + encodeURIComponent(data.value);
    });
    // Return the resulting serialization
    return retArr.join('&').replace(r20, '+');
}
forms.serialize = serialize;
/**
 * Encode a set of form elements as an array of names and values.
 *
 * @category Forms
 * @example
 *
 * ```js
 * $('<form><input name="foo" value="bar" /></form>').serializeArray();
 * //=> [ { name: 'foo', value: 'bar' } ]
 * ```
 *
 * @returns The serialized form.
 * @see {@link https://api.jquery.com/serializeArray/}
 */
function serializeArray() {
    var _this = this;
    // Resolve all form elements from either forms or collections of form elements
    return this.map(function (_, elem) {
        var $elem = _this._make(elem);
        if (utils_1$1.isTag(elem) && elem.name === 'form') {
            return $elem.find(submittableSelector).toArray();
        }
        return $elem.filter(submittableSelector).toArray();
    })
        .filter(
    // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)
    '[name!=""]:enabled' +
        // And cannot be clicked (`[type=submit]`) or are used in `x-www-form-urlencoded` (`[type=file]`)
        ':not(:submit, :button, :image, :reset, :file)' +
        // And are either checked/don't have a checkable state
        ':matches([checked], :not(:checkbox, :radio))'
    // Convert each of the elements to its value(s)
    )
        .map(function (_, elem) {
        var _a;
        var $elem = _this._make(elem);
        var name = $elem.attr('name'); // We have filtered for elements with a name before.
        // If there is no value set (e.g. `undefined`, `null`), then default value to empty
        var value = (_a = $elem.val()) !== null && _a !== void 0 ? _a : '';
        // If we have an array of values (e.g. `<select multiple>`), return an array of key/value pairs
        if (Array.isArray(value)) {
            return value.map(function (val) {
                /*
                 * We trim replace any line endings (e.g. `\r` or `\r\n` with `\r\n`) to guarantee consistency across platforms
                 * These can occur inside of `<textarea>'s`
                 */
                return ({ name: name, value: val.replace(rCRLF, '\r\n') });
            });
        }
        // Otherwise (e.g. `<input type="text">`, return only one key/value pair
        return { name: name, value: value.replace(rCRLF, '\r\n') };
    })
        .toArray();
}
forms.serializeArray = serializeArray;

Object.defineProperty(cheerio, "__esModule", { value: true });
cheerio.Cheerio = void 0;
var tslib_1$1 = require$$0$2;
var parse_1$3 = tslib_1$1.__importDefault(parse$a);
var options_1$1 = tslib_1$1.__importDefault(options);
var utils_1 = utils$n;
var Attributes = tslib_1$1.__importStar(attributes);
var Traversing = tslib_1$1.__importStar(traversing);
var Manipulation = tslib_1$1.__importStar(manipulation);
var Css = tslib_1$1.__importStar(css$1);
var Forms = tslib_1$1.__importStar(forms);
var Cheerio = /** @class */ (function () {
    /**
     * Instance of cheerio. Methods are specified in the modules. Usage of this
     * constructor is not recommended. Please use $.load instead.
     *
     * @private
     * @param selector - The new selection.
     * @param context - Context of the selection.
     * @param root - Sets the root node.
     * @param options - Options for the instance.
     */
    function Cheerio(selector, context, root, options) {
        var _this = this;
        if (options === void 0) { options = options_1$1.default; }
        this.length = 0;
        this.options = options;
        // $(), $(null), $(undefined), $(false)
        if (!selector)
            return this;
        if (root) {
            if (typeof root === 'string')
                root = parse_1$3.default(root, this.options, false);
            this._root = new this.constructor(root, null, null, this.options);
            // Add a cyclic reference, so that calling methods on `_root` never fails.
            this._root._root = this._root;
        }
        // $($)
        if (utils_1.isCheerio(selector))
            return selector;
        var elements = typeof selector === 'string' && utils_1.isHtml(selector)
            ? // $(<html>)
                parse_1$3.default(selector, this.options, false).children
            : isNode(selector)
                ? // $(dom)
                    [selector]
                : Array.isArray(selector)
                    ? // $([dom])
                        selector
                    : null;
        if (elements) {
            elements.forEach(function (elem, idx) {
                _this[idx] = elem;
            });
            this.length = elements.length;
            return this;
        }
        // We know that our selector is a string now.
        var search = selector;
        var searchContext = !context
            ? // If we don't have a context, maybe we have a root, from loading
                this._root
            : typeof context === 'string'
                ? utils_1.isHtml(context)
                    ? // $('li', '<ul>...</ul>')
                        this._make(parse_1$3.default(context, this.options, false))
                    : // $('li', 'ul')
                        ((search = context + " " + search), this._root)
                : utils_1.isCheerio(context)
                    ? // $('li', $)
                        context
                    : // $('li', node), $('li', [nodes])
                        this._make(context);
        // If we still don't have a context, return
        if (!searchContext)
            return this;
        /*
         * #id, .class, tag
         */
        // @ts-expect-error No good way to type this — we will always return `Cheerio<Element>` here.
        return searchContext.find(search);
    }
    /**
     * Make a cheerio object.
     *
     * @private
     * @param dom - The contents of the new object.
     * @param context - The context of the new object.
     * @returns The new cheerio object.
     */
    Cheerio.prototype._make = function (dom, context) {
        var cheerio = new this.constructor(dom, context, this._root, this.options);
        cheerio.prevObject = this;
        return cheerio;
    };
    return Cheerio;
}());
cheerio.Cheerio = Cheerio;
/** Set a signature of the object. */
Cheerio.prototype.cheerio = '[cheerio object]';
/*
 * Make cheerio an array-like object
 */
Cheerio.prototype.splice = Array.prototype.splice;
// Support for (const element of $(...)) iteration:
Cheerio.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
// Plug in the API
Object.assign(Cheerio.prototype, Attributes, Traversing, Manipulation, Css, Forms);
function isNode(obj) {
    return (!!obj.name ||
        obj.type === 'root' ||
        obj.type === 'text' ||
        obj.type === 'comment');
}

Object.defineProperty(load$1, "__esModule", { value: true });
load$1.load = void 0;
var tslib_1 = require$$0$2;
var options_1 = tslib_1.__importStar(options);
var staticMethods = tslib_1.__importStar(_static);
var cheerio_1 = cheerio;
var parse_1$2 = tslib_1.__importDefault(parse$a);
/**
 * Create a querying function, bound to a document created from the provided
 * markup. Note that similar to web browser contexts, this operation may
 * introduce `<html>`, `<head>`, and `<body>` elements; set `isDocument` to
 * `false` to switch to fragment mode and disable this.
 *
 * @param content - Markup to be loaded.
 * @param options - Options for the created instance.
 * @param isDocument - Allows parser to be switched to fragment mode.
 * @returns The loaded document.
 * @see {@link https://cheerio.js.org#loading} for additional usage information.
 */
function load(content, options, isDocument) {
    if (isDocument === void 0) { isDocument = true; }
    if (content == null) {
        throw new Error('cheerio.load() expects a string');
    }
    var internalOpts = tslib_1.__assign(tslib_1.__assign({}, options_1.default), options_1.flatten(options));
    var root = parse_1$2.default(content, internalOpts, isDocument);
    /** Create an extended class here, so that extensions only live on one instance. */
    var LoadedCheerio = /** @class */ (function (_super) {
        tslib_1.__extends(LoadedCheerio, _super);
        function LoadedCheerio() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return LoadedCheerio;
    }(cheerio_1.Cheerio));
    function initialize(selector, context, r, opts) {
        if (r === void 0) { r = root; }
        return new LoadedCheerio(selector, context, r, tslib_1.__assign(tslib_1.__assign({}, internalOpts), options_1.flatten(opts)));
    }
    // Add in static methods & properties
    Object.assign(initialize, staticMethods, {
        load: load,
        // `_root` and `_options` are used in static methods.
        _root: root,
        _options: internalOpts,
        // Add `fn` for plugins
        fn: LoadedCheerio.prototype,
        // Add the prototype here to maintain `instanceof` behavior.
        prototype: LoadedCheerio.prototype,
    });
    return initialize;
}
load$1.load = load;

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.root = exports.parseHTML = exports.merge = exports.contains = void 0;
var tslib_1 = require$$0$2;
/**
 * Types used in signatures of Cheerio methods.
 *
 * @category Cheerio
 */
tslib_1.__exportStar(types, exports);
tslib_1.__exportStar(load$1, exports);
var load_1 = load$1;
/**
 * The default cheerio instance.
 *
 * @deprecated Use the function returned by `load` instead.
 */
exports.default = load_1.load([]);
var staticMethods = tslib_1.__importStar(_static);
/**
 * In order to promote consistency with the jQuery library, users are encouraged
 * to instead use the static method of the same name.
 *
 * @deprecated
 * @example
 *
 * ```js
 * const $ = cheerio.load('<div><p></p></div>');
 *
 * $.contains($('div').get(0), $('p').get(0));
 * //=> true
 *
 * $.contains($('p').get(0), $('div').get(0));
 * //=> false
 * ```
 *
 * @returns {boolean}
 */
exports.contains = staticMethods.contains;
/**
 * In order to promote consistency with the jQuery library, users are encouraged
 * to instead use the static method of the same name.
 *
 * @deprecated
 * @example
 *
 * ```js
 * const $ = cheerio.load('');
 *
 * $.merge([1, 2], [3, 4]);
 * //=> [1, 2, 3, 4]
 * ```
 */
exports.merge = staticMethods.merge;
/**
 * In order to promote consistency with the jQuery library, users are encouraged
 * to instead use the static method of the same name as it is defined on the
 * "loaded" Cheerio factory function.
 *
 * @deprecated See {@link static/parseHTML}.
 * @example
 *
 * ```js
 * const $ = cheerio.load('');
 * $.parseHTML('<b>markup</b>');
 * ```
 */
exports.parseHTML = staticMethods.parseHTML;
/**
 * Users seeking to access the top-level element of a parsed document should
 * instead use the `root` static method of a "loaded" Cheerio function.
 *
 * @deprecated
 * @example
 *
 * ```js
 * const $ = cheerio.load('');
 * $.root();
 * ```
 */
exports.root = staticMethods.root;
}(lib$c));

Object.defineProperty(dist, '__esModule', { value: true });

const cheerio2 = lib$c;

function _interopDefaultLegacy$1 (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

const cheerio2__default = /*#__PURE__*/_interopDefaultLegacy$1(cheerio2);

function declass(html) {
  const {items, map} = parseHTML(html);
  const groups = makeGroups(items).filter((item) => item.uses.size > 5 && getClasses(item).length > 2).sort((a, b) => b.uses.size - a.uses.size);
  return groups.map((g) => ({
    class: g.class,
    uses: Array.from(g.uses).map((u) => map[u])
  }));
}
function makeGroups(items) {
  const itemGroups = {};
  for (let i = 0; i < items.length; i++) {
    for (let j = i + 1; j < items.length; j++) {
      const commonClasses = intersect(getClasses(items[i]), getClasses(items[j]));
      if (commonClasses.length > 1) {
        const uClass = commonClasses.join(" ");
        if (!itemGroups[uClass]) {
          itemGroups[uClass] = {class: uClass, uses: new Set()};
        }
        itemGroups[uClass].uses = union(itemGroups[uClass].uses, items[i].uses, items[j].uses);
      }
    }
  }
  return Object.values(itemGroups);
}
function getClasses(item) {
  if (!item._class) {
    item._class = uniq$1(item.class.split(" ").map((x) => x.trim()).filter(Boolean).sort());
  }
  return item._class;
}
function uniq$1(arr) {
  return Array.from(new Set(arr));
}
function intersect(a, b) {
  return a.filter((item) => b.includes(item));
}
function union(...args) {
  const r = new Set();
  for (const arg of args) {
    arg.forEach((x) => {
      r.add(x);
    });
  }
  return r;
}
function parseHTML(html) {
  const items = [];
  const map = {};
  const $ = cheerio2__default['default'].load(html);
  $("*").each((id, el) => {
    map[id] = `<${el.tagName} ${Object.entries(el.attribs).map((a) => `${a[0]}="${a[1]}"`).join(" ")}>`;
    const item = {
      uses: new Set(),
      class: el.attribs.class || ""
    };
    item.uses.add(id);
    if (getClasses(item).length > 1) {
      items.push(item);
    }
  });
  return {
    items,
    map
  };
}

var declass_1 = dist.declass = declass;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics$2 = function(d, b) {
    extendStatics$2 = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics$2(d, b);
};

function __extends$2(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics$2(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function __spreadArray$2(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function toArray$3(v) {
    if (Array.isArray(v))
        return v;
    return [v];
}
function hash$1(str) {
    str = str.replace(/\r/g, '');
    var hash = 5381;
    var i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return (hash >>> 0).toString(36);
}
function indent$2(code, tab) {
    if (tab === void 0) { tab = 2; }
    var spaces = Array(tab).fill(' ').join('');
    return code
        .split('\n')
        .map(function (line) { return spaces + line; })
        .join('\n');
}
function wrapit$2(code, start, end, tab, minify) {
    if (start === void 0) { start = '{'; }
    if (end === void 0) { end = '}'; }
    if (tab === void 0) { tab = 2; }
    if (minify === void 0) { minify = false; }
    if (minify)
        return "".concat(start).concat(code).concat(end);
    return "".concat(start, "\n").concat(indent$2(code, tab), "\n").concat(end);
}
function camelToDash$2(str) {
    // Use exact the same regex as Post CSS
    return str.replace(/([A-Z])/g, '-$1').replace(/^ms-/, '-ms-').toLowerCase();
}
function searchFrom$2(text, target, startIndex, endIndex) {
    if (startIndex === void 0) { startIndex = 0; }
    // search from partial of string
    var subText = text.substring(startIndex, endIndex);
    var relativeIndex = subText.search(target);
    return relativeIndex === -1 ? -1 : startIndex + relativeIndex;
}
function connectList$2(a, b, append) {
    if (append === void 0) { append = true; }
    return append ? __spreadArray$2(__spreadArray$2([], (a !== null && a !== void 0 ? a : []), true), (b !== null && b !== void 0 ? b : []), true) : __spreadArray$2(__spreadArray$2([], (b !== null && b !== void 0 ? b : []), true), (a !== null && a !== void 0 ? a : []), true);
}
function deepCopy$2(source) {
    return Array.isArray(source)
        ? source.map(function (item) { return deepCopy$2(item); })
        : source instanceof Date
            ? new Date(source.getTime())
            : source && typeof source === 'object'
                ? Object.getOwnPropertyNames(source).reduce(function (o, prop) {
                    var descriptor = Object.getOwnPropertyDescriptor(source, prop);
                    if (descriptor) {
                        Object.defineProperty(o, prop, descriptor);
                        if (source && typeof source === 'object') {
                            o[prop] = deepCopy$2(source[prop]);
                        }
                    }
                    return o;
                }, Object.create(Object.getPrototypeOf(source)))
                : source;
}
function isTagName$2(name) {
    return ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embd', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'svg', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr'].includes(name);
}
function searchPropEnd$2(text, startIndex) {
    if (startIndex === void 0) { startIndex = 0; }
    var index = startIndex;
    var output = -1;
    var openSingleQuote = false;
    var openDoubleQuote = false;
    var openBracket = false;
    var isEscaped = false;
    while (index < text.length) {
        switch (text.charAt(index)) {
            case '\\':
                isEscaped = !isEscaped;
                break;
            case '\'':
                if (!openDoubleQuote && !openBracket && !isEscaped)
                    openSingleQuote = !openSingleQuote;
                isEscaped = false;
                break;
            case '"':
                if (!openSingleQuote && !openBracket && !isEscaped)
                    openDoubleQuote = !openDoubleQuote;
                isEscaped = false;
                break;
            case '(':
                if (!openBracket && !openSingleQuote && !openDoubleQuote && !isEscaped)
                    openBracket = true;
                isEscaped = false;
                break;
            case ')':
                if (openBracket && !isEscaped)
                    openBracket = false;
                isEscaped = false;
                break;
            case ';':
                if (!isEscaped && !openSingleQuote && !openDoubleQuote && !openBracket)
                    output = index;
                isEscaped = false;
                break;
            default:
                isEscaped = false;
                break;
        }
        if (output !== -1)
            break;
        index++;
    }
    return output;
}

var Property$2 = /** @class */ (function () {
    function Property(name, value, comment, important) {
        if (important === void 0) { important = false; }
        this.meta = { type: 'utilities', group: 'plugin', order: 0, offset: 0, corePlugin: false };
        this.name = name;
        this.value = value;
        this.comment = comment;
        this.important = important;
    }
    Property._singleParse = function (css) {
        css = css.trim();
        if (!css)
            return;
        if (css.charAt(0) === '@')
            return InlineAtRule$2.parse(css);
        var split = css.search(':');
        var end = searchPropEnd$2(css);
        if (split === -1)
            return;
        var important = false;
        var prop = css.substring(split + 1, end === -1 ? undefined : end).trim();
        if (/!important;?$/.test(prop)) {
            important = true;
            prop = prop.replace(/!important/, '').trimRight();
        }
        return new Property(css.substring(0, split).trim(), prop, undefined, important);
    };
    Property.parse = function (css) {
        if (!/;\s*$/.test(css))
            css += ';'; // Fix for the situation where the last semicolon is omitted
        var properties = [];
        var index = 0;
        var end = searchPropEnd$2(css, index);
        while (end !== -1) {
            var parsed = this._singleParse(css.substring(searchFrom$2(css, /\S/, index), end + 1));
            if (parsed)
                properties.push(parsed);
            index = end + 1;
            end = searchPropEnd$2(css, index);
        }
        var count = properties.length;
        if (count > 1)
            return properties;
        if (count === 1)
            return properties[0];
    };
    Property.prototype.clone = function () {
        return deepCopy$2(this);
    };
    Property.prototype.toStyle = function (selector) {
        var style = new Style$2(selector, this, this.important);
        style.meta = this.meta;
        return style;
    };
    Property.prototype.build = function (minify) {
        var _this = this;
        if (minify === void 0) { minify = false; }
        var createProperty = function (name, value) {
            if (minify) {
                return "".concat(name, ":").concat(value).concat(_this.important ? '!important' : '', ";");
            }
            else {
                var p = "".concat(name, ": ").concat(value).concat(_this.important ? ' !important' : '', ";");
                return _this.comment ? p + " /* ".concat(_this.comment, " */") : p;
            }
        };
        if (!this.value)
            return '';
        return typeof this.name === 'string'
            ? createProperty(this.name, this.value)
            : this.name
                .map(function (i) { return createProperty(i, _this.value); })
                .join(minify ? '' : '\n');
    };
    Property.prototype.updateMeta = function (type, group, order, offset, corePlugin) {
        if (offset === void 0) { offset = 0; }
        if (corePlugin === void 0) { corePlugin = false; }
        this.meta = {
            type: type,
            group: group,
            order: order,
            offset: offset,
            corePlugin: corePlugin,
        };
        return this;
    };
    return Property;
}());
var InlineAtRule$2 = /** @class */ (function (_super) {
    __extends$2(InlineAtRule, _super);
    function InlineAtRule(name, value, important) {
        if (important === void 0) { important = false; }
        var _this = _super.call(this, name, value, undefined, important) || this;
        _this.name = name;
        return _this;
    }
    InlineAtRule.parse = function (css) {
        var _a;
        var matchName = css.match(/@[^\s;{}]+/);
        if (matchName) {
            var name_1 = matchName[0].substring(1);
            var important = false;
            var expression = matchName.index !== undefined
                ? (_a = css
                    .substring(matchName.index + name_1.length + 1)
                    .match(/(?:(['"]).*?\1|[^;])*/)) === null || _a === void 0 ? void 0 : _a[0].trim()
                : undefined;
            if (expression && /!important;?$/.test(expression)) {
                important = true;
                expression = expression.replace(/!important/, '').trimRight();
            }
            return new InlineAtRule(name_1, expression === '' ? undefined : expression, important);
        }
    };
    InlineAtRule.prototype.build = function () {
        return this.value
            ? "@".concat(this.name, " ").concat(this.value).concat(this.important ? ' !important' : '', ";")
            : "@".concat(this.name).concat(this.important ? ' !important' : '', ";");
    };
    return InlineAtRule;
}(Property$2));
var Style$2 = /** @class */ (function () {
    function Style(selector, property, important) {
        if (important === void 0) { important = false; }
        this.meta = { type: 'components', group: 'plugin', order: 0, offset: 0, corePlugin: false };
        this.selector = selector;
        this.important = important;
        this.property = toArray$3(property || []);
    }
    Object.defineProperty(Style.prototype, "rule", {
        get: function () {
            var _this = this;
            var _a, _b, _c;
            var selectors = ((_a = this.selector) !== null && _a !== void 0 ? _a : '').trim().split(/\s*,\s*/g);
            this._parentSelectors && (selectors = selectors.map(function (i) { var _a; return "".concat((_a = _this._parentSelectors) === null || _a === void 0 ? void 0 : _a.join(' '), " ").concat(i); }));
            ((_b = this._wrapSelectors) !== null && _b !== void 0 ? _b : []).forEach(function (func) { return (selectors = selectors.map(function (i) { return func(i); })); });
            this._pseudoClasses && (selectors = selectors.map(function (i) { var _a; return i + ":".concat((_a = _this._pseudoClasses) === null || _a === void 0 ? void 0 : _a.join(':')); }));
            this._pseudoElements && (selectors = selectors.map(function (i) { var _a; return i + "::".concat((_a = _this._pseudoElements) === null || _a === void 0 ? void 0 : _a.join('::')); }));
            this._brotherSelectors && (selectors = selectors.map(function (i) { var _a; return i + ".".concat((_a = _this._brotherSelectors) === null || _a === void 0 ? void 0 : _a.join('.')); }));
            this._childSelectors && (selectors = selectors.map(function (i) { var _a; return i + " ".concat((_a = _this._childSelectors) === null || _a === void 0 ? void 0 : _a.join(' ')); }));
            ((_c = this._wrapRules) !== null && _c !== void 0 ? _c : []).forEach(function (func) { return (selectors = selectors.map(function (i) { return func(i); })); });
            return selectors.join(', ');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "pseudoClasses", {
        get: function () {
            return this._pseudoClasses;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "pseudoElements", {
        get: function () {
            return this._pseudoElements;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "parentSelectors", {
        get: function () {
            return this._parentSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "childSelectors", {
        get: function () {
            return this._childSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "brotherSelectors", {
        get: function () {
            return this._brotherSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapProperties", {
        get: function () {
            return this._wrapProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapSelectors", {
        get: function () {
            return this._wrapSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapRules", {
        get: function () {
            return this._wrapRules;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "simple", {
        get: function () {
            // is this style only has property and no wrap?
            return !(this.atRules || this._pseudoClasses || this._pseudoElements || this._parentSelectors || this._childSelectors || this._brotherSelectors || this._wrapProperties || this._wrapSelectors || this._wrapRules);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "isAtrule", {
        get: function () {
            return !(this.atRules === undefined || this.atRules.length === 0);
        },
        enumerable: false,
        configurable: true
    });
    Style.generate = function (parent, property, root) {
        if (!root)
            root = (parent === null || parent === void 0 ? void 0 : parent.startsWith('@'))
                ? new Style().atRule(parent)
                : new Style(parent);
        var output = [];
        var _loop_1 = function (key, value) {
            var propertyValue = value;
            if (Array.isArray(propertyValue) && propertyValue.every(function (e) { return typeof e === 'object'; })) {
                propertyValue = Object.assign.apply(Object, __spreadArray$2([{}], propertyValue, false));
            }
            if (typeof propertyValue === 'string') {
                root.add(new Property$2(camelToDash$2(key), propertyValue));
            }
            else if (Array.isArray(propertyValue)) {
                propertyValue.map(function (i) { return root === null || root === void 0 ? void 0 : root.add(new Property$2(camelToDash$2(key), i)); });
            }
            else {
                var wrap = deepCopy$2(root);
                wrap.property = [];
                var child = void 0;
                if (key.startsWith('@')) {
                    child = wrap.atRule(key, false);
                }
                else {
                    if (wrap.selector === undefined) {
                        wrap.selector = key;
                        child = wrap;
                    }
                    else {
                        if (/^[a-z]+$/.test(key) && !isTagName$2(key)) {
                            wrap.wrapProperty(function (property) { return "".concat(key, "-").concat(property); });
                            child = wrap;
                        }
                        else {
                            var _hKey_1 = function (selector, key) { return (/&/.test(key) ? key : "& ".concat(key)).replace('&', selector); };
                            wrap.wrapSelector(function (selector) {
                                return selector
                                    .trim()
                                    .split(/\s*,\s*/g)
                                    .map(function (s) {
                                    return key
                                        .split(/\s*,\s*/g)
                                        .map(function (i) { return _hKey_1(s, i); })
                                        .join(', ');
                                })
                                    .join(', ');
                            });
                            child = wrap;
                        }
                    }
                }
                output = output.concat(Style.generate(key.startsWith('@') ? undefined : key, propertyValue, child));
            }
        };
        for (var _i = 0, _a = Object.entries(property !== null && property !== void 0 ? property : {}); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            _loop_1(key, value);
        }
        if (root.property.length > 0)
            output.unshift(root);
        return output;
    };
    Style.prototype.atRule = function (atrule, append) {
        if (append === void 0) { append = true; }
        if (!atrule)
            return this;
        if (this.atRules) {
            append ? this.atRules.push(atrule) : this.atRules.unshift(atrule);
        }
        else {
            this.atRules = [atrule];
        }
        return this;
    };
    Style.prototype.pseudoClass = function (string) {
        if (this._pseudoClasses) {
            this._pseudoClasses.push(string);
        }
        else {
            this._pseudoClasses = [string];
        }
        return this;
    };
    Style.prototype.pseudoElement = function (string) {
        if (this._pseudoElements) {
            this._pseudoElements.push(string);
        }
        else {
            this._pseudoElements = [string];
        }
        return this;
    };
    Style.prototype.brother = function (string) {
        if (this._brotherSelectors) {
            this._brotherSelectors.push(string);
        }
        else {
            this._brotherSelectors = [string];
        }
        return this;
    };
    Style.prototype.parent = function (string) {
        if (this._parentSelectors) {
            this._parentSelectors.push(string);
        }
        else {
            this._parentSelectors = [string];
        }
        return this;
    };
    Style.prototype.child = function (string) {
        if (this._childSelectors) {
            this._childSelectors.push(string);
        }
        else {
            this._childSelectors = [string];
        }
        return this;
    };
    Style.prototype.wrapProperty = function (func) {
        if (this._wrapProperties) {
            this._wrapProperties.push(func);
        }
        else {
            this._wrapProperties = [func];
        }
        return this;
    };
    Style.prototype.wrapSelector = function (func) {
        if (this._wrapSelectors) {
            this._wrapSelectors.push(func);
        }
        else {
            this._wrapSelectors = [func];
        }
        return this;
    };
    Style.prototype.wrapRule = function (func) {
        if (this._wrapRules) {
            this._wrapRules.push(func);
        }
        else {
            this._wrapRules = [func];
        }
        return this;
    };
    Style.prototype.add = function (item) {
        item = toArray$3(item);
        if (this.important)
            item.forEach(function (i) { return (i.important = true); });
        this.property = __spreadArray$2(__spreadArray$2([], this.property, true), item, true);
        return this;
    };
    Style.prototype.extend = function (item, onlyProperty, append) {
        if (onlyProperty === void 0) { onlyProperty = false; }
        if (append === void 0) { append = true; }
        if (!item)
            return this;
        if (item.wrapProperties) {
            var props_1 = [];
            item.property.forEach(function (p) {
                var _a;
                var pc = new Property$2(p.name, p.value, p.comment);
                (_a = item.wrapProperties) === null || _a === void 0 ? void 0 : _a.forEach(function (wrap) {
                    pc.name = Array.isArray(pc.name)
                        ? pc.name.map(function (i) { return wrap(i); })
                        : wrap(pc.name);
                });
                if (item.important)
                    pc.important = true;
                props_1.push(pc);
            });
            this.property = connectList$2(this.property, props_1, append);
        }
        else {
            if (item.important)
                item.property.forEach(function (i) { return (i.important = true); });
            this.property = connectList$2(this.property, item.property, append);
        }
        if (onlyProperty)
            return this;
        item.selector && (this.selector = item.selector);
        this.meta = item.meta;
        item.atRules &&
            (this.atRules = connectList$2(item.atRules, this.atRules, append)); // atrule is build in reverse
        item._brotherSelectors &&
            (this._brotherSelectors = connectList$2(this._brotherSelectors, item._brotherSelectors, append));
        item._childSelectors &&
            (this._childSelectors = connectList$2(this._childSelectors, item._childSelectors, append));
        item._parentSelectors &&
            (this._parentSelectors = connectList$2(this._parentSelectors, item._parentSelectors, append));
        item._pseudoClasses &&
            (this._pseudoClasses = connectList$2(this._pseudoClasses, item._pseudoClasses, append));
        item._pseudoElements &&
            (this._pseudoElements = connectList$2(this._pseudoElements, item._pseudoElements, append));
        item._wrapRules &&
            (this._wrapRules = connectList$2(this._wrapRules, item._wrapRules, append));
        item._wrapSelectors &&
            (this._wrapSelectors = connectList$2(this._wrapSelectors, item._wrapSelectors, append));
        return this;
    };
    Style.prototype.clean = function () {
        // remove duplicated property
        var property = [];
        var cache = [];
        this.property.forEach(function (i) {
            var inline = i.build();
            if (!cache.includes(inline)) {
                cache.push(inline);
                property.push(i);
            }
        });
        this.property = property;
        return this;
    };
    Style.prototype.flat = function () {
        var properties = [];
        this.property.forEach(function (p) {
            if (Array.isArray(p.name)) {
                p.name.forEach(function (i) {
                    properties.push(new Property$2(i, p.value, p.comment));
                });
            }
            else {
                properties.push(p);
            }
        });
        this.property = properties;
        return this;
    };
    Style.prototype.clone = function (selector, property) {
        var newStyle = deepCopy$2(this);
        if (selector)
            newStyle.selector = selector;
        if (property)
            newStyle.property = Array.isArray(property) ? property : [property];
        return newStyle;
    };
    Style.prototype.sort = function () {
        // sort property
        this.property = this.property.sort(function (a, b) {
            return "".concat(a.name).substring(0, 2) > "".concat(b.name).substring(0, 2) ? 1 : -1;
        });
        return this;
    };
    Style.prototype.build = function (minify, prefixer) {
        var _this = this;
        if (minify === void 0) { minify = false; }
        if (prefixer === void 0) { prefixer = true; }
        var properties = this.property;
        if (!prefixer)
            properties = properties.filter(function (p) {
                if (p.value && /-(webkit|ms|moz|o)-/.test(p.value))
                    return false;
                if (Array.isArray(p.name)) {
                    p.name = p.name.filter(function (i) { return !/^-(webkit|ms|moz|o)-/.test(i); });
                    return true;
                }
                return !/^-(webkit|ms|moz|o)-/.test(p.name);
            });
        var result = properties.map(function (p) {
            if (_this._wrapProperties) {
                var name_2 = p.name;
                _this._wrapProperties.forEach(function (w) { return (name_2 = Array.isArray(name_2) ? name_2.map(function (n) { return w(n); }) : w(name_2)); });
                return new Property$2(name_2, p.value, p.comment, _this.important ? true : p.important).build(minify);
            }
            return _this.important ? new Property$2(p.name, p.value, p.comment, true).build(minify) : p.build(minify);
        }).join(minify ? '' : '\n');
        if (!this.selector && !this.atRules)
            return result.replace(/;}/g, '}');
        if (this.selector)
            result = (minify ? this.rule.replace(/,\s/g, ',') : this.rule + ' ') + wrapit$2(result, undefined, undefined, undefined, result !== '' ? minify : true);
        if (this.atRules) {
            for (var _i = 0, _a = this.atRules; _i < _a.length; _i++) {
                var rule = _a[_i];
                result = minify ? "".concat(rule.replace(/\s/g, '')).concat(wrapit$2(result, undefined, undefined, undefined, minify)) : "".concat(rule, " ").concat(wrapit$2(result, undefined, undefined, undefined, result !== '' ? minify : true));
            }
        }
        return minify ? result.replace(/;}/g, '}') : result;
    };
    Style.prototype.updateMeta = function (type, group, order, offset, corePlugin, respectSelector) {
        if (offset === void 0) { offset = 0; }
        if (corePlugin === void 0) { corePlugin = false; }
        if (respectSelector === void 0) { respectSelector = false; }
        this.meta = {
            type: type,
            group: group,
            order: order,
            offset: offset,
            corePlugin: corePlugin,
            respectSelector: respectSelector,
        };
        return this;
    };
    return Style;
}());
/** @class */ ((function (_super) {
    __extends$2(GlobalStyle, _super);
    function GlobalStyle(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    return GlobalStyle;
})(Style$2));
/** @class */ ((function (_super) {
    __extends$2(Keyframes, _super);
    function Keyframes(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    // root param only for consist with style
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Keyframes.generate = function (name, children, root, prefixer) {
        if (prefixer === void 0) { prefixer = true; }
        var styles = [];
        var webkitStyles = [];
        for (var _i = 0, _a = Object.entries(children); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            var style = new Keyframes(key).atRule("@keyframes ".concat(name));
            var webkitStyle = new Keyframes(key).atRule("@-webkit-keyframes ".concat(name));
            for (var _c = 0, _d = Object.entries(value); _c < _d.length; _c++) {
                var _e = _d[_c], pkey = _e[0], pvalue = _e[1];
                var prop = pkey;
                if (pkey === 'transform') {
                    prop = prefixer ? ['-webkit-transform', 'transform'] : 'transform';
                }
                else if (['animationTimingFunction', 'animation-timing-function'].includes(pkey)) {
                    prop = prefixer ? [
                        '-webkit-animation-timing-function',
                        'animation-timing-function',
                    ] : 'animation-timing-function';
                }
                style.add(new Property$2(prop, pvalue));
                webkitStyle.add(new Property$2(prop, pvalue));
            }
            styles.push(style);
            if (prefixer)
                webkitStyles.push(webkitStyle);
        }
        return __spreadArray$2(__spreadArray$2([], styles, true), webkitStyles, true);
    };
    return Keyframes;
})(Style$2));
/** @class */ ((function (_super) {
    __extends$2(Container, _super);
    function Container(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    return Container;
})(Style$2));

var minMaxWidth$1 = /(!?\(\s*min(-device-)?-width).+\(\s*max(-device)?-width/i;
var minWidth$1 = /\(\s*min(-device)?-width/i;
var maxMinWidth$1 = /(!?\(\s*max(-device)?-width).+\(\s*min(-device)?-width/i;
var maxWidth$1 = /\(\s*max(-device)?-width/i;
var isMinWidth$1 = _testQuery$1(minMaxWidth$1, maxMinWidth$1, minWidth$1);
var isMaxWidth$1 = _testQuery$1(maxMinWidth$1, minMaxWidth$1, maxWidth$1);
var minMaxHeight$1 = /(!?\(\s*min(-device)?-height).+\(\s*max(-device)?-height/i;
var minHeight$1 = /\(\s*min(-device)?-height/i;
var maxMinHeight$1 = /(!?\(\s*max(-device)?-height).+\(\s*min(-device)?-height/i;
var maxHeight$1 = /\(\s*max(-device)?-height/i;
var isMinHeight$1 = _testQuery$1(minMaxHeight$1, maxMinHeight$1, minHeight$1);
var isMaxHeight$1 = _testQuery$1(maxMinHeight$1, minMaxHeight$1, maxHeight$1);
var isPrint$1 = /print/i;
var isPrintOnly$1 = /^print\$/i;
var isAtRule$1 = /^\s*@/i;
var isMedia$1 = /^\s*@media/i;
var maxValue$1 = Number.MAX_VALUE;
function _getQueryLength$1(length) {
    var result = /(-?\d*\.?\d+)(ch|em|ex|px|rpx|rem)/.exec(length);
    if (result === null) {
        return maxValue$1;
    }
    var number = result[1];
    var unit = result[2];
    switch (unit) {
        case 'ch':
            return parseFloat(number) * 8.8984375;
        case 'em':
        case 'rem':
            return parseFloat(number) * 16;
        case 'ex':
            return parseFloat(number) * 8.296875;
        case 'px':
        case 'rpx':
            return parseFloat(number);
    }
    return +number;
}
function _testQuery$1(doubleTestTrue, doubleTestFalse, singleTest) {
    return function (query) {
        if (doubleTestTrue.test(query)) {
            return true;
        }
        else if (doubleTestFalse.test(query)) {
            return false;
        }
        return singleTest.test(query);
    };
}
function _testAtRule$1(a, b) {
    var isMediaA = isMedia$1.test(a);
    var isMediaB = isMedia$1.test(b);
    if (isMediaA && isMediaB)
        return null;
    var isAtRuleA = isAtRule$1.test(a);
    var isAtRuleB = isAtRule$1.test(b);
    if (isAtRuleA)
        return 1;
    if (isAtRuleB)
        return -1;
    return 0; // don't sort selector name, may cause overwrite bug.
}
function _testIsPrint$1(a, b) {
    var isPrintA = isPrint$1.test(a);
    var isPrintOnlyA = isPrintOnly$1.test(a);
    var isPrintB = isPrint$1.test(b);
    var isPrintOnlyB = isPrintOnly$1.test(b);
    if (isPrintA && isPrintB) {
        if (!isPrintOnlyA && isPrintOnlyB) {
            return 1;
        }
        if (isPrintOnlyA && !isPrintOnlyB) {
            return -1;
        }
        return a.localeCompare(b);
    }
    if (isPrintA) {
        return 1;
    }
    if (isPrintB) {
        return -1;
    }
    return null;
}
function sortMediaQuery$1(a, b) {
    var testAtRule = _testAtRule$1(a, b);
    if (testAtRule !== null)
        return testAtRule;
    var testIsPrint = _testIsPrint$1(a, b);
    if (testIsPrint !== null)
        return testIsPrint;
    var minA = isMinWidth$1(a) || isMinHeight$1(a);
    var maxA = isMaxWidth$1(a) || isMaxHeight$1(a);
    var minB = isMinWidth$1(b) || isMinHeight$1(b);
    var maxB = isMaxWidth$1(b) || isMaxHeight$1(b);
    if (minA && maxB) {
        return -1;
    }
    if (maxA && minB) {
        return 1;
    }
    var lengthA = _getQueryLength$1(a);
    var lengthB = _getQueryLength$1(b);
    if (lengthA === maxValue$1 && lengthB === maxValue$1) {
        return a.localeCompare(b);
    }
    else if (lengthA === maxValue$1) {
        return 1;
    }
    else if (lengthB === maxValue$1) {
        return -1;
    }
    if (lengthA > lengthB) {
        if (maxA) {
            return -1;
        }
        return 1;
    }
    if (lengthA < lengthB) {
        if (maxA) {
            return 1;
        }
        return -1;
    }
    return a.localeCompare(b);
}

function getWeights$1(a) {
    var first = a.charAt(0);
    var second = a.charAt(1);
    if (first === ':' && second === ':')
        return 59; // ::moz ...
    if (first === '#')
        return 500; // #id ...
    if (first !== '.')
        return first.charCodeAt(0); // html, body ...
    return 499;
}
function sortMeta$1(a, b) {
    var _a, _b, _c, _d;
    if (a.meta.type === 'base' && b.meta.type === 'base')
        return getWeights$1((_a = a.selector) !== null && _a !== void 0 ? _a : '') - getWeights$1((_b = b.selector) !== null && _b !== void 0 ? _b : '');
    return sortMediaQuery$1(((_c = a.meta.variants) === null || _c === void 0 ? void 0 : _c[0]) || '', ((_d = b.meta.variants) === null || _d === void 0 ? void 0 : _d[0]) || '') || (a.meta.order - b.meta.order) || (a.meta.offset - b.meta.offset) || +b.meta.corePlugin - +a.meta.corePlugin;
}

function _buildAtrule$1(atrule, children, minify, prefixer) {
    if (minify === void 0) { minify = false; }
    if (prefixer === void 0) { prefixer = true; }
    return "".concat(atrule).concat(minify ? '' : ' ').concat(wrapit$2(_buildStyleList$1(children, minify, prefixer), undefined, undefined, undefined, minify));
}
function _buildStyleList$1(styleList, minify, prefixer) {
    if (minify === void 0) { minify = false; }
    if (prefixer === void 0) { prefixer = true; }
    var currentAtrule;
    var currentStyle;
    var styleStack = [];
    var output = [];
    var _loop_1 = function (style) {
        if (style.isAtrule) {
            if (currentStyle) {
                output.push(currentStyle.clean().build(minify, prefixer));
                currentStyle = undefined;
            }
            var newAtrule = style.atRules.pop();
            if (currentAtrule) {
                if (currentAtrule === newAtrule && newAtrule !== '@font-face') { // @font-face shouldn't been combined
                    styleStack.push(style);
                }
                else {
                    output.push(_buildAtrule$1(currentAtrule, styleStack, minify, prefixer));
                    currentAtrule = newAtrule;
                    styleStack = [style];
                }
            }
            else {
                currentAtrule = newAtrule;
                styleStack = [style];
            }
        }
        else {
            if (currentAtrule) {
                output.push(_buildAtrule$1(currentAtrule, styleStack, minify, prefixer));
                currentAtrule = undefined;
                styleStack = [];
            }
            if (currentStyle) {
                if (style.rule === currentStyle.rule) {
                    if (style.important)
                        style.property.forEach(function (p) { return p.important = true; });
                    if (style.wrapProperties)
                        style.property.forEach(function (p) { var _a; return (_a = style.wrapProperties) === null || _a === void 0 ? void 0 : _a.forEach(function (wrap) { return p.name = Array.isArray(p.name) ? p.name.map(function (i) { return wrap(i); }) : wrap(p.name); }); });
                    currentStyle.add(style.property);
                }
                else {
                    output.push(currentStyle.clean().build(minify, prefixer));
                    currentStyle = style;
                }
            }
            else {
                currentStyle = style;
            }
        }
    };
    for (var _i = 0, styleList_1 = styleList; _i < styleList_1.length; _i++) {
        var style = styleList_1[_i];
        _loop_1(style);
    }
    if (currentAtrule)
        output.push(_buildAtrule$1(currentAtrule, styleStack, minify, prefixer));
    if (currentStyle)
        output.push(currentStyle.clean().build(minify, prefixer));
    return output.join(minify ? '' : '\n');
}
function compileStyleSheet$1 (styleList, minify, prefixer) {
    if (minify === void 0) { minify = false; }
    if (prefixer === void 0) { prefixer = true; }
    return _buildStyleList$1(deepCopy$2(styleList), minify, prefixer);
}

var StyleSheet$1 = /** @class */ (function () {
    function StyleSheet(children) {
        this.prefixer = true;
        this.children = children || [];
    }
    StyleSheet.prototype.add = function (item) {
        if (!item)
            return this;
        if (Array.isArray(item)) {
            this.children = __spreadArray$2(__spreadArray$2([], this.children, true), item, true);
        }
        else {
            this.children.push(item);
        }
        return this;
    };
    StyleSheet.prototype.extend = function (styleSheet, append, dedup) {
        if (append === void 0) { append = true; }
        if (dedup === void 0) { dedup = false; }
        if (styleSheet) {
            var extended = styleSheet.children;
            if (dedup) {
                var hashes_1 = extended.map(function (i) { return hash$1(i.build()); });
                extended = extended.filter(function (i) { return !hashes_1.includes(hash$1(i.build())); });
            }
            this.prefixer = styleSheet.prefixer;
            this.children = append ? __spreadArray$2(__spreadArray$2([], this.children, true), extended, true) : __spreadArray$2(__spreadArray$2([], extended, true), this.children, true);
        }
        return this;
    };
    StyleSheet.prototype.combine = function () {
        var styleMap = {};
        this.children.forEach(function (style, index) {
            var _a;
            var hashValue = hash$1(style.atRules + style.meta.type + style.rule);
            if (hashValue in styleMap) {
                if ((_a = style.atRules) === null || _a === void 0 ? void 0 : _a.includes('@font-face')) {
                    // keeps multiple @font-face
                    styleMap[hashValue + index] = style;
                }
                else {
                    styleMap[hashValue] = styleMap[hashValue].extend(style, true);
                }
            }
            else {
                styleMap[hashValue] = style;
            }
        });
        this.children = Object.values(styleMap).map(function (i) { return i.clean(); });
        return this;
    };
    StyleSheet.prototype.layer = function (type) {
        var styleSheet = new StyleSheet(this.children.filter(function (i) { return i.meta.type === type; }));
        styleSheet.prefixer = this.prefixer;
        return styleSheet;
    };
    StyleSheet.prototype.split = function () {
        return {
            base: this.layer('base'),
            components: this.layer('components'),
            utilities: this.layer('utilities'),
        };
    };
    StyleSheet.prototype.clone = function () {
        return deepCopy$2(this);
    };
    StyleSheet.prototype.sort = function () {
        this.children = this.children.sort(sortMeta$1);
        return this;
    };
    StyleSheet.prototype.sortby = function (compareFn) {
        this.children = this.children.sort(compareFn);
        return this;
    };
    StyleSheet.prototype.build = function (minify) {
        if (minify === void 0) { minify = false; }
        return compileStyleSheet$1(this.children, minify, this.prefixer);
    };
    return StyleSheet;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics$1 = function(d, b) {
    extendStatics$1 = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics$1(d, b);
};

function __extends$1(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics$1(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function __spreadArray$1(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function toArray$2(v) {
    if (Array.isArray(v))
        return v;
    return [v];
}
function hash(str) {
    str = str.replace(/\r/g, '');
    var hash = 5381;
    var i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return (hash >>> 0).toString(36);
}
function indent$1(code, tab) {
    if (tab === void 0) { tab = 2; }
    var spaces = Array(tab).fill(' ').join('');
    return code
        .split('\n')
        .map(function (line) { return spaces + line; })
        .join('\n');
}
function wrapit$1(code, start, end, tab, minify) {
    if (start === void 0) { start = '{'; }
    if (end === void 0) { end = '}'; }
    if (tab === void 0) { tab = 2; }
    if (minify === void 0) { minify = false; }
    if (minify)
        return "".concat(start).concat(code).concat(end);
    return "".concat(start, "\n").concat(indent$1(code, tab), "\n").concat(end);
}
function isSpace(str) {
    return /^\s*$/.test(str);
}
function camelToDash$1(str) {
    // Use exact the same regex as Post CSS
    return str.replace(/([A-Z])/g, '-$1').replace(/^ms-/, '-ms-').toLowerCase();
}
function searchFrom$1(text, target, startIndex, endIndex) {
    if (startIndex === void 0) { startIndex = 0; }
    // search from partial of string
    var subText = text.substring(startIndex, endIndex);
    var relativeIndex = subText.search(target);
    return relativeIndex === -1 ? -1 : startIndex + relativeIndex;
}
function connectList$1(a, b, append) {
    if (append === void 0) { append = true; }
    return append ? __spreadArray$1(__spreadArray$1([], (a !== null && a !== void 0 ? a : []), true), (b !== null && b !== void 0 ? b : []), true) : __spreadArray$1(__spreadArray$1([], (b !== null && b !== void 0 ? b : []), true), (a !== null && a !== void 0 ? a : []), true);
}
function deepCopy$1(source) {
    return Array.isArray(source)
        ? source.map(function (item) { return deepCopy$1(item); })
        : source instanceof Date
            ? new Date(source.getTime())
            : source && typeof source === 'object'
                ? Object.getOwnPropertyNames(source).reduce(function (o, prop) {
                    var descriptor = Object.getOwnPropertyDescriptor(source, prop);
                    if (descriptor) {
                        Object.defineProperty(o, prop, descriptor);
                        if (source && typeof source === 'object') {
                            o[prop] = deepCopy$1(source[prop]);
                        }
                    }
                    return o;
                }, Object.create(Object.getPrototypeOf(source)))
                : source;
}
function isTagName$1(name) {
    return ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embd', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'svg', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr'].includes(name);
}
function searchPropEnd$1(text, startIndex) {
    if (startIndex === void 0) { startIndex = 0; }
    var index = startIndex;
    var output = -1;
    var openSingleQuote = false;
    var openDoubleQuote = false;
    var openBracket = false;
    var isEscaped = false;
    while (index < text.length) {
        switch (text.charAt(index)) {
            case '\\':
                isEscaped = !isEscaped;
                break;
            case '\'':
                if (!openDoubleQuote && !openBracket && !isEscaped)
                    openSingleQuote = !openSingleQuote;
                isEscaped = false;
                break;
            case '"':
                if (!openSingleQuote && !openBracket && !isEscaped)
                    openDoubleQuote = !openDoubleQuote;
                isEscaped = false;
                break;
            case '(':
                if (!openBracket && !openSingleQuote && !openDoubleQuote && !isEscaped)
                    openBracket = true;
                isEscaped = false;
                break;
            case ')':
                if (openBracket && !isEscaped)
                    openBracket = false;
                isEscaped = false;
                break;
            case ';':
                if (!isEscaped && !openSingleQuote && !openDoubleQuote && !openBracket)
                    output = index;
                isEscaped = false;
                break;
            default:
                isEscaped = false;
                break;
        }
        if (output !== -1)
            break;
        index++;
    }
    return output;
}

var Property$1 = /** @class */ (function () {
    function Property(name, value, comment, important) {
        if (important === void 0) { important = false; }
        this.meta = { type: 'utilities', group: 'plugin', order: 0, offset: 0, corePlugin: false };
        this.name = name;
        this.value = value;
        this.comment = comment;
        this.important = important;
    }
    Property._singleParse = function (css) {
        css = css.trim();
        if (!css)
            return;
        if (css.charAt(0) === '@')
            return InlineAtRule$1.parse(css);
        var split = css.search(':');
        var end = searchPropEnd$1(css);
        if (split === -1)
            return;
        var important = false;
        var prop = css.substring(split + 1, end === -1 ? undefined : end).trim();
        if (/!important;?$/.test(prop)) {
            important = true;
            prop = prop.replace(/!important/, '').trimRight();
        }
        return new Property(css.substring(0, split).trim(), prop, undefined, important);
    };
    Property.parse = function (css) {
        if (!/;\s*$/.test(css))
            css += ';'; // Fix for the situation where the last semicolon is omitted
        var properties = [];
        var index = 0;
        var end = searchPropEnd$1(css, index);
        while (end !== -1) {
            var parsed = this._singleParse(css.substring(searchFrom$1(css, /\S/, index), end + 1));
            if (parsed)
                properties.push(parsed);
            index = end + 1;
            end = searchPropEnd$1(css, index);
        }
        var count = properties.length;
        if (count > 1)
            return properties;
        if (count === 1)
            return properties[0];
    };
    Property.prototype.clone = function () {
        return deepCopy$1(this);
    };
    Property.prototype.toStyle = function (selector) {
        var style = new Style$1(selector, this, this.important);
        style.meta = this.meta;
        return style;
    };
    Property.prototype.build = function (minify) {
        var _this = this;
        if (minify === void 0) { minify = false; }
        var createProperty = function (name, value) {
            if (minify) {
                return "".concat(name, ":").concat(value).concat(_this.important ? '!important' : '', ";");
            }
            else {
                var p = "".concat(name, ": ").concat(value).concat(_this.important ? ' !important' : '', ";");
                return _this.comment ? p + " /* ".concat(_this.comment, " */") : p;
            }
        };
        if (!this.value)
            return '';
        return typeof this.name === 'string'
            ? createProperty(this.name, this.value)
            : this.name
                .map(function (i) { return createProperty(i, _this.value); })
                .join(minify ? '' : '\n');
    };
    Property.prototype.updateMeta = function (type, group, order, offset, corePlugin) {
        if (offset === void 0) { offset = 0; }
        if (corePlugin === void 0) { corePlugin = false; }
        this.meta = {
            type: type,
            group: group,
            order: order,
            offset: offset,
            corePlugin: corePlugin,
        };
        return this;
    };
    return Property;
}());
var InlineAtRule$1 = /** @class */ (function (_super) {
    __extends$1(InlineAtRule, _super);
    function InlineAtRule(name, value, important) {
        if (important === void 0) { important = false; }
        var _this = _super.call(this, name, value, undefined, important) || this;
        _this.name = name;
        return _this;
    }
    InlineAtRule.parse = function (css) {
        var _a;
        var matchName = css.match(/@[^\s;{}]+/);
        if (matchName) {
            var name_1 = matchName[0].substring(1);
            var important = false;
            var expression = matchName.index !== undefined
                ? (_a = css
                    .substring(matchName.index + name_1.length + 1)
                    .match(/(?:(['"]).*?\1|[^;])*/)) === null || _a === void 0 ? void 0 : _a[0].trim()
                : undefined;
            if (expression && /!important;?$/.test(expression)) {
                important = true;
                expression = expression.replace(/!important/, '').trimRight();
            }
            return new InlineAtRule(name_1, expression === '' ? undefined : expression, important);
        }
    };
    InlineAtRule.prototype.build = function () {
        return this.value
            ? "@".concat(this.name, " ").concat(this.value).concat(this.important ? ' !important' : '', ";")
            : "@".concat(this.name).concat(this.important ? ' !important' : '', ";");
    };
    return InlineAtRule;
}(Property$1));
var Style$1 = /** @class */ (function () {
    function Style(selector, property, important) {
        if (important === void 0) { important = false; }
        this.meta = { type: 'components', group: 'plugin', order: 0, offset: 0, corePlugin: false };
        this.selector = selector;
        this.important = important;
        this.property = toArray$2(property || []);
    }
    Object.defineProperty(Style.prototype, "rule", {
        get: function () {
            var _this = this;
            var _a, _b, _c;
            var selectors = ((_a = this.selector) !== null && _a !== void 0 ? _a : '').trim().split(/\s*,\s*/g);
            this._parentSelectors && (selectors = selectors.map(function (i) { var _a; return "".concat((_a = _this._parentSelectors) === null || _a === void 0 ? void 0 : _a.join(' '), " ").concat(i); }));
            ((_b = this._wrapSelectors) !== null && _b !== void 0 ? _b : []).forEach(function (func) { return (selectors = selectors.map(function (i) { return func(i); })); });
            this._pseudoClasses && (selectors = selectors.map(function (i) { var _a; return i + ":".concat((_a = _this._pseudoClasses) === null || _a === void 0 ? void 0 : _a.join(':')); }));
            this._pseudoElements && (selectors = selectors.map(function (i) { var _a; return i + "::".concat((_a = _this._pseudoElements) === null || _a === void 0 ? void 0 : _a.join('::')); }));
            this._brotherSelectors && (selectors = selectors.map(function (i) { var _a; return i + ".".concat((_a = _this._brotherSelectors) === null || _a === void 0 ? void 0 : _a.join('.')); }));
            this._childSelectors && (selectors = selectors.map(function (i) { var _a; return i + " ".concat((_a = _this._childSelectors) === null || _a === void 0 ? void 0 : _a.join(' ')); }));
            ((_c = this._wrapRules) !== null && _c !== void 0 ? _c : []).forEach(function (func) { return (selectors = selectors.map(function (i) { return func(i); })); });
            return selectors.join(', ');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "pseudoClasses", {
        get: function () {
            return this._pseudoClasses;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "pseudoElements", {
        get: function () {
            return this._pseudoElements;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "parentSelectors", {
        get: function () {
            return this._parentSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "childSelectors", {
        get: function () {
            return this._childSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "brotherSelectors", {
        get: function () {
            return this._brotherSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapProperties", {
        get: function () {
            return this._wrapProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapSelectors", {
        get: function () {
            return this._wrapSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapRules", {
        get: function () {
            return this._wrapRules;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "simple", {
        get: function () {
            // is this style only has property and no wrap?
            return !(this.atRules || this._pseudoClasses || this._pseudoElements || this._parentSelectors || this._childSelectors || this._brotherSelectors || this._wrapProperties || this._wrapSelectors || this._wrapRules);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "isAtrule", {
        get: function () {
            return !(this.atRules === undefined || this.atRules.length === 0);
        },
        enumerable: false,
        configurable: true
    });
    Style.generate = function (parent, property, root) {
        if (!root)
            root = (parent === null || parent === void 0 ? void 0 : parent.startsWith('@'))
                ? new Style().atRule(parent)
                : new Style(parent);
        var output = [];
        var _loop_1 = function (key, value) {
            var propertyValue = value;
            if (Array.isArray(propertyValue) && propertyValue.every(function (e) { return typeof e === 'object'; })) {
                propertyValue = Object.assign.apply(Object, __spreadArray$1([{}], propertyValue, false));
            }
            if (typeof propertyValue === 'string') {
                root.add(new Property$1(camelToDash$1(key), propertyValue));
            }
            else if (Array.isArray(propertyValue)) {
                propertyValue.map(function (i) { return root === null || root === void 0 ? void 0 : root.add(new Property$1(camelToDash$1(key), i)); });
            }
            else {
                var wrap = deepCopy$1(root);
                wrap.property = [];
                var child = void 0;
                if (key.startsWith('@')) {
                    child = wrap.atRule(key, false);
                }
                else {
                    if (wrap.selector === undefined) {
                        wrap.selector = key;
                        child = wrap;
                    }
                    else {
                        if (/^[a-z]+$/.test(key) && !isTagName$1(key)) {
                            wrap.wrapProperty(function (property) { return "".concat(key, "-").concat(property); });
                            child = wrap;
                        }
                        else {
                            var _hKey_1 = function (selector, key) { return (/&/.test(key) ? key : "& ".concat(key)).replace('&', selector); };
                            wrap.wrapSelector(function (selector) {
                                return selector
                                    .trim()
                                    .split(/\s*,\s*/g)
                                    .map(function (s) {
                                    return key
                                        .split(/\s*,\s*/g)
                                        .map(function (i) { return _hKey_1(s, i); })
                                        .join(', ');
                                })
                                    .join(', ');
                            });
                            child = wrap;
                        }
                    }
                }
                output = output.concat(Style.generate(key.startsWith('@') ? undefined : key, propertyValue, child));
            }
        };
        for (var _i = 0, _a = Object.entries(property !== null && property !== void 0 ? property : {}); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            _loop_1(key, value);
        }
        if (root.property.length > 0)
            output.unshift(root);
        return output;
    };
    Style.prototype.atRule = function (atrule, append) {
        if (append === void 0) { append = true; }
        if (!atrule)
            return this;
        if (this.atRules) {
            append ? this.atRules.push(atrule) : this.atRules.unshift(atrule);
        }
        else {
            this.atRules = [atrule];
        }
        return this;
    };
    Style.prototype.pseudoClass = function (string) {
        if (this._pseudoClasses) {
            this._pseudoClasses.push(string);
        }
        else {
            this._pseudoClasses = [string];
        }
        return this;
    };
    Style.prototype.pseudoElement = function (string) {
        if (this._pseudoElements) {
            this._pseudoElements.push(string);
        }
        else {
            this._pseudoElements = [string];
        }
        return this;
    };
    Style.prototype.brother = function (string) {
        if (this._brotherSelectors) {
            this._brotherSelectors.push(string);
        }
        else {
            this._brotherSelectors = [string];
        }
        return this;
    };
    Style.prototype.parent = function (string) {
        if (this._parentSelectors) {
            this._parentSelectors.push(string);
        }
        else {
            this._parentSelectors = [string];
        }
        return this;
    };
    Style.prototype.child = function (string) {
        if (this._childSelectors) {
            this._childSelectors.push(string);
        }
        else {
            this._childSelectors = [string];
        }
        return this;
    };
    Style.prototype.wrapProperty = function (func) {
        if (this._wrapProperties) {
            this._wrapProperties.push(func);
        }
        else {
            this._wrapProperties = [func];
        }
        return this;
    };
    Style.prototype.wrapSelector = function (func) {
        if (this._wrapSelectors) {
            this._wrapSelectors.push(func);
        }
        else {
            this._wrapSelectors = [func];
        }
        return this;
    };
    Style.prototype.wrapRule = function (func) {
        if (this._wrapRules) {
            this._wrapRules.push(func);
        }
        else {
            this._wrapRules = [func];
        }
        return this;
    };
    Style.prototype.add = function (item) {
        item = toArray$2(item);
        if (this.important)
            item.forEach(function (i) { return (i.important = true); });
        this.property = __spreadArray$1(__spreadArray$1([], this.property, true), item, true);
        return this;
    };
    Style.prototype.extend = function (item, onlyProperty, append) {
        if (onlyProperty === void 0) { onlyProperty = false; }
        if (append === void 0) { append = true; }
        if (!item)
            return this;
        if (item.wrapProperties) {
            var props_1 = [];
            item.property.forEach(function (p) {
                var _a;
                var pc = new Property$1(p.name, p.value, p.comment);
                (_a = item.wrapProperties) === null || _a === void 0 ? void 0 : _a.forEach(function (wrap) {
                    pc.name = Array.isArray(pc.name)
                        ? pc.name.map(function (i) { return wrap(i); })
                        : wrap(pc.name);
                });
                if (item.important)
                    pc.important = true;
                props_1.push(pc);
            });
            this.property = connectList$1(this.property, props_1, append);
        }
        else {
            if (item.important)
                item.property.forEach(function (i) { return (i.important = true); });
            this.property = connectList$1(this.property, item.property, append);
        }
        if (onlyProperty)
            return this;
        item.selector && (this.selector = item.selector);
        this.meta = item.meta;
        item.atRules &&
            (this.atRules = connectList$1(item.atRules, this.atRules, append)); // atrule is build in reverse
        item._brotherSelectors &&
            (this._brotherSelectors = connectList$1(this._brotherSelectors, item._brotherSelectors, append));
        item._childSelectors &&
            (this._childSelectors = connectList$1(this._childSelectors, item._childSelectors, append));
        item._parentSelectors &&
            (this._parentSelectors = connectList$1(this._parentSelectors, item._parentSelectors, append));
        item._pseudoClasses &&
            (this._pseudoClasses = connectList$1(this._pseudoClasses, item._pseudoClasses, append));
        item._pseudoElements &&
            (this._pseudoElements = connectList$1(this._pseudoElements, item._pseudoElements, append));
        item._wrapRules &&
            (this._wrapRules = connectList$1(this._wrapRules, item._wrapRules, append));
        item._wrapSelectors &&
            (this._wrapSelectors = connectList$1(this._wrapSelectors, item._wrapSelectors, append));
        return this;
    };
    Style.prototype.clean = function () {
        // remove duplicated property
        var property = [];
        var cache = [];
        this.property.forEach(function (i) {
            var inline = i.build();
            if (!cache.includes(inline)) {
                cache.push(inline);
                property.push(i);
            }
        });
        this.property = property;
        return this;
    };
    Style.prototype.flat = function () {
        var properties = [];
        this.property.forEach(function (p) {
            if (Array.isArray(p.name)) {
                p.name.forEach(function (i) {
                    properties.push(new Property$1(i, p.value, p.comment));
                });
            }
            else {
                properties.push(p);
            }
        });
        this.property = properties;
        return this;
    };
    Style.prototype.clone = function (selector, property) {
        var newStyle = deepCopy$1(this);
        if (selector)
            newStyle.selector = selector;
        if (property)
            newStyle.property = Array.isArray(property) ? property : [property];
        return newStyle;
    };
    Style.prototype.sort = function () {
        // sort property
        this.property = this.property.sort(function (a, b) {
            return "".concat(a.name).substring(0, 2) > "".concat(b.name).substring(0, 2) ? 1 : -1;
        });
        return this;
    };
    Style.prototype.build = function (minify, prefixer) {
        var _this = this;
        if (minify === void 0) { minify = false; }
        if (prefixer === void 0) { prefixer = true; }
        var properties = this.property;
        if (!prefixer)
            properties = properties.filter(function (p) {
                if (p.value && /-(webkit|ms|moz|o)-/.test(p.value))
                    return false;
                if (Array.isArray(p.name)) {
                    p.name = p.name.filter(function (i) { return !/^-(webkit|ms|moz|o)-/.test(i); });
                    return true;
                }
                return !/^-(webkit|ms|moz|o)-/.test(p.name);
            });
        var result = properties.map(function (p) {
            if (_this._wrapProperties) {
                var name_2 = p.name;
                _this._wrapProperties.forEach(function (w) { return (name_2 = Array.isArray(name_2) ? name_2.map(function (n) { return w(n); }) : w(name_2)); });
                return new Property$1(name_2, p.value, p.comment, _this.important ? true : p.important).build(minify);
            }
            return _this.important ? new Property$1(p.name, p.value, p.comment, true).build(minify) : p.build(minify);
        }).join(minify ? '' : '\n');
        if (!this.selector && !this.atRules)
            return result.replace(/;}/g, '}');
        if (this.selector)
            result = (minify ? this.rule.replace(/,\s/g, ',') : this.rule + ' ') + wrapit$1(result, undefined, undefined, undefined, result !== '' ? minify : true);
        if (this.atRules) {
            for (var _i = 0, _a = this.atRules; _i < _a.length; _i++) {
                var rule = _a[_i];
                result = minify ? "".concat(rule.replace(/\s/g, '')).concat(wrapit$1(result, undefined, undefined, undefined, minify)) : "".concat(rule, " ").concat(wrapit$1(result, undefined, undefined, undefined, result !== '' ? minify : true));
            }
        }
        return minify ? result.replace(/;}/g, '}') : result;
    };
    Style.prototype.updateMeta = function (type, group, order, offset, corePlugin, respectSelector) {
        if (offset === void 0) { offset = 0; }
        if (corePlugin === void 0) { corePlugin = false; }
        if (respectSelector === void 0) { respectSelector = false; }
        this.meta = {
            type: type,
            group: group,
            order: order,
            offset: offset,
            corePlugin: corePlugin,
            respectSelector: respectSelector,
        };
        return this;
    };
    return Style;
}());
/** @class */ ((function (_super) {
    __extends$1(GlobalStyle, _super);
    function GlobalStyle(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    return GlobalStyle;
})(Style$1));
var Keyframes = /** @class */ (function (_super) {
    __extends$1(Keyframes, _super);
    function Keyframes(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    // root param only for consist with style
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Keyframes.generate = function (name, children, root, prefixer) {
        if (prefixer === void 0) { prefixer = true; }
        var styles = [];
        var webkitStyles = [];
        for (var _i = 0, _a = Object.entries(children); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            var style = new Keyframes(key).atRule("@keyframes ".concat(name));
            var webkitStyle = new Keyframes(key).atRule("@-webkit-keyframes ".concat(name));
            for (var _c = 0, _d = Object.entries(value); _c < _d.length; _c++) {
                var _e = _d[_c], pkey = _e[0], pvalue = _e[1];
                var prop = pkey;
                if (pkey === 'transform') {
                    prop = prefixer ? ['-webkit-transform', 'transform'] : 'transform';
                }
                else if (['animationTimingFunction', 'animation-timing-function'].includes(pkey)) {
                    prop = prefixer ? [
                        '-webkit-animation-timing-function',
                        'animation-timing-function',
                    ] : 'animation-timing-function';
                }
                style.add(new Property$1(prop, pvalue));
                webkitStyle.add(new Property$1(prop, pvalue));
            }
            styles.push(style);
            if (prefixer)
                webkitStyles.push(webkitStyle);
        }
        return __spreadArray$1(__spreadArray$1([], styles, true), webkitStyles, true);
    };
    return Keyframes;
}(Style$1));
/** @class */ ((function (_super) {
    __extends$1(Container, _super);
    function Container(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    return Container;
})(Style$1));

var minMaxWidth = /(!?\(\s*min(-device-)?-width).+\(\s*max(-device)?-width/i;
var minWidth = /\(\s*min(-device)?-width/i;
var maxMinWidth = /(!?\(\s*max(-device)?-width).+\(\s*min(-device)?-width/i;
var maxWidth = /\(\s*max(-device)?-width/i;
var isMinWidth = _testQuery(minMaxWidth, maxMinWidth, minWidth);
var isMaxWidth = _testQuery(maxMinWidth, minMaxWidth, maxWidth);
var minMaxHeight = /(!?\(\s*min(-device)?-height).+\(\s*max(-device)?-height/i;
var minHeight = /\(\s*min(-device)?-height/i;
var maxMinHeight = /(!?\(\s*max(-device)?-height).+\(\s*min(-device)?-height/i;
var maxHeight = /\(\s*max(-device)?-height/i;
var isMinHeight = _testQuery(minMaxHeight, maxMinHeight, minHeight);
var isMaxHeight = _testQuery(maxMinHeight, minMaxHeight, maxHeight);
var isPrint = /print/i;
var isPrintOnly = /^print\$/i;
var isAtRule = /^\s*@/i;
var isMedia = /^\s*@media/i;
var maxValue = Number.MAX_VALUE;
function _getQueryLength(length) {
    var result = /(-?\d*\.?\d+)(ch|em|ex|px|rpx|rem)/.exec(length);
    if (result === null) {
        return maxValue;
    }
    var number = result[1];
    var unit = result[2];
    switch (unit) {
        case 'ch':
            return parseFloat(number) * 8.8984375;
        case 'em':
        case 'rem':
            return parseFloat(number) * 16;
        case 'ex':
            return parseFloat(number) * 8.296875;
        case 'px':
        case 'rpx':
            return parseFloat(number);
    }
    return +number;
}
function _testQuery(doubleTestTrue, doubleTestFalse, singleTest) {
    return function (query) {
        if (doubleTestTrue.test(query)) {
            return true;
        }
        else if (doubleTestFalse.test(query)) {
            return false;
        }
        return singleTest.test(query);
    };
}
function _testAtRule(a, b) {
    var isMediaA = isMedia.test(a);
    var isMediaB = isMedia.test(b);
    if (isMediaA && isMediaB)
        return null;
    var isAtRuleA = isAtRule.test(a);
    var isAtRuleB = isAtRule.test(b);
    if (isAtRuleA)
        return 1;
    if (isAtRuleB)
        return -1;
    return 0; // don't sort selector name, may cause overwrite bug.
}
function _testIsPrint(a, b) {
    var isPrintA = isPrint.test(a);
    var isPrintOnlyA = isPrintOnly.test(a);
    var isPrintB = isPrint.test(b);
    var isPrintOnlyB = isPrintOnly.test(b);
    if (isPrintA && isPrintB) {
        if (!isPrintOnlyA && isPrintOnlyB) {
            return 1;
        }
        if (isPrintOnlyA && !isPrintOnlyB) {
            return -1;
        }
        return a.localeCompare(b);
    }
    if (isPrintA) {
        return 1;
    }
    if (isPrintB) {
        return -1;
    }
    return null;
}
function sortMediaQuery(a, b) {
    var testAtRule = _testAtRule(a, b);
    if (testAtRule !== null)
        return testAtRule;
    var testIsPrint = _testIsPrint(a, b);
    if (testIsPrint !== null)
        return testIsPrint;
    var minA = isMinWidth(a) || isMinHeight(a);
    var maxA = isMaxWidth(a) || isMaxHeight(a);
    var minB = isMinWidth(b) || isMinHeight(b);
    var maxB = isMaxWidth(b) || isMaxHeight(b);
    if (minA && maxB) {
        return -1;
    }
    if (maxA && minB) {
        return 1;
    }
    var lengthA = _getQueryLength(a);
    var lengthB = _getQueryLength(b);
    if (lengthA === maxValue && lengthB === maxValue) {
        return a.localeCompare(b);
    }
    else if (lengthA === maxValue) {
        return 1;
    }
    else if (lengthB === maxValue) {
        return -1;
    }
    if (lengthA > lengthB) {
        if (maxA) {
            return -1;
        }
        return 1;
    }
    if (lengthA < lengthB) {
        if (maxA) {
            return 1;
        }
        return -1;
    }
    return a.localeCompare(b);
}

function getWeights(a) {
    var first = a.charAt(0);
    var second = a.charAt(1);
    if (first === ':' && second === ':')
        return 59; // ::moz ...
    if (first === '#')
        return 500; // #id ...
    if (first !== '.')
        return first.charCodeAt(0); // html, body ...
    return 499;
}
function sortMeta(a, b) {
    var _a, _b, _c, _d;
    if (a.meta.type === 'base' && b.meta.type === 'base')
        return getWeights((_a = a.selector) !== null && _a !== void 0 ? _a : '') - getWeights((_b = b.selector) !== null && _b !== void 0 ? _b : '');
    return sortMediaQuery(((_c = a.meta.variants) === null || _c === void 0 ? void 0 : _c[0]) || '', ((_d = b.meta.variants) === null || _d === void 0 ? void 0 : _d[0]) || '') || (a.meta.order - b.meta.order) || (a.meta.offset - b.meta.offset) || +b.meta.corePlugin - +a.meta.corePlugin;
}

function _buildAtrule(atrule, children, minify, prefixer) {
    if (minify === void 0) { minify = false; }
    if (prefixer === void 0) { prefixer = true; }
    return "".concat(atrule).concat(minify ? '' : ' ').concat(wrapit$1(_buildStyleList(children, minify, prefixer), undefined, undefined, undefined, minify));
}
function _buildStyleList(styleList, minify, prefixer) {
    if (minify === void 0) { minify = false; }
    if (prefixer === void 0) { prefixer = true; }
    var currentAtrule;
    var currentStyle;
    var styleStack = [];
    var output = [];
    var _loop_1 = function (style) {
        if (style.isAtrule) {
            if (currentStyle) {
                output.push(currentStyle.clean().build(minify, prefixer));
                currentStyle = undefined;
            }
            var newAtrule = style.atRules.pop();
            if (currentAtrule) {
                if (currentAtrule === newAtrule && newAtrule !== '@font-face') { // @font-face shouldn't been combined
                    styleStack.push(style);
                }
                else {
                    output.push(_buildAtrule(currentAtrule, styleStack, minify, prefixer));
                    currentAtrule = newAtrule;
                    styleStack = [style];
                }
            }
            else {
                currentAtrule = newAtrule;
                styleStack = [style];
            }
        }
        else {
            if (currentAtrule) {
                output.push(_buildAtrule(currentAtrule, styleStack, minify, prefixer));
                currentAtrule = undefined;
                styleStack = [];
            }
            if (currentStyle) {
                if (style.rule === currentStyle.rule) {
                    if (style.important)
                        style.property.forEach(function (p) { return p.important = true; });
                    if (style.wrapProperties)
                        style.property.forEach(function (p) { var _a; return (_a = style.wrapProperties) === null || _a === void 0 ? void 0 : _a.forEach(function (wrap) { return p.name = Array.isArray(p.name) ? p.name.map(function (i) { return wrap(i); }) : wrap(p.name); }); });
                    currentStyle.add(style.property);
                }
                else {
                    output.push(currentStyle.clean().build(minify, prefixer));
                    currentStyle = style;
                }
            }
            else {
                currentStyle = style;
            }
        }
    };
    for (var _i = 0, styleList_1 = styleList; _i < styleList_1.length; _i++) {
        var style = styleList_1[_i];
        _loop_1(style);
    }
    if (currentAtrule)
        output.push(_buildAtrule(currentAtrule, styleStack, minify, prefixer));
    if (currentStyle)
        output.push(currentStyle.clean().build(minify, prefixer));
    return output.join(minify ? '' : '\n');
}
function compileStyleSheet (styleList, minify, prefixer) {
    if (minify === void 0) { minify = false; }
    if (prefixer === void 0) { prefixer = true; }
    return _buildStyleList(deepCopy$1(styleList), minify, prefixer);
}

var StyleSheet = /** @class */ (function () {
    function StyleSheet(children) {
        this.prefixer = true;
        this.children = children || [];
    }
    StyleSheet.prototype.add = function (item) {
        if (!item)
            return this;
        if (Array.isArray(item)) {
            this.children = __spreadArray$1(__spreadArray$1([], this.children, true), item, true);
        }
        else {
            this.children.push(item);
        }
        return this;
    };
    StyleSheet.prototype.extend = function (styleSheet, append, dedup) {
        if (append === void 0) { append = true; }
        if (dedup === void 0) { dedup = false; }
        if (styleSheet) {
            var extended = styleSheet.children;
            if (dedup) {
                var hashes_1 = extended.map(function (i) { return hash(i.build()); });
                extended = extended.filter(function (i) { return !hashes_1.includes(hash(i.build())); });
            }
            this.prefixer = styleSheet.prefixer;
            this.children = append ? __spreadArray$1(__spreadArray$1([], this.children, true), extended, true) : __spreadArray$1(__spreadArray$1([], extended, true), this.children, true);
        }
        return this;
    };
    StyleSheet.prototype.combine = function () {
        var styleMap = {};
        this.children.forEach(function (style, index) {
            var _a;
            var hashValue = hash(style.atRules + style.meta.type + style.rule);
            if (hashValue in styleMap) {
                if ((_a = style.atRules) === null || _a === void 0 ? void 0 : _a.includes('@font-face')) {
                    // keeps multiple @font-face
                    styleMap[hashValue + index] = style;
                }
                else {
                    styleMap[hashValue] = styleMap[hashValue].extend(style, true);
                }
            }
            else {
                styleMap[hashValue] = style;
            }
        });
        this.children = Object.values(styleMap).map(function (i) { return i.clean(); });
        return this;
    };
    StyleSheet.prototype.layer = function (type) {
        var styleSheet = new StyleSheet(this.children.filter(function (i) { return i.meta.type === type; }));
        styleSheet.prefixer = this.prefixer;
        return styleSheet;
    };
    StyleSheet.prototype.split = function () {
        return {
            base: this.layer('base'),
            components: this.layer('components'),
            utilities: this.layer('utilities'),
        };
    };
    StyleSheet.prototype.clone = function () {
        return deepCopy$1(this);
    };
    StyleSheet.prototype.sort = function () {
        this.children = this.children.sort(sortMeta);
        return this;
    };
    StyleSheet.prototype.sortby = function (compareFn) {
        this.children = this.children.sort(compareFn);
        return this;
    };
    StyleSheet.prototype.build = function (minify) {
        if (minify === void 0) { minify = false; }
        return compileStyleSheet(this.children, minify, this.prefixer);
    };
    return StyleSheet;
}());

var layerOrder;
(function (layerOrder) {
    layerOrder[layerOrder["base"] = 10] = "base";
    layerOrder[layerOrder["components"] = 150] = "components";
    layerOrder[layerOrder["shortcuts"] = 160] = "shortcuts";
    layerOrder[layerOrder["utilities"] = 20000] = "utilities";
})(layerOrder || (layerOrder = {}));
var pluginOrder;
(function (pluginOrder) {
    pluginOrder[pluginOrder["columns"] = 80] = "columns";
    pluginOrder[pluginOrder["container"] = 100] = "container";
    pluginOrder[pluginOrder["space"] = 200] = "space";
    pluginOrder[pluginOrder["divideWidth"] = 300] = "divideWidth";
    pluginOrder[pluginOrder["divideColor"] = 400] = "divideColor";
    pluginOrder[pluginOrder["divideStyle"] = 500] = "divideStyle";
    pluginOrder[pluginOrder["divideOpacity"] = 600] = "divideOpacity";
    pluginOrder[pluginOrder["accessibility"] = 700] = "accessibility";
    pluginOrder[pluginOrder["appearance"] = 800] = "appearance";
    pluginOrder[pluginOrder["backgroundAttachment"] = 900] = "backgroundAttachment";
    pluginOrder[pluginOrder["backgroundClip"] = 1000] = "backgroundClip";
    pluginOrder[pluginOrder["backgroundColor"] = 1100] = "backgroundColor";
    pluginOrder[pluginOrder["backgroundImage"] = 1200] = "backgroundImage";
    pluginOrder[pluginOrder["gradientColorStops"] = 1300] = "gradientColorStops";
    pluginOrder[pluginOrder["backgroundOpacity"] = 1400] = "backgroundOpacity";
    pluginOrder[pluginOrder["backgroundPosition"] = 1500] = "backgroundPosition";
    pluginOrder[pluginOrder["backgroundRepeat"] = 1600] = "backgroundRepeat";
    pluginOrder[pluginOrder["backgroundSize"] = 1700] = "backgroundSize";
    pluginOrder[pluginOrder["backgroundOrigin"] = 1750] = "backgroundOrigin";
    pluginOrder[pluginOrder["borderCollapse"] = 1800] = "borderCollapse";
    pluginOrder[pluginOrder["borderColor"] = 1900] = "borderColor";
    pluginOrder[pluginOrder["borderOpacity"] = 2000] = "borderOpacity";
    pluginOrder[pluginOrder["borderRadius"] = 2100] = "borderRadius";
    pluginOrder[pluginOrder["borderStyle"] = 2200] = "borderStyle";
    pluginOrder[pluginOrder["borderWidth"] = 2300] = "borderWidth";
    pluginOrder[pluginOrder["boxDecorationBreak"] = 2350] = "boxDecorationBreak";
    pluginOrder[pluginOrder["boxSizing"] = 2400] = "boxSizing";
    pluginOrder[pluginOrder["cursor"] = 2500] = "cursor";
    pluginOrder[pluginOrder["captionSide"] = 2550] = "captionSide";
    pluginOrder[pluginOrder["emptyCells"] = 2560] = "emptyCells";
    pluginOrder[pluginOrder["display"] = 2600] = "display";
    pluginOrder[pluginOrder["flexBasis"] = 2699] = "flexBasis";
    pluginOrder[pluginOrder["flexDirection"] = 2700] = "flexDirection";
    pluginOrder[pluginOrder["flexWrap"] = 2800] = "flexWrap";
    pluginOrder[pluginOrder["placeItems"] = 2900] = "placeItems";
    pluginOrder[pluginOrder["placeContent"] = 3000] = "placeContent";
    pluginOrder[pluginOrder["placeSelf"] = 3100] = "placeSelf";
    pluginOrder[pluginOrder["alignItems"] = 3200] = "alignItems";
    pluginOrder[pluginOrder["alignContent"] = 3300] = "alignContent";
    pluginOrder[pluginOrder["alignSelf"] = 3400] = "alignSelf";
    pluginOrder[pluginOrder["justifyItems"] = 3500] = "justifyItems";
    pluginOrder[pluginOrder["justifyContent"] = 3600] = "justifyContent";
    pluginOrder[pluginOrder["justifySelf"] = 3700] = "justifySelf";
    pluginOrder[pluginOrder["flex"] = 3800] = "flex";
    pluginOrder[pluginOrder["flexGrow"] = 3900] = "flexGrow";
    pluginOrder[pluginOrder["flexShrink"] = 4000] = "flexShrink";
    pluginOrder[pluginOrder["order"] = 4100] = "order";
    pluginOrder[pluginOrder["float"] = 4200] = "float";
    pluginOrder[pluginOrder["clear"] = 4300] = "clear";
    pluginOrder[pluginOrder["fontFamily"] = 4400] = "fontFamily";
    pluginOrder[pluginOrder["fontWeight"] = 4500] = "fontWeight";
    pluginOrder[pluginOrder["height"] = 4600] = "height";
    pluginOrder[pluginOrder["fontSize"] = 4700] = "fontSize";
    pluginOrder[pluginOrder["lineHeight"] = 4800] = "lineHeight";
    pluginOrder[pluginOrder["listStylePosition"] = 4900] = "listStylePosition";
    pluginOrder[pluginOrder["listStyleType"] = 5000] = "listStyleType";
    pluginOrder[pluginOrder["margin"] = 5100] = "margin";
    pluginOrder[pluginOrder["maxHeight"] = 5200] = "maxHeight";
    pluginOrder[pluginOrder["maxWidth"] = 5300] = "maxWidth";
    pluginOrder[pluginOrder["minHeight"] = 5400] = "minHeight";
    pluginOrder[pluginOrder["minWidth"] = 5500] = "minWidth";
    pluginOrder[pluginOrder["objectFit"] = 5600] = "objectFit";
    pluginOrder[pluginOrder["objectPosition"] = 5700] = "objectPosition";
    pluginOrder[pluginOrder["opacity"] = 5800] = "opacity";
    pluginOrder[pluginOrder["outline"] = 5900] = "outline";
    pluginOrder[pluginOrder["overflow"] = 6000] = "overflow";
    pluginOrder[pluginOrder["overscrollBehavior"] = 6100] = "overscrollBehavior";
    pluginOrder[pluginOrder["padding"] = 6200] = "padding";
    pluginOrder[pluginOrder["placeholderColor"] = 6300] = "placeholderColor";
    pluginOrder[pluginOrder["placeholderOpacity"] = 6400] = "placeholderOpacity";
    pluginOrder[pluginOrder["caretColor"] = 6450] = "caretColor";
    pluginOrder[pluginOrder["caretOpacity"] = 6460] = "caretOpacity";
    pluginOrder[pluginOrder["tabSize"] = 6470] = "tabSize";
    pluginOrder[pluginOrder["pointerEvents"] = 6500] = "pointerEvents";
    pluginOrder[pluginOrder["position"] = 6600] = "position";
    pluginOrder[pluginOrder["inset"] = 6700] = "inset";
    pluginOrder[pluginOrder["resize"] = 6800] = "resize";
    pluginOrder[pluginOrder["boxShadow"] = 6900] = "boxShadow";
    pluginOrder[pluginOrder["boxShadowColor"] = 6950] = "boxShadowColor";
    pluginOrder[pluginOrder["ringWidth"] = 7000] = "ringWidth";
    pluginOrder[pluginOrder["ringOffsetColor"] = 7100] = "ringOffsetColor";
    pluginOrder[pluginOrder["ringOffsetWidth"] = 7200] = "ringOffsetWidth";
    pluginOrder[pluginOrder["ringColor"] = 7300] = "ringColor";
    pluginOrder[pluginOrder["ringOpacity"] = 7400] = "ringOpacity";
    pluginOrder[pluginOrder["fill"] = 7500] = "fill";
    pluginOrder[pluginOrder["stroke"] = 7600] = "stroke";
    pluginOrder[pluginOrder["strokeWidth"] = 7700] = "strokeWidth";
    pluginOrder[pluginOrder["strokeDashArray"] = 7750] = "strokeDashArray";
    pluginOrder[pluginOrder["strokeDashOffset"] = 7760] = "strokeDashOffset";
    pluginOrder[pluginOrder["tableLayout"] = 7800] = "tableLayout";
    pluginOrder[pluginOrder["textAlign"] = 7900] = "textAlign";
    pluginOrder[pluginOrder["textColor"] = 8000] = "textColor";
    pluginOrder[pluginOrder["textOpacity"] = 8100] = "textOpacity";
    pluginOrder[pluginOrder["textOverflow"] = 8200] = "textOverflow";
    pluginOrder[pluginOrder["textShadow"] = 8250] = "textShadow";
    pluginOrder[pluginOrder["fontStyle"] = 8300] = "fontStyle";
    pluginOrder[pluginOrder["textTransform"] = 8400] = "textTransform";
    pluginOrder[pluginOrder["textDecorationStyle"] = 8450] = "textDecorationStyle";
    pluginOrder[pluginOrder["textDecorationLength"] = 8455] = "textDecorationLength";
    pluginOrder[pluginOrder["textDecorationColor"] = 8460] = "textDecorationColor";
    pluginOrder[pluginOrder["textDecorationOpacity"] = 8470] = "textDecorationOpacity";
    pluginOrder[pluginOrder["textDecorationOffset"] = 8480] = "textDecorationOffset";
    pluginOrder[pluginOrder["textDecorationThickness"] = 8490] = "textDecorationThickness";
    pluginOrder[pluginOrder["textDecoration"] = 8500] = "textDecoration";
    pluginOrder[pluginOrder["textIndent"] = 8550] = "textIndent";
    pluginOrder[pluginOrder["textStrokeColor"] = 8560] = "textStrokeColor";
    pluginOrder[pluginOrder["textStrokeWidth"] = 8570] = "textStrokeWidth";
    pluginOrder[pluginOrder["content"] = 8580] = "content";
    pluginOrder[pluginOrder["fontSmoothing"] = 8600] = "fontSmoothing";
    pluginOrder[pluginOrder["fontVariantNumeric"] = 8700] = "fontVariantNumeric";
    pluginOrder[pluginOrder["letterSpacing"] = 8800] = "letterSpacing";
    pluginOrder[pluginOrder["userSelect"] = 8900] = "userSelect";
    pluginOrder[pluginOrder["verticalAlign"] = 9000] = "verticalAlign";
    pluginOrder[pluginOrder["visibility"] = 9100] = "visibility";
    pluginOrder[pluginOrder["backfaceVisibility"] = 9150] = "backfaceVisibility";
    pluginOrder[pluginOrder["whitespace"] = 9200] = "whitespace";
    pluginOrder[pluginOrder["wordBreak"] = 9300] = "wordBreak";
    pluginOrder[pluginOrder["writingMode"] = 9340] = "writingMode";
    pluginOrder[pluginOrder["hyphens"] = 9350] = "hyphens";
    pluginOrder[pluginOrder["width"] = 9400] = "width";
    pluginOrder[pluginOrder["zIndex"] = 9500] = "zIndex";
    pluginOrder[pluginOrder["isolation"] = 9550] = "isolation";
    pluginOrder[pluginOrder["gap"] = 9600] = "gap";
    pluginOrder[pluginOrder["gridAutoFlow"] = 9700] = "gridAutoFlow";
    pluginOrder[pluginOrder["gridTemplateColumns"] = 9800] = "gridTemplateColumns";
    pluginOrder[pluginOrder["gridAutoColumns"] = 9900] = "gridAutoColumns";
    pluginOrder[pluginOrder["gridColumn"] = 10000] = "gridColumn";
    pluginOrder[pluginOrder["gridColumnStart"] = 10100] = "gridColumnStart";
    pluginOrder[pluginOrder["gridColumnEnd"] = 10200] = "gridColumnEnd";
    pluginOrder[pluginOrder["gridTemplateRows"] = 10300] = "gridTemplateRows";
    pluginOrder[pluginOrder["gridAutoRows"] = 10400] = "gridAutoRows";
    pluginOrder[pluginOrder["gridRow"] = 10500] = "gridRow";
    pluginOrder[pluginOrder["gridRowStart"] = 10600] = "gridRowStart";
    pluginOrder[pluginOrder["gridRowEnd"] = 10700] = "gridRowEnd";
    pluginOrder[pluginOrder["transform"] = 10800] = "transform";
    pluginOrder[pluginOrder["transformOrigin"] = 10900] = "transformOrigin";
    pluginOrder[pluginOrder["scale"] = 11000] = "scale";
    pluginOrder[pluginOrder["rotate"] = 11100] = "rotate";
    pluginOrder[pluginOrder["translate"] = 11200] = "translate";
    pluginOrder[pluginOrder["skew"] = 11300] = "skew";
    pluginOrder[pluginOrder["perspective"] = 11350] = "perspective";
    pluginOrder[pluginOrder["perspectiveOrigin"] = 11360] = "perspectiveOrigin";
    pluginOrder[pluginOrder["transitionProperty"] = 11400] = "transitionProperty";
    pluginOrder[pluginOrder["transitionTimingFunction"] = 11500] = "transitionTimingFunction";
    pluginOrder[pluginOrder["transitionDuration"] = 11600] = "transitionDuration";
    pluginOrder[pluginOrder["transitionDelay"] = 11700] = "transitionDelay";
    pluginOrder[pluginOrder["keyframes"] = 11800] = "keyframes";
    pluginOrder[pluginOrder["animation"] = 11900] = "animation";
    pluginOrder[pluginOrder["imageRendering"] = 11950] = "imageRendering";
    pluginOrder[pluginOrder["mixBlendMode"] = 12000] = "mixBlendMode";
    pluginOrder[pluginOrder["backgroundBlendMode"] = 12100] = "backgroundBlendMode";
    pluginOrder[pluginOrder["filter"] = 12200] = "filter";
    pluginOrder[pluginOrder["blur"] = 12300] = "blur";
    pluginOrder[pluginOrder["brightness"] = 12400] = "brightness";
    pluginOrder[pluginOrder["contrast"] = 12500] = "contrast";
    pluginOrder[pluginOrder["dropShadow"] = 12600] = "dropShadow";
    pluginOrder[pluginOrder["grayscale"] = 12700] = "grayscale";
    pluginOrder[pluginOrder["hueRotate"] = 12800] = "hueRotate";
    pluginOrder[pluginOrder["invert"] = 12900] = "invert";
    pluginOrder[pluginOrder["saturate"] = 13000] = "saturate";
    pluginOrder[pluginOrder["sepia"] = 13100] = "sepia";
    pluginOrder[pluginOrder["backdropFilter"] = 13200] = "backdropFilter";
    pluginOrder[pluginOrder["backdropBlur"] = 13300] = "backdropBlur";
    pluginOrder[pluginOrder["backdropBrightness"] = 13400] = "backdropBrightness";
    pluginOrder[pluginOrder["backdropContrast"] = 13500] = "backdropContrast";
    pluginOrder[pluginOrder["backdropGrayscale"] = 13600] = "backdropGrayscale";
    pluginOrder[pluginOrder["backdropHueRotate"] = 13700] = "backdropHueRotate";
    pluginOrder[pluginOrder["backdropInvert"] = 13800] = "backdropInvert";
    pluginOrder[pluginOrder["backdropOpacity"] = 13900] = "backdropOpacity";
    pluginOrder[pluginOrder["backdropSaturate"] = 14000] = "backdropSaturate";
    pluginOrder[pluginOrder["backdropSepia"] = 14100] = "backdropSepia";
    pluginOrder[pluginOrder["willChange"] = 14200] = "willChange";
    pluginOrder[pluginOrder["touchAction"] = 14300] = "touchAction";
    pluginOrder[pluginOrder["scrollBehavior"] = 14400] = "scrollBehavior";
    pluginOrder[pluginOrder["accentColor"] = 14500] = "accentColor";
})(pluginOrder || (pluginOrder = {}));

var CSSParser = /** @class */ (function () {
    function CSSParser(css, processor) {
        this.variables = {};
        this._cache = {};
        this.css = css;
        this.processor = processor;
    }
    CSSParser.prototype._addCache = function (style) {
        var rule = style.rule;
        if (['.', '#'].includes(rule.charAt(0)))
            this._cache[rule] = (rule in this._cache) ? __spreadArray$1(__spreadArray$1([], this._cache[rule], true), [deepCopy$1(style)], false) : [deepCopy$1(style)];
    };
    CSSParser.prototype._searchGroup = function (text, startIndex) {
        if (startIndex === void 0) { startIndex = 0; }
        var level = 1;
        var endBracket = searchFrom$1(text, '}', startIndex);
        while (endBracket !== -1) {
            var nextBracket = searchFrom$1(text, '{', startIndex);
            if (endBracket < nextBracket || nextBracket === -1) {
                level--;
                startIndex = endBracket + 1;
                if (level === 0)
                    return endBracket;
            }
            else {
                level++;
                startIndex = nextBracket + 1;
            }
            endBracket = searchFrom$1(text, '}', startIndex);
        }
        return -1;
    };
    CSSParser.prototype._loadTheme = function (prop) {
        if (!prop)
            return;
        if (!this.processor)
            return prop;
        var index = 0;
        var output = [];
        while (index < prop.length) {
            var matched = prop.slice(index).match(/theme\([^)]*?\)/);
            if (!matched || matched.index === undefined)
                break;
            output.push(prop.slice(index, index + matched.index));
            var args = matched[0].slice(6, -1).split(/\s*,\s*/).map(function (i) { return i.trim().replace(/^['"]+|['"]+$/g, ''); });
            output.push(this.processor.theme(args[0], args[1]));
            index += matched.index + matched[0].length;
        }
        output.push(prop.slice(index));
        return output.join('');
    };
    CSSParser.prototype._handleDirectives = function (atrule) {
        var _a, _b, _c;
        if (!this.processor)
            return { atrule: atrule };
        var iatrule = InlineAtRule$1.parse(atrule);
        if (!iatrule)
            return;
        if (iatrule.name === 'apply')
            return { apply: iatrule.value, important: iatrule.important };
        if (iatrule.name === 'layer')
            return { layer: ((_a = iatrule.value) !== null && _a !== void 0 ? _a : 'components') };
        if (iatrule.name === 'variants' && iatrule.value)
            return { variants: iatrule.value.split(',').map(function (i) { return i.trim().split(':'); }) };
        if (iatrule.name === 'screen' && iatrule.value) {
            var screens = this.processor.resolveVariants('screen');
            if (iatrule.value in screens)
                return { atrule: (_c = (_b = screens[iatrule.value]().atRules) === null || _b === void 0 ? void 0 : _b[0]) !== null && _c !== void 0 ? _c : atrule };
            if (['dark', 'light'].includes(iatrule.value))
                return { atrule: "@media (prefers-color-scheme: ".concat(iatrule.value, ")") };
        }
        return { atrule: atrule };
    };
    CSSParser.prototype._generateNestProperty = function (props, parent, parentType) {
        var style = new Style$1(undefined, props);
        if (!parent || !parentType)
            return style;
        if (parentType === 'selector') {
            style.selector = parent;
            return style;
        }
        return style.atRule(parent);
    };
    CSSParser.prototype._generateNestStyle = function (styles, parent, parentType) {
        var _this = this;
        var layer = 'utilities';
        var order = layerOrder['utilities'] + 1;
        var group = 'block';
        if (!parent)
            return styles;
        if (parentType === 'selector') {
            styles.forEach(function (i) {
                if (i instanceof Keyframes)
                    return;
                if (!i.selector) {
                    i.selector = parent;
                }
                else {
                    var selector_1 = i.selector;
                    selector_1 = selector_1.trim().split(/\s*,\s*/g).map(function (i) { return /&/.test(i) ? i : "& ".concat(i); }).join(', ');
                    i.selector = /\s*,\s*/.test(parent) ? parent.trim().split(/\s*,\s*/g).map(function (i) { return selector_1.replace(/&/g, i); }).join(', ') : selector_1.replace(/&/g, parent);
                }
                i.updateMeta(layer, group, order);
                _this._addCache(i);
            });
        }
        else if (parentType === 'atRule') {
            var atrule_1 = parent;
            if (this.processor) {
                // handle directives
                var directives = this._handleDirectives(parent);
                if (directives) {
                    if ('atrule' in directives) {
                        // @screen
                        atrule_1 = directives.atrule;
                    }
                    else if ('layer' in directives) {
                        // @layer
                        atrule_1 = undefined;
                        layer = directives.layer;
                        order = layerOrder[layer];
                        group = 'layer-block';
                    }
                    else if ('variants' in directives) {
                        // @variants
                        var output = [];
                        for (var _i = 0, _a = directives.variants; _i < _a.length; _i++) {
                            var variant = _a[_i];
                            var wrapper = this.processor.wrapWithVariants(variant, styles);
                            if (wrapper)
                                output = output.concat(wrapper);
                        }
                        output.map(function (i) {
                            i.updateMeta(layer, group, order);
                            _this._addCache(i);
                        });
                        return output;
                    }
                }
            }
            styles.filter(function (i) { return !(i instanceof Keyframes); }).forEach(function (i) {
                i.atRule(atrule_1);
                i.updateMeta(layer, group, order);
                _this._addCache(i);
            });
        }
        return styles;
    };
    CSSParser.prototype.parse = function (css, parent, parentType) {
        var _this = this;
        var _a;
        if (css === void 0) { css = this.css; }
        var styleSheet = new StyleSheet();
        if (!css || isSpace(css))
            return styleSheet;
        var index = 0;
        var firstLetter = searchFrom$1(css, /\S/, index);
        var len = css.length;
        var _loop_1 = function () {
            var propEnd = searchPropEnd$1(css, index);
            var nestStart = searchFrom$1(css, '{', firstLetter);
            var firstChar = css.charAt(firstLetter);
            if (firstChar === '/') {
                // remove comment
                switch (css.charAt(firstLetter + 1)) {
                    case '/':
                        index = firstLetter + 2;
                        while (index < len) {
                            if (css.charAt(index) === '\n')
                                break;
                            index++;
                        }
                        index += 1;
                        break;
                    case '*':
                        index = firstLetter + 2;
                        while (index < len) {
                            if (css.charAt(index) === '*' && css.charAt(index + 1) === '/')
                                break;
                            index++;
                        }
                        index += 2;
                        break;
                }
            }
            else if (propEnd === -1 || (nestStart !== -1 && propEnd > nestStart)) {
                // nested AtRule or Selector
                var selector = css.substring(firstLetter, nestStart).trim();
                index = nestStart + 1;
                var nestEnd = this_1._searchGroup(css, index);
                if (nestEnd === -1)
                    return "break"; // doesn't close block
                // allow last rule without semicolon
                var rule = css.slice(index, nestEnd);
                if (!/[};]\s*$/.test(rule))
                    rule = rule + ';';
                var content = this_1.parse(rule, selector);
                index = nestEnd + 1;
                styleSheet.add(this_1._generateNestStyle(content.children, selector, firstChar === '@' ? 'atRule' : 'selector'));
            }
            else if (firstChar === '$') {
                // define variable
                var prop = Property$1.parse(css.slice(firstLetter, propEnd));
                if (prop && !Array.isArray(prop) && !Array.isArray(prop.name) && prop.value) {
                    this_1.variables[prop.name.slice(1)] = prop.value;
                }
                index = propEnd + 1;
            }
            else if (firstChar === '@') {
                // inline AtRule
                var data = css.slice(firstLetter, propEnd);
                if (this_1.processor) {
                    // handle directives
                    var directives_1 = this_1._handleDirectives(data.trim());
                    if (directives_1) {
                        if ('atrule' in directives_1) {
                            var atRule = InlineAtRule$1.parse(directives_1.atrule);
                            if (atRule)
                                styleSheet.add(this_1._generateNestProperty(atRule, parent, parentType));
                        }
                        else if ('apply' in directives_1 && directives_1.apply) {
                            var result = this_1.processor.compile(directives_1.apply, undefined, false, false, function (ignored) {
                                if (('.' + ignored) in _this._cache)
                                    return _this._cache['.' + ignored];
                            });
                            styleSheet.add(result.styleSheet.clone().children.map(function (i) {
                                if (!(i instanceof Keyframes)) {
                                    i.selector = undefined;
                                    if (directives_1.important) {
                                        i.property.map(function (i) { return i.important = true; });
                                    }
                                }
                                return i;
                            }));
                        }
                    }
                }
                else {
                    // normal atrule
                    var atRule = InlineAtRule$1.parse(data);
                    if (atRule)
                        styleSheet.add(this_1._generateNestProperty(atRule, parent, parentType));
                }
                index = propEnd + 1;
            }
            else {
                // inline Property
                var prop = Property$1.parse(css.slice(firstLetter, propEnd));
                index = propEnd + 1;
                if (prop) {
                    // handle theme function
                    if (Array.isArray(prop)) {
                        prop.filter(function (p) { var _a; return (_a = p.value) === null || _a === void 0 ? void 0 : _a.match(/theme\([^)]*\)/); }).forEach(function (p) { return p.value = _this._loadTheme(p.value); });
                    }
                    else if ((_a = prop.value) === null || _a === void 0 ? void 0 : _a.match(/theme\([^)]*\)/)) {
                        prop.value = this_1._loadTheme(prop.value);
                    }
                    styleSheet.add(this_1._generateNestProperty(prop, parent, parentType));
                }
            }
            firstLetter = searchFrom$1(css, /\S/, index);
        };
        var this_1 = this;
        while (firstLetter !== -1) {
            var state_1 = _loop_1();
            if (state_1 === "break")
                break;
        }
        if (!parent)
            this._cache = {};
        return styleSheet.combine();
    };
    return CSSParser;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}
function toArray$1(v) {
    if (Array.isArray(v))
        return v;
    return [v];
}
function indent(code, tab) {
    if (tab === void 0) { tab = 2; }
    var spaces = Array(tab).fill(' ').join('');
    return code
        .split('\n')
        .map(function (line) { return spaces + line; })
        .join('\n');
}
function wrapit(code, start, end, tab, minify) {
    if (start === void 0) { start = '{'; }
    if (end === void 0) { end = '}'; }
    if (tab === void 0) { tab = 2; }
    if (minify === void 0) { minify = false; }
    if (minify)
        return "".concat(start).concat(code).concat(end);
    return "".concat(start, "\n").concat(indent(code, tab), "\n").concat(end);
}
function camelToDash(str) {
    // Use exact the same regex as Post CSS
    return str.replace(/([A-Z])/g, '-$1').replace(/^ms-/, '-ms-').toLowerCase();
}
function searchFrom(text, target, startIndex, endIndex) {
    if (startIndex === void 0) { startIndex = 0; }
    // search from partial of string
    var subText = text.substring(startIndex, endIndex);
    var relativeIndex = subText.search(target);
    return relativeIndex === -1 ? -1 : startIndex + relativeIndex;
}
function connectList(a, b, append) {
    if (append === void 0) { append = true; }
    return append ? __spreadArray(__spreadArray([], (a !== null && a !== void 0 ? a : []), true), (b !== null && b !== void 0 ? b : []), true) : __spreadArray(__spreadArray([], (b !== null && b !== void 0 ? b : []), true), (a !== null && a !== void 0 ? a : []), true);
}
function deepCopy(source) {
    return Array.isArray(source)
        ? source.map(function (item) { return deepCopy(item); })
        : source instanceof Date
            ? new Date(source.getTime())
            : source && typeof source === 'object'
                ? Object.getOwnPropertyNames(source).reduce(function (o, prop) {
                    var descriptor = Object.getOwnPropertyDescriptor(source, prop);
                    if (descriptor) {
                        Object.defineProperty(o, prop, descriptor);
                        if (source && typeof source === 'object') {
                            o[prop] = deepCopy(source[prop]);
                        }
                    }
                    return o;
                }, Object.create(Object.getPrototypeOf(source)))
                : source;
}
function isTagName(name) {
    return ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embd', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'svg', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr'].includes(name);
}
function flatColors$1(colors, head) {
    var flatten = {};
    for (var _i = 0, _a = Object.entries(colors); _i < _a.length; _i++) {
        var _b = _a[_i], key = _b[0], value = _b[1];
        if (typeof value === 'string' || typeof value === 'function') {
            flatten[(head && key === 'DEFAULT') ? head : head ? "".concat(head, "-").concat(key) : key] = value;
        }
        else {
            flatten = __assign(__assign({}, flatten), flatColors$1(value, head ? "".concat(head, "-").concat(key) : key));
        }
    }
    return flatten;
}
function searchPropEnd(text, startIndex) {
    if (startIndex === void 0) { startIndex = 0; }
    var index = startIndex;
    var output = -1;
    var openSingleQuote = false;
    var openDoubleQuote = false;
    var openBracket = false;
    var isEscaped = false;
    while (index < text.length) {
        switch (text.charAt(index)) {
            case '\\':
                isEscaped = !isEscaped;
                break;
            case '\'':
                if (!openDoubleQuote && !openBracket && !isEscaped)
                    openSingleQuote = !openSingleQuote;
                isEscaped = false;
                break;
            case '"':
                if (!openSingleQuote && !openBracket && !isEscaped)
                    openDoubleQuote = !openDoubleQuote;
                isEscaped = false;
                break;
            case '(':
                if (!openBracket && !openSingleQuote && !openDoubleQuote && !isEscaped)
                    openBracket = true;
                isEscaped = false;
                break;
            case ')':
                if (openBracket && !isEscaped)
                    openBracket = false;
                isEscaped = false;
                break;
            case ';':
                if (!isEscaped && !openSingleQuote && !openDoubleQuote && !openBracket)
                    output = index;
                isEscaped = false;
                break;
            default:
                isEscaped = false;
                break;
        }
        if (output !== -1)
            break;
        index++;
    }
    return output;
}

var Property = /** @class */ (function () {
    function Property(name, value, comment, important) {
        if (important === void 0) { important = false; }
        this.meta = { type: 'utilities', group: 'plugin', order: 0, offset: 0, corePlugin: false };
        this.name = name;
        this.value = value;
        this.comment = comment;
        this.important = important;
    }
    Property._singleParse = function (css) {
        css = css.trim();
        if (!css)
            return;
        if (css.charAt(0) === '@')
            return InlineAtRule.parse(css);
        var split = css.search(':');
        var end = searchPropEnd(css);
        if (split === -1)
            return;
        var important = false;
        var prop = css.substring(split + 1, end === -1 ? undefined : end).trim();
        if (/!important;?$/.test(prop)) {
            important = true;
            prop = prop.replace(/!important/, '').trimRight();
        }
        return new Property(css.substring(0, split).trim(), prop, undefined, important);
    };
    Property.parse = function (css) {
        if (!/;\s*$/.test(css))
            css += ';'; // Fix for the situation where the last semicolon is omitted
        var properties = [];
        var index = 0;
        var end = searchPropEnd(css, index);
        while (end !== -1) {
            var parsed = this._singleParse(css.substring(searchFrom(css, /\S/, index), end + 1));
            if (parsed)
                properties.push(parsed);
            index = end + 1;
            end = searchPropEnd(css, index);
        }
        var count = properties.length;
        if (count > 1)
            return properties;
        if (count === 1)
            return properties[0];
    };
    Property.prototype.clone = function () {
        return deepCopy(this);
    };
    Property.prototype.toStyle = function (selector) {
        var style = new Style(selector, this, this.important);
        style.meta = this.meta;
        return style;
    };
    Property.prototype.build = function (minify) {
        var _this = this;
        if (minify === void 0) { minify = false; }
        var createProperty = function (name, value) {
            if (minify) {
                return "".concat(name, ":").concat(value).concat(_this.important ? '!important' : '', ";");
            }
            else {
                var p = "".concat(name, ": ").concat(value).concat(_this.important ? ' !important' : '', ";");
                return _this.comment ? p + " /* ".concat(_this.comment, " */") : p;
            }
        };
        if (!this.value)
            return '';
        return typeof this.name === 'string'
            ? createProperty(this.name, this.value)
            : this.name
                .map(function (i) { return createProperty(i, _this.value); })
                .join(minify ? '' : '\n');
    };
    Property.prototype.updateMeta = function (type, group, order, offset, corePlugin) {
        if (offset === void 0) { offset = 0; }
        if (corePlugin === void 0) { corePlugin = false; }
        this.meta = {
            type: type,
            group: group,
            order: order,
            offset: offset,
            corePlugin: corePlugin,
        };
        return this;
    };
    return Property;
}());
var InlineAtRule = /** @class */ (function (_super) {
    __extends(InlineAtRule, _super);
    function InlineAtRule(name, value, important) {
        if (important === void 0) { important = false; }
        var _this = _super.call(this, name, value, undefined, important) || this;
        _this.name = name;
        return _this;
    }
    InlineAtRule.parse = function (css) {
        var _a;
        var matchName = css.match(/@[^\s;{}]+/);
        if (matchName) {
            var name_1 = matchName[0].substring(1);
            var important = false;
            var expression = matchName.index !== undefined
                ? (_a = css
                    .substring(matchName.index + name_1.length + 1)
                    .match(/(?:(['"]).*?\1|[^;])*/)) === null || _a === void 0 ? void 0 : _a[0].trim()
                : undefined;
            if (expression && /!important;?$/.test(expression)) {
                important = true;
                expression = expression.replace(/!important/, '').trimRight();
            }
            return new InlineAtRule(name_1, expression === '' ? undefined : expression, important);
        }
    };
    InlineAtRule.prototype.build = function () {
        return this.value
            ? "@".concat(this.name, " ").concat(this.value).concat(this.important ? ' !important' : '', ";")
            : "@".concat(this.name).concat(this.important ? ' !important' : '', ";");
    };
    return InlineAtRule;
}(Property));
var Style = /** @class */ (function () {
    function Style(selector, property, important) {
        if (important === void 0) { important = false; }
        this.meta = { type: 'components', group: 'plugin', order: 0, offset: 0, corePlugin: false };
        this.selector = selector;
        this.important = important;
        this.property = toArray$1(property || []);
    }
    Object.defineProperty(Style.prototype, "rule", {
        get: function () {
            var _this = this;
            var _a, _b, _c;
            var selectors = ((_a = this.selector) !== null && _a !== void 0 ? _a : '').trim().split(/\s*,\s*/g);
            this._parentSelectors && (selectors = selectors.map(function (i) { var _a; return "".concat((_a = _this._parentSelectors) === null || _a === void 0 ? void 0 : _a.join(' '), " ").concat(i); }));
            ((_b = this._wrapSelectors) !== null && _b !== void 0 ? _b : []).forEach(function (func) { return (selectors = selectors.map(function (i) { return func(i); })); });
            this._pseudoClasses && (selectors = selectors.map(function (i) { var _a; return i + ":".concat((_a = _this._pseudoClasses) === null || _a === void 0 ? void 0 : _a.join(':')); }));
            this._pseudoElements && (selectors = selectors.map(function (i) { var _a; return i + "::".concat((_a = _this._pseudoElements) === null || _a === void 0 ? void 0 : _a.join('::')); }));
            this._brotherSelectors && (selectors = selectors.map(function (i) { var _a; return i + ".".concat((_a = _this._brotherSelectors) === null || _a === void 0 ? void 0 : _a.join('.')); }));
            this._childSelectors && (selectors = selectors.map(function (i) { var _a; return i + " ".concat((_a = _this._childSelectors) === null || _a === void 0 ? void 0 : _a.join(' ')); }));
            ((_c = this._wrapRules) !== null && _c !== void 0 ? _c : []).forEach(function (func) { return (selectors = selectors.map(function (i) { return func(i); })); });
            return selectors.join(', ');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "pseudoClasses", {
        get: function () {
            return this._pseudoClasses;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "pseudoElements", {
        get: function () {
            return this._pseudoElements;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "parentSelectors", {
        get: function () {
            return this._parentSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "childSelectors", {
        get: function () {
            return this._childSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "brotherSelectors", {
        get: function () {
            return this._brotherSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapProperties", {
        get: function () {
            return this._wrapProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapSelectors", {
        get: function () {
            return this._wrapSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapRules", {
        get: function () {
            return this._wrapRules;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "simple", {
        get: function () {
            // is this style only has property and no wrap?
            return !(this.atRules || this._pseudoClasses || this._pseudoElements || this._parentSelectors || this._childSelectors || this._brotherSelectors || this._wrapProperties || this._wrapSelectors || this._wrapRules);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "isAtrule", {
        get: function () {
            return !(this.atRules === undefined || this.atRules.length === 0);
        },
        enumerable: false,
        configurable: true
    });
    Style.generate = function (parent, property, root) {
        if (!root)
            root = (parent === null || parent === void 0 ? void 0 : parent.startsWith('@'))
                ? new Style().atRule(parent)
                : new Style(parent);
        var output = [];
        var _loop_1 = function (key, value) {
            var propertyValue = value;
            if (Array.isArray(propertyValue) && propertyValue.every(function (e) { return typeof e === 'object'; })) {
                propertyValue = Object.assign.apply(Object, __spreadArray([{}], propertyValue, false));
            }
            if (typeof propertyValue === 'string') {
                root.add(new Property(camelToDash(key), propertyValue));
            }
            else if (Array.isArray(propertyValue)) {
                propertyValue.map(function (i) { return root === null || root === void 0 ? void 0 : root.add(new Property(camelToDash(key), i)); });
            }
            else {
                var wrap = deepCopy(root);
                wrap.property = [];
                var child = void 0;
                if (key.startsWith('@')) {
                    child = wrap.atRule(key, false);
                }
                else {
                    if (wrap.selector === undefined) {
                        wrap.selector = key;
                        child = wrap;
                    }
                    else {
                        if (/^[a-z]+$/.test(key) && !isTagName(key)) {
                            wrap.wrapProperty(function (property) { return "".concat(key, "-").concat(property); });
                            child = wrap;
                        }
                        else {
                            var _hKey_1 = function (selector, key) { return (/&/.test(key) ? key : "& ".concat(key)).replace('&', selector); };
                            wrap.wrapSelector(function (selector) {
                                return selector
                                    .trim()
                                    .split(/\s*,\s*/g)
                                    .map(function (s) {
                                    return key
                                        .split(/\s*,\s*/g)
                                        .map(function (i) { return _hKey_1(s, i); })
                                        .join(', ');
                                })
                                    .join(', ');
                            });
                            child = wrap;
                        }
                    }
                }
                output = output.concat(Style.generate(key.startsWith('@') ? undefined : key, propertyValue, child));
            }
        };
        for (var _i = 0, _a = Object.entries(property !== null && property !== void 0 ? property : {}); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            _loop_1(key, value);
        }
        if (root.property.length > 0)
            output.unshift(root);
        return output;
    };
    Style.prototype.atRule = function (atrule, append) {
        if (append === void 0) { append = true; }
        if (!atrule)
            return this;
        if (this.atRules) {
            append ? this.atRules.push(atrule) : this.atRules.unshift(atrule);
        }
        else {
            this.atRules = [atrule];
        }
        return this;
    };
    Style.prototype.pseudoClass = function (string) {
        if (this._pseudoClasses) {
            this._pseudoClasses.push(string);
        }
        else {
            this._pseudoClasses = [string];
        }
        return this;
    };
    Style.prototype.pseudoElement = function (string) {
        if (this._pseudoElements) {
            this._pseudoElements.push(string);
        }
        else {
            this._pseudoElements = [string];
        }
        return this;
    };
    Style.prototype.brother = function (string) {
        if (this._brotherSelectors) {
            this._brotherSelectors.push(string);
        }
        else {
            this._brotherSelectors = [string];
        }
        return this;
    };
    Style.prototype.parent = function (string) {
        if (this._parentSelectors) {
            this._parentSelectors.push(string);
        }
        else {
            this._parentSelectors = [string];
        }
        return this;
    };
    Style.prototype.child = function (string) {
        if (this._childSelectors) {
            this._childSelectors.push(string);
        }
        else {
            this._childSelectors = [string];
        }
        return this;
    };
    Style.prototype.wrapProperty = function (func) {
        if (this._wrapProperties) {
            this._wrapProperties.push(func);
        }
        else {
            this._wrapProperties = [func];
        }
        return this;
    };
    Style.prototype.wrapSelector = function (func) {
        if (this._wrapSelectors) {
            this._wrapSelectors.push(func);
        }
        else {
            this._wrapSelectors = [func];
        }
        return this;
    };
    Style.prototype.wrapRule = function (func) {
        if (this._wrapRules) {
            this._wrapRules.push(func);
        }
        else {
            this._wrapRules = [func];
        }
        return this;
    };
    Style.prototype.add = function (item) {
        item = toArray$1(item);
        if (this.important)
            item.forEach(function (i) { return (i.important = true); });
        this.property = __spreadArray(__spreadArray([], this.property, true), item, true);
        return this;
    };
    Style.prototype.extend = function (item, onlyProperty, append) {
        if (onlyProperty === void 0) { onlyProperty = false; }
        if (append === void 0) { append = true; }
        if (!item)
            return this;
        if (item.wrapProperties) {
            var props_1 = [];
            item.property.forEach(function (p) {
                var _a;
                var pc = new Property(p.name, p.value, p.comment);
                (_a = item.wrapProperties) === null || _a === void 0 ? void 0 : _a.forEach(function (wrap) {
                    pc.name = Array.isArray(pc.name)
                        ? pc.name.map(function (i) { return wrap(i); })
                        : wrap(pc.name);
                });
                if (item.important)
                    pc.important = true;
                props_1.push(pc);
            });
            this.property = connectList(this.property, props_1, append);
        }
        else {
            if (item.important)
                item.property.forEach(function (i) { return (i.important = true); });
            this.property = connectList(this.property, item.property, append);
        }
        if (onlyProperty)
            return this;
        item.selector && (this.selector = item.selector);
        this.meta = item.meta;
        item.atRules &&
            (this.atRules = connectList(item.atRules, this.atRules, append)); // atrule is build in reverse
        item._brotherSelectors &&
            (this._brotherSelectors = connectList(this._brotherSelectors, item._brotherSelectors, append));
        item._childSelectors &&
            (this._childSelectors = connectList(this._childSelectors, item._childSelectors, append));
        item._parentSelectors &&
            (this._parentSelectors = connectList(this._parentSelectors, item._parentSelectors, append));
        item._pseudoClasses &&
            (this._pseudoClasses = connectList(this._pseudoClasses, item._pseudoClasses, append));
        item._pseudoElements &&
            (this._pseudoElements = connectList(this._pseudoElements, item._pseudoElements, append));
        item._wrapRules &&
            (this._wrapRules = connectList(this._wrapRules, item._wrapRules, append));
        item._wrapSelectors &&
            (this._wrapSelectors = connectList(this._wrapSelectors, item._wrapSelectors, append));
        return this;
    };
    Style.prototype.clean = function () {
        // remove duplicated property
        var property = [];
        var cache = [];
        this.property.forEach(function (i) {
            var inline = i.build();
            if (!cache.includes(inline)) {
                cache.push(inline);
                property.push(i);
            }
        });
        this.property = property;
        return this;
    };
    Style.prototype.flat = function () {
        var properties = [];
        this.property.forEach(function (p) {
            if (Array.isArray(p.name)) {
                p.name.forEach(function (i) {
                    properties.push(new Property(i, p.value, p.comment));
                });
            }
            else {
                properties.push(p);
            }
        });
        this.property = properties;
        return this;
    };
    Style.prototype.clone = function (selector, property) {
        var newStyle = deepCopy(this);
        if (selector)
            newStyle.selector = selector;
        if (property)
            newStyle.property = Array.isArray(property) ? property : [property];
        return newStyle;
    };
    Style.prototype.sort = function () {
        // sort property
        this.property = this.property.sort(function (a, b) {
            return "".concat(a.name).substring(0, 2) > "".concat(b.name).substring(0, 2) ? 1 : -1;
        });
        return this;
    };
    Style.prototype.build = function (minify, prefixer) {
        var _this = this;
        if (minify === void 0) { minify = false; }
        if (prefixer === void 0) { prefixer = true; }
        var properties = this.property;
        if (!prefixer)
            properties = properties.filter(function (p) {
                if (p.value && /-(webkit|ms|moz|o)-/.test(p.value))
                    return false;
                if (Array.isArray(p.name)) {
                    p.name = p.name.filter(function (i) { return !/^-(webkit|ms|moz|o)-/.test(i); });
                    return true;
                }
                return !/^-(webkit|ms|moz|o)-/.test(p.name);
            });
        var result = properties.map(function (p) {
            if (_this._wrapProperties) {
                var name_2 = p.name;
                _this._wrapProperties.forEach(function (w) { return (name_2 = Array.isArray(name_2) ? name_2.map(function (n) { return w(n); }) : w(name_2)); });
                return new Property(name_2, p.value, p.comment, _this.important ? true : p.important).build(minify);
            }
            return _this.important ? new Property(p.name, p.value, p.comment, true).build(minify) : p.build(minify);
        }).join(minify ? '' : '\n');
        if (!this.selector && !this.atRules)
            return result.replace(/;}/g, '}');
        if (this.selector)
            result = (minify ? this.rule.replace(/,\s/g, ',') : this.rule + ' ') + wrapit(result, undefined, undefined, undefined, result !== '' ? minify : true);
        if (this.atRules) {
            for (var _i = 0, _a = this.atRules; _i < _a.length; _i++) {
                var rule = _a[_i];
                result = minify ? "".concat(rule.replace(/\s/g, '')).concat(wrapit(result, undefined, undefined, undefined, minify)) : "".concat(rule, " ").concat(wrapit(result, undefined, undefined, undefined, result !== '' ? minify : true));
            }
        }
        return minify ? result.replace(/;}/g, '}') : result;
    };
    Style.prototype.updateMeta = function (type, group, order, offset, corePlugin, respectSelector) {
        if (offset === void 0) { offset = 0; }
        if (corePlugin === void 0) { corePlugin = false; }
        if (respectSelector === void 0) { respectSelector = false; }
        this.meta = {
            type: type,
            group: group,
            order: order,
            offset: offset,
            corePlugin: corePlugin,
            respectSelector: respectSelector,
        };
        return this;
    };
    return Style;
}());
/** @class */ ((function (_super) {
    __extends(GlobalStyle, _super);
    function GlobalStyle(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    return GlobalStyle;
})(Style));
/** @class */ ((function (_super) {
    __extends(Keyframes, _super);
    function Keyframes(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    // root param only for consist with style
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Keyframes.generate = function (name, children, root, prefixer) {
        if (prefixer === void 0) { prefixer = true; }
        var styles = [];
        var webkitStyles = [];
        for (var _i = 0, _a = Object.entries(children); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            var style = new Keyframes(key).atRule("@keyframes ".concat(name));
            var webkitStyle = new Keyframes(key).atRule("@-webkit-keyframes ".concat(name));
            for (var _c = 0, _d = Object.entries(value); _c < _d.length; _c++) {
                var _e = _d[_c], pkey = _e[0], pvalue = _e[1];
                var prop = pkey;
                if (pkey === 'transform') {
                    prop = prefixer ? ['-webkit-transform', 'transform'] : 'transform';
                }
                else if (['animationTimingFunction', 'animation-timing-function'].includes(pkey)) {
                    prop = prefixer ? [
                        '-webkit-animation-timing-function',
                        'animation-timing-function',
                    ] : 'animation-timing-function';
                }
                style.add(new Property(prop, pvalue));
                webkitStyle.add(new Property(prop, pvalue));
            }
            styles.push(style);
            if (prefixer)
                webkitStyles.push(webkitStyle);
        }
        return __spreadArray(__spreadArray([], styles, true), webkitStyles, true);
    };
    return Keyframes;
})(Style));
/** @class */ ((function (_super) {
    __extends(Container, _super);
    function Container(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    return Container;
})(Style));

var colorName = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

var simpleSwizzle = {exports: {}};

var isArrayish$1 = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

var isArrayish = isArrayish$1;

var concat = Array.prototype.concat;
var slice$1 = Array.prototype.slice;

var swizzle$1 = simpleSwizzle.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice$1.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle$1.wrap = function (fn) {
	return function () {
		return fn(swizzle$1(arguments));
	};
};

/* MIT license */

var colorNames = colorName;
var swizzle = simpleSwizzle.exports;
var hasOwnProperty = Object.hasOwnProperty;

var reverseNames = {};

// create a list of reverse color names
for (var name in colorNames) {
	if (hasOwnProperty.call(colorNames, name)) {
		reverseNames[colorNames[name]] = name;
	}
}

var cs = {
	to: {},
	get: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
	var keyword = /^(\w+)$/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha, 16) / 255;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			if (match[5]) {
				rgb[3] = parseFloat(match[4]) * 0.01;
			} else {
				rgb[3] = parseFloat(match[4]);
			}
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			if (match[5]) {
				rgb[3] = parseFloat(match[4]) * 0.01;
			} else {
				rgb[3] = parseFloat(match[4]);
			}
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		if (!hasOwnProperty.call(colorNames, match[1])) {
			return null;
		}

		rgb = colorNames[match[1]];
		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function () {
	var rgba = swizzle(arguments);

	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function () {
	var rgba = swizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = swizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = swizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = swizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = Math.round(num).toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}

var utilities = {
    // Layout
    columns: [
        'columns-${static}',
        'columns-${float}',
        'columns-${size}',
        'columns-${int}xl',
    ],
    container: [
        'container',
    ],
    objectPosition: [
        'object-${static}',
    ],
    inset: [
        'inset-${static}',
        'inset-${float}',
        'inset-${fraction}',
        'inset-${size}',
        'inset-y-${static}',
        'inset-y-${float}',
        'inset-y-${fraction}',
        'inset-y-${size}',
        'inset-x-${static}',
        'inset-x-${float}',
        'inset-x-${fraction}',
        'inset-x-${size}',
        'top-${static}',
        'top-${float}',
        'top-${fraction}',
        'top-${size}',
        'right-${static}',
        'right-${float}',
        'right-${fraction}',
        'right-${size}',
        'bottom-${static}',
        'bottom-${float}',
        'bottom-${fraction}',
        'bottom-${size}',
        'left-${static}',
        'left-${float}',
        'left-${fraction}',
        'left-${size}',
    ],
    zIndex: [
        'z-${static}',
        'z-${int}',
    ],
    // Flexbox
    flex: [
        'flex-${static}',
    ],
    flexGrow: [
        'flex-grow-${static}',
    ],
    flexShrink: [
        'flex-shrink-${static}',
    ],
    order: [
        'order-${static}',
        'order-${int}',
    ],
    // Grid
    gridTemplateColumns: [
        'grid-cols-${static}',
        'grid-cols-${int}',
    ],
    gridTemplateRows: [
        'grid-rows-${static}',
        'grid-rows-${int}',
    ],
    gridColumn: [
        'col-${static}',
        'col-span-${int}',
    ],
    gridColumnEnd: [
        'col-end-${static}',
        'col-end-${int}',
    ],
    gridColumnStart: [
        'col-start-${static}',
        'col-start-${int}',
    ],
    gridRow: [
        'row-${static}',
        'row-span-${int}',
    ],
    gridRowEnd: [
        'row-end-${static}',
        'row-end-${int}',
    ],
    gridRowStart: [
        'row-start-${static}',
        'row-start-${int}',
    ],
    gap: [
        'gap-${static}',
        'gap-x-${static}',
        'gap-y-${static}',
        'gap-${float}',
        'gap-x-${float}',
        'gap-y-${float}',
        'gap-${size}',
        'gap-x-${size}',
        'gap-y-${size}',
    ],
    // Box Alignment
    // Spacing
    padding: [
        'p-${static}',
        'py-${static}',
        'px-${static}',
        'pt-${static}',
        'pr-${static}',
        'pb-${static}',
        'pl-${static}',
        'p-${float}',
        'py-${float}',
        'px-${float}',
        'pt-${float}',
        'pr-${float}',
        'pb-${float}',
        'pl-${float}',
        'p-${size}',
        'py-${size}',
        'px-${size}',
        'pt-${size}',
        'pr-${size}',
        'pb-${size}',
        'pl-${size}',
    ],
    margin: [
        'm-${static}',
        'my-${static}',
        'mx-${static}',
        'mt-${static}',
        'mr-${static}',
        'mb-${static}',
        'ml-${static}',
        'm-${float}',
        'my-${float}',
        'mx-${float}',
        'mt-${float}',
        'mr-${float}',
        'mb-${float}',
        'ml-${float}',
        'm-${size}',
        'my-${size}',
        'mx-${size}',
        'mt-${size}',
        'mr-${size}',
        'mb-${size}',
        'ml-${size}',
    ],
    space: [
        'space-y-${static}',
        'space-y-reverse',
        'space-x-${static}',
        'space-x-reverse',
        'space-y-${float}',
        'space-x-${float}',
    ],
    width: [
        'w-${static}',
        'w-${float}',
        'w-${fraction}',
        'w-${int}xl',
        'w-${size}',
    ],
    minWidth: [
        'min-w-${static}',
        'min-w-${float}',
        'min-w-${fraction}',
        'min-w-${int}xl',
        'min-w-${size}',
    ],
    maxWidth: [
        'max-w-${static}',
        'max-w-${float}',
        'max-w-${fraction}',
        'max-w-${int}xl',
        'max-w-${size}',
    ],
    height: [
        'h-${static}',
        'h-${float}',
        'h-${fraction}',
        'h-${int}xl',
        'h-${size}',
    ],
    minHeight: [
        'min-h-${static}',
        'min-h-${float}',
        'min-h-${fraction}',
        'min-h-${int}xl',
        'min-h-${size}',
    ],
    maxHeight: [
        'max-h-${static}',
        'max-h-${float}',
        'max-h-${fraction}',
        'max-h-${int}xl',
        'max-h-${size}',
    ],
    // Typography
    fontSize: [
        'text-${static}',
        'text-${int}xl',
    ],
    textOpacity: [
        'text-opacity-${static}',
        'text-opacity-${int<=100}',
    ],
    textColor: [
        'text-${color}',
    ],
    fontFamily: [
        'font-${static}',
    ],
    fontWeight: [
        'font-${static}',
        'font-${int}',
    ],
    letterSpacing: [
        'tracking-${static}',
        'tracking-${size}',
    ],
    lineHeight: [
        'leading-${static}',
        'leading-${int}',
        'leading-${size}',
    ],
    listStyleType: [
        'list-${static}',
    ],
    placeholderColor: [
        'placeholder-${color}',
    ],
    placeholderOpacity: [
        'placeholder-opacity-${static}',
        'placeholder-opacity-${int<=100}',
    ],
    // Backgrounds
    backgroundColor: [
        'bg-${color}',
    ],
    backgroundOpacity: [
        'bg-opacity-${static}',
        'bg-opacity-${int<=100}',
    ],
    backgroundPosition: [
        'bg-${static}',
    ],
    backgroundSize: [
        'bg-${static}',
    ],
    backgroundImage: [
        'bg-${static}',
    ],
    gradientColorStops: [
        'from-${color}',
        'via-${color}',
        'to-${color}',
    ],
    // Borders
    borderRadius: [
        'rounded-${static}',
        'rounded-t-${static}',
        'rounded-l-${static}',
        'rounded-r-${static}',
        'rounded-b-${static}',
        'rounded-tl-${static}',
        'rounded-tr-${static}',
        'rounded-br-${static}',
        'rounded-bl-${static}',
        'rounded-${int}xl',
        'rounded-${size}',
        'rounded-t-${int}xl',
        'rounded-t-${size}',
        'rounded-l-${int}xl',
        'rounded-l-${size}',
        'rounded-r-${int}xl',
        'rounded-r-${size}',
        'rounded-b-${int}xl',
        'rounded-b-${size}',
        'rounded-tl-${int}xl',
        'rounded-tl-${size}',
        'rounded-tr-${int}xl',
        'rounded-tr-${size}',
        'rounded-br-${int}xl',
        'rounded-br-${size}',
        'rounded-bl-${int}xl',
        'rounded-bl-${size}',
    ],
    borderWidth: [
        'border-${static}',
        'border-${int}',
        'border-${size}',
        'border-t-${int}',
        'border-t-${size}',
        'border-r-${int}',
        'border-r-${size}',
        'border-b-${int}',
        'border-b-${size}',
        'border-l-${int}',
        'border-l-${size}',
        'border-x-${int}',
        'border-x-${size}',
        'border-y-${int}',
        'border-y-${size}',
    ],
    borderColor: [
        'border-${color}',
    ],
    borderOpacity: [
        'border-opacity-${static}',
        'border-opacity-${int<=100}',
    ],
    divideWidth: [
        'divide-y-reverse',
        'divide-x-reverse',
        'divide-y-${int}',
        'divide-x-${int}',
    ],
    divideColor: [
        'divide-${color}',
    ],
    divideOpacity: [
        'divide-${static}',
        'divide-opacity-${int<=100}',
    ],
    ringOffsetWidth: [
        'ring-offset-${static}',
        'ring-offset-${int}',
    ],
    ringOffsetColor: [
        'ring-offset-${color}',
    ],
    ringWidth: [
        'ring-${static}',
        'ring-${int}',
    ],
    ringColor: [
        'ring-${color}',
    ],
    ringOpacity: [
        'ring-${static}',
        'ring-opacity-${int<=100}',
    ],
    // Effects
    boxShadow: [
        'shadow-${static}',
    ],
    opacity: [
        'opacity-${static}',
        'opacity-${int<=100}',
    ],
    transition: [
        'transition-${static}',
    ],
    transitionDuration: [
        'duration-${static}',
        'duration-${int}',
    ],
    transitionTimingFunction: [
        'ease-${static}',
    ],
    transitionDelay: [
        'delay-${static}',
        'delay-${int}',
    ],
    animation: [
        'animate-${static}',
    ],
    // Transforms
    transformOrigin: [
        'origin-${static}',
    ],
    scale: [
        'scale-${static}',
        'scale-${int}',
        'scale-x-${static}',
        'scale-x-${int}',
        'scale-y-${static}',
        'scale-y-${int}',
    ],
    rotate: [
        'rotate-${static}',
        'rotate-${float}',
    ],
    translate: [
        'translate-${static}',
        'translate-x-${static}',
        'translate-y-${static}',
        'translate-x-${float}',
        'translate-x-${fraction}',
        'translate-x-${size}',
        'translate-y-${float}',
        'translate-y-${fraction}',
        'translate-y-${size}',
    ],
    skew: [
        'skew-x-${static}',
        'skew-x-${float}',
        'skew-y-${static}',
        'skew-y-${float}',
    ],
    cursor: [
        'cursor-${static}',
    ],
    // Interactivity
    outline: [
        'outline-${static}',
        'outline-${color}',
    ],
    // SVG
    fill: [
        'fill-${color}',
    ],
    // Stroke
    stroke: [
        'stroke-${color}',
    ],
    strokeWidth: [
        'stroke-${int}',
    ],
    // Plugins
    typography: [
        'prose-sm',
        'prose',
        'prose-lg',
        'prose-xl',
        'prose-2xl',
        'prose-red',
        'prose-yellow',
        'prose-green',
        'prose-blue',
        'prose-indigo',
        'prose-purple',
        'prose-pink',
    ],
    aspectRatio: [
        'aspect-none',
        'aspect-auto',
        'aspect-square',
        'aspect-video',
        'aspect-w-${float}',
        'aspect-h-${float}',
        'aspect-${fraction}',
    ],
    lineClamp: [
        'line-clamp-none',
        'line-clamp-${int}',
    ],
    filter: [
        'filter-${static}',
    ],
    backdropFilter: [
        'backdrop-${static}',
    ],
    basis: [
        'basis-${static}',
        'basis-${float}',
        'basis-${size}',
        'basis-${fraction}',
    ],
    blur: [
        'blur-${static}',
        'blur-${float}',
        'blur-${size}',
    ],
    willChange: [
        'will-change-auto',
        'will-change-scroll',
        'will-change-contents',
        'will-change-transform',
    ],
    touchAction: [
        'touch-auto',
        'touch-none',
        'touch-pan-x',
        'touch-pan-left',
        'touch-pan-right',
        'touch-pan-y',
        'touch-pan-up',
        'touch-pan-down',
        'touch-pinch-zoom',
        'touch-manipulation',
    ],
    scrollBehavior: [
        'scroll-auto',
        'scroll-smooth',
    ],
    shadow: [
        'shadow-${static}',
    ],
};
var negative = {
    inset: true,
    zIndex: true,
    order: true,
    margin: true,
    space: true,
    letterSpacing: true,
    rotate: true,
    translate: true,
    skew: true,
};
function generateCompletions(processor) {
    var completions = { static: [], color: [], dynamic: [] };
    var colors = flatColors$1(processor.theme('colors'));
    var _loop_1 = function (config, list) {
        list.forEach(function (utility) {
            var mark = utility.search(/\$/);
            if (mark === -1) {
                completions.static.push(utility);
            }
            else {
                var prefix_1 = utility.slice(0, mark - 1);
                var suffix = utility.slice(mark);
                switch (suffix) {
                    case '${static}':
                        completions.static = completions.static.concat(Object.keys(processor.theme(config, {})).map(function (i) { return i === 'DEFAULT' ? prefix_1 : i.charAt(0) === '-' ? "-".concat(prefix_1).concat(i) : "".concat(prefix_1, "-").concat(i); }));
                        break;
                    case '${color}':
                        for (var _i = 0, _a = Object.keys(flatColors$1(processor.theme(config, colors))); _i < _a.length; _i++) {
                            var key = _a[_i];
                            if (key !== 'DEFAULT')
                                completions.color.push("".concat(prefix_1, "-").concat(key));
                        }
                        break;
                    default:
                        completions.dynamic.push(utility);
                        if (config in negative)
                            completions.dynamic.push("-".concat(utility));
                        break;
                }
            }
        });
    };
    for (var _i = 0, _a = Object.entries(utilities); _i < _a.length; _i++) {
        var _b = _a[_i], config = _b[0], list = _b[1];
        _loop_1(config, list);
    }
    return completions;
}

// src/math.ts

// src/array.ts
function toArray(array) {
  array = array || [];
  if (Array.isArray(array))
    return array;
  return [array];
}
function partition(array, ...filters) {
  const result = new Array(filters.length + 1).fill(null).map(() => []);
  array.forEach((e, idx, arr) => {
    let i = 0;
    for (const filter of filters) {
      if (filter(e, idx, arr)) {
        result[i].push(e);
        return;
      }
      i += 1;
    }
    result[i].push(e);
  });
  return result;
}

// src/string.ts
function slash$1(str) {
  return str.replace(/\\/g, "/");
}

// src/promise.ts
function createSingletonPromise(fn) {
  let _promise;
  function wrapper() {
    if (!_promise)
      _promise = fn();
    return _promise;
  }
  wrapper.reset = async () => {
    const _prev = _promise;
    _promise = void 0;
    if (_prev)
      await _prev;
  };
  return wrapper;
}

var tasks = {};

var utils$m = {};

var array$1 = {};

Object.defineProperty(array$1, "__esModule", { value: true });
array$1.splitWhen = array$1.flatten = void 0;
function flatten(items) {
    return items.reduce((collection, item) => [].concat(collection, item), []);
}
array$1.flatten = flatten;
function splitWhen(items, predicate) {
    const result = [[]];
    let groupIndex = 0;
    for (const item of items) {
        if (predicate(item)) {
            groupIndex++;
            result[groupIndex] = [];
        }
        else {
            result[groupIndex].push(item);
        }
    }
    return result;
}
array$1.splitWhen = splitWhen;

var errno$1 = {};

Object.defineProperty(errno$1, "__esModule", { value: true });
errno$1.isEnoentCodeError = void 0;
function isEnoentCodeError(error) {
    return error.code === 'ENOENT';
}
errno$1.isEnoentCodeError = isEnoentCodeError;

var fs$q = {};

Object.defineProperty(fs$q, "__esModule", { value: true });
fs$q.createDirentFromStats = void 0;
class DirentFromStats$1 {
    constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
}
function createDirentFromStats$1(name, stats) {
    return new DirentFromStats$1(name, stats);
}
fs$q.createDirentFromStats = createDirentFromStats$1;

var path$m = {};

Object.defineProperty(path$m, "__esModule", { value: true });
path$m.removeLeadingDotSegment = path$m.escape = path$m.makeAbsolute = path$m.unixify = void 0;
const path$l = require$$0__default$1["default"];
const LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2; // ./ or .\\
const UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
/**
 * Designed to work only with simple paths: `dir\\file`.
 */
function unixify(filepath) {
    return filepath.replace(/\\/g, '/');
}
path$m.unixify = unixify;
function makeAbsolute(cwd, filepath) {
    return path$l.resolve(cwd, filepath);
}
path$m.makeAbsolute = makeAbsolute;
function escape(pattern) {
    return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, '\\$2');
}
path$m.escape = escape;
function removeLeadingDotSegment(entry) {
    // We do not use `startsWith` because this is 10x slower than current implementation for some cases.
    // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
    if (entry.charAt(0) === '.') {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === '/' || secondCharactery === '\\') {
            return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
    }
    return entry;
}
path$m.removeLeadingDotSegment = removeLeadingDotSegment;

var pattern$1 = {};

/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

var isExtglob$1 = function isExtglob(str) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  var match;
  while ((match = /(\\).|([@?!+*]\(.*\))/g.exec(str))) {
    if (match[2]) return true;
    str = str.slice(match.index + match[0].length);
  }

  return false;
};

/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var isExtglob = isExtglob$1;
var chars$1 = { '{': '}', '(': ')', '[': ']'};
var strictCheck = function(str) {
  if (str[0] === '!') {
    return true;
  }
  var index = 0;
  var pipeIndex = -2;
  var closeSquareIndex = -2;
  var closeCurlyIndex = -2;
  var closeParenIndex = -2;
  var backSlashIndex = -2;
  while (index < str.length) {
    if (str[index] === '*') {
      return true;
    }

    if (str[index + 1] === '?' && /[\].+)]/.test(str[index])) {
      return true;
    }

    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {
      if (closeSquareIndex < index) {
        closeSquareIndex = str.indexOf(']', index);
      }
      if (closeSquareIndex > index) {
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
        backSlashIndex = str.indexOf('\\', index);
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
      }
    }

    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {
      closeCurlyIndex = str.indexOf('}', index);
      if (closeCurlyIndex > index) {
        backSlashIndex = str.indexOf('\\', index);
        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
          return true;
        }
      }
    }

    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {
      closeParenIndex = str.indexOf(')', index);
      if (closeParenIndex > index) {
        backSlashIndex = str.indexOf('\\', index);
        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
          return true;
        }
      }
    }

    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {
      if (pipeIndex < index) {
        pipeIndex = str.indexOf('|', index);
      }
      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {
        closeParenIndex = str.indexOf(')', pipeIndex);
        if (closeParenIndex > pipeIndex) {
          backSlashIndex = str.indexOf('\\', pipeIndex);
          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
            return true;
          }
        }
      }
    }

    if (str[index] === '\\') {
      var open = str[index + 1];
      index += 2;
      var close = chars$1[open];

      if (close) {
        var n = str.indexOf(close, index);
        if (n !== -1) {
          index = n + 1;
        }
      }

      if (str[index] === '!') {
        return true;
      }
    } else {
      index++;
    }
  }
  return false;
};

var relaxedCheck = function(str) {
  if (str[0] === '!') {
    return true;
  }
  var index = 0;
  while (index < str.length) {
    if (/[*?{}()[\]]/.test(str[index])) {
      return true;
    }

    if (str[index] === '\\') {
      var open = str[index + 1];
      index += 2;
      var close = chars$1[open];

      if (close) {
        var n = str.indexOf(close, index);
        if (n !== -1) {
          index = n + 1;
        }
      }

      if (str[index] === '!') {
        return true;
      }
    } else {
      index++;
    }
  }
  return false;
};

var isGlob$1 = function isGlob(str, options) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  if (isExtglob(str)) {
    return true;
  }

  var check = strictCheck;

  // optionally relax check
  if (options && options.strict === false) {
    check = relaxedCheck;
  }

  return check(str);
};

var isGlob = isGlob$1;
var pathPosixDirname = require$$0__default$1["default"].posix.dirname;
var isWin32 = require$$5__default["default"].platform() === 'win32';

var slash = '/';
var backslash = /\\/g;
var enclosure = /[\{\[].*[\}\]]$/;
var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;

/**
 * @param {string} str
 * @param {Object} opts
 * @param {boolean} [opts.flipBackslashes=true]
 * @returns {string}
 */
var globParent$1 = function globParent(str, opts) {
  var options = Object.assign({ flipBackslashes: true }, opts);

  // flip windows path separators
  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
    str = str.replace(backslash, slash);
  }

  // special case for strings ending in enclosure containing path separator
  if (enclosure.test(str)) {
    str += slash;
  }

  // preserves full path in case of trailing path separator
  str += 'a';

  // remove path parts that are globby
  do {
    str = pathPosixDirname(str);
  } while (isGlob(str) || globby.test(str));

  // remove escape chars and return result
  return str.replace(escaped, '$1');
};

var utils$l = {};

(function (exports) {

exports.isInteger = num => {
  if (typeof num === 'number') {
    return Number.isInteger(num);
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isInteger(Number(num));
  }
  return false;
};

/**
 * Find a node of the given type
 */

exports.find = (node, type) => node.nodes.find(node => node.type === type);

/**
 * Find a node of the given type
 */

exports.exceedsLimit = (min, max, step = 1, limit) => {
  if (limit === false) return false;
  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
  return ((Number(max) - Number(min)) / Number(step)) >= limit;
};

/**
 * Escape the given node with '\\' before node.value
 */

exports.escapeNode = (block, n = 0, type) => {
  let node = block.nodes[n];
  if (!node) return;

  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {
    if (node.escaped !== true) {
      node.value = '\\' + node.value;
      node.escaped = true;
    }
  }
};

/**
 * Returns true if the given brace node should be enclosed in literal braces
 */

exports.encloseBrace = node => {
  if (node.type !== 'brace') return false;
  if ((node.commas >> 0 + node.ranges >> 0) === 0) {
    node.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a brace node is invalid.
 */

exports.isInvalidBrace = block => {
  if (block.type !== 'brace') return false;
  if (block.invalid === true || block.dollar) return true;
  if ((block.commas >> 0 + block.ranges >> 0) === 0) {
    block.invalid = true;
    return true;
  }
  if (block.open !== true || block.close !== true) {
    block.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a node is an open or close node
 */

exports.isOpenOrClose = node => {
  if (node.type === 'open' || node.type === 'close') {
    return true;
  }
  return node.open === true || node.close === true;
};

/**
 * Reduce an array of text nodes.
 */

exports.reduce = nodes => nodes.reduce((acc, node) => {
  if (node.type === 'text') acc.push(node.value);
  if (node.type === 'range') node.type = 'text';
  return acc;
}, []);

/**
 * Flatten an array
 */

exports.flatten = (...args) => {
  const result = [];
  const flat = arr => {
    for (let i = 0; i < arr.length; i++) {
      let ele = arr[i];
      Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);
    }
    return result;
  };
  flat(args);
  return result;
};
}(utils$l));

const utils$k = utils$l;

var stringify$8 = (ast, options = {}) => {
  let stringify = (node, parent = {}) => {
    let invalidBlock = options.escapeInvalid && utils$k.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let output = '';

    if (node.value) {
      if ((invalidBlock || invalidNode) && utils$k.isOpenOrClose(node)) {
        return '\\' + node.value;
      }
      return node.value;
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += stringify(child);
      }
    }
    return output;
  };

  return stringify(ast);
};

/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */

var isNumber$2 = function(num) {
  if (typeof num === 'number') {
    return num - num === 0;
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }
  return false;
};

/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */

const isNumber$1 = isNumber$2;

const toRegexRange$1 = (min, max, options) => {
  if (isNumber$1(min) === false) {
    throw new TypeError('toRegexRange: expected the first argument to be a number');
  }

  if (max === void 0 || min === max) {
    return String(min);
  }

  if (isNumber$1(max) === false) {
    throw new TypeError('toRegexRange: expected the second argument to be a number.');
  }

  let opts = { relaxZeros: true, ...options };
  if (typeof opts.strictZeros === 'boolean') {
    opts.relaxZeros = opts.strictZeros === false;
  }

  let relax = String(opts.relaxZeros);
  let shorthand = String(opts.shorthand);
  let capture = String(opts.capture);
  let wrap = String(opts.wrap);
  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;

  if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {
    return toRegexRange$1.cache[cacheKey].result;
  }

  let a = Math.min(min, max);
  let b = Math.max(min, max);

  if (Math.abs(a - b) === 1) {
    let result = min + '|' + max;
    if (opts.capture) {
      return `(${result})`;
    }
    if (opts.wrap === false) {
      return result;
    }
    return `(?:${result})`;
  }

  let isPadded = hasPadding(min) || hasPadding(max);
  let state = { min, max, a, b };
  let positives = [];
  let negatives = [];

  if (isPadded) {
    state.isPadded = isPadded;
    state.maxLen = String(state.max).length;
  }

  if (a < 0) {
    let newMin = b < 0 ? Math.abs(b) : 1;
    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
    a = state.a = 0;
  }

  if (b >= 0) {
    positives = splitToPatterns(a, b, state, opts);
  }

  state.negatives = negatives;
  state.positives = positives;
  state.result = collatePatterns(negatives, positives);

  if (opts.capture === true) {
    state.result = `(${state.result})`;
  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {
    state.result = `(?:${state.result})`;
  }

  toRegexRange$1.cache[cacheKey] = state;
  return state.result;
};

function collatePatterns(neg, pos, options) {
  let onlyNegative = filterPatterns(neg, pos, '-', false) || [];
  let onlyPositive = filterPatterns(pos, neg, '', false) || [];
  let intersected = filterPatterns(neg, pos, '-?', true) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
}

function splitToRanges(min, max) {
  let nines = 1;
  let zeros = 1;

  let stop = countNines(min, nines);
  let stops = new Set([max]);

  while (min <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = countNines(min, nines);
  }

  stop = countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) {
    stops.add(stop);
    zeros += 1;
    stop = countZeros(max + 1, zeros) - 1;
  }

  stops = [...stops];
  stops.sort(compare);
  return stops;
}

/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */

function rangeToPattern(start, stop, options) {
  if (start === stop) {
    return { pattern: start, count: [], digits: 0 };
  }

  let zipped = zip(start, stop);
  let digits = zipped.length;
  let pattern = '';
  let count = 0;

  for (let i = 0; i < digits; i++) {
    let [startDigit, stopDigit] = zipped[i];

    if (startDigit === stopDigit) {
      pattern += startDigit;

    } else if (startDigit !== '0' || stopDigit !== '9') {
      pattern += toCharacterClass(startDigit, stopDigit);

    } else {
      count++;
    }
  }

  if (count) {
    pattern += options.shorthand === true ? '\\d' : '[0-9]';
  }

  return { pattern, count: [count], digits };
}

function splitToPatterns(min, max, tok, options) {
  let ranges = splitToRanges(min, max);
  let tokens = [];
  let start = min;
  let prev;

  for (let i = 0; i < ranges.length; i++) {
    let max = ranges[i];
    let obj = rangeToPattern(String(start), String(max), options);
    let zeros = '';

    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }

      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start = max + 1;
      continue;
    }

    if (tok.isPadded) {
      zeros = padZeros(max, tok, options);
    }

    obj.string = zeros + obj.pattern + toQuantifier(obj.count);
    tokens.push(obj);
    start = max + 1;
    prev = obj;
  }

  return tokens;
}

function filterPatterns(arr, comparison, prefix, intersection, options) {
  let result = [];

  for (let ele of arr) {
    let { string } = ele;

    // only push if _both_ are negative...
    if (!intersection && !contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }

    // or _both_ are positive
    if (intersection && contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }
  }
  return result;
}

/**
 * Zip strings
 */

function zip(a, b) {
  let arr = [];
  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
  return arr;
}

function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}

function contains(arr, key, val) {
  return arr.some(ele => ele[key] === val);
}

function countNines(min, len) {
  return Number(String(min).slice(0, -len) + '9'.repeat(len));
}

function countZeros(integer, zeros) {
  return integer - (integer % Math.pow(10, zeros));
}

function toQuantifier(digits) {
  let [start = 0, stop = ''] = digits;
  if (stop || start > 1) {
    return `{${start + (stop ? ',' + stop : '')}}`;
  }
  return '';
}

function toCharacterClass(a, b, options) {
  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;
}

function hasPadding(str) {
  return /^-?(0+)\d/.test(str);
}

function padZeros(value, tok, options) {
  if (!tok.isPadded) {
    return value;
  }

  let diff = Math.abs(tok.maxLen - String(value).length);
  let relax = options.relaxZeros !== false;

  switch (diff) {
    case 0:
      return '';
    case 1:
      return relax ? '0?' : '0';
    case 2:
      return relax ? '0{0,2}' : '00';
    default: {
      return relax ? `0{0,${diff}}` : `0{${diff}}`;
    }
  }
}

/**
 * Cache
 */

toRegexRange$1.cache = {};
toRegexRange$1.clearCache = () => (toRegexRange$1.cache = {});

/**
 * Expose `toRegexRange`
 */

var toRegexRange_1 = toRegexRange$1;

/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */

const util$3 = require$$1__default["default"];
const toRegexRange = toRegexRange_1;

const isObject$3 = val => val !== null && typeof val === 'object' && !Array.isArray(val);

const transform$1 = toNumber => {
  return value => toNumber === true ? Number(value) : String(value);
};

const isValidValue = value => {
  return typeof value === 'number' || (typeof value === 'string' && value !== '');
};

const isNumber = num => Number.isInteger(+num);

const zeros = input => {
  let value = `${input}`;
  let index = -1;
  if (value[0] === '-') value = value.slice(1);
  if (value === '0') return false;
  while (value[++index] === '0');
  return index > 0;
};

const stringify$7 = (start, end, options) => {
  if (typeof start === 'string' || typeof end === 'string') {
    return true;
  }
  return options.stringify === true;
};

const pad = (input, maxLength, toNumber) => {
  if (maxLength > 0) {
    let dash = input[0] === '-' ? '-' : '';
    if (dash) input = input.slice(1);
    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));
  }
  if (toNumber === false) {
    return String(input);
  }
  return input;
};

const toMaxLen = (input, maxLength) => {
  let negative = input[0] === '-' ? '-' : '';
  if (negative) {
    input = input.slice(1);
    maxLength--;
  }
  while (input.length < maxLength) input = '0' + input;
  return negative ? ('-' + input) : input;
};

const toSequence = (parts, options) => {
  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);

  let prefix = options.capture ? '' : '?:';
  let positives = '';
  let negatives = '';
  let result;

  if (parts.positives.length) {
    positives = parts.positives.join('|');
  }

  if (parts.negatives.length) {
    negatives = `-(${prefix}${parts.negatives.join('|')})`;
  }

  if (positives && negatives) {
    result = `${positives}|${negatives}`;
  } else {
    result = positives || negatives;
  }

  if (options.wrap) {
    return `(${prefix}${result})`;
  }

  return result;
};

const toRange = (a, b, isNumbers, options) => {
  if (isNumbers) {
    return toRegexRange(a, b, { wrap: false, ...options });
  }

  let start = String.fromCharCode(a);
  if (a === b) return start;

  let stop = String.fromCharCode(b);
  return `[${start}-${stop}]`;
};

const toRegex = (start, end, options) => {
  if (Array.isArray(start)) {
    let wrap = options.wrap === true;
    let prefix = options.capture ? '' : '?:';
    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');
  }
  return toRegexRange(start, end, options);
};

const rangeError = (...args) => {
  return new RangeError('Invalid range arguments: ' + util$3.inspect(...args));
};

const invalidRange = (start, end, options) => {
  if (options.strictRanges === true) throw rangeError([start, end]);
  return [];
};

const invalidStep = (step, options) => {
  if (options.strictRanges === true) {
    throw new TypeError(`Expected step "${step}" to be a number`);
  }
  return [];
};

const fillNumbers = (start, end, step = 1, options = {}) => {
  let a = Number(start);
  let b = Number(end);

  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    if (options.strictRanges === true) throw rangeError([start, end]);
    return [];
  }

  // fix negative zero
  if (a === 0) a = 0;
  if (b === 0) b = 0;

  let descending = a > b;
  let startString = String(start);
  let endString = String(end);
  let stepString = String(step);
  step = Math.max(Math.abs(step), 1);

  let padded = zeros(startString) || zeros(endString) || zeros(stepString);
  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  let toNumber = padded === false && stringify$7(start, end, options) === false;
  let format = options.transform || transform$1(toNumber);

  if (options.toRegex && step === 1) {
    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
  }

  let parts = { negatives: [], positives: [] };
  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    if (options.toRegex === true && step > 1) {
      push(a);
    } else {
      range.push(pad(format(a, index), maxLen, toNumber));
    }
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return step > 1
      ? toSequence(parts, options)
      : toRegex(range, null, { wrap: false, ...options });
  }

  return range;
};

const fillLetters = (start, end, step = 1, options = {}) => {
  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {
    return invalidRange(start, end, options);
  }


  let format = options.transform || (val => String.fromCharCode(val));
  let a = `${start}`.charCodeAt(0);
  let b = `${end}`.charCodeAt(0);

  let descending = a > b;
  let min = Math.min(a, b);
  let max = Math.max(a, b);

  if (options.toRegex && step === 1) {
    return toRange(min, max, false, options);
  }

  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    range.push(format(a, index));
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return toRegex(range, null, { wrap: false, options });
  }

  return range;
};

const fill$2 = (start, end, step, options = {}) => {
  if (end == null && isValidValue(start)) {
    return [start];
  }

  if (!isValidValue(start) || !isValidValue(end)) {
    return invalidRange(start, end, options);
  }

  if (typeof step === 'function') {
    return fill$2(start, end, 1, { transform: step });
  }

  if (isObject$3(step)) {
    return fill$2(start, end, 0, step);
  }

  let opts = { ...options };
  if (opts.capture === true) opts.wrap = true;
  step = step || opts.step || 1;

  if (!isNumber(step)) {
    if (step != null && !isObject$3(step)) return invalidStep(step, opts);
    return fill$2(start, end, 1, step);
  }

  if (isNumber(start) && isNumber(end)) {
    return fillNumbers(start, end, step, opts);
  }

  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};

var fillRange = fill$2;

const fill$1 = fillRange;
const utils$j = utils$l;

const compile$1 = (ast, options = {}) => {
  let walk = (node, parent = {}) => {
    let invalidBlock = utils$j.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let invalid = invalidBlock === true || invalidNode === true;
    let prefix = options.escapeInvalid === true ? '\\' : '';
    let output = '';

    if (node.isOpen === true) {
      return prefix + node.value;
    }
    if (node.isClose === true) {
      return prefix + node.value;
    }

    if (node.type === 'open') {
      return invalid ? (prefix + node.value) : '(';
    }

    if (node.type === 'close') {
      return invalid ? (prefix + node.value) : ')';
    }

    if (node.type === 'comma') {
      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes && node.ranges > 0) {
      let args = utils$j.reduce(node.nodes);
      let range = fill$1(...args, { ...options, wrap: false, toRegex: true });

      if (range.length !== 0) {
        return args.length > 1 && range.length > 1 ? `(${range})` : range;
      }
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += walk(child, node);
      }
    }
    return output;
  };

  return walk(ast);
};

var compile_1 = compile$1;

const fill = fillRange;
const stringify$6 = stringify$8;
const utils$i = utils$l;

const append = (queue = '', stash = '', enclose = false) => {
  let result = [];

  queue = [].concat(queue);
  stash = [].concat(stash);

  if (!stash.length) return queue;
  if (!queue.length) {
    return enclose ? utils$i.flatten(stash).map(ele => `{${ele}}`) : stash;
  }

  for (let item of queue) {
    if (Array.isArray(item)) {
      for (let value of item) {
        result.push(append(value, stash, enclose));
      }
    } else {
      for (let ele of stash) {
        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;
        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));
      }
    }
  }
  return utils$i.flatten(result);
};

const expand$1 = (ast, options = {}) => {
  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;

  let walk = (node, parent = {}) => {
    node.queue = [];

    let p = parent;
    let q = parent.queue;

    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
      p = p.parent;
      q = p.queue;
    }

    if (node.invalid || node.dollar) {
      q.push(append(q.pop(), stringify$6(node, options)));
      return;
    }

    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
      q.push(append(q.pop(), ['{}']));
      return;
    }

    if (node.nodes && node.ranges > 0) {
      let args = utils$i.reduce(node.nodes);

      if (utils$i.exceedsLimit(...args, options.step, rangeLimit)) {
        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
      }

      let range = fill(...args, options);
      if (range.length === 0) {
        range = stringify$6(node, options);
      }

      q.push(append(q.pop(), range));
      node.nodes = [];
      return;
    }

    let enclose = utils$i.encloseBrace(node);
    let queue = node.queue;
    let block = node;

    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {
      block = block.parent;
      queue = block.queue;
    }

    for (let i = 0; i < node.nodes.length; i++) {
      let child = node.nodes[i];

      if (child.type === 'comma' && node.type === 'brace') {
        if (i === 1) queue.push('');
        queue.push('');
        continue;
      }

      if (child.type === 'close') {
        q.push(append(q.pop(), queue, enclose));
        continue;
      }

      if (child.value && child.type !== 'open') {
        queue.push(append(queue.pop(), child.value));
        continue;
      }

      if (child.nodes) {
        walk(child, node);
      }
    }

    return queue;
  };

  return utils$i.flatten(walk(ast));
};

var expand_1 = expand$1;

var constants$5 = {
  MAX_LENGTH: 1024 * 64,

  // Digits
  CHAR_0: '0', /* 0 */
  CHAR_9: '9', /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 'A', /* A */
  CHAR_LOWERCASE_A: 'a', /* a */
  CHAR_UPPERCASE_Z: 'Z', /* Z */
  CHAR_LOWERCASE_Z: 'z', /* z */

  CHAR_LEFT_PARENTHESES: '(', /* ( */
  CHAR_RIGHT_PARENTHESES: ')', /* ) */

  CHAR_ASTERISK: '*', /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: '&', /* & */
  CHAR_AT: '@', /* @ */
  CHAR_BACKSLASH: '\\', /* \ */
  CHAR_BACKTICK: '`', /* ` */
  CHAR_CARRIAGE_RETURN: '\r', /* \r */
  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */
  CHAR_COLON: ':', /* : */
  CHAR_COMMA: ',', /* , */
  CHAR_DOLLAR: '$', /* . */
  CHAR_DOT: '.', /* . */
  CHAR_DOUBLE_QUOTE: '"', /* " */
  CHAR_EQUAL: '=', /* = */
  CHAR_EXCLAMATION_MARK: '!', /* ! */
  CHAR_FORM_FEED: '\f', /* \f */
  CHAR_FORWARD_SLASH: '/', /* / */
  CHAR_HASH: '#', /* # */
  CHAR_HYPHEN_MINUS: '-', /* - */
  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */
  CHAR_LEFT_CURLY_BRACE: '{', /* { */
  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */
  CHAR_LINE_FEED: '\n', /* \n */
  CHAR_NO_BREAK_SPACE: '\u00A0', /* \u00A0 */
  CHAR_PERCENT: '%', /* % */
  CHAR_PLUS: '+', /* + */
  CHAR_QUESTION_MARK: '?', /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */
  CHAR_RIGHT_CURLY_BRACE: '}', /* } */
  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */
  CHAR_SEMICOLON: ';', /* ; */
  CHAR_SINGLE_QUOTE: '\'', /* ' */
  CHAR_SPACE: ' ', /*   */
  CHAR_TAB: '\t', /* \t */
  CHAR_UNDERSCORE: '_', /* _ */
  CHAR_VERTICAL_LINE: '|', /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF' /* \uFEFF */
};

const stringify$5 = stringify$8;

/**
 * Constants
 */

const {
  MAX_LENGTH: MAX_LENGTH$1,
  CHAR_BACKSLASH, /* \ */
  CHAR_BACKTICK, /* ` */
  CHAR_COMMA: CHAR_COMMA$1, /* , */
  CHAR_DOT: CHAR_DOT$1, /* . */
  CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1, /* ( */
  CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1, /* ) */
  CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1, /* { */
  CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1, /* } */
  CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1, /* [ */
  CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1, /* ] */
  CHAR_DOUBLE_QUOTE, /* " */
  CHAR_SINGLE_QUOTE, /* ' */
  CHAR_NO_BREAK_SPACE,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE
} = constants$5;

/**
 * parse
 */

const parse$7 = (input, options = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  let opts = options || {};
  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;
  if (input.length > max) {
    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
  }

  let ast = { type: 'root', input, nodes: [] };
  let stack = [ast];
  let block = ast;
  let prev = ast;
  let brackets = 0;
  let length = input.length;
  let index = 0;
  let depth = 0;
  let value;

  /**
   * Helpers
   */

  const advance = () => input[index++];
  const push = node => {
    if (node.type === 'text' && prev.type === 'dot') {
      prev.type = 'text';
    }

    if (prev && prev.type === 'text' && node.type === 'text') {
      prev.value += node.value;
      return;
    }

    block.nodes.push(node);
    node.parent = block;
    node.prev = prev;
    prev = node;
    return node;
  };

  push({ type: 'bos' });

  while (index < length) {
    block = stack[stack.length - 1];
    value = advance();

    /**
     * Invalid chars
     */

    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
      continue;
    }

    /**
     * Escaped chars
     */

    if (value === CHAR_BACKSLASH) {
      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });
      continue;
    }

    /**
     * Right square bracket (literal): ']'
     */

    if (value === CHAR_RIGHT_SQUARE_BRACKET$1) {
      push({ type: 'text', value: '\\' + value });
      continue;
    }

    /**
     * Left square bracket: '['
     */

    if (value === CHAR_LEFT_SQUARE_BRACKET$1) {
      brackets++;
      let next;

      while (index < length && (next = advance())) {
        value += next;

        if (next === CHAR_LEFT_SQUARE_BRACKET$1) {
          brackets++;
          continue;
        }

        if (next === CHAR_BACKSLASH) {
          value += advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET$1) {
          brackets--;

          if (brackets === 0) {
            break;
          }
        }
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Parentheses
     */

    if (value === CHAR_LEFT_PARENTHESES$1) {
      block = push({ type: 'paren', nodes: [] });
      stack.push(block);
      push({ type: 'text', value });
      continue;
    }

    if (value === CHAR_RIGHT_PARENTHESES$1) {
      if (block.type !== 'paren') {
        push({ type: 'text', value });
        continue;
      }
      block = stack.pop();
      push({ type: 'text', value });
      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Quotes: '|"|`
     */

    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
      let open = value;
      let next;

      if (options.keepQuotes !== true) {
        value = '';
      }

      while (index < length && (next = advance())) {
        if (next === CHAR_BACKSLASH) {
          value += next + advance();
          continue;
        }

        if (next === open) {
          if (options.keepQuotes === true) value += next;
          break;
        }

        value += next;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Left curly brace: '{'
     */

    if (value === CHAR_LEFT_CURLY_BRACE$1) {
      depth++;

      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
      let brace = {
        type: 'brace',
        open: true,
        close: false,
        dollar,
        depth,
        commas: 0,
        ranges: 0,
        nodes: []
      };

      block = push(brace);
      stack.push(block);
      push({ type: 'open', value });
      continue;
    }

    /**
     * Right curly brace: '}'
     */

    if (value === CHAR_RIGHT_CURLY_BRACE$1) {
      if (block.type !== 'brace') {
        push({ type: 'text', value });
        continue;
      }

      let type = 'close';
      block = stack.pop();
      block.close = true;

      push({ type, value });
      depth--;

      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Comma: ','
     */

    if (value === CHAR_COMMA$1 && depth > 0) {
      if (block.ranges > 0) {
        block.ranges = 0;
        let open = block.nodes.shift();
        block.nodes = [open, { type: 'text', value: stringify$5(block) }];
      }

      push({ type: 'comma', value });
      block.commas++;
      continue;
    }

    /**
     * Dot: '.'
     */

    if (value === CHAR_DOT$1 && depth > 0 && block.commas === 0) {
      let siblings = block.nodes;

      if (depth === 0 || siblings.length === 0) {
        push({ type: 'text', value });
        continue;
      }

      if (prev.type === 'dot') {
        block.range = [];
        prev.value += value;
        prev.type = 'range';

        if (block.nodes.length !== 3 && block.nodes.length !== 5) {
          block.invalid = true;
          block.ranges = 0;
          prev.type = 'text';
          continue;
        }

        block.ranges++;
        block.args = [];
        continue;
      }

      if (prev.type === 'range') {
        siblings.pop();

        let before = siblings[siblings.length - 1];
        before.value += prev.value + value;
        prev = before;
        block.ranges--;
        continue;
      }

      push({ type: 'dot', value });
      continue;
    }

    /**
     * Text
     */

    push({ type: 'text', value });
  }

  // Mark imbalanced braces and brackets as invalid
  do {
    block = stack.pop();

    if (block.type !== 'root') {
      block.nodes.forEach(node => {
        if (!node.nodes) {
          if (node.type === 'open') node.isOpen = true;
          if (node.type === 'close') node.isClose = true;
          if (!node.nodes) node.type = 'text';
          node.invalid = true;
        }
      });

      // get the location of the block on parent.nodes (block's siblings)
      let parent = stack[stack.length - 1];
      let index = parent.nodes.indexOf(block);
      // replace the (invalid) block with it's nodes
      parent.nodes.splice(index, 1, ...block.nodes);
    }
  } while (stack.length > 0);

  push({ type: 'eos' });
  return ast;
};

var parse_1$1 = parse$7;

const stringify$4 = stringify$8;
const compile = compile_1;
const expand = expand_1;
const parse$6 = parse_1$1;

/**
 * Expand the given pattern or create a regex-compatible string.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
 * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

const braces$1 = (input, options = {}) => {
  let output = [];

  if (Array.isArray(input)) {
    for (let pattern of input) {
      let result = braces$1.create(pattern, options);
      if (Array.isArray(result)) {
        output.push(...result);
      } else {
        output.push(result);
      }
    }
  } else {
    output = [].concat(braces$1.create(input, options));
  }

  if (options && options.expand === true && options.nodupes === true) {
    output = [...new Set(output)];
  }
  return output;
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * ```
 * @param {String} pattern Brace pattern to parse
 * @param {Object} options
 * @return {Object} Returns an AST
 * @api public
 */

braces$1.parse = (input, options = {}) => parse$6(input, options);

/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/{a,b}/bar');
 * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces$1.stringify = (input, options = {}) => {
  if (typeof input === 'string') {
    return stringify$4(braces$1.parse(input, options), options);
  }
  return stringify$4(input, options);
};

/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces$1.compile = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces$1.parse(input, options);
  }
  return compile(input, options);
};

/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces$1.expand = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces$1.parse(input, options);
  }

  let result = expand(input, options);

  // filter out empty strings if specified
  if (options.noempty === true) {
    result = result.filter(Boolean);
  }

  // filter out duplicates if specified
  if (options.nodupes === true) {
    result = [...new Set(result)];
  }

  return result;
};

/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces$1.create = (input, options = {}) => {
  if (input === '' || input.length < 3) {
    return [input];
  }

 return options.expand !== true
    ? braces$1.compile(input, options)
    : braces$1.expand(input, options);
};

/**
 * Expose "braces"
 */

var braces_1 = braces$1;

var utils$h = {};

const path$k = require$$0__default$1["default"];
const WIN_SLASH = '\\\\/';
const WIN_NO_SLASH = `[^${WIN_SLASH}]`;

/**
 * Posix glob regex
 */

const DOT_LITERAL = '\\.';
const PLUS_LITERAL = '\\+';
const QMARK_LITERAL = '\\?';
const SLASH_LITERAL = '\\/';
const ONE_CHAR = '(?=.)';
const QMARK = '[^/]';
const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
const NO_DOT = `(?!${DOT_LITERAL})`;
const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
const STAR = `${QMARK}*?`;

const POSIX_CHARS = {
  DOT_LITERAL,
  PLUS_LITERAL,
  QMARK_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  QMARK,
  END_ANCHOR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOTS,
  NO_DOT_SLASH,
  NO_DOTS_SLASH,
  QMARK_NO_DOT,
  STAR,
  START_ANCHOR
};

/**
 * Windows glob regex
 */

const WINDOWS_CHARS = {
  ...POSIX_CHARS,

  SLASH_LITERAL: `[${WIN_SLASH}]`,
  QMARK: WIN_NO_SLASH,
  STAR: `${WIN_NO_SLASH}*?`,
  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
  NO_DOT: `(?!${DOT_LITERAL})`,
  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
};

/**
 * POSIX Bracket Regex
 */

const POSIX_REGEX_SOURCE$1 = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};

var constants$4 = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1,

  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,

  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    '***': '*',
    '**/**': '**',
    '**/**/**': '**'
  },

  // Digits
  CHAR_0: 48, /* 0 */
  CHAR_9: 57, /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 65, /* A */
  CHAR_LOWERCASE_A: 97, /* a */
  CHAR_UPPERCASE_Z: 90, /* Z */
  CHAR_LOWERCASE_Z: 122, /* z */

  CHAR_LEFT_PARENTHESES: 40, /* ( */
  CHAR_RIGHT_PARENTHESES: 41, /* ) */

  CHAR_ASTERISK: 42, /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38, /* & */
  CHAR_AT: 64, /* @ */
  CHAR_BACKWARD_SLASH: 92, /* \ */
  CHAR_CARRIAGE_RETURN: 13, /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */
  CHAR_COLON: 58, /* : */
  CHAR_COMMA: 44, /* , */
  CHAR_DOT: 46, /* . */
  CHAR_DOUBLE_QUOTE: 34, /* " */
  CHAR_EQUAL: 61, /* = */
  CHAR_EXCLAMATION_MARK: 33, /* ! */
  CHAR_FORM_FEED: 12, /* \f */
  CHAR_FORWARD_SLASH: 47, /* / */
  CHAR_GRAVE_ACCENT: 96, /* ` */
  CHAR_HASH: 35, /* # */
  CHAR_HYPHEN_MINUS: 45, /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */
  CHAR_LEFT_CURLY_BRACE: 123, /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */
  CHAR_LINE_FEED: 10, /* \n */
  CHAR_NO_BREAK_SPACE: 160, /* \u00A0 */
  CHAR_PERCENT: 37, /* % */
  CHAR_PLUS: 43, /* + */
  CHAR_QUESTION_MARK: 63, /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */
  CHAR_RIGHT_CURLY_BRACE: 125, /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */
  CHAR_SEMICOLON: 59, /* ; */
  CHAR_SINGLE_QUOTE: 39, /* ' */
  CHAR_SPACE: 32, /*   */
  CHAR_TAB: 9, /* \t */
  CHAR_UNDERSCORE: 95, /* _ */
  CHAR_VERTICAL_LINE: 124, /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \uFEFF */

  SEP: path$k.sep,

  /**
   * Create EXTGLOB_CHARS
   */

  extglobChars(chars) {
    return {
      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
      '?': { type: 'qmark', open: '(?:', close: ')?' },
      '+': { type: 'plus', open: '(?:', close: ')+' },
      '*': { type: 'star', open: '(?:', close: ')*' },
      '@': { type: 'at', open: '(?:', close: ')' }
    };
  },

  /**
   * Create GLOB_CHARS
   */

  globChars(win32) {
    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
  }
};

(function (exports) {

const path = require$$0__default$1["default"];
const win32 = process.platform === 'win32';
const {
  REGEX_BACKSLASH,
  REGEX_REMOVE_BACKSLASH,
  REGEX_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_GLOBAL
} = constants$4;

exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');

exports.removeBackslashes = str => {
  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
    return match === '\\' ? '' : match;
  });
};

exports.supportsLookbehinds = () => {
  const segs = process.version.slice(1).split('.').map(Number);
  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {
    return true;
  }
  return false;
};

exports.isWindows = options => {
  if (options && typeof options.windows === 'boolean') {
    return options.windows;
  }
  return win32 === true || path.sep === '\\';
};

exports.escapeLast = (input, char, lastIdx) => {
  const idx = input.lastIndexOf(char, lastIdx);
  if (idx === -1) return input;
  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
};

exports.removePrefix = (input, state = {}) => {
  let output = input;
  if (output.startsWith('./')) {
    output = output.slice(2);
    state.prefix = './';
  }
  return output;
};

exports.wrapOutput = (input, state = {}, options = {}) => {
  const prepend = options.contains ? '' : '^';
  const append = options.contains ? '' : '$';

  let output = `${prepend}(?:${input})${append}`;
  if (state.negated === true) {
    output = `(?:^(?!${output}).*$)`;
  }
  return output;
};
}(utils$h));

const utils$g = utils$h;
const {
  CHAR_ASTERISK,             /* * */
  CHAR_AT,                   /* @ */
  CHAR_BACKWARD_SLASH,       /* \ */
  CHAR_COMMA,                /* , */
  CHAR_DOT,                  /* . */
  CHAR_EXCLAMATION_MARK,     /* ! */
  CHAR_FORWARD_SLASH,        /* / */
  CHAR_LEFT_CURLY_BRACE,     /* { */
  CHAR_LEFT_PARENTHESES,     /* ( */
  CHAR_LEFT_SQUARE_BRACKET,  /* [ */
  CHAR_PLUS,                 /* + */
  CHAR_QUESTION_MARK,        /* ? */
  CHAR_RIGHT_CURLY_BRACE,    /* } */
  CHAR_RIGHT_PARENTHESES,    /* ) */
  CHAR_RIGHT_SQUARE_BRACKET  /* ] */
} = constants$4;

const isPathSeparator = code => {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};

const depth = token => {
  if (token.isPrefix !== true) {
    token.depth = token.isGlobstar ? Infinity : 1;
  }
};

/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
 * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */

const scan$1 = (input, options) => {
  const opts = options || {};

  const length = input.length - 1;
  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
  const slashes = [];
  const tokens = [];
  const parts = [];

  let str = input;
  let index = -1;
  let start = 0;
  let lastIndex = 0;
  let isBrace = false;
  let isBracket = false;
  let isGlob = false;
  let isExtglob = false;
  let isGlobstar = false;
  let braceEscaped = false;
  let backslashes = false;
  let negated = false;
  let negatedExtglob = false;
  let finished = false;
  let braces = 0;
  let prev;
  let code;
  let token = { value: '', depth: 0, isGlob: false };

  const eos = () => index >= length;
  const peek = () => str.charCodeAt(index + 1);
  const advance = () => {
    prev = code;
    return str.charCodeAt(++index);
  };

  while (index < length) {
    code = advance();
    let next;

    if (code === CHAR_BACKWARD_SLASH) {
      backslashes = token.backslashes = true;
      code = advance();

      if (code === CHAR_LEFT_CURLY_BRACE) {
        braceEscaped = true;
      }
      continue;
    }

    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
      braces++;

      while (eos() !== true && (code = advance())) {
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          continue;
        }

        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (braceEscaped !== true && code === CHAR_COMMA) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (code === CHAR_RIGHT_CURLY_BRACE) {
          braces--;

          if (braces === 0) {
            braceEscaped = false;
            isBrace = token.isBrace = true;
            finished = true;
            break;
          }
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (code === CHAR_FORWARD_SLASH) {
      slashes.push(index);
      tokens.push(token);
      token = { value: '', depth: 0, isGlob: false };

      if (finished === true) continue;
      if (prev === CHAR_DOT && index === (start + 1)) {
        start += 2;
        continue;
      }

      lastIndex = index + 1;
      continue;
    }

    if (opts.noext !== true) {
      const isExtglobChar = code === CHAR_PLUS
        || code === CHAR_AT
        || code === CHAR_ASTERISK
        || code === CHAR_QUESTION_MARK
        || code === CHAR_EXCLAMATION_MARK;

      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        isExtglob = token.isExtglob = true;
        finished = true;
        if (code === CHAR_EXCLAMATION_MARK && index === start) {
          negatedExtglob = true;
        }

        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }

            if (code === CHAR_RIGHT_PARENTHESES) {
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
    }

    if (code === CHAR_ASTERISK) {
      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_QUESTION_MARK) {
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_LEFT_SQUARE_BRACKET) {
      while (eos() !== true && (next = advance())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          isBracket = token.isBracket = true;
          isGlob = token.isGlob = true;
          finished = true;
          break;
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
      negated = token.negated = true;
      start++;
      continue;
    }

    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
      isGlob = token.isGlob = true;

      if (scanToEnd === true) {
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_LEFT_PARENTHESES) {
            backslashes = token.backslashes = true;
            code = advance();
            continue;
          }

          if (code === CHAR_RIGHT_PARENTHESES) {
            finished = true;
            break;
          }
        }
        continue;
      }
      break;
    }

    if (isGlob === true) {
      finished = true;

      if (scanToEnd === true) {
        continue;
      }

      break;
    }
  }

  if (opts.noext === true) {
    isExtglob = false;
    isGlob = false;
  }

  let base = str;
  let prefix = '';
  let glob = '';

  if (start > 0) {
    prefix = str.slice(0, start);
    str = str.slice(start);
    lastIndex -= start;
  }

  if (base && isGlob === true && lastIndex > 0) {
    base = str.slice(0, lastIndex);
    glob = str.slice(lastIndex);
  } else if (isGlob === true) {
    base = '';
    glob = str;
  } else {
    base = str;
  }

  if (base && base !== '' && base !== '/' && base !== str) {
    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
      base = base.slice(0, -1);
    }
  }

  if (opts.unescape === true) {
    if (glob) glob = utils$g.removeBackslashes(glob);

    if (base && backslashes === true) {
      base = utils$g.removeBackslashes(base);
    }
  }

  const state = {
    prefix,
    input,
    start,
    base,
    glob,
    isBrace,
    isBracket,
    isGlob,
    isExtglob,
    isGlobstar,
    negated,
    negatedExtglob
  };

  if (opts.tokens === true) {
    state.maxDepth = 0;
    if (!isPathSeparator(code)) {
      tokens.push(token);
    }
    state.tokens = tokens;
  }

  if (opts.parts === true || opts.tokens === true) {
    let prevIndex;

    for (let idx = 0; idx < slashes.length; idx++) {
      const n = prevIndex ? prevIndex + 1 : start;
      const i = slashes[idx];
      const value = input.slice(n, i);
      if (opts.tokens) {
        if (idx === 0 && start !== 0) {
          tokens[idx].isPrefix = true;
          tokens[idx].value = prefix;
        } else {
          tokens[idx].value = value;
        }
        depth(tokens[idx]);
        state.maxDepth += tokens[idx].depth;
      }
      if (idx !== 0 || value !== '') {
        parts.push(value);
      }
      prevIndex = i;
    }

    if (prevIndex && prevIndex + 1 < input.length) {
      const value = input.slice(prevIndex + 1);
      parts.push(value);

      if (opts.tokens) {
        tokens[tokens.length - 1].value = value;
        depth(tokens[tokens.length - 1]);
        state.maxDepth += tokens[tokens.length - 1].depth;
      }
    }

    state.slashes = slashes;
    state.parts = parts;
  }

  return state;
};

var scan_1 = scan$1;

const constants$3 = constants$4;
const utils$f = utils$h;

/**
 * Constants
 */

const {
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants$3;

/**
 * Helpers
 */

const expandRange = (args, options) => {
  if (typeof options.expandRange === 'function') {
    return options.expandRange(...args, options);
  }

  args.sort();
  const value = `[${args.join('-')}]`;

  try {
    /* eslint-disable-next-line no-new */
    new RegExp(value);
  } catch (ex) {
    return args.map(v => utils$f.escapeRegex(v)).join('..');
  }

  return value;
};

/**
 * Create the message for a syntax error
 */

const syntaxError = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};

/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */

const parse$5 = (input, options) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  input = REPLACEMENTS[input] || input;

  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  const bos = { type: 'bos', value: '', output: opts.prepend || '' };
  const tokens = [bos];

  const capture = opts.capture ? '' : '?:';
  const win32 = utils$f.isWindows(options);

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = constants$3.globChars(win32);
  const EXTGLOB_CHARS = constants$3.extglobChars(PLATFORM_CHARS);

  const {
    DOT_LITERAL,
    PLUS_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  } = PLATFORM_CHARS;

  const globstar = opts => {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const nodot = opts.dot ? '' : NO_DOT;
  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  // minimatch options support
  if (typeof opts.noext === 'boolean') {
    opts.noextglob = opts.noext;
  }

  const state = {
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: '',
    output: '',
    prefix: '',
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens
  };

  input = utils$f.removePrefix(input, state);
  len = input.length;

  const extglobs = [];
  const braces = [];
  const stack = [];
  let prev = bos;
  let value;

  /**
   * Tokenizing helpers
   */

  const eos = () => state.index === len - 1;
  const peek = state.peek = (n = 1) => input[state.index + n];
  const advance = state.advance = () => input[++state.index] || '';
  const remaining = () => input.slice(state.index + 1);
  const consume = (value = '', num = 0) => {
    state.consumed += value;
    state.index += num;
  };

  const append = token => {
    state.output += token.output != null ? token.output : token.value;
    consume(token.value);
  };

  const negate = () => {
    let count = 1;

    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
      advance();
      state.start++;
      count++;
    }

    if (count % 2 === 0) {
      return false;
    }

    state.negated = true;
    state.start++;
    return true;
  };

  const increment = type => {
    state[type]++;
    stack.push(type);
  };

  const decrement = type => {
    state[type]--;
    stack.pop();
  };

  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */

  const push = tok => {
    if (prev.type === 'globstar') {
      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));

      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = 'star';
        prev.value = '*';
        prev.output = star;
        state.output += prev.output;
      }
    }

    if (extglobs.length && tok.type !== 'paren') {
      extglobs[extglobs.length - 1].inner += tok.value;
    }

    if (tok.value || tok.output) append(tok);
    if (prev && prev.type === 'text' && tok.type === 'text') {
      prev.value += tok.value;
      prev.output = (prev.output || '') + tok.value;
      return;
    }

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };

  const extglobOpen = (type, value) => {
    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    const output = (opts.capture ? '(' : '') + token.open;

    increment('parens');
    push({ type, value, output: state.output ? '' : ONE_CHAR });
    push({ type: 'paren', extglob: true, value: advance(), output });
    extglobs.push(token);
  };

  const extglobClose = token => {
    let output = token.close + (opts.capture ? ')' : '');
    let rest;

    if (token.type === 'negate') {
      let extglobStar = star;

      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
        extglobStar = globstar(opts);
      }

      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
        output = token.close = `)$))${extglobStar}`;
      }

      if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
        // In this case, we need to parse the string and use it in the output of the original pattern.
        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
        //
        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
        const expression = parse$5(rest, { ...options, fastpaths: false }).output;

        output = token.close = `)${expression})${extglobStar})`;
      }

      if (token.prev.type === 'bos') {
        state.negatedExtglob = true;
      }
    }

    push({ type: 'paren', extglob: true, value, output });
    decrement('parens');
  };

  /**
   * Fast paths
   */

  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
    let backslashes = false;

    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
      if (first === '\\') {
        backslashes = true;
        return m;
      }

      if (first === '?') {
        if (esc) {
          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
        }
        if (index === 0) {
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
        }
        return QMARK.repeat(chars.length);
      }

      if (first === '.') {
        return DOT_LITERAL.repeat(chars.length);
      }

      if (first === '*') {
        if (esc) {
          return esc + first + (rest ? star : '');
        }
        return star;
      }
      return esc ? m : `\\${m}`;
    });

    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, '');
      } else {
        output = output.replace(/\\+/g, m => {
          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
        });
      }
    }

    if (output === input && opts.contains === true) {
      state.output = input;
      return state;
    }

    state.output = utils$f.wrapOutput(output, state, options);
    return state;
  }

  /**
   * Tokenize input until we reach end-of-string
   */

  while (!eos()) {
    value = advance();

    if (value === '\u0000') {
      continue;
    }

    /**
     * Escaped characters
     */

    if (value === '\\') {
      const next = peek();

      if (next === '/' && opts.bash !== true) {
        continue;
      }

      if (next === '.' || next === ';') {
        continue;
      }

      if (!next) {
        value += '\\';
        push({ type: 'text', value });
        continue;
      }

      // collapse slashes to reduce potential for exploits
      const match = /^\\+/.exec(remaining());
      let slashes = 0;

      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) {
          value += '\\';
        }
      }

      if (opts.unescape === true) {
        value = advance();
      } else {
        value += advance();
      }

      if (state.brackets === 0) {
        push({ type: 'text', value });
        continue;
      }
    }

    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */

    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
      if (opts.posix !== false && value === ':') {
        const inner = prev.value.slice(1);
        if (inner.includes('[')) {
          prev.posix = true;

          if (inner.includes(':')) {
            const idx = prev.value.lastIndexOf('[');
            const pre = prev.value.slice(0, idx);
            const rest = prev.value.slice(idx + 2);
            const posix = POSIX_REGEX_SOURCE[rest];
            if (posix) {
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR;
              }
              continue;
            }
          }
        }
      }

      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
        value = `\\${value}`;
      }

      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
        value = `\\${value}`;
      }

      if (opts.posix === true && value === '!' && prev.value === '[') {
        value = '^';
      }

      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */

    if (state.quotes === 1 && value !== '"') {
      value = utils$f.escapeRegex(value);
      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * Double quotes
     */

    if (value === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push({ type: 'text', value });
      }
      continue;
    }

    /**
     * Parentheses
     */

    if (value === '(') {
      increment('parens');
      push({ type: 'paren', value });
      continue;
    }

    if (value === ')') {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError('opening', '('));
      }

      const extglob = extglobs[extglobs.length - 1];
      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }

      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
      decrement('parens');
      continue;
    }

    /**
     * Square brackets
     */

    if (value === '[') {
      if (opts.nobracket === true || !remaining().includes(']')) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('closing', ']'));
        }

        value = `\\${value}`;
      } else {
        increment('brackets');
      }

      push({ type: 'bracket', value });
      continue;
    }

    if (value === ']') {
      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '['));
        }

        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      decrement('brackets');

      const prevValue = prev.value.slice(1);
      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
        value = `/${value}`;
      }

      prev.value += value;
      append({ value });

      // when literal brackets are explicitly disabled
      // assume we should match with a regex character class
      if (opts.literalBrackets === false || utils$f.hasRegexChars(prevValue)) {
        continue;
      }

      const escaped = utils$f.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length);

      // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters
      if (opts.literalBrackets === true) {
        state.output += escaped;
        prev.value = escaped;
        continue;
      }

      // when the user specifies nothing, try to match both
      prev.value = `(${capture}${escaped}|${prev.value})`;
      state.output += prev.value;
      continue;
    }

    /**
     * Braces
     */

    if (value === '{' && opts.nobrace !== true) {
      increment('braces');

      const open = {
        type: 'brace',
        value,
        output: '(',
        outputIndex: state.output.length,
        tokensIndex: state.tokens.length
      };

      braces.push(open);
      push(open);
      continue;
    }

    if (value === '}') {
      const brace = braces[braces.length - 1];

      if (opts.nobrace === true || !brace) {
        push({ type: 'text', value, output: value });
        continue;
      }

      let output = ')';

      if (brace.dots === true) {
        const arr = tokens.slice();
        const range = [];

        for (let i = arr.length - 1; i >= 0; i--) {
          tokens.pop();
          if (arr[i].type === 'brace') {
            break;
          }
          if (arr[i].type !== 'dots') {
            range.unshift(arr[i].value);
          }
        }

        output = expandRange(range, opts);
        state.backtrack = true;
      }

      if (brace.comma !== true && brace.dots !== true) {
        const out = state.output.slice(0, brace.outputIndex);
        const toks = state.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = '\\{';
        value = output = '\\}';
        state.output = out;
        for (const t of toks) {
          state.output += (t.output || t.value);
        }
      }

      push({ type: 'brace', value, output });
      decrement('braces');
      braces.pop();
      continue;
    }

    /**
     * Pipes
     */

    if (value === '|') {
      if (extglobs.length > 0) {
        extglobs[extglobs.length - 1].conditions++;
      }
      push({ type: 'text', value });
      continue;
    }

    /**
     * Commas
     */

    if (value === ',') {
      let output = value;

      const brace = braces[braces.length - 1];
      if (brace && stack[stack.length - 1] === 'braces') {
        brace.comma = true;
        output = '|';
      }

      push({ type: 'comma', value, output });
      continue;
    }

    /**
     * Slashes
     */

    if (value === '/') {
      // if the beginning of the glob is "./", advance the start
      // to the current index, and don't add the "./" characters
      // to the state. This greatly simplifies lookbehinds when
      // checking for BOS characters like "!" and "." (not "./")
      if (prev.type === 'dot' && state.index === state.start + 1) {
        state.start = state.index + 1;
        state.consumed = '';
        state.output = '';
        tokens.pop();
        prev = bos; // reset "prev" to the first token
        continue;
      }

      push({ type: 'slash', value, output: SLASH_LITERAL });
      continue;
    }

    /**
     * Dots
     */

    if (value === '.') {
      if (state.braces > 0 && prev.type === 'dot') {
        if (prev.value === '.') prev.output = DOT_LITERAL;
        const brace = braces[braces.length - 1];
        prev.type = 'dots';
        prev.output += value;
        prev.value += value;
        brace.dots = true;
        continue;
      }

      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
        push({ type: 'text', value, output: DOT_LITERAL });
        continue;
      }

      push({ type: 'dot', value, output: DOT_LITERAL });
      continue;
    }

    /**
     * Question marks
     */

    if (value === '?') {
      const isGroup = prev && prev.value === '(';
      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('qmark', value);
        continue;
      }

      if (prev && prev.type === 'paren') {
        const next = peek();
        let output = value;

        if (next === '<' && !utils$f.supportsLookbehinds()) {
          throw new Error('Node.js v10 or higher is required for regex lookbehinds');
        }

        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) {
          output = `\\${value}`;
        }

        push({ type: 'text', value, output });
        continue;
      }

      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
        push({ type: 'qmark', value, output: QMARK_NO_DOT });
        continue;
      }

      push({ type: 'qmark', value, output: QMARK });
      continue;
    }

    /**
     * Exclamation
     */

    if (value === '!') {
      if (opts.noextglob !== true && peek() === '(') {
        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
          extglobOpen('negate', value);
          continue;
        }
      }

      if (opts.nonegate !== true && state.index === 0) {
        negate();
        continue;
      }
    }

    /**
     * Plus
     */

    if (value === '+') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('plus', value);
        continue;
      }

      if ((prev && prev.value === '(') || opts.regex === false) {
        push({ type: 'plus', value, output: PLUS_LITERAL });
        continue;
      }

      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {
        push({ type: 'plus', value });
        continue;
      }

      push({ type: 'plus', value: PLUS_LITERAL });
      continue;
    }

    /**
     * Plain text
     */

    if (value === '@') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        push({ type: 'at', extglob: true, value, output: '' });
        continue;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Plain text
     */

    if (value !== '*') {
      if (value === '$' || value === '^') {
        value = `\\${value}`;
      }

      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
      if (match) {
        value += match[0];
        state.index += match[0].length;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Stars
     */

    if (prev && (prev.type === 'globstar' || prev.star === true)) {
      prev.type = 'star';
      prev.star = true;
      prev.value += value;
      prev.output = star;
      state.backtrack = true;
      state.globstar = true;
      consume(value);
      continue;
    }

    let rest = remaining();
    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
      extglobOpen('star', value);
      continue;
    }

    if (prev.type === 'star') {
      if (opts.noglobstar === true) {
        consume(value);
        continue;
      }

      const prior = prev.prev;
      const before = prior.prev;
      const isStart = prior.type === 'slash' || prior.type === 'bos';
      const afterStar = before && (before.type === 'star' || before.type === 'globstar');

      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      // strip consecutive `/**/`
      while (rest.slice(0, 3) === '/**') {
        const after = input[state.index + 4];
        if (after && after !== '/') {
          break;
        }
        rest = rest.slice(3);
        consume('/**', 3);
      }

      if (prior.type === 'bos' && eos()) {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
        prev.value += value;
        state.globstar = true;
        state.output += prior.output + prev.output;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
        const end = rest[1] !== void 0 ? '|$' : '';

        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
        prev.value += value;

        state.output += prior.output + prev.output;
        state.globstar = true;

        consume(value + advance());

        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      if (prior.type === 'bos' && rest[0] === '/') {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
        state.output = prev.output;
        state.globstar = true;
        consume(value + advance());
        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      // remove single star from output
      state.output = state.output.slice(0, -prev.output.length);

      // reset previous token to globstar
      prev.type = 'globstar';
      prev.output = globstar(opts);
      prev.value += value;

      // reset output with globstar
      state.output += prev.output;
      state.globstar = true;
      consume(value);
      continue;
    }

    const token = { type: 'star', value, output: star };

    if (opts.bash === true) {
      token.output = '.*?';
      if (prev.type === 'bos' || prev.type === 'slash') {
        token.output = nodot + token.output;
      }
      push(token);
      continue;
    }

    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
      token.output = value;
      push(token);
      continue;
    }

    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
      if (prev.type === 'dot') {
        state.output += NO_DOT_SLASH;
        prev.output += NO_DOT_SLASH;

      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH;
        prev.output += NO_DOTS_SLASH;

      } else {
        state.output += nodot;
        prev.output += nodot;
      }

      if (peek() !== '*') {
        state.output += ONE_CHAR;
        prev.output += ONE_CHAR;
      }
    }

    push(token);
  }

  while (state.brackets > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
    state.output = utils$f.escapeLast(state.output, '[');
    decrement('brackets');
  }

  while (state.parens > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
    state.output = utils$f.escapeLast(state.output, '(');
    decrement('parens');
  }

  while (state.braces > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
    state.output = utils$f.escapeLast(state.output, '{');
    decrement('braces');
  }

  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
  }

  // rebuild the output if we had to backtrack at any point
  if (state.backtrack === true) {
    state.output = '';

    for (const token of state.tokens) {
      state.output += token.output != null ? token.output : token.value;

      if (token.suffix) {
        state.output += token.suffix;
      }
    }
  }

  return state;
};

/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */

parse$5.fastpaths = (input, options) => {
  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  const len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  input = REPLACEMENTS[input] || input;
  const win32 = utils$f.isWindows(options);

  // create constants based on platform, for windows or posix
  const {
    DOT_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOTS_SLASH,
    STAR,
    START_ANCHOR
  } = constants$3.globChars(win32);

  const nodot = opts.dot ? NO_DOTS : NO_DOT;
  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
  const capture = opts.capture ? '' : '?:';
  const state = { negated: false, prefix: '' };
  let star = opts.bash === true ? '.*?' : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  const globstar = opts => {
    if (opts.noglobstar === true) return star;
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const create = str => {
    switch (str) {
      case '*':
        return `${nodot}${ONE_CHAR}${star}`;

      case '.*':
        return `${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*.*':
        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*/*':
        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

      case '**':
        return nodot + globstar(opts);

      case '**/*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

      case '**/*.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '**/.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

      default: {
        const match = /^(.*?)\.(\w+)$/.exec(str);
        if (!match) return;

        const source = create(match[1]);
        if (!source) return;

        return source + DOT_LITERAL + match[2];
      }
    }
  };

  const output = utils$f.removePrefix(input, state);
  let source = create(output);

  if (source && opts.strictSlashes !== true) {
    source += `${SLASH_LITERAL}?`;
  }

  return source;
};

var parse_1 = parse$5;

const path$j = require$$0__default$1["default"];
const scan = scan_1;
const parse$4 = parse_1;
const utils$e = utils$h;
const constants$2 = constants$4;
const isObject$2 = val => val && typeof val === 'object' && !Array.isArray(val);

/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */

const picomatch$2 = (glob, options, returnState = false) => {
  if (Array.isArray(glob)) {
    const fns = glob.map(input => picomatch$2(input, options, returnState));
    const arrayMatcher = str => {
      for (const isMatch of fns) {
        const state = isMatch(str);
        if (state) return state;
      }
      return false;
    };
    return arrayMatcher;
  }

  const isState = isObject$2(glob) && glob.tokens && glob.input;

  if (glob === '' || (typeof glob !== 'string' && !isState)) {
    throw new TypeError('Expected pattern to be a non-empty string');
  }

  const opts = options || {};
  const posix = utils$e.isWindows(options);
  const regex = isState
    ? picomatch$2.compileRe(glob, options)
    : picomatch$2.makeRe(glob, options, false, true);

  const state = regex.state;
  delete regex.state;

  let isIgnored = () => false;
  if (opts.ignore) {
    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
    isIgnored = picomatch$2(opts.ignore, ignoreOpts, returnState);
  }

  const matcher = (input, returnObject = false) => {
    const { isMatch, match, output } = picomatch$2.test(input, regex, options, { glob, posix });
    const result = { glob, state, regex, posix, input, output, match, isMatch };

    if (typeof opts.onResult === 'function') {
      opts.onResult(result);
    }

    if (isMatch === false) {
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (isIgnored(input)) {
      if (typeof opts.onIgnore === 'function') {
        opts.onIgnore(result);
      }
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (typeof opts.onMatch === 'function') {
      opts.onMatch(result);
    }
    return returnObject ? result : true;
  };

  if (returnState) {
    matcher.state = state;
  }

  return matcher;
};

/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */

picomatch$2.test = (input, regex, options, { glob, posix } = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected input to be a string');
  }

  if (input === '') {
    return { isMatch: false, output: '' };
  }

  const opts = options || {};
  const format = opts.format || (posix ? utils$e.toPosixSlashes : null);
  let match = input === glob;
  let output = (match && format) ? format(input) : input;

  if (match === false) {
    output = format ? format(input) : input;
    match = output === glob;
  }

  if (match === false || opts.capture === true) {
    if (opts.matchBase === true || opts.basename === true) {
      match = picomatch$2.matchBase(input, regex, options, posix);
    } else {
      match = regex.exec(output);
    }
  }

  return { isMatch: Boolean(match), match, output };
};

/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */

picomatch$2.matchBase = (input, glob, options, posix = utils$e.isWindows(options)) => {
  const regex = glob instanceof RegExp ? glob : picomatch$2.makeRe(glob, options);
  return regex.test(path$j.basename(input));
};

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

picomatch$2.isMatch = (str, patterns, options) => picomatch$2(patterns, options)(str);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */

picomatch$2.parse = (pattern, options) => {
  if (Array.isArray(pattern)) return pattern.map(p => picomatch$2.parse(p, options));
  return parse$4(pattern, { ...options, fastpaths: false });
};

/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

picomatch$2.scan = (input, options) => scan(input, options);

/**
 * Compile a regular expression from the `state` object returned by the
 * [parse()](#parse) method.
 *
 * @param {Object} `state`
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
 * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
 * @return {RegExp}
 * @api public
 */

picomatch$2.compileRe = (state, options, returnOutput = false, returnState = false) => {
  if (returnOutput === true) {
    return state.output;
  }

  const opts = options || {};
  const prepend = opts.contains ? '' : '^';
  const append = opts.contains ? '' : '$';

  let source = `${prepend}(?:${state.output})${append}`;
  if (state && state.negated === true) {
    source = `^(?!${source}).*$`;
  }

  const regex = picomatch$2.toRegex(source, options);
  if (returnState === true) {
    regex.state = state;
  }

  return regex;
};

/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
 * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

picomatch$2.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
  if (!input || typeof input !== 'string') {
    throw new TypeError('Expected a non-empty string');
  }

  let parsed = { negated: false, fastpaths: true };

  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
    parsed.output = parse$4.fastpaths(input, options);
  }

  if (!parsed.output) {
    parsed = parse$4(input, options);
  }

  return picomatch$2.compileRe(parsed, options, returnOutput, returnState);
};

/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

picomatch$2.toRegex = (source, options) => {
  try {
    const opts = options || {};
    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
  } catch (err) {
    if (options && options.debug === true) throw err;
    return /$^/;
  }
};

/**
 * Picomatch constants.
 * @return {Object}
 */

picomatch$2.constants = constants$2;

/**
 * Expose "picomatch"
 */

var picomatch_1 = picomatch$2;

var picomatch$1 = picomatch_1;

const util$2 = require$$1__default["default"];
const braces = braces_1;
const picomatch = picomatch$1;
const utils$d = utils$h;
const isEmptyString = val => val === '' || val === './';

/**
 * Returns an array of strings that match one or more glob patterns.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm(list, patterns[, options]);
 *
 * console.log(mm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {String|Array<string>} `list` List of strings to match.
 * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options)
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */

const micromatch$1 = (list, patterns, options) => {
  patterns = [].concat(patterns);
  list = [].concat(list);

  let omit = new Set();
  let keep = new Set();
  let items = new Set();
  let negatives = 0;

  let onResult = state => {
    items.add(state.output);
    if (options && options.onResult) {
      options.onResult(state);
    }
  };

  for (let i = 0; i < patterns.length; i++) {
    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
    if (negated) negatives++;

    for (let item of list) {
      let matched = isMatch(item, true);

      let match = negated ? !matched.isMatch : matched.isMatch;
      if (!match) continue;

      if (negated) {
        omit.add(matched.output);
      } else {
        omit.delete(matched.output);
        keep.add(matched.output);
      }
    }
  }

  let result = negatives === patterns.length ? [...items] : [...keep];
  let matches = result.filter(item => !omit.has(item));

  if (options && matches.length === 0) {
    if (options.failglob === true) {
      throw new Error(`No matches found for "${patterns.join(', ')}"`);
    }

    if (options.nonull === true || options.nullglob === true) {
      return options.unescape ? patterns.map(p => p.replace(/\\/g, '')) : patterns;
    }
  }

  return matches;
};

/**
 * Backwards compatibility
 */

micromatch$1.match = micromatch$1;

/**
 * Returns a matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matcher(pattern[, options]);
 *
 * const isMatch = mm.matcher('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options`
 * @return {Function} Returns a matcher function.
 * @api public
 */

micromatch$1.matcher = (pattern, options) => picomatch(pattern, options);

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.isMatch(string, patterns[, options]);
 *
 * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(mm.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `[options]` See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch$1.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Backwards compatibility
 */

micromatch$1.any = micromatch$1.isMatch;

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.not(list, patterns[, options]);
 *
 * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

micromatch$1.not = (list, patterns, options = {}) => {
  patterns = [].concat(patterns).map(String);
  let result = new Set();
  let items = [];

  let onResult = state => {
    if (options.onResult) options.onResult(state);
    items.push(state.output);
  };

  let matches = micromatch$1(list, patterns, { ...options, onResult });

  for (let item of items) {
    if (!matches.includes(item)) {
      result.add(item);
    }
  }
  return [...result];
};

/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require('micromatch');
 * // mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(mm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any of the patterns matches any part of `str`.
 * @api public
 */

micromatch$1.contains = (str, pattern, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${util$2.inspect(str)}"`);
  }

  if (Array.isArray(pattern)) {
    return pattern.some(p => micromatch$1.contains(str, p, options));
  }

  if (typeof pattern === 'string') {
    if (isEmptyString(str) || isEmptyString(pattern)) {
      return false;
    }

    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {
      return true;
    }
  }

  return micromatch$1.isMatch(str, pattern, { ...options, contains: true });
};

/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matchKeys(object, patterns[, options]);
 *
 * const obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(mm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */

micromatch$1.matchKeys = (obj, patterns, options) => {
  if (!utils$d.isObject(obj)) {
    throw new TypeError('Expected the first argument to be an object');
  }
  let keys = micromatch$1(Object.keys(obj), patterns, options);
  let res = {};
  for (let key of keys) res[key] = obj[key];
  return res;
};

/**
 * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.some(list, patterns[, options]);
 *
 * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`
 * @api public
 */

micromatch$1.some = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (items.some(item => isMatch(item))) {
      return true;
    }
  }
  return false;
};

/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.every(list, patterns[, options]);
 *
 * console.log(mm.every('foo.js', ['foo.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`
 * @api public
 */

micromatch$1.every = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (!items.every(item => isMatch(item))) {
      return false;
    }
  }
  return true;
};

/**
 * Returns true if **all** of the given `patterns` match
 * the specified string.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.all(string, patterns[, options]);
 *
 * console.log(mm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch$1.all = (str, patterns, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${util$2.inspect(str)}"`);
  }

  return [].concat(patterns).every(p => picomatch(p, options)(str));
};

/**
 * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.capture(pattern, string[, options]);
 *
 * console.log(mm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(mm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `glob` Glob pattern to use for matching.
 * @param {String} `input` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.
 * @api public
 */

micromatch$1.capture = (glob, input, options) => {
  let posix = utils$d.isWindows(options);
  let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
  let match = regex.exec(posix ? utils$d.toPosixSlashes(input) : input);

  if (match) {
    return match.slice(1).map(v => v === void 0 ? '' : v);
  }
};

/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.makeRe(pattern[, options]);
 *
 * console.log(mm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

micromatch$1.makeRe = (...args) => picomatch.makeRe(...args);

/**
 * Scan a glob pattern to separate the pattern into segments. Used
 * by the [split](#split) method.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm.scan(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

micromatch$1.scan = (...args) => picomatch.scan(...args);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm(pattern[, options]);
 * ```
 * @param {String} `glob`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as regex source string.
 * @api public
 */

micromatch$1.parse = (patterns, options) => {
  let res = [];
  for (let pattern of [].concat(patterns || [])) {
    for (let str of braces(String(pattern), options)) {
      res.push(picomatch.parse(str, options));
    }
  }
  return res;
};

/**
 * Process the given brace `pattern`.
 *
 * ```js
 * const { braces } = require('micromatch');
 * console.log(braces('foo/{a,b,c}/bar'));
 * //=> [ 'foo/(a|b|c)/bar' ]
 *
 * console.log(braces('foo/{a,b,c}/bar', { expand: true }));
 * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]
 * ```
 * @param {String} `pattern` String with brace pattern to process.
 * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return {Array}
 * @api public
 */

micromatch$1.braces = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  if ((options && options.nobrace === true) || !/\{.*\}/.test(pattern)) {
    return [pattern];
  }
  return braces(pattern, options);
};

/**
 * Expand braces
 */

micromatch$1.braceExpand = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  return micromatch$1.braces(pattern, { ...options, expand: true });
};

/**
 * Expose micromatch
 */

var micromatch_1 = micromatch$1;

Object.defineProperty(pattern$1, "__esModule", { value: true });
pattern$1.matchAny = pattern$1.convertPatternsToRe = pattern$1.makeRe = pattern$1.getPatternParts = pattern$1.expandBraceExpansion = pattern$1.expandPatternsWithBraceExpansion = pattern$1.isAffectDepthOfReadingPattern = pattern$1.endsWithSlashGlobStar = pattern$1.hasGlobStar = pattern$1.getBaseDirectory = pattern$1.isPatternRelatedToParentDirectory = pattern$1.getPatternsOutsideCurrentDirectory = pattern$1.getPatternsInsideCurrentDirectory = pattern$1.getPositivePatterns = pattern$1.getNegativePatterns = pattern$1.isPositivePattern = pattern$1.isNegativePattern = pattern$1.convertToNegativePattern = pattern$1.convertToPositivePattern = pattern$1.isDynamicPattern = pattern$1.isStaticPattern = void 0;
const path$i = require$$0__default$1["default"];
const globParent = globParent$1;
const micromatch = micromatch_1;
const GLOBSTAR = '**';
const ESCAPE_SYMBOL = '\\';
const COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
const REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
const REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
const GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
const BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
function isStaticPattern(pattern, options = {}) {
    return !isDynamicPattern(pattern, options);
}
pattern$1.isStaticPattern = isStaticPattern;
function isDynamicPattern(pattern, options = {}) {
    /**
     * A special case with an empty string is necessary for matching patterns that start with a forward slash.
     * An empty string cannot be a dynamic pattern.
     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.
     */
    if (pattern === '') {
        return false;
    }
    /**
     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check
     * filepath directly (without read directory).
     */
    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
    }
    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
        return true;
    }
    return false;
}
pattern$1.isDynamicPattern = isDynamicPattern;
function hasBraceExpansion(pattern) {
    const openingBraceIndex = pattern.indexOf('{');
    if (openingBraceIndex === -1) {
        return false;
    }
    const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);
    if (closingBraceIndex === -1) {
        return false;
    }
    const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
    return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
}
function convertToPositivePattern(pattern) {
    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
}
pattern$1.convertToPositivePattern = convertToPositivePattern;
function convertToNegativePattern(pattern) {
    return '!' + pattern;
}
pattern$1.convertToNegativePattern = convertToNegativePattern;
function isNegativePattern(pattern) {
    return pattern.startsWith('!') && pattern[1] !== '(';
}
pattern$1.isNegativePattern = isNegativePattern;
function isPositivePattern(pattern) {
    return !isNegativePattern(pattern);
}
pattern$1.isPositivePattern = isPositivePattern;
function getNegativePatterns(patterns) {
    return patterns.filter(isNegativePattern);
}
pattern$1.getNegativePatterns = getNegativePatterns;
function getPositivePatterns$1(patterns) {
    return patterns.filter(isPositivePattern);
}
pattern$1.getPositivePatterns = getPositivePatterns$1;
/**
 * Returns patterns that can be applied inside the current directory.
 *
 * @example
 * // ['./*', '*', 'a/*']
 * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])
 */
function getPatternsInsideCurrentDirectory(patterns) {
    return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
}
pattern$1.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
/**
 * Returns patterns to be expanded relative to (outside) the current directory.
 *
 * @example
 * // ['../*', './../*']
 * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])
 */
function getPatternsOutsideCurrentDirectory(patterns) {
    return patterns.filter(isPatternRelatedToParentDirectory);
}
pattern$1.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
function isPatternRelatedToParentDirectory(pattern) {
    return pattern.startsWith('..') || pattern.startsWith('./..');
}
pattern$1.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
function getBaseDirectory(pattern) {
    return globParent(pattern, { flipBackslashes: false });
}
pattern$1.getBaseDirectory = getBaseDirectory;
function hasGlobStar(pattern) {
    return pattern.includes(GLOBSTAR);
}
pattern$1.hasGlobStar = hasGlobStar;
function endsWithSlashGlobStar(pattern) {
    return pattern.endsWith('/' + GLOBSTAR);
}
pattern$1.endsWithSlashGlobStar = endsWithSlashGlobStar;
function isAffectDepthOfReadingPattern(pattern) {
    const basename = path$i.basename(pattern);
    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
}
pattern$1.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
function expandPatternsWithBraceExpansion(patterns) {
    return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
    }, []);
}
pattern$1.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
function expandBraceExpansion(pattern) {
    return micromatch.braces(pattern, {
        expand: true,
        nodupes: true
    });
}
pattern$1.expandBraceExpansion = expandBraceExpansion;
function getPatternParts(pattern, options) {
    let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
    /**
     * The scan method returns an empty array in some cases.
     * See micromatch/picomatch#58 for more details.
     */
    if (parts.length === 0) {
        parts = [pattern];
    }
    /**
     * The scan method does not return an empty part for the pattern with a forward slash.
     * This is another part of micromatch/picomatch#58.
     */
    if (parts[0].startsWith('/')) {
        parts[0] = parts[0].slice(1);
        parts.unshift('');
    }
    return parts;
}
pattern$1.getPatternParts = getPatternParts;
function makeRe(pattern, options) {
    return micromatch.makeRe(pattern, options);
}
pattern$1.makeRe = makeRe;
function convertPatternsToRe(patterns, options) {
    return patterns.map((pattern) => makeRe(pattern, options));
}
pattern$1.convertPatternsToRe = convertPatternsToRe;
function matchAny(entry, patternsRe) {
    return patternsRe.some((patternRe) => patternRe.test(entry));
}
pattern$1.matchAny = matchAny;

var stream$4 = {};

/*
 * merge2
 * https://github.com/teambition/merge2
 *
 * Copyright (c) 2014-2020 Teambition
 * Licensed under the MIT license.
 */
const Stream$1 = require$$0__default$3["default"];
const PassThrough = Stream$1.PassThrough;
const slice = Array.prototype.slice;

var merge2_1 = merge2$1;

function merge2$1 () {
  const streamsQueue = [];
  const args = slice.call(arguments);
  let merging = false;
  let options = args[args.length - 1];

  if (options && !Array.isArray(options) && options.pipe == null) {
    args.pop();
  } else {
    options = {};
  }

  const doEnd = options.end !== false;
  const doPipeError = options.pipeError === true;
  if (options.objectMode == null) {
    options.objectMode = true;
  }
  if (options.highWaterMark == null) {
    options.highWaterMark = 64 * 1024;
  }
  const mergedStream = PassThrough(options);

  function addStream () {
    for (let i = 0, len = arguments.length; i < len; i++) {
      streamsQueue.push(pauseStreams(arguments[i], options));
    }
    mergeStream();
    return this
  }

  function mergeStream () {
    if (merging) {
      return
    }
    merging = true;

    let streams = streamsQueue.shift();
    if (!streams) {
      process.nextTick(endStream);
      return
    }
    if (!Array.isArray(streams)) {
      streams = [streams];
    }

    let pipesCount = streams.length + 1;

    function next () {
      if (--pipesCount > 0) {
        return
      }
      merging = false;
      mergeStream();
    }

    function pipe (stream) {
      function onend () {
        stream.removeListener('merge2UnpipeEnd', onend);
        stream.removeListener('end', onend);
        if (doPipeError) {
          stream.removeListener('error', onerror);
        }
        next();
      }
      function onerror (err) {
        mergedStream.emit('error', err);
      }
      // skip ended stream
      if (stream._readableState.endEmitted) {
        return next()
      }

      stream.on('merge2UnpipeEnd', onend);
      stream.on('end', onend);

      if (doPipeError) {
        stream.on('error', onerror);
      }

      stream.pipe(mergedStream, { end: false });
      // compatible for old stream
      stream.resume();
    }

    for (let i = 0; i < streams.length; i++) {
      pipe(streams[i]);
    }

    next();
  }

  function endStream () {
    merging = false;
    // emit 'queueDrain' when all streams merged.
    mergedStream.emit('queueDrain');
    if (doEnd) {
      mergedStream.end();
    }
  }

  mergedStream.setMaxListeners(0);
  mergedStream.add = addStream;
  mergedStream.on('unpipe', function (stream) {
    stream.emit('merge2UnpipeEnd');
  });

  if (args.length) {
    addStream.apply(null, args);
  }
  return mergedStream
}

// check and pause streams for pipe.
function pauseStreams (streams, options) {
  if (!Array.isArray(streams)) {
    // Backwards-compat with old-style streams
    if (!streams._readableState && streams.pipe) {
      streams = streams.pipe(PassThrough(options));
    }
    if (!streams._readableState || !streams.pause || !streams.pipe) {
      throw new Error('Only readable stream can be merged.')
    }
    streams.pause();
  } else {
    for (let i = 0, len = streams.length; i < len; i++) {
      streams[i] = pauseStreams(streams[i], options);
    }
  }
  return streams
}

Object.defineProperty(stream$4, "__esModule", { value: true });
stream$4.merge = void 0;
const merge2 = merge2_1;
function merge(streams) {
    const mergedStream = merge2(streams);
    streams.forEach((stream) => {
        stream.once('error', (error) => mergedStream.emit('error', error));
    });
    mergedStream.once('close', () => propagateCloseEventToSources(streams));
    mergedStream.once('end', () => propagateCloseEventToSources(streams));
    return mergedStream;
}
stream$4.merge = merge;
function propagateCloseEventToSources(streams) {
    streams.forEach((stream) => stream.emit('close'));
}

var string$1 = {};

Object.defineProperty(string$1, "__esModule", { value: true });
string$1.isEmpty = string$1.isString = void 0;
function isString(input) {
    return typeof input === 'string';
}
string$1.isString = isString;
function isEmpty(input) {
    return input === '';
}
string$1.isEmpty = isEmpty;

Object.defineProperty(utils$m, "__esModule", { value: true });
utils$m.string = utils$m.stream = utils$m.pattern = utils$m.path = utils$m.fs = utils$m.errno = utils$m.array = void 0;
const array = array$1;
utils$m.array = array;
const errno = errno$1;
utils$m.errno = errno;
const fs$p = fs$q;
utils$m.fs = fs$p;
const path$h = path$m;
utils$m.path = path$h;
const pattern = pattern$1;
utils$m.pattern = pattern;
const stream$3 = stream$4;
utils$m.stream = stream$3;
const string = string$1;
utils$m.string = string;

Object.defineProperty(tasks, "__esModule", { value: true });
tasks.convertPatternGroupToTask = tasks.convertPatternGroupsToTasks = tasks.groupPatternsByBaseDirectory = tasks.getNegativePatternsAsPositive = tasks.getPositivePatterns = tasks.convertPatternsToTasks = tasks.generate = void 0;
const utils$c = utils$m;
function generate(patterns, settings) {
    const positivePatterns = getPositivePatterns(patterns);
    const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
    const staticPatterns = positivePatterns.filter((pattern) => utils$c.pattern.isStaticPattern(pattern, settings));
    const dynamicPatterns = positivePatterns.filter((pattern) => utils$c.pattern.isDynamicPattern(pattern, settings));
    const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */ false);
    const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */ true);
    return staticTasks.concat(dynamicTasks);
}
tasks.generate = generate;
/**
 * Returns tasks grouped by basic pattern directories.
 *
 * Patterns that can be found inside (`./`) and outside (`../`) the current directory are handled separately.
 * This is necessary because directory traversal starts at the base directory and goes deeper.
 */
function convertPatternsToTasks(positive, negative, dynamic) {
    const tasks = [];
    const patternsOutsideCurrentDirectory = utils$c.pattern.getPatternsOutsideCurrentDirectory(positive);
    const patternsInsideCurrentDirectory = utils$c.pattern.getPatternsInsideCurrentDirectory(positive);
    const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
    const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
    tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
    /*
     * For the sake of reducing future accesses to the file system, we merge all tasks within the current directory
     * into a global task, if at least one pattern refers to the root (`.`). In this case, the global task covers the rest.
     */
    if ('.' in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask('.', patternsInsideCurrentDirectory, negative, dynamic));
    }
    else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
    }
    return tasks;
}
tasks.convertPatternsToTasks = convertPatternsToTasks;
function getPositivePatterns(patterns) {
    return utils$c.pattern.getPositivePatterns(patterns);
}
tasks.getPositivePatterns = getPositivePatterns;
function getNegativePatternsAsPositive(patterns, ignore) {
    const negative = utils$c.pattern.getNegativePatterns(patterns).concat(ignore);
    const positive = negative.map(utils$c.pattern.convertToPositivePattern);
    return positive;
}
tasks.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
function groupPatternsByBaseDirectory(patterns) {
    const group = {};
    return patterns.reduce((collection, pattern) => {
        const base = utils$c.pattern.getBaseDirectory(pattern);
        if (base in collection) {
            collection[base].push(pattern);
        }
        else {
            collection[base] = [pattern];
        }
        return collection;
    }, group);
}
tasks.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
function convertPatternGroupsToTasks(positive, negative, dynamic) {
    return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
    });
}
tasks.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
function convertPatternGroupToTask(base, positive, negative, dynamic) {
    return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils$c.pattern.convertToNegativePattern))
    };
}
tasks.convertPatternGroupToTask = convertPatternGroupToTask;

var patterns = {};

Object.defineProperty(patterns, "__esModule", { value: true });
patterns.removeDuplicateSlashes = patterns.transform = void 0;
/**
 * Matches a sequence of two or more consecutive slashes, excluding the first two slashes at the beginning of the string.
 * The latter is due to the presence of the device path at the beginning of the UNC path.
 * @todo rewrite to negative lookbehind with the next major release.
 */
const DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
function transform(patterns) {
    return patterns.map((pattern) => removeDuplicateSlashes(pattern));
}
patterns.transform = transform;
/**
 * This package only works with forward slashes as a path separator.
 * Because of this, we cannot use the standard `path.normalize` method, because on Windows platform it will use of backslashes.
 */
function removeDuplicateSlashes(pattern) {
    return pattern.replace(DOUBLE_SLASH_RE, '/');
}
patterns.removeDuplicateSlashes = removeDuplicateSlashes;

var async$6 = {};

var stream$2 = {};

var out$3 = {};

var async$5 = {};

Object.defineProperty(async$5, "__esModule", { value: true });
async$5.read = void 0;
function read$3(path, settings, callback) {
    settings.fs.lstat(path, (lstatError, lstat) => {
        if (lstatError !== null) {
            callFailureCallback$2(callback, lstatError);
            return;
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
            callSuccessCallback$2(callback, lstat);
            return;
        }
        settings.fs.stat(path, (statError, stat) => {
            if (statError !== null) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    callFailureCallback$2(callback, statError);
                    return;
                }
                callSuccessCallback$2(callback, lstat);
                return;
            }
            if (settings.markSymbolicLink) {
                stat.isSymbolicLink = () => true;
            }
            callSuccessCallback$2(callback, stat);
        });
    });
}
async$5.read = read$3;
function callFailureCallback$2(callback, error) {
    callback(error);
}
function callSuccessCallback$2(callback, result) {
    callback(null, result);
}

var sync$7 = {};

Object.defineProperty(sync$7, "__esModule", { value: true });
sync$7.read = void 0;
function read$2(path, settings) {
    const lstat = settings.fs.lstatSync(path);
    if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
    }
    try {
        const stat = settings.fs.statSync(path);
        if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
        }
        return stat;
    }
    catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
            return lstat;
        }
        throw error;
    }
}
sync$7.read = read$2;

var settings$3 = {};

var fs$o = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
const fs = fs__default["default"];
exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync
};
function createFileSystemAdapter(fsMethods) {
    if (fsMethods === undefined) {
        return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
}
exports.createFileSystemAdapter = createFileSystemAdapter;
}(fs$o));

Object.defineProperty(settings$3, "__esModule", { value: true });
const fs$n = fs$o;
class Settings$2 {
    constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs$n.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
    }
    _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
    }
}
settings$3.default = Settings$2;

Object.defineProperty(out$3, "__esModule", { value: true });
out$3.statSync = out$3.stat = out$3.Settings = void 0;
const async$4 = async$5;
const sync$6 = sync$7;
const settings_1$3 = settings$3;
out$3.Settings = settings_1$3.default;
function stat$5(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        async$4.read(path, getSettings$2(), optionsOrSettingsOrCallback);
        return;
    }
    async$4.read(path, getSettings$2(optionsOrSettingsOrCallback), callback);
}
out$3.stat = stat$5;
function statSync(path, optionsOrSettings) {
    const settings = getSettings$2(optionsOrSettings);
    return sync$6.read(path, settings);
}
out$3.statSync = statSync;
function getSettings$2(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1$3.default) {
        return settingsOrOptions;
    }
    return new settings_1$3.default(settingsOrOptions);
}

var out$2 = {};

var async$3 = {};

var async$2 = {};

var out$1 = {};

var async$1 = {};

/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

let promise;

var queueMicrotask_1 = typeof queueMicrotask === 'function'
  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : commonjsGlobal)
  // reuse resolved promise, and allocate it lazily
  : cb => (promise || (promise = Promise.resolve()))
    .then(cb)
    .catch(err => setTimeout(() => { throw err }, 0));

/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

var runParallel_1 = runParallel;

const queueMicrotask$1 = queueMicrotask_1;

function runParallel (tasks, cb) {
  let results, pending, keys;
  let isSync = true;

  if (Array.isArray(tasks)) {
    results = [];
    pending = tasks.length;
  } else {
    keys = Object.keys(tasks);
    results = {};
    pending = keys.length;
  }

  function done (err) {
    function end () {
      if (cb) cb(err, results);
      cb = null;
    }
    if (isSync) queueMicrotask$1(end);
    else end();
  }

  function each (i, err, result) {
    results[i] = result;
    if (--pending === 0 || err) {
      done(err);
    }
  }

  if (!pending) {
    // empty
    done(null);
  } else if (keys) {
    // object
    keys.forEach(function (key) {
      tasks[key](function (err, result) { each(key, err, result); });
    });
  } else {
    // array
    tasks.forEach(function (task, i) {
      task(function (err, result) { each(i, err, result); });
    });
  }

  isSync = false;
}

var constants$1 = {};

Object.defineProperty(constants$1, "__esModule", { value: true });
constants$1.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
const NODE_PROCESS_VERSION_PARTS = process.versions.node.split('.');
if (NODE_PROCESS_VERSION_PARTS[0] === undefined || NODE_PROCESS_VERSION_PARTS[1] === undefined) {
    throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
}
const MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
const MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
const SUPPORTED_MAJOR_VERSION = 10;
const SUPPORTED_MINOR_VERSION = 10;
const IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
const IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
/**
 * IS `true` for Node.js 10.10 and greater.
 */
constants$1.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;

var utils$b = {};

var fs$m = {};

Object.defineProperty(fs$m, "__esModule", { value: true });
fs$m.createDirentFromStats = void 0;
class DirentFromStats {
    constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
}
function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
}
fs$m.createDirentFromStats = createDirentFromStats;

Object.defineProperty(utils$b, "__esModule", { value: true });
utils$b.fs = void 0;
const fs$l = fs$m;
utils$b.fs = fs$l;

var common$7 = {};

Object.defineProperty(common$7, "__esModule", { value: true });
common$7.joinPathSegments = void 0;
function joinPathSegments$1(a, b, separator) {
    /**
     * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).
     */
    if (a.endsWith(separator)) {
        return a + b;
    }
    return a + separator + b;
}
common$7.joinPathSegments = joinPathSegments$1;

Object.defineProperty(async$1, "__esModule", { value: true });
async$1.readdir = async$1.readdirWithFileTypes = async$1.read = void 0;
const fsStat$5 = out$3;
const rpl = runParallel_1;
const constants_1$1 = constants$1;
const utils$a = utils$b;
const common$6 = common$7;
function read$1(directory, settings, callback) {
    if (!settings.stats && constants_1$1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes$1(directory, settings, callback);
        return;
    }
    readdir$1(directory, settings, callback);
}
async$1.read = read$1;
function readdirWithFileTypes$1(directory, settings, callback) {
    settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
            callFailureCallback$1(callback, readdirError);
            return;
        }
        const entries = dirents.map((dirent) => ({
            dirent,
            name: dirent.name,
            path: common$6.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
            callSuccessCallback$1(callback, entries);
            return;
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
            if (rplError !== null) {
                callFailureCallback$1(callback, rplError);
                return;
            }
            callSuccessCallback$1(callback, rplEntries);
        });
    });
}
async$1.readdirWithFileTypes = readdirWithFileTypes$1;
function makeRplTaskEntry(entry, settings) {
    return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
            done(null, entry);
            return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
            if (statError !== null) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    done(statError);
                    return;
                }
                done(null, entry);
                return;
            }
            entry.dirent = utils$a.fs.createDirentFromStats(entry.name, stats);
            done(null, entry);
        });
    };
}
function readdir$1(directory, settings, callback) {
    settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
            callFailureCallback$1(callback, readdirError);
            return;
        }
        const tasks = names.map((name) => {
            const path = common$6.joinPathSegments(directory, name, settings.pathSegmentSeparator);
            return (done) => {
                fsStat$5.stat(path, settings.fsStatSettings, (error, stats) => {
                    if (error !== null) {
                        done(error);
                        return;
                    }
                    const entry = {
                        name,
                        path,
                        dirent: utils$a.fs.createDirentFromStats(name, stats)
                    };
                    if (settings.stats) {
                        entry.stats = stats;
                    }
                    done(null, entry);
                });
            };
        });
        rpl(tasks, (rplError, entries) => {
            if (rplError !== null) {
                callFailureCallback$1(callback, rplError);
                return;
            }
            callSuccessCallback$1(callback, entries);
        });
    });
}
async$1.readdir = readdir$1;
function callFailureCallback$1(callback, error) {
    callback(error);
}
function callSuccessCallback$1(callback, result) {
    callback(null, result);
}

var sync$5 = {};

Object.defineProperty(sync$5, "__esModule", { value: true });
sync$5.readdir = sync$5.readdirWithFileTypes = sync$5.read = void 0;
const fsStat$4 = out$3;
const constants_1 = constants$1;
const utils$9 = utils$b;
const common$5 = common$7;
function read(directory, settings) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
    }
    return readdir(directory, settings);
}
sync$5.read = read;
function readdirWithFileTypes(directory, settings) {
    const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
    return dirents.map((dirent) => {
        const entry = {
            dirent,
            name: dirent.name,
            path: common$5.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
            try {
                const stats = settings.fs.statSync(entry.path);
                entry.dirent = utils$9.fs.createDirentFromStats(entry.name, stats);
            }
            catch (error) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    throw error;
                }
            }
        }
        return entry;
    });
}
sync$5.readdirWithFileTypes = readdirWithFileTypes;
function readdir(directory, settings) {
    const names = settings.fs.readdirSync(directory);
    return names.map((name) => {
        const entryPath = common$5.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat$4.statSync(entryPath, settings.fsStatSettings);
        const entry = {
            name,
            path: entryPath,
            dirent: utils$9.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
            entry.stats = stats;
        }
        return entry;
    });
}
sync$5.readdir = readdir;

var settings$2 = {};

var fs$k = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
const fs = fs__default["default"];
exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
};
function createFileSystemAdapter(fsMethods) {
    if (fsMethods === undefined) {
        return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
}
exports.createFileSystemAdapter = createFileSystemAdapter;
}(fs$k));

Object.defineProperty(settings$2, "__esModule", { value: true });
const path$g = require$$0__default$1["default"];
const fsStat$3 = out$3;
const fs$j = fs$k;
class Settings$1 {
    constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs$j.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path$g.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat$3.Settings({
            followSymbolicLink: this.followSymbolicLinks,
            fs: this.fs,
            throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
    }
    _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
    }
}
settings$2.default = Settings$1;

Object.defineProperty(out$1, "__esModule", { value: true });
out$1.Settings = out$1.scandirSync = out$1.scandir = void 0;
const async = async$1;
const sync$4 = sync$5;
const settings_1$2 = settings$2;
out$1.Settings = settings_1$2.default;
function scandir(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        async.read(path, getSettings$1(), optionsOrSettingsOrCallback);
        return;
    }
    async.read(path, getSettings$1(optionsOrSettingsOrCallback), callback);
}
out$1.scandir = scandir;
function scandirSync(path, optionsOrSettings) {
    const settings = getSettings$1(optionsOrSettings);
    return sync$4.read(path, settings);
}
out$1.scandirSync = scandirSync;
function getSettings$1(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1$2.default) {
        return settingsOrOptions;
    }
    return new settings_1$2.default(settingsOrOptions);
}

var queue$1 = {exports: {}};

function reusify$1 (Constructor) {
  var head = new Constructor();
  var tail = head;

  function get () {
    var current = head;

    if (current.next) {
      head = current.next;
    } else {
      head = new Constructor();
      tail = head;
    }

    current.next = null;

    return current
  }

  function release (obj) {
    tail.next = obj;
    tail = obj;
  }

  return {
    get: get,
    release: release
  }
}

var reusify_1 = reusify$1;

/* eslint-disable no-var */

var reusify = reusify_1;

function fastqueue (context, worker, concurrency) {
  if (typeof context === 'function') {
    concurrency = worker;
    worker = context;
    context = null;
  }

  if (concurrency < 1) {
    throw new Error('fastqueue concurrency must be greater than 1')
  }

  var cache = reusify(Task);
  var queueHead = null;
  var queueTail = null;
  var _running = 0;
  var errorHandler = null;

  var self = {
    push: push,
    drain: noop$1,
    saturated: noop$1,
    pause: pause,
    paused: false,
    concurrency: concurrency,
    running: running,
    resume: resume,
    idle: idle,
    length: length,
    getQueue: getQueue,
    unshift: unshift,
    empty: noop$1,
    kill: kill,
    killAndDrain: killAndDrain,
    error: error
  };

  return self

  function running () {
    return _running
  }

  function pause () {
    self.paused = true;
  }

  function length () {
    var current = queueHead;
    var counter = 0;

    while (current) {
      current = current.next;
      counter++;
    }

    return counter
  }

  function getQueue () {
    var current = queueHead;
    var tasks = [];

    while (current) {
      tasks.push(current.value);
      current = current.next;
    }

    return tasks
  }

  function resume () {
    if (!self.paused) return
    self.paused = false;
    for (var i = 0; i < self.concurrency; i++) {
      _running++;
      release();
    }
  }

  function idle () {
    return _running === 0 && self.length() === 0
  }

  function push (value, done) {
    var current = cache.get();

    current.context = context;
    current.release = release;
    current.value = value;
    current.callback = done || noop$1;
    current.errorHandler = errorHandler;

    if (_running === self.concurrency || self.paused) {
      if (queueTail) {
        queueTail.next = current;
        queueTail = current;
      } else {
        queueHead = current;
        queueTail = current;
        self.saturated();
      }
    } else {
      _running++;
      worker.call(context, current.value, current.worked);
    }
  }

  function unshift (value, done) {
    var current = cache.get();

    current.context = context;
    current.release = release;
    current.value = value;
    current.callback = done || noop$1;

    if (_running === self.concurrency || self.paused) {
      if (queueHead) {
        current.next = queueHead;
        queueHead = current;
      } else {
        queueHead = current;
        queueTail = current;
        self.saturated();
      }
    } else {
      _running++;
      worker.call(context, current.value, current.worked);
    }
  }

  function release (holder) {
    if (holder) {
      cache.release(holder);
    }
    var next = queueHead;
    if (next) {
      if (!self.paused) {
        if (queueTail === queueHead) {
          queueTail = null;
        }
        queueHead = next.next;
        next.next = null;
        worker.call(context, next.value, next.worked);
        if (queueTail === null) {
          self.empty();
        }
      } else {
        _running--;
      }
    } else if (--_running === 0) {
      self.drain();
    }
  }

  function kill () {
    queueHead = null;
    queueTail = null;
    self.drain = noop$1;
  }

  function killAndDrain () {
    queueHead = null;
    queueTail = null;
    self.drain();
    self.drain = noop$1;
  }

  function error (handler) {
    errorHandler = handler;
  }
}

function noop$1 () {}

function Task () {
  this.value = null;
  this.callback = noop$1;
  this.next = null;
  this.release = noop$1;
  this.context = null;
  this.errorHandler = null;

  var self = this;

  this.worked = function worked (err, result) {
    var callback = self.callback;
    var errorHandler = self.errorHandler;
    var val = self.value;
    self.value = null;
    self.callback = noop$1;
    if (self.errorHandler) {
      errorHandler(err, val);
    }
    callback.call(self.context, err, result);
    self.release(self);
  };
}

function queueAsPromised (context, worker, concurrency) {
  if (typeof context === 'function') {
    concurrency = worker;
    worker = context;
    context = null;
  }

  function asyncWrapper (arg, cb) {
    worker.call(this, arg)
      .then(function (res) {
        cb(null, res);
      }, cb);
  }

  var queue = fastqueue(context, asyncWrapper, concurrency);

  var pushCb = queue.push;
  var unshiftCb = queue.unshift;

  queue.push = push;
  queue.unshift = unshift;
  queue.drained = drained;

  return queue

  function push (value) {
    var p = new Promise(function (resolve, reject) {
      pushCb(value, function (err, result) {
        if (err) {
          reject(err);
          return
        }
        resolve(result);
      });
    });

    // Let's fork the promise chain to
    // make the error bubble up to the user but
    // not lead to a unhandledRejection
    p.catch(noop$1);

    return p
  }

  function unshift (value) {
    var p = new Promise(function (resolve, reject) {
      unshiftCb(value, function (err, result) {
        if (err) {
          reject(err);
          return
        }
        resolve(result);
      });
    });

    // Let's fork the promise chain to
    // make the error bubble up to the user but
    // not lead to a unhandledRejection
    p.catch(noop$1);

    return p
  }

  function drained () {
    var previousDrain = queue.drain;

    var p = new Promise(function (resolve) {
      queue.drain = function () {
        previousDrain();
        resolve();
      };
    });

    return p
  }
}

queue$1.exports = fastqueue;
queue$1.exports.promise = queueAsPromised;

var common$4 = {};

Object.defineProperty(common$4, "__esModule", { value: true });
common$4.joinPathSegments = common$4.replacePathSegmentSeparator = common$4.isAppliedFilter = common$4.isFatalError = void 0;
function isFatalError(settings, error) {
    if (settings.errorFilter === null) {
        return true;
    }
    return !settings.errorFilter(error);
}
common$4.isFatalError = isFatalError;
function isAppliedFilter(filter, value) {
    return filter === null || filter(value);
}
common$4.isAppliedFilter = isAppliedFilter;
function replacePathSegmentSeparator(filepath, separator) {
    return filepath.split(/[/\\]/).join(separator);
}
common$4.replacePathSegmentSeparator = replacePathSegmentSeparator;
function joinPathSegments(a, b, separator) {
    if (a === '') {
        return b;
    }
    /**
     * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).
     */
    if (a.endsWith(separator)) {
        return a + b;
    }
    return a + separator + b;
}
common$4.joinPathSegments = joinPathSegments;

var reader$1 = {};

Object.defineProperty(reader$1, "__esModule", { value: true });
const common$3 = common$4;
class Reader$1 {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common$3.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
    }
}
reader$1.default = Reader$1;

Object.defineProperty(async$2, "__esModule", { value: true });
const events_1 = require$$0__default$4["default"];
const fsScandir$2 = out$1;
const fastq = queue$1.exports;
const common$2 = common$4;
const reader_1$3 = reader$1;
class AsyncReader extends reader_1$3.default {
    constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir$2.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
            if (!this._isFatalError) {
                this._emitter.emit('end');
            }
        };
    }
    read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
            this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
    }
    get isDestroyed() {
        return this._isDestroyed;
    }
    destroy() {
        if (this._isDestroyed) {
            throw new Error('The reader is already destroyed');
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
    }
    onEntry(callback) {
        this._emitter.on('entry', callback);
    }
    onError(callback) {
        this._emitter.once('error', callback);
    }
    onEnd(callback) {
        this._emitter.once('end', callback);
    }
    _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
            if (error !== null) {
                this._handleError(error);
            }
        });
    }
    _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
            if (error !== null) {
                done(error, undefined);
                return;
            }
            for (const entry of entries) {
                this._handleEntry(entry, item.base);
            }
            done(null, undefined);
        });
    }
    _handleError(error) {
        if (this._isDestroyed || !common$2.isFatalError(this._settings, error)) {
            return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit('error', error);
    }
    _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
            return;
        }
        const fullpath = entry.path;
        if (base !== undefined) {
            entry.path = common$2.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common$2.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common$2.isAppliedFilter(this._settings.deepFilter, entry)) {
            this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);
        }
    }
    _emitEntry(entry) {
        this._emitter.emit('entry', entry);
    }
}
async$2.default = AsyncReader;

Object.defineProperty(async$3, "__esModule", { value: true });
const async_1$3 = async$2;
class AsyncProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1$3.default(this._root, this._settings);
        this._storage = [];
    }
    read(callback) {
        this._reader.onError((error) => {
            callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
            this._storage.push(entry);
        });
        this._reader.onEnd(() => {
            callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
    }
}
async$3.default = AsyncProvider;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, entries) {
    callback(null, entries);
}

var stream$1 = {};

Object.defineProperty(stream$1, "__esModule", { value: true });
const stream_1$5 = require$$0__default$3["default"];
const async_1$2 = async$2;
class StreamProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1$2.default(this._root, this._settings);
        this._stream = new stream_1$5.Readable({
            objectMode: true,
            read: () => { },
            destroy: () => {
                if (!this._reader.isDestroyed) {
                    this._reader.destroy();
                }
            }
        });
    }
    read() {
        this._reader.onError((error) => {
            this._stream.emit('error', error);
        });
        this._reader.onEntry((entry) => {
            this._stream.push(entry);
        });
        this._reader.onEnd(() => {
            this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
    }
}
stream$1.default = StreamProvider;

var sync$3 = {};

var sync$2 = {};

Object.defineProperty(sync$2, "__esModule", { value: true });
const fsScandir$1 = out$1;
const common$1 = common$4;
const reader_1$2 = reader$1;
class SyncReader extends reader_1$2.default {
    constructor() {
        super(...arguments);
        this._scandir = fsScandir$1.scandirSync;
        this._storage = [];
        this._queue = new Set();
    }
    read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
    }
    _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
    }
    _handleQueue() {
        for (const item of this._queue.values()) {
            this._handleDirectory(item.directory, item.base);
        }
    }
    _handleDirectory(directory, base) {
        try {
            const entries = this._scandir(directory, this._settings.fsScandirSettings);
            for (const entry of entries) {
                this._handleEntry(entry, base);
            }
        }
        catch (error) {
            this._handleError(error);
        }
    }
    _handleError(error) {
        if (!common$1.isFatalError(this._settings, error)) {
            return;
        }
        throw error;
    }
    _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== undefined) {
            entry.path = common$1.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common$1.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common$1.isAppliedFilter(this._settings.deepFilter, entry)) {
            this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);
        }
    }
    _pushToStorage(entry) {
        this._storage.push(entry);
    }
}
sync$2.default = SyncReader;

Object.defineProperty(sync$3, "__esModule", { value: true });
const sync_1$3 = sync$2;
class SyncProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1$3.default(this._root, this._settings);
    }
    read() {
        return this._reader.read();
    }
}
sync$3.default = SyncProvider;

var settings$1 = {};

Object.defineProperty(settings$1, "__esModule", { value: true });
const path$f = require$$0__default$1["default"];
const fsScandir = out$1;
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, undefined);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path$f.sep);
        this.fsScandirSettings = new fsScandir.Settings({
            followSymbolicLinks: this._options.followSymbolicLinks,
            fs: this._options.fs,
            pathSegmentSeparator: this._options.pathSegmentSeparator,
            stats: this._options.stats,
            throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
    }
    _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
    }
}
settings$1.default = Settings;

Object.defineProperty(out$2, "__esModule", { value: true });
out$2.Settings = out$2.walkStream = out$2.walkSync = out$2.walk = void 0;
const async_1$1 = async$3;
const stream_1$4 = stream$1;
const sync_1$2 = sync$3;
const settings_1$1 = settings$1;
out$2.Settings = settings_1$1.default;
function walk(directory, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        new async_1$1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
    }
    new async_1$1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
}
out$2.walk = walk;
function walkSync(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new sync_1$2.default(directory, settings);
    return provider.read();
}
out$2.walkSync = walkSync;
function walkStream(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new stream_1$4.default(directory, settings);
    return provider.read();
}
out$2.walkStream = walkStream;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1$1.default) {
        return settingsOrOptions;
    }
    return new settings_1$1.default(settingsOrOptions);
}

var reader = {};

Object.defineProperty(reader, "__esModule", { value: true });
const path$e = require$$0__default$1["default"];
const fsStat$2 = out$3;
const utils$8 = utils$m;
class Reader {
    constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat$2.Settings({
            followSymbolicLink: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
    }
    _getFullEntryPath(filepath) {
        return path$e.resolve(this._settings.cwd, filepath);
    }
    _makeEntry(stats, pattern) {
        const entry = {
            name: pattern,
            path: pattern,
            dirent: utils$8.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
            entry.stats = stats;
        }
        return entry;
    }
    _isFatalError(error) {
        return !utils$8.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
    }
}
reader.default = Reader;

Object.defineProperty(stream$2, "__esModule", { value: true });
const stream_1$3 = require$$0__default$3["default"];
const fsStat$1 = out$3;
const fsWalk$1 = out$2;
const reader_1$1 = reader;
class ReaderStream extends reader_1$1.default {
    constructor() {
        super(...arguments);
        this._walkStream = fsWalk$1.walkStream;
        this._stat = fsStat$1.stat;
    }
    dynamic(root, options) {
        return this._walkStream(root, options);
    }
    static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1$3.PassThrough({ objectMode: true });
        stream._write = (index, _enc, done) => {
            return this._getEntry(filepaths[index], patterns[index], options)
                .then((entry) => {
                if (entry !== null && options.entryFilter(entry)) {
                    stream.push(entry);
                }
                if (index === filepaths.length - 1) {
                    stream.end();
                }
                done();
            })
                .catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
            stream.write(i);
        }
        return stream;
    }
    _getEntry(filepath, pattern, options) {
        return this._getStat(filepath)
            .then((stats) => this._makeEntry(stats, pattern))
            .catch((error) => {
            if (options.errorFilter(error)) {
                return null;
            }
            throw error;
        });
    }
    _getStat(filepath) {
        return new Promise((resolve, reject) => {
            this._stat(filepath, this._fsStatSettings, (error, stats) => {
                return error === null ? resolve(stats) : reject(error);
            });
        });
    }
}
stream$2.default = ReaderStream;

var provider = {};

var deep = {};

var partial = {};

var matcher = {};

Object.defineProperty(matcher, "__esModule", { value: true });
const utils$7 = utils$m;
class Matcher {
    constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
    }
    _fillStorage() {
        /**
         * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).
         * So, before expand patterns with brace expansion into separated patterns.
         */
        const patterns = utils$7.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern of patterns) {
            const segments = this._getPatternSegments(pattern);
            const sections = this._splitSegmentsIntoSections(segments);
            this._storage.push({
                complete: sections.length <= 1,
                pattern,
                segments,
                sections
            });
        }
    }
    _getPatternSegments(pattern) {
        const parts = utils$7.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
            const dynamic = utils$7.pattern.isDynamicPattern(part, this._settings);
            if (!dynamic) {
                return {
                    dynamic: false,
                    pattern: part
                };
            }
            return {
                dynamic: true,
                pattern: part,
                patternRe: utils$7.pattern.makeRe(part, this._micromatchOptions)
            };
        });
    }
    _splitSegmentsIntoSections(segments) {
        return utils$7.array.splitWhen(segments, (segment) => segment.dynamic && utils$7.pattern.hasGlobStar(segment.pattern));
    }
}
matcher.default = Matcher;

Object.defineProperty(partial, "__esModule", { value: true });
const matcher_1 = matcher;
class PartialMatcher extends matcher_1.default {
    match(filepath) {
        const parts = filepath.split('/');
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
            const section = pattern.sections[0];
            /**
             * In this case, the pattern has a globstar and we must read all directories unconditionally,
             * but only if the level has reached the end of the first group.
             *
             * fixtures/{a,b}/**
             *  ^ true/false  ^ always true
            */
            if (!pattern.complete && levels > section.length) {
                return true;
            }
            const match = parts.every((part, index) => {
                const segment = pattern.segments[index];
                if (segment.dynamic && segment.patternRe.test(part)) {
                    return true;
                }
                if (!segment.dynamic && segment.pattern === part) {
                    return true;
                }
                return false;
            });
            if (match) {
                return true;
            }
        }
        return false;
    }
}
partial.default = PartialMatcher;

Object.defineProperty(deep, "__esModule", { value: true });
const utils$6 = utils$m;
const partial_1 = partial;
class DeepFilter {
    constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
    }
    getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
    }
    _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
    }
    _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils$6.pattern.isAffectDepthOfReadingPattern);
        return utils$6.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
    }
    _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
            return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
            return false;
        }
        const filepath = utils$6.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
            return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
    }
    _isSkippedByDeep(basePath, entryPath) {
        /**
         * Avoid unnecessary depth calculations when it doesn't matter.
         */
        if (this._settings.deep === Infinity) {
            return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
    }
    _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split('/').length;
        if (basePath === '') {
            return entryPathDepth;
        }
        const basePathDepth = basePath.split('/').length;
        return entryPathDepth - basePathDepth;
    }
    _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
    }
    _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
    }
    _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils$6.pattern.matchAny(entryPath, patternsRe);
    }
}
deep.default = DeepFilter;

var entry$1 = {};

Object.defineProperty(entry$1, "__esModule", { value: true });
const utils$5 = utils$m;
class EntryFilter {
    constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = new Map();
    }
    getFilter(positive, negative) {
        const positiveRe = utils$5.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils$5.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry) => this._filter(entry, positiveRe, negativeRe);
    }
    _filter(entry, positiveRe, negativeRe) {
        if (this._settings.unique && this._isDuplicateEntry(entry)) {
            return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
            return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
            return false;
        }
        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
        const isMatched = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);
        if (this._settings.unique && isMatched) {
            this._createIndexRecord(entry);
        }
        return isMatched;
    }
    _isDuplicateEntry(entry) {
        return this.index.has(entry.path);
    }
    _createIndexRecord(entry) {
        this.index.set(entry.path, undefined);
    }
    _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
    }
    _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
    }
    _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
            return false;
        }
        const fullpath = utils$5.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils$5.pattern.matchAny(fullpath, patternsRe);
    }
    /**
     * First, just trying to apply patterns to the path.
     * Second, trying to apply patterns to the path with final slash.
     */
    _isMatchToPatterns(entryPath, patternsRe) {
        const filepath = utils$5.path.removeLeadingDotSegment(entryPath);
        return utils$5.pattern.matchAny(filepath, patternsRe) || utils$5.pattern.matchAny(filepath + '/', patternsRe);
    }
}
entry$1.default = EntryFilter;

var error = {};

Object.defineProperty(error, "__esModule", { value: true });
const utils$4 = utils$m;
class ErrorFilter {
    constructor(_settings) {
        this._settings = _settings;
    }
    getFilter() {
        return (error) => this._isNonFatalError(error);
    }
    _isNonFatalError(error) {
        return utils$4.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
    }
}
error.default = ErrorFilter;

var entry = {};

Object.defineProperty(entry, "__esModule", { value: true });
const utils$3 = utils$m;
class EntryTransformer {
    constructor(_settings) {
        this._settings = _settings;
    }
    getTransformer() {
        return (entry) => this._transform(entry);
    }
    _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
            filepath = utils$3.path.makeAbsolute(this._settings.cwd, filepath);
            filepath = utils$3.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
            filepath += '/';
        }
        if (!this._settings.objectMode) {
            return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
    }
}
entry.default = EntryTransformer;

Object.defineProperty(provider, "__esModule", { value: true });
const path$d = require$$0__default$1["default"];
const deep_1 = deep;
const entry_1 = entry$1;
const error_1 = error;
const entry_2 = entry;
class Provider {
    constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
    }
    _getRootDirectory(task) {
        return path$d.resolve(this._settings.cwd, task.base);
    }
    _getReaderOptions(task) {
        const basePath = task.base === '.' ? '' : task.base;
        return {
            basePath,
            pathSegmentSeparator: '/',
            concurrency: this._settings.concurrency,
            deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
            entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
            errorFilter: this.errorFilter.getFilter(),
            followSymbolicLinks: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            stats: this._settings.stats,
            throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
            transform: this.entryTransformer.getTransformer()
        };
    }
    _getMicromatchOptions() {
        return {
            dot: this._settings.dot,
            matchBase: this._settings.baseNameMatch,
            nobrace: !this._settings.braceExpansion,
            nocase: !this._settings.caseSensitiveMatch,
            noext: !this._settings.extglob,
            noglobstar: !this._settings.globstar,
            posix: true,
            strictSlashes: false
        };
    }
}
provider.default = Provider;

Object.defineProperty(async$6, "__esModule", { value: true });
const stream_1$2 = stream$2;
const provider_1$2 = provider;
class ProviderAsync extends provider_1$2.default {
    constructor() {
        super(...arguments);
        this._reader = new stream_1$2.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = [];
        return new Promise((resolve, reject) => {
            const stream = this.api(root, task, options);
            stream.once('error', reject);
            stream.on('data', (entry) => entries.push(options.transform(entry)));
            stream.once('end', () => resolve(entries));
        });
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
async$6.default = ProviderAsync;

var stream = {};

Object.defineProperty(stream, "__esModule", { value: true });
const stream_1$1 = require$$0__default$3["default"];
const stream_2 = stream$2;
const provider_1$1 = provider;
class ProviderStream extends provider_1$1.default {
    constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1$1.Readable({ objectMode: true, read: () => { } });
        source
            .once('error', (error) => destination.emit('error', error))
            .on('data', (entry) => destination.emit('data', options.transform(entry)))
            .once('end', () => destination.emit('end'));
        destination
            .once('close', () => source.destroy());
        return destination;
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
stream.default = ProviderStream;

var sync$1 = {};

var sync = {};

Object.defineProperty(sync, "__esModule", { value: true });
const fsStat = out$3;
const fsWalk = out$2;
const reader_1 = reader;
class ReaderSync extends reader_1.default {
    constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
    }
    dynamic(root, options) {
        return this._walkSync(root, options);
    }
    static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
            const filepath = this._getFullEntryPath(pattern);
            const entry = this._getEntry(filepath, pattern, options);
            if (entry === null || !options.entryFilter(entry)) {
                continue;
            }
            entries.push(entry);
        }
        return entries;
    }
    _getEntry(filepath, pattern, options) {
        try {
            const stats = this._getStat(filepath);
            return this._makeEntry(stats, pattern);
        }
        catch (error) {
            if (options.errorFilter(error)) {
                return null;
            }
            throw error;
        }
    }
    _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
    }
}
sync.default = ReaderSync;

Object.defineProperty(sync$1, "__esModule", { value: true });
const sync_1$1 = sync;
const provider_1 = provider;
class ProviderSync extends provider_1.default {
    constructor() {
        super(...arguments);
        this._reader = new sync_1$1.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
sync$1.default = ProviderSync;

var settings = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
const fs = fs__default["default"];
const os = require$$5__default["default"];
/**
 * The `os.cpus` method can return zero. We expect the number of cores to be greater than zero.
 * https://github.com/nodejs/node/blob/7faeddf23a98c53896f8b574a6e66589e8fb1eb8/lib/os.js#L106-L107
 */
const CPU_COUNT = Math.max(os.cpus().length, 1);
exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    lstatSync: fs.lstatSync,
    stat: fs.stat,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
};
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
            this.onlyFiles = false;
        }
        if (this.stats) {
            this.objectMode = true;
        }
    }
    _getValue(option, value) {
        return option === undefined ? value : option;
    }
    _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
    }
}
exports.default = Settings;
}(settings));

const taskManager = tasks;
const patternManager = patterns;
const async_1 = async$6;
const stream_1 = stream;
const sync_1 = sync$1;
const settings_1 = settings;
const utils$2 = utils$m;
async function FastGlob(source, options) {
    assertPatternsInput(source);
    const works = getWorks(source, async_1.default, options);
    const result = await Promise.all(works);
    return utils$2.array.flatten(result);
}
// https://github.com/typescript-eslint/typescript-eslint/issues/60
// eslint-disable-next-line no-redeclare
(function (FastGlob) {
    function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils$2.array.flatten(works);
    }
    FastGlob.sync = sync;
    function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        /**
         * The stream returned by the provider cannot work with an asynchronous iterator.
         * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.
         * This affects performance (+25%). I don't see best solution right now.
         */
        return utils$2.stream.merge(works);
    }
    FastGlob.stream = stream;
    function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = patternManager.transform([].concat(source));
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
    }
    FastGlob.generateTasks = generateTasks;
    function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils$2.pattern.isDynamicPattern(source, settings);
    }
    FastGlob.isDynamicPattern = isDynamicPattern;
    function escapePath(source) {
        assertPatternsInput(source);
        return utils$2.path.escape(source);
    }
    FastGlob.escapePath = escapePath;
})(FastGlob || (FastGlob = {}));
function getWorks(source, _Provider, options) {
    const patterns = patternManager.transform([].concat(source));
    const settings = new settings_1.default(options);
    const tasks = taskManager.generate(patterns, settings);
    const provider = new _Provider(settings);
    return tasks.map(provider.read, provider);
}
function assertPatternsInput(input) {
    const source = [].concat(input);
    const isValidSource = source.every((item) => utils$2.string.isString(item) && !utils$2.string.isEmpty(item));
    if (!isValidSource) {
        throw new TypeError('Patterns must be a string (non empty) or an array of strings');
    }
}
var out = FastGlob;

var src$2 = {exports: {}};

var browser$2 = {exports: {}};

/**
 * Helpers.
 */

var s$2 = 1000;
var m$2 = s$2 * 60;
var h$2 = m$2 * 60;
var d$2 = h$2 * 24;
var w = d$2 * 7;
var y$2 = d$2 * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms$2 = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse$3(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong$2(val) : fmtShort$2(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse$3(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y$2;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d$2;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h$2;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m$2;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s$2;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort$2(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d$2) {
    return Math.round(ms / d$2) + 'd';
  }
  if (msAbs >= h$2) {
    return Math.round(ms / h$2) + 'h';
  }
  if (msAbs >= m$2) {
    return Math.round(ms / m$2) + 'm';
  }
  if (msAbs >= s$2) {
    return Math.round(ms / s$2) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong$2(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d$2) {
    return plural$2(ms, msAbs, d$2, 'day');
  }
  if (msAbs >= h$2) {
    return plural$2(ms, msAbs, h$2, 'hour');
  }
  if (msAbs >= m$2) {
    return plural$2(ms, msAbs, m$2, 'minute');
  }
  if (msAbs >= s$2) {
    return plural$2(ms, msAbs, s$2, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural$2(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = ms$2;
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

var common = setup;

/* eslint-env browser */

(function (module, exports) {
/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = common(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};
}(browser$2, browser$2.exports));

var node$2 = {exports: {}};

/**
 * Module dependencies.
 */

(function (module, exports) {
const tty = require$$0__default$2["default"];
const util = require$$1__default["default"];

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = require('supports-color');

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = common(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};
}(node$2, node$2.exports));

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	src$2.exports = browser$2.exports;
} else {
	src$2.exports = node$2.exports;
}

var _debug2 = src$2.exports;

// src/index.ts
var jiti;
var defaultConfigureFiles = [
  "windi.config.ts",
  "windi.config.js",
  "windi.config.mjs",
  "windi.config.cjs",
  "windicss.config.ts",
  "windicss.config.js",
  "windicss.config.mjs",
  "windicss.config.cjs",
  "tailwind.config.ts",
  "tailwind.config.js",
  "tailwind.config.mjs",
  "tailwind.config.cjs"
];
function loadConfiguration(options) {
  if (!jiti)
    jiti = lib$d(void 0, { requireCache: false, cache: false, v8cache: false });
  let resolved = {};
  let configFilePath;
  let error;
  const {
    name = "windicss-config",
    config,
    root = process.cwd(),
    configFiles: configureFiles = defaultConfigureFiles,
    onConfigurationError = (e) => {
      throw e;
    },
    onConfigurationNotFound = (path2) => {
      console.warn(`[${name}] config file "${path2}" not found, ignored`);
    }
  } = options;
  const debugConfig = _debug2(`${name}:config`);
  if (typeof config === "string" || !config) {
    if (!config) {
      for (const name2 of configureFiles) {
        const tryPath = require$$0__default$1["default"].resolve(root, name2);
        if (fs__default["default"].existsSync(tryPath)) {
          configFilePath = tryPath;
          break;
        }
      }
    } else {
      configFilePath = require$$0__default$1["default"].resolve(root, config);
      if (!fs__default["default"].existsSync(configFilePath)) {
        onConfigurationNotFound(config);
        configFilePath = void 0;
      }
    }
    if (configFilePath) {
      try {
        debugConfig("loading from ", configFilePath);
        resolved = jiti(configFilePath);
        if (resolved.default)
          resolved = resolved.default;
      } catch (e) {
        error = e;
        configFilePath = void 0;
        resolved = {};
        onConfigurationError == null ? void 0 : onConfigurationError(e);
      }
    }
  } else {
    resolved = config;
  }
  debugConfig(resolved);
  return {
    error,
    config: resolved,
    filepath: configFilePath
  };
}

var config_star = /*#__PURE__*/Object.freeze({
	__proto__: null,
	defaultConfigureFiles: defaultConfigureFiles,
	loadConfiguration: loadConfiguration
});

var charToInteger = {};
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
for (var i = 0; i < chars.length; i++) {
    charToInteger[chars.charCodeAt(i)] = i;
}
function encode(decoded) {
    var sourceFileIndex = 0; // second field
    var sourceCodeLine = 0; // third field
    var sourceCodeColumn = 0; // fourth field
    var nameIndex = 0; // fifth field
    var mappings = '';
    for (var i = 0; i < decoded.length; i++) {
        var line = decoded[i];
        if (i > 0)
            mappings += ';';
        if (line.length === 0)
            continue;
        var generatedCodeColumn = 0; // first field
        var lineMappings = [];
        for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
            var segment = line_1[_i];
            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);
            generatedCodeColumn = segment[0];
            if (segment.length > 1) {
                segmentMappings +=
                    encodeInteger(segment[1] - sourceFileIndex) +
                        encodeInteger(segment[2] - sourceCodeLine) +
                        encodeInteger(segment[3] - sourceCodeColumn);
                sourceFileIndex = segment[1];
                sourceCodeLine = segment[2];
                sourceCodeColumn = segment[3];
            }
            if (segment.length === 5) {
                segmentMappings += encodeInteger(segment[4] - nameIndex);
                nameIndex = segment[4];
            }
            lineMappings.push(segmentMappings);
        }
        mappings += lineMappings.join(',');
    }
    return mappings;
}
function encodeInteger(num) {
    var result = '';
    num = num < 0 ? (-num << 1) | 1 : num << 1;
    do {
        var clamped = num & 31;
        num >>>= 5;
        if (num > 0) {
            clamped |= 32;
        }
        result += chars[clamped];
    } while (num > 0);
    return result;
}

var BitSet = function BitSet(arg) {
	this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
};

BitSet.prototype.add = function add (n) {
	this.bits[n >> 5] |= 1 << (n & 31);
};

BitSet.prototype.has = function has (n) {
	return !!(this.bits[n >> 5] & (1 << (n & 31)));
};

var Chunk = function Chunk(start, end, content) {
	this.start = start;
	this.end = end;
	this.original = content;

	this.intro = '';
	this.outro = '';

	this.content = content;
	this.storeName = false;
	this.edited = false;

	// we make these non-enumerable, for sanity while debugging
	Object.defineProperties(this, {
		previous: { writable: true, value: null },
		next:     { writable: true, value: null }
	});
};

Chunk.prototype.appendLeft = function appendLeft (content) {
	this.outro += content;
};

Chunk.prototype.appendRight = function appendRight (content) {
	this.intro = this.intro + content;
};

Chunk.prototype.clone = function clone () {
	var chunk = new Chunk(this.start, this.end, this.original);

	chunk.intro = this.intro;
	chunk.outro = this.outro;
	chunk.content = this.content;
	chunk.storeName = this.storeName;
	chunk.edited = this.edited;

	return chunk;
};

Chunk.prototype.contains = function contains (index) {
	return this.start < index && index < this.end;
};

Chunk.prototype.eachNext = function eachNext (fn) {
	var chunk = this;
	while (chunk) {
		fn(chunk);
		chunk = chunk.next;
	}
};

Chunk.prototype.eachPrevious = function eachPrevious (fn) {
	var chunk = this;
	while (chunk) {
		fn(chunk);
		chunk = chunk.previous;
	}
};

Chunk.prototype.edit = function edit (content, storeName, contentOnly) {
	this.content = content;
	if (!contentOnly) {
		this.intro = '';
		this.outro = '';
	}
	this.storeName = storeName;

	this.edited = true;

	return this;
};

Chunk.prototype.prependLeft = function prependLeft (content) {
	this.outro = content + this.outro;
};

Chunk.prototype.prependRight = function prependRight (content) {
	this.intro = content + this.intro;
};

Chunk.prototype.split = function split (index) {
	var sliceIndex = index - this.start;

	var originalBefore = this.original.slice(0, sliceIndex);
	var originalAfter = this.original.slice(sliceIndex);

	this.original = originalBefore;

	var newChunk = new Chunk(index, this.end, originalAfter);
	newChunk.outro = this.outro;
	this.outro = '';

	this.end = index;

	if (this.edited) {
		// TODO is this block necessary?...
		newChunk.edit('', false);
		this.content = '';
	} else {
		this.content = originalBefore;
	}

	newChunk.next = this.next;
	if (newChunk.next) { newChunk.next.previous = newChunk; }
	newChunk.previous = this;
	this.next = newChunk;

	return newChunk;
};

Chunk.prototype.toString = function toString () {
	return this.intro + this.content + this.outro;
};

Chunk.prototype.trimEnd = function trimEnd (rx) {
	this.outro = this.outro.replace(rx, '');
	if (this.outro.length) { return true; }

	var trimmed = this.content.replace(rx, '');

	if (trimmed.length) {
		if (trimmed !== this.content) {
			this.split(this.start + trimmed.length).edit('', undefined, true);
		}
		return true;

	} else {
		this.edit('', undefined, true);

		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) { return true; }
	}
};

Chunk.prototype.trimStart = function trimStart (rx) {
	this.intro = this.intro.replace(rx, '');
	if (this.intro.length) { return true; }

	var trimmed = this.content.replace(rx, '');

	if (trimmed.length) {
		if (trimmed !== this.content) {
			this.split(this.end - trimmed.length);
			this.edit('', undefined, true);
		}
		return true;

	} else {
		this.edit('', undefined, true);

		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) { return true; }
	}
};

var btoa = function () {
	throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
};
if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
	btoa = function (str) { return window.btoa(unescape(encodeURIComponent(str))); };
} else if (typeof Buffer === 'function') {
	btoa = function (str) { return Buffer.from(str, 'utf-8').toString('base64'); };
}

var SourceMap = function SourceMap(properties) {
	this.version = 3;
	this.file = properties.file;
	this.sources = properties.sources;
	this.sourcesContent = properties.sourcesContent;
	this.names = properties.names;
	this.mappings = encode(properties.mappings);
};

SourceMap.prototype.toString = function toString () {
	return JSON.stringify(this);
};

SourceMap.prototype.toUrl = function toUrl () {
	return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
};

function guessIndent(code) {
	var lines = code.split('\n');

	var tabbed = lines.filter(function (line) { return /^\t+/.test(line); });
	var spaced = lines.filter(function (line) { return /^ {2,}/.test(line); });

	if (tabbed.length === 0 && spaced.length === 0) {
		return null;
	}

	// More lines tabbed than spaced? Assume tabs, and
	// default to tabs in the case of a tie (or nothing
	// to go on)
	if (tabbed.length >= spaced.length) {
		return '\t';
	}

	// Otherwise, we need to guess the multiple
	var min = spaced.reduce(function (previous, current) {
		var numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);

	return new Array(min + 1).join(' ');
}

function getRelativePath(from, to) {
	var fromParts = from.split(/[/\\]/);
	var toParts = to.split(/[/\\]/);

	fromParts.pop(); // get dirname

	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}

	if (fromParts.length) {
		var i = fromParts.length;
		while (i--) { fromParts[i] = '..'; }
	}

	return fromParts.concat(toParts).join('/');
}

var toString$1 = Object.prototype.toString;

function isObject$1(thing) {
	return toString$1.call(thing) === '[object Object]';
}

function getLocator(source) {
	var originalLines = source.split('\n');
	var lineOffsets = [];

	for (var i = 0, pos = 0; i < originalLines.length; i++) {
		lineOffsets.push(pos);
		pos += originalLines[i].length + 1;
	}

	return function locate(index) {
		var i = 0;
		var j = lineOffsets.length;
		while (i < j) {
			var m = (i + j) >> 1;
			if (index < lineOffsets[m]) {
				j = m;
			} else {
				i = m + 1;
			}
		}
		var line = i - 1;
		var column = index - lineOffsets[line];
		return { line: line, column: column };
	};
}

var Mappings = function Mappings(hires) {
	this.hires = hires;
	this.generatedCodeLine = 0;
	this.generatedCodeColumn = 0;
	this.raw = [];
	this.rawSegments = this.raw[this.generatedCodeLine] = [];
	this.pending = null;
};

Mappings.prototype.addEdit = function addEdit (sourceIndex, content, loc, nameIndex) {
	if (content.length) {
		var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
		if (nameIndex >= 0) {
			segment.push(nameIndex);
		}
		this.rawSegments.push(segment);
	} else if (this.pending) {
		this.rawSegments.push(this.pending);
	}

	this.advance(content);
	this.pending = null;
};

Mappings.prototype.addUneditedChunk = function addUneditedChunk (sourceIndex, chunk, original, loc, sourcemapLocations) {
	var originalCharIndex = chunk.start;
	var first = true;

	while (originalCharIndex < chunk.end) {
		if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
			this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
		}

		if (original[originalCharIndex] === '\n') {
			loc.line += 1;
			loc.column = 0;
			this.generatedCodeLine += 1;
			this.raw[this.generatedCodeLine] = this.rawSegments = [];
			this.generatedCodeColumn = 0;
			first = true;
		} else {
			loc.column += 1;
			this.generatedCodeColumn += 1;
			first = false;
		}

		originalCharIndex += 1;
	}

	this.pending = null;
};

Mappings.prototype.advance = function advance (str) {
	if (!str) { return; }

	var lines = str.split('\n');

	if (lines.length > 1) {
		for (var i = 0; i < lines.length - 1; i++) {
			this.generatedCodeLine++;
			this.raw[this.generatedCodeLine] = this.rawSegments = [];
		}
		this.generatedCodeColumn = 0;
	}

	this.generatedCodeColumn += lines[lines.length - 1].length;
};

var n = '\n';

var warned = {
	insertLeft: false,
	insertRight: false,
	storeName: false
};

var MagicString = function MagicString(string, options) {
	if ( options === void 0 ) options = {};

	var chunk = new Chunk(0, string.length, string);

	Object.defineProperties(this, {
		original:              { writable: true, value: string },
		outro:                 { writable: true, value: '' },
		intro:                 { writable: true, value: '' },
		firstChunk:            { writable: true, value: chunk },
		lastChunk:             { writable: true, value: chunk },
		lastSearchedChunk:     { writable: true, value: chunk },
		byStart:               { writable: true, value: {} },
		byEnd:                 { writable: true, value: {} },
		filename:              { writable: true, value: options.filename },
		indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
		sourcemapLocations:    { writable: true, value: new BitSet() },
		storedNames:           { writable: true, value: {} },
		indentStr:             { writable: true, value: guessIndent(string) }
	});

	this.byStart[0] = chunk;
	this.byEnd[string.length] = chunk;
};

MagicString.prototype.addSourcemapLocation = function addSourcemapLocation (char) {
	this.sourcemapLocations.add(char);
};

MagicString.prototype.append = function append (content) {
	if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }

	this.outro += content;
	return this;
};

MagicString.prototype.appendLeft = function appendLeft (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byEnd[index];

	if (chunk) {
		chunk.appendLeft(content);
	} else {
		this.intro += content;
	}
	return this;
};

MagicString.prototype.appendRight = function appendRight (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byStart[index];

	if (chunk) {
		chunk.appendRight(content);
	} else {
		this.outro += content;
	}
	return this;
};

MagicString.prototype.clone = function clone () {
	var cloned = new MagicString(this.original, { filename: this.filename });

	var originalChunk = this.firstChunk;
	var clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());

	while (originalChunk) {
		cloned.byStart[clonedChunk.start] = clonedChunk;
		cloned.byEnd[clonedChunk.end] = clonedChunk;

		var nextOriginalChunk = originalChunk.next;
		var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

		if (nextClonedChunk) {
			clonedChunk.next = nextClonedChunk;
			nextClonedChunk.previous = clonedChunk;

			clonedChunk = nextClonedChunk;
		}

		originalChunk = nextOriginalChunk;
	}

	cloned.lastChunk = clonedChunk;

	if (this.indentExclusionRanges) {
		cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
	}

	cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);

	cloned.intro = this.intro;
	cloned.outro = this.outro;

	return cloned;
};

MagicString.prototype.generateDecodedMap = function generateDecodedMap (options) {
		var this$1$1 = this;

	options = options || {};

	var sourceIndex = 0;
	var names = Object.keys(this.storedNames);
	var mappings = new Mappings(options.hires);

	var locate = getLocator(this.original);

	if (this.intro) {
		mappings.advance(this.intro);
	}

	this.firstChunk.eachNext(function (chunk) {
		var loc = locate(chunk.start);

		if (chunk.intro.length) { mappings.advance(chunk.intro); }

		if (chunk.edited) {
			mappings.addEdit(
				sourceIndex,
				chunk.content,
				loc,
				chunk.storeName ? names.indexOf(chunk.original) : -1
			);
		} else {
			mappings.addUneditedChunk(sourceIndex, chunk, this$1$1.original, loc, this$1$1.sourcemapLocations);
		}

		if (chunk.outro.length) { mappings.advance(chunk.outro); }
	});

	return {
		file: options.file ? options.file.split(/[/\\]/).pop() : null,
		sources: [options.source ? getRelativePath(options.file || '', options.source) : null],
		sourcesContent: options.includeContent ? [this.original] : [null],
		names: names,
		mappings: mappings.raw
	};
};

MagicString.prototype.generateMap = function generateMap (options) {
	return new SourceMap(this.generateDecodedMap(options));
};

MagicString.prototype.getIndentString = function getIndentString () {
	return this.indentStr === null ? '\t' : this.indentStr;
};

MagicString.prototype.indent = function indent (indentStr, options) {
	var pattern = /^[^\r\n]/gm;

	if (isObject$1(indentStr)) {
		options = indentStr;
		indentStr = undefined;
	}

	indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\t';

	if (indentStr === '') { return this; } // noop

	options = options || {};

	// Process exclusion ranges
	var isExcluded = {};

	if (options.exclude) {
		var exclusions =
			typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
		exclusions.forEach(function (exclusion) {
			for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
				isExcluded[i] = true;
			}
		});
	}

	var shouldIndentNextCharacter = options.indentStart !== false;
	var replacer = function (match) {
		if (shouldIndentNextCharacter) { return ("" + indentStr + match); }
		shouldIndentNextCharacter = true;
		return match;
	};

	this.intro = this.intro.replace(pattern, replacer);

	var charIndex = 0;
	var chunk = this.firstChunk;

	while (chunk) {
		var end = chunk.end;

		if (chunk.edited) {
			if (!isExcluded[charIndex]) {
				chunk.content = chunk.content.replace(pattern, replacer);

				if (chunk.content.length) {
					shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
				}
			}
		} else {
			charIndex = chunk.start;

			while (charIndex < end) {
				if (!isExcluded[charIndex]) {
					var char = this.original[charIndex];

					if (char === '\n') {
						shouldIndentNextCharacter = true;
					} else if (char !== '\r' && shouldIndentNextCharacter) {
						shouldIndentNextCharacter = false;

						if (charIndex === chunk.start) {
							chunk.prependRight(indentStr);
						} else {
							this._splitChunk(chunk, charIndex);
							chunk = chunk.next;
							chunk.prependRight(indentStr);
						}
					}
				}

				charIndex += 1;
			}
		}

		charIndex = chunk.end;
		chunk = chunk.next;
	}

	this.outro = this.outro.replace(pattern, replacer);

	return this;
};

MagicString.prototype.insert = function insert () {
	throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');
};

MagicString.prototype.insertLeft = function insertLeft (index, content) {
	if (!warned.insertLeft) {
		console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console
		warned.insertLeft = true;
	}

	return this.appendLeft(index, content);
};

MagicString.prototype.insertRight = function insertRight (index, content) {
	if (!warned.insertRight) {
		console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console
		warned.insertRight = true;
	}

	return this.prependRight(index, content);
};

MagicString.prototype.move = function move (start, end, index) {
	if (index >= start && index <= end) { throw new Error('Cannot move a selection inside itself'); }

	this._split(start);
	this._split(end);
	this._split(index);

	var first = this.byStart[start];
	var last = this.byEnd[end];

	var oldLeft = first.previous;
	var oldRight = last.next;

	var newRight = this.byStart[index];
	if (!newRight && last === this.lastChunk) { return this; }
	var newLeft = newRight ? newRight.previous : this.lastChunk;

	if (oldLeft) { oldLeft.next = oldRight; }
	if (oldRight) { oldRight.previous = oldLeft; }

	if (newLeft) { newLeft.next = first; }
	if (newRight) { newRight.previous = last; }

	if (!first.previous) { this.firstChunk = last.next; }
	if (!last.next) {
		this.lastChunk = first.previous;
		this.lastChunk.next = null;
	}

	first.previous = newLeft;
	last.next = newRight || null;

	if (!newLeft) { this.firstChunk = first; }
	if (!newRight) { this.lastChunk = last; }
	return this;
};

MagicString.prototype.overwrite = function overwrite (start, end, content, options) {
	if (typeof content !== 'string') { throw new TypeError('replacement content must be a string'); }

	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	if (end > this.original.length) { throw new Error('end is out of bounds'); }
	if (start === end)
		{ throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead'); }

	this._split(start);
	this._split(end);

	if (options === true) {
		if (!warned.storeName) {
			console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console
			warned.storeName = true;
		}

		options = { storeName: true };
	}
	var storeName = options !== undefined ? options.storeName : false;
	var contentOnly = options !== undefined ? options.contentOnly : false;

	if (storeName) {
		var original = this.original.slice(start, end);
		this.storedNames[original] = true;
	}

	var first = this.byStart[start];
	var last = this.byEnd[end];

	if (first) {
		if (end > first.end && first.next !== this.byStart[first.end]) {
			throw new Error('Cannot overwrite across a split point');
		}

		first.edit(content, storeName, contentOnly);

		if (first !== last) {
			var chunk = first.next;
			while (chunk !== last) {
				chunk.edit('', false);
				chunk = chunk.next;
			}

			chunk.edit('', false);
		}
	} else {
		// must be inserting at the end
		var newChunk = new Chunk(start, end, '').edit(content, storeName);

		// TODO last chunk in the array may not be the last chunk, if it's moved...
		last.next = newChunk;
		newChunk.previous = last;
	}
	return this;
};

MagicString.prototype.prepend = function prepend (content) {
	if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }

	this.intro = content + this.intro;
	return this;
};

MagicString.prototype.prependLeft = function prependLeft (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byEnd[index];

	if (chunk) {
		chunk.prependLeft(content);
	} else {
		this.intro = content + this.intro;
	}
	return this;
};

MagicString.prototype.prependRight = function prependRight (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byStart[index];

	if (chunk) {
		chunk.prependRight(content);
	} else {
		this.outro = content + this.outro;
	}
	return this;
};

MagicString.prototype.remove = function remove (start, end) {
	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	if (start === end) { return this; }

	if (start < 0 || end > this.original.length) { throw new Error('Character is out of bounds'); }
	if (start > end) { throw new Error('end must be greater than start'); }

	this._split(start);
	this._split(end);

	var chunk = this.byStart[start];

	while (chunk) {
		chunk.intro = '';
		chunk.outro = '';
		chunk.edit('');

		chunk = end > chunk.end ? this.byStart[chunk.end] : null;
	}
	return this;
};

MagicString.prototype.lastChar = function lastChar () {
	if (this.outro.length)
		{ return this.outro[this.outro.length - 1]; }
	var chunk = this.lastChunk;
	do {
		if (chunk.outro.length)
			{ return chunk.outro[chunk.outro.length - 1]; }
		if (chunk.content.length)
			{ return chunk.content[chunk.content.length - 1]; }
		if (chunk.intro.length)
			{ return chunk.intro[chunk.intro.length - 1]; }
	} while (chunk = chunk.previous);
	if (this.intro.length)
		{ return this.intro[this.intro.length - 1]; }
	return '';
};

MagicString.prototype.lastLine = function lastLine () {
	var lineIndex = this.outro.lastIndexOf(n);
	if (lineIndex !== -1)
		{ return this.outro.substr(lineIndex + 1); }
	var lineStr = this.outro;
	var chunk = this.lastChunk;
	do {
		if (chunk.outro.length > 0) {
			lineIndex = chunk.outro.lastIndexOf(n);
			if (lineIndex !== -1)
				{ return chunk.outro.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.outro + lineStr;
		}

		if (chunk.content.length > 0) {
			lineIndex = chunk.content.lastIndexOf(n);
			if (lineIndex !== -1)
				{ return chunk.content.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.content + lineStr;
		}

		if (chunk.intro.length > 0) {
			lineIndex = chunk.intro.lastIndexOf(n);
			if (lineIndex !== -1)
				{ return chunk.intro.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.intro + lineStr;
		}
	} while (chunk = chunk.previous);
	lineIndex = this.intro.lastIndexOf(n);
	if (lineIndex !== -1)
		{ return this.intro.substr(lineIndex + 1) + lineStr; }
	return this.intro + lineStr;
};

MagicString.prototype.slice = function slice (start, end) {
		if ( start === void 0 ) start = 0;
		if ( end === void 0 ) end = this.original.length;

	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	var result = '';

	// find start chunk
	var chunk = this.firstChunk;
	while (chunk && (chunk.start > start || chunk.end <= start)) {
		// found end chunk before start
		if (chunk.start < end && chunk.end >= end) {
			return result;
		}

		chunk = chunk.next;
	}

	if (chunk && chunk.edited && chunk.start !== start)
		{ throw new Error(("Cannot use replaced character " + start + " as slice start anchor.")); }

	var startChunk = chunk;
	while (chunk) {
		if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
			result += chunk.intro;
		}

		var containsEnd = chunk.start < end && chunk.end >= end;
		if (containsEnd && chunk.edited && chunk.end !== end)
			{ throw new Error(("Cannot use replaced character " + end + " as slice end anchor.")); }

		var sliceStart = startChunk === chunk ? start - chunk.start : 0;
		var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

		result += chunk.content.slice(sliceStart, sliceEnd);

		if (chunk.outro && (!containsEnd || chunk.end === end)) {
			result += chunk.outro;
		}

		if (containsEnd) {
			break;
		}

		chunk = chunk.next;
	}

	return result;
};

// TODO deprecate this? not really very useful
MagicString.prototype.snip = function snip (start, end) {
	var clone = this.clone();
	clone.remove(0, start);
	clone.remove(end, clone.original.length);

	return clone;
};

MagicString.prototype._split = function _split (index) {
	if (this.byStart[index] || this.byEnd[index]) { return; }

	var chunk = this.lastSearchedChunk;
	var searchForward = index > chunk.end;

	while (chunk) {
		if (chunk.contains(index)) { return this._splitChunk(chunk, index); }

		chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
	}
};

MagicString.prototype._splitChunk = function _splitChunk (chunk, index) {
	if (chunk.edited && chunk.content.length) {
		// zero-length edited chunks are a special case (overlapping replacements)
		var loc = getLocator(this.original)(index);
		throw new Error(
			("Cannot split a chunk that has already been edited (" + (loc.line) + ":" + (loc.column) + " – \"" + (chunk.original) + "\")")
		);
	}

	var newChunk = chunk.split(index);

	this.byEnd[index] = chunk;
	this.byStart[index] = newChunk;
	this.byEnd[newChunk.end] = newChunk;

	if (chunk === this.lastChunk) { this.lastChunk = newChunk; }

	this.lastSearchedChunk = chunk;
	return true;
};

MagicString.prototype.toString = function toString () {
	var str = this.intro;

	var chunk = this.firstChunk;
	while (chunk) {
		str += chunk.toString();
		chunk = chunk.next;
	}

	return str + this.outro;
};

MagicString.prototype.isEmpty = function isEmpty () {
	var chunk = this.firstChunk;
	do {
		if (chunk.intro.length && chunk.intro.trim() ||
				chunk.content.length && chunk.content.trim() ||
				chunk.outro.length && chunk.outro.trim())
			{ return false; }
	} while (chunk = chunk.next);
	return true;
};

MagicString.prototype.length = function length () {
	var chunk = this.firstChunk;
	var length = 0;
	do {
		length += chunk.intro.length + chunk.content.length + chunk.outro.length;
	} while (chunk = chunk.next);
	return length;
};

MagicString.prototype.trimLines = function trimLines () {
	return this.trim('[\\r\\n]');
};

MagicString.prototype.trim = function trim (charType) {
	return this.trimStart(charType).trimEnd(charType);
};

MagicString.prototype.trimEndAborted = function trimEndAborted (charType) {
	var rx = new RegExp((charType || '\\s') + '+$');

	this.outro = this.outro.replace(rx, '');
	if (this.outro.length) { return true; }

	var chunk = this.lastChunk;

	do {
		var end = chunk.end;
		var aborted = chunk.trimEnd(rx);

		// if chunk was trimmed, we have a new lastChunk
		if (chunk.end !== end) {
			if (this.lastChunk === chunk) {
				this.lastChunk = chunk.next;
			}

			this.byEnd[chunk.end] = chunk;
			this.byStart[chunk.next.start] = chunk.next;
			this.byEnd[chunk.next.end] = chunk.next;
		}

		if (aborted) { return true; }
		chunk = chunk.previous;
	} while (chunk);

	return false;
};

MagicString.prototype.trimEnd = function trimEnd (charType) {
	this.trimEndAborted(charType);
	return this;
};
MagicString.prototype.trimStartAborted = function trimStartAborted (charType) {
	var rx = new RegExp('^' + (charType || '\\s') + '+');

	this.intro = this.intro.replace(rx, '');
	if (this.intro.length) { return true; }

	var chunk = this.firstChunk;

	do {
		var end = chunk.end;
		var aborted = chunk.trimStart(rx);

		if (chunk.end !== end) {
			// special case...
			if (chunk === this.lastChunk) { this.lastChunk = chunk.next; }

			this.byEnd[chunk.end] = chunk;
			this.byStart[chunk.next.start] = chunk.next;
			this.byEnd[chunk.next.end] = chunk.next;
		}

		if (aborted) { return true; }
		chunk = chunk.next;
	} while (chunk);

	return false;
};

MagicString.prototype.trimStart = function trimStart (charType) {
	this.trimStartAborted(charType);
	return this;
};

var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropNames$1 = Object.getOwnPropertyNames;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var __require$1 = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __export = (target, all) => {
  for (var name in all)
    __defProp$1(target, name, { get: all[name], enumerable: true });
};
var __reExport$1 = (target, module, copyDefault, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames$1(module))
      if (!__hasOwnProp$1.call(target, key) && (copyDefault || key !== "default"))
        __defProp$1(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc$1(module, key)) || desc.enumerable });
  }
  return target;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  DefaultExtractor: () => DefaultExtractor,
  PugExtractor: () => PugExtractor,
  SupportedLayers: () => SupportedLayers,
  SvelteExtractor: () => SvelteExtractor,
  applyExtractors: () => applyExtractors,
  buildAliasTransformer: () => buildAliasTransformer,
  createUtils: () => createUtils,
  defaultAlias: () => defaultAlias,
  defineConfig: () => defineConfig,
  escapeRegExp: () => escapeRegExp,
  exclude: () => exclude,
  flattenArray: () => flattenArray,
  getDefaultExtractors: () => getDefaultExtractors,
  htmlTags: () => htmlTags,
  include: () => include,
  isResolvedOptions: () => isResolvedOptions,
  kebabCase: () => kebabCase,
  mergeArrays: () => mergeArrays,
  mergeWindicssConfig: () => mergeWindicssConfig,
  partition: () => partition,
  preflightTags: () => preflightTags,
  resolveOptions: () => resolveOptions,
  slash: () => slash$1,
  toArray: () => toArray,
  transformGroups: () => transformGroups
});

// src/constants.ts
var defaultAlias = {
  "router-link": "a"
};
var preflightTags = ["html", "body", "div"];
var htmlTags = [
  "html",
  "body",
  "div",
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "base",
  "basefont",
  "bdo",
  "blink",
  "blockquote",
  "br",
  "button",
  "canvas",
  "caption",
  "center",
  "col",
  "colgroup",
  "command",
  "comment",
  "datalist",
  "dd",
  "del",
  "details",
  "dir",
  "dl",
  "dt",
  "embed",
  "fieldset",
  "figure",
  "b",
  "big",
  "i",
  "small",
  "tt",
  "font",
  "footer",
  "form",
  "frame",
  "frameset",
  "head",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "isindex",
  "iframe",
  "ilayer",
  "img",
  "input",
  "ins",
  "keygen",
  "keygen",
  "label",
  "layer",
  "legend",
  "li",
  "link",
  "map",
  "mark",
  "marquee",
  "menu",
  "meta",
  "meter",
  "multicol",
  "nav",
  "nobr",
  "noembed",
  "noframes",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "cite",
  "code",
  "dfn",
  "em",
  "kbd",
  "samp",
  "strong",
  "var",
  "plaintext",
  "pre",
  "progress",
  "q",
  "ruby",
  "script",
  "section",
  "select",
  "spacer",
  "span",
  "s",
  "strike",
  "style",
  "sub",
  "sup",
  "svg",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "u",
  "ul",
  "video",
  "wbr",
  "wbr",
  "xmp"
];

// src/defineConfig.ts
function defineConfig(config) {
  return config;
}

// src/resolveOptions.ts
var resolveOptions_exports = {};
__export(resolveOptions_exports, {
  isResolvedOptions: () => isResolvedOptions,
  resolveOptions: () => resolveOptions
});
function flattenArray(v) {
  return toArray(v).flat();
}
function mergeArrays(...args) {
  return args.flatMap((i) => flattenArray(i || []));
}
function kebabCase(str) {
  return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function include(set, v) {
  for (const i of v)
    set.add(i);
}
function exclude(set, v) {
  for (const i of v)
    set.delete(i);
}
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// src/regexes.ts
var regexHtmlTag = /<(\w[\w-]*)([\S\s]*?)\/?>/mg;
var regexClassSplitter = /[\s'"`{}]/g;
var regexClassGroup = /([!\w+-<@][\w+:_/-]*?\w):\(((?:[!\w\s:/\\,%#.$-]|\[.*?\])*?)\)/gm;
var regexAttributifyItem = /(?:\s|^)([\w+:_/-]+)\s?=\s?(['"{])((?:\\\2|\\\\|\n|\r|.)*?)(?:\2|\})/gm;
var regexClassCheck1 = /^!?[a-z\d@<>.+-](?:\([\w,.%#\(\)+-]*\)|[\w:/\\,%#\[\].$-])*$/;
var regexClassCheck2 = /[a-z].*[\w)\]]$/;
var regexClassChecks = [
  regexClassCheck1,
  regexClassCheck2
];
var regexSvelteClass = /class:([\w:/\\,%#\[\].$-]+?)=["']?\{/g;
function validClassName(i) {
  return regexClassChecks.every((r) => i.length > 2 && i.match(r));
}

// src/extractors/default.ts
function DefaultExtractor(code, id) {
  if ((id == null ? void 0 : id.endsWith(".css")) || (id == null ? void 0 : id.endsWith(".postcss"))) {
    return {
      classes: [],
      tags: []
    };
  }
  const tags = Array.from(code.matchAll(regexHtmlTag));
  const tagNames = tags.map((i) => i[1]);
  return {
    tags: tagNames,
    get classes() {
      return code.split(regexClassSplitter).filter(validClassName);
    },
    get attributes() {
      const attrRanges = [];
      const attributes = {
        names: [],
        values: []
      };
      const attributesBlocklist = ["class", "className"];
      const tagsBlocklist = ["meta", "script", "style", "link"];
      tags.filter((i) => !tagsBlocklist.includes(i[1])).forEach((i) => {
        return Array.from(i[2].matchAll(regexAttributifyItem) || []).forEach((match) => {
          let name = match[1];
          const [full, , , value] = match;
          name = name.replace(/^(:|v-bind:)/, "");
          if (attributesBlocklist.includes(name))
            return;
          attributes.names.push(name);
          attributes.values.push(value);
          if (match.index != null)
            attrRanges.push([match.index, match.index + full.length]);
        });
      });
      return attributes;
    }
  };
}

// src/extractors/pug.ts
var regexTemplate = /<template.*?lang=['"]pug['"][^>]*?>\n([\s\S]*?\n)<\/template>/gm;
function PugExtractor(code, id) {
  const Pug = __require$1("pug");
  const compile = (code2) => {
    try {
      return Pug.compile(code2, { filename: id })();
    } catch {
    }
  };
  let compiled;
  if (id && id.match(/\.vue$/)) {
    const matches = Array.from(code.matchAll(regexTemplate));
    let tail = "";
    for (const match of matches) {
      if (match && match[1])
        tail += `

${compile(match[1])}`;
    }
    if (tail)
      compiled = `${code}

${tail}`;
  } else {
    compiled = compile(code);
  }
  return DefaultExtractor(compiled || code);
}

// src/extractors/svelte.ts
function SvelteExtractor(code, id) {
  const result = DefaultExtractor(code, id);
  return {
    tags: result.tags,
    get classes() {
      return [
        ...result.classes,
        ...Array.from(code.matchAll(regexSvelteClass)).map((i) => i[1]).filter(Boolean)
      ];
    },
    get attributes() {
      return result.attributes;
    }
  };
}

// src/extractors/helper.ts
function getDefaultExtractors() {
  const extractors = [
    {
      extractor: SvelteExtractor,
      extensions: ["svelte"]
    }
  ];
  try {
    __require$1("pug");
    extractors.push({
      extractor: PugExtractor,
      extensions: ["vue", "pug"]
    });
  } catch (e) {
  }
  return extractors;
}
async function applyExtractors(code, id, extractors = [], defaultExtract = DefaultExtractor) {
  let ext = id ? require$$0$4.extname(id) : "*";
  if (ext[0] === ".")
    ext = ext.slice(1);
  for (const { extractor, extensions } of extractors) {
    if (extensions.includes(ext))
      return extractor(code, id);
  }
  return defaultExtract(code, id);
}

// src/resolveOptions.ts
__reExport$1(resolveOptions_exports, config_star);
function isResolvedOptions(options) {
  return options.__windi_resolved;
}
function buildGlobs(dirs, fileExtensions) {
  dirs = toArray(dirs);
  const exts = toArray(fileExtensions);
  const globs = exts.length ? dirs.map((i) => require$$0__default$1["default"].posix.join(i, exts.length > 1 ? `**/*.{${exts.join(",")}}` : `**/*.${exts[0]}`)) : [];
  globs.push("index.html");
  return globs;
}
async function resolveOptions(options = {}, utilsOptions = {}, loadConfigFile = false) {
  var _a, _b, _c, _d, _e, _f, _g;
  if (isResolvedOptions(options))
    return options;
  const {
    name = "windicss-plugin-utils"
  } = utilsOptions;
  const debugOptions = _debug2(`${name}:options`);
  const root = options.root || utilsOptions.root || process.cwd();
  let { config, filepath: configFilePath } = loadConfigFile ? loadConfiguration(__spreadProps$1(__spreadValues$1({
    onConfigurationError: (error) => console.error(error)
  }, utilsOptions), {
    root,
    config: options.config,
    configFiles: options.configFiles
  })) : { config: {}, filepath: void 0 };
  const modifiedConfigs = await ((_a = options.onConfigResolved) == null ? void 0 : _a.call(options, config, configFilePath));
  if (modifiedConfigs != null)
    config = modifiedConfigs;
  const {
    scan = true,
    preflight = true,
    transformCSS = true,
    transformGroups: transformGroups2 = true,
    sortUtilities = true
  } = options;
  const preflightOptions = Object.assign({
    includeBase: true,
    includeGlobal: true,
    includePlugin: true,
    enableAll: false,
    includeAll: false,
    safelist: [],
    blocklist: [],
    alias: {}
  }, typeof config.preflight === "boolean" ? {} : config.preflight, typeof preflight === "boolean" ? {} : preflight);
  preflightOptions.includeAll = preflightOptions.includeAll || preflightOptions.enableAll;
  const scanOptions = Object.assign({
    fileExtensions: ["html", "vue", "md", "mdx", "pug", "jsx", "tsx", "svelte", "ts", "js", "css", "postcss", "pcss"],
    dirs: ["src"],
    exclude: [],
    include: [],
    runOnStartup: true,
    transformers: [],
    extractors: [],
    extraTransformTargets: {
      css: [],
      detect: []
    }
  }, typeof scan === "boolean" ? {} : scan);
  function resolveGlob(glob) {
    if (glob.startsWith("!"))
      return `!${slash$1(require$$0__default$1["default"].resolve(root, glob.slice(1)))}`;
    return slash$1(require$$0__default$1["default"].resolve(root, glob));
  }
  scanOptions.exclude = mergeArrays((_b = config.extract) == null ? void 0 : _b.exclude, scanOptions.exclude, ((_c = config.extract) == null ? void 0 : _c.exclude) ? [] : [
    "node_modules",
    ".git",
    "windi.config.{ts,js}",
    "tailwind.config.{ts,js}"
  ]).map(resolveGlob);
  scanOptions.include = mergeArrays((_d = config.extract) == null ? void 0 : _d.include, scanOptions.include, ((_e = config.extract) == null ? void 0 : _e.include) ? [] : buildGlobs(scanOptions.dirs, scanOptions.fileExtensions)).map(resolveGlob);
  scanOptions.extractors = mergeArrays(getDefaultExtractors(), (_f = config.extract) == null ? void 0 : _f.extractors);
  const safelist = new Set(mergeArrays(config.safelist, options.safelist).flatMap((i) => i.split(" ")));
  const blocklist = new Set(mergeArrays(config.blocklist, options.blocklist).flatMap((i) => i.split(" ")));
  const configPreflightOptions = typeof config.preflight === "boolean" ? {} : config.preflight || {};
  preflightOptions.safelist = new Set(mergeArrays(configPreflightOptions == null ? void 0 : configPreflightOptions.safelist, Array.from(preflightOptions.safelist)).flatMap((i) => i.split(" ")).map((i) => {
    var _a2;
    const match = (_a2 = i.match(/^\[(.*?)\]$/)) == null ? void 0 : _a2[1];
    if (match)
      return `div ${match}`;
    return i;
  }));
  preflightOptions.blocklist = new Set(mergeArrays(configPreflightOptions == null ? void 0 : configPreflightOptions.blocklist, Array.from(preflightOptions.blocklist)).flatMap((i) => i.split(" ")));
  preflightOptions.alias = Object.fromEntries(Object.entries(__spreadValues$1(__spreadValues$1(__spreadValues$1({}, defaultAlias), configPreflightOptions.alias), preflightOptions.alias)).filter(([k, v]) => [kebabCase(k), v]));
  let resolvedOptions = __spreadProps$1(__spreadValues$1({}, options), {
    root,
    config,
    configFilePath,
    enableScan: Boolean(scan),
    scanOptions,
    enablePreflight: config.preflight !== false && Boolean(preflight),
    preflightOptions,
    transformCSS,
    transformGroups: transformGroups2,
    sortUtilities,
    safelist,
    blocklist,
    __windi_resolved: true
  });
  const modifiedOptions = await ((_g = resolvedOptions.onOptionsResolved) == null ? void 0 : _g.call(resolvedOptions, resolvedOptions));
  if (modifiedOptions != null && modifiedOptions !== resolvedOptions)
    resolvedOptions = Object.assign(resolvedOptions, modifiedOptions);
  debugOptions(resolvedOptions);
  return resolvedOptions;
}
function transformGroups(code, sourcemap = true) {
  const s = new MagicString(code);
  let hasReplaced = false;
  let match;
  regexClassGroup.lastIndex = 0;
  while (match = regexClassGroup.exec(code)) {
    hasReplaced = true;
    const start = match.index;
    const end = start + match[0].length;
    const a = match[1];
    const b = match[2];
    const replacement = b.split(/\s+/g).filter(Boolean).map((i) => i.replace(/^(!?)(.*)/, `$1${a}:$2`)).join(" ");
    s.overwrite(start, end, replacement);
  }
  if (!hasReplaced)
    return null;
  return {
    code: s.toString(),
    map: sourcemap ? s.generateMap({ hires: true }) : void 0
  };
}
function buildAliasTransformer(alias) {
  if (!alias || !Object.keys(alias).length)
    return () => null;
  const keys = Object.keys(alias).sort((a, b) => b.length - a.length).map((i) => escapeRegExp(i)).join("|");
  const regexText = `\\*(?:${keys})(?<=[^w-])`;
  const regex = new RegExp(regexText, "g");
  return function transformAlias(code, sourcemap = true) {
    const s = new MagicString(code);
    let hasReplaced = false;
    let match;
    regex.lastIndex = 0;
    while (match = regex.exec(code)) {
      hasReplaced = true;
      const start = match.index;
      const end = start + match[0].length;
      const name = code.slice(start + 1, end);
      const replacement = alias[name];
      s.overwrite(start, end, replacement);
    }
    if (!hasReplaced)
      return null;
    return {
      code: s.toString(),
      map: sourcemap ? s.generateMap({ hires: true }) : void 0
    };
  };
}

// src/createUtils.ts
var SupportedLayers = ["base", "utilities", "components"];
function createUtils(userOptions = {}, utilsOptions = {
  name: "windicss-plugin-utils"
}) {
  let options = {};
  const name = utilsOptions.name;
  const debug = {
    config: _debug2(`${name}:config`),
    debug: _debug2(`${name}:debug`),
    compile: _debug2(`${name}:compile`),
    scan: _debug2(`${name}:scan`),
    scanGlob: _debug2(`${name}:scan:glob`),
    scanTransform: _debug2(`${name}:scan:transform`),
    detectClass: _debug2(`${name}:detect:class`),
    detectTag: _debug2(`${name}:detect:tag`),
    detectAttrs: _debug2(`${name}:detect:attrs`),
    compileLayer: _debug2(`${name}:compile:layer`)
  };
  let processor;
  let completions;
  let files = [];
  const classesGenerated = /* @__PURE__ */ new Set();
  const classesPending = /* @__PURE__ */ new Set();
  const tagsGenerated = /* @__PURE__ */ new Set();
  const tagsPending = /* @__PURE__ */ new Set();
  const attrsGenerated = /* @__PURE__ */ new Set();
  const tagsAvailable = /* @__PURE__ */ new Set();
  const attributes = [];
  let _transformAlias = () => null;
  const _locks = [];
  function getCompletions() {
    if (!completions)
      completions = generateCompletions(processor);
    return completions;
  }
  async function getFiles() {
    await ensureInit();
    debug.scanGlob("include", options.scanOptions.include);
    debug.scanGlob("exclude", options.scanOptions.exclude);
    const files2 = await out(options.scanOptions.include, {
      cwd: options.root,
      ignore: options.scanOptions.exclude,
      onlyFiles: true,
      absolute: true
    });
    files2.sort();
    debug.scanGlob("files", files2);
    return files2;
  }
  let scanned = false;
  const scan = createSingletonPromise(async () => {
    await ensureInit();
    debug.scan("started");
    files.push(...await getFiles());
    const contents = await Promise.all(files.filter((id) => isDetectTarget(id)).map(async (id) => [await fs__default["default"].promises.readFile(id, "utf-8"), id]));
    await Promise.all(contents.map(async ([content, id]) => {
      if (isCssTransformTarget(id))
        return transformCSS(content, id);
      else
        return extractFile(content, id, true);
    }));
    scanned = true;
    debug.scan("finished");
  });
  function isExcluded(id) {
    return micromatch_1.contains(slash$1(id), options.scanOptions.exclude, { dot: true });
  }
  function isIncluded(id) {
    return micromatch_1.isMatch(slash$1(id), options.scanOptions.include);
  }
  function isDetectTarget(id) {
    if (options.scanOptions.extraTransformTargets.detect.some((i) => typeof i === "string" ? i === id : i(id)))
      return true;
    if (files.includes(id) || files.includes(id.slice(0, id.indexOf("?"))))
      return true;
    id = slash$1(id);
    return isIncluded(id) && !isExcluded(id);
  }
  function isScanTarget(id) {
    return options.enableScan ? files.some((file) => id.startsWith(file)) : isDetectTarget(id);
  }
  function isCssTransformTarget(id) {
    if (options.scanOptions.extraTransformTargets.css.some((i) => typeof i === "string" ? i === id : i(id)))
      return true;
    if (id.match(/\.(?:postcss|pcss|scss|sass|css|stylus|less)(?:$|\?)/i) && !isExcluded(id))
      return true;
    return false;
  }
  function addClasses(classes) {
    let changed = false;
    classes.forEach((i) => {
      if (!i || classesGenerated.has(i) || classesPending.has(i) || options.blocklist.has(i))
        return;
      classesPending.add(i);
      changed = true;
    });
    return changed;
  }
  function addTags(tags) {
    if (options.preflightOptions.includeAll)
      return false;
    let changed = false;
    tags.forEach((tag) => {
      if (!tagsAvailable.has(tag))
        tag = options.preflightOptions.alias[kebabCase(tag)];
      if (options.preflightOptions.blocklist.has(tag))
        return;
      if (tagsAvailable.has(tag) && !tagsPending.has(tag)) {
        tagsPending.add(tag);
        tagsAvailable.delete(tag);
        changed = true;
      }
    });
    return changed;
  }
  async function applyExtractors2(code, id) {
    return await applyExtractors(code, id, options.scanOptions.extractors);
  }
  async function extractFile(code, id, applyTransform = true) {
    var _a, _b, _c, _d;
    if (applyTransform) {
      code = (_b = (_a = _transformAlias(code, false)) == null ? void 0 : _a.code) != null ? _b : code;
      if (options.transformGroups)
        code = (_d = (_c = transformGroups(code, false)) == null ? void 0 : _c.code) != null ? _d : code;
    }
    if (id) {
      debug.scanTransform(id);
      for (const trans of options.scanOptions.transformers) {
        const result = trans(code, id);
        if (result != null)
          code = result;
      }
    }
    const extractResult = await applyExtractors2(code, id);
    let changed = false;
    if (options.enablePreflight && !options.preflightOptions.includeAll) {
      changed = addTags(extractResult.tags || []) || changed;
    }
    if (options.config.attributify) {
      const extractedAttrs = extractResult.attributes;
      if (extractedAttrs == null ? void 0 : extractedAttrs.names.length) {
        extractedAttrs.names.forEach((name2, i) => {
          attributes.push([name2, extractedAttrs.values[i]]);
        });
        changed = true;
      }
      changed = addClasses((extractedAttrs == null ? void 0 : extractedAttrs.classes) || extractResult.classes || []) || changed;
    } else {
      changed = addClasses(extractResult.classes || []) || changed;
    }
    if (changed) {
      debug.detectClass(classesPending);
      debug.detectTag(tagsPending);
      debug.detectAttrs(attributes);
    }
    return changed;
  }
  function transformCSS(css, id, transformOptions) {
    var _a;
    if (!options.transformCSS)
      return css;
    const style = new CSSParser(css, processor).parse();
    if (transformOptions == null ? void 0 : transformOptions.globaliseKeyframes) {
      const [nonKeyframeBlocks, keyframeBlocks] = partition(style.children, (i) => !i.atRules || !i.atRules[0].match(/keyframes (pulse|spin|ping|bounce)/));
      updateLayers(keyframeBlocks, "__classes", false);
      style.children = nonKeyframeBlocks;
    }
    const [layerBlocks, blocks] = partition(style.children, (i) => i.meta.group === "layer-block" && SupportedLayers.includes(i.meta.type));
    if (layerBlocks.length) {
      updateLayers(layerBlocks, id);
      style.children = blocks;
    }
    const transformed = style.build();
    if (layerBlocks.length)
      (_a = transformOptions == null ? void 0 : transformOptions.onLayerUpdated) == null ? void 0 : _a.call(transformOptions);
    return transformed;
  }
  const layers = {
    base: {},
    utilities: {},
    components: {}
  };
  const layerStylesMap = /* @__PURE__ */ new Map();
  function updateLayers(styles, filepath, replace = true) {
    var _a;
    const timestamp = +Date.now();
    debug.compileLayer("update", filepath);
    const changedLayers = /* @__PURE__ */ new Set();
    styles.forEach((i) => changedLayers.add(i.meta.type));
    if (replace) {
      (_a = layerStylesMap.get(filepath)) == null ? void 0 : _a.forEach((i) => changedLayers.add(i.meta.type));
      layerStylesMap.set(filepath, styles);
    } else {
      const prevStyles = layerStylesMap.get(filepath) || [];
      layerStylesMap.set(filepath, prevStyles.concat(styles));
    }
    for (const name2 of changedLayers) {
      const layer = layers[name2];
      if (layer) {
        layer.timestamp = timestamp;
        layer.cssCache = void 0;
      }
    }
  }
  function buildLayerCss(name2) {
    var _a;
    const layer = layers[name2];
    if (layer.cssCache == null) {
      const style = new StyleSheet$1(Array.from(layerStylesMap.values()).flatMap((i) => i).filter((i) => i.meta.type === name2));
      style.prefixer = (_a = options.config.prefixer) != null ? _a : true;
      debug.compileLayer(name2, style.children.length);
      if (options.sortUtilities)
        style.sort();
      layer.cssCache = `/* windicss layer ${name2} */
${style.build()}`;
    }
    return layer.cssCache;
  }
  function buildPendingStyles() {
    var _a, _b;
    (_a = options.onBeforeGenerate) == null ? void 0 : _a.call(options, {
      classesPending,
      tagsPending
    });
    if (classesPending.size) {
      const result = processor.interpret(Array.from(classesPending).join(" "));
      if (result.success.length) {
        debug.compile(`compiled ${result.success.length} classes out of ${classesPending.size}`);
        debug.compile(result.success);
        updateLayers(result.styleSheet.children, "__classes", false);
        include(classesGenerated, result.success);
        classesPending.clear();
      }
    }
    if (options.enablePreflight) {
      if (options.preflightOptions.includeAll) {
        if (!layerStylesMap.has("__preflights")) {
          const preflightStyle = processor.preflight(void 0, options.preflightOptions.includeBase, options.preflightOptions.includeGlobal, options.preflightOptions.includePlugin);
          updateLayers(preflightStyle.children, "__preflights", true);
        }
      } else if (tagsPending.size) {
        const preflightStyle = processor.preflight(Array.from(tagsPending).map((i) => `<${i}/>`).join(" "), options.preflightOptions.includeBase, options.preflightOptions.includeGlobal, options.preflightOptions.includePlugin);
        updateLayers(preflightStyle.children, "__preflights", false);
        include(tagsGenerated, tagsPending);
        tagsPending.clear();
      }
    }
    if (options.config.attributify) {
      if (attributes.length) {
        const attributesObject = {};
        attributes.forEach(([name2, value]) => {
          if (!attributesObject[name2])
            attributesObject[name2] = [];
          attributesObject[name2].push(...value.split(regexClassSplitter).filter(Boolean));
        });
        const attributifyStyle = processor.attributify(attributesObject);
        updateLayers(attributifyStyle.styleSheet.children, "__attributify", false);
        attributes.length = 0;
      }
    }
    (_b = options.onGenerated) == null ? void 0 : _b.call(options, {
      classes: classesGenerated,
      tags: tagsGenerated
    });
  }
  async function generateCSS(layer) {
    await ensureInit();
    if (options.enableScan && options.scanOptions.runOnStartup)
      await scan();
    buildPendingStyles();
    return layer ? buildLayerCss(layer) : [
      buildLayerCss("base"),
      buildLayerCss("components"),
      buildLayerCss("utilities")
    ].join("\n").trim();
  }
  function clearCache(clearAll = false) {
    layers.base = {};
    layers.utilities = {};
    layers.components = {};
    layerStylesMap.clear();
    completions = void 0;
    if (clearAll) {
      classesPending.clear();
      tagsPending.clear();
      tagsAvailable.clear();
    } else {
      include(classesPending, classesGenerated);
      include(tagsPending, tagsGenerated);
      include(tagsPending, preflightTags);
    }
    include(tagsAvailable, htmlTags);
    include(classesPending, options.safelist);
    include(tagsPending, options.preflightOptions.safelist);
    exclude(tagsAvailable, preflightTags);
    exclude(tagsAvailable, options.preflightOptions.safelist);
    classesGenerated.clear();
    tagsGenerated.clear();
    attrsGenerated.clear();
  }
  async function lock(fn) {
    const p = fn();
    _locks.push(p);
    await p;
    const i = _locks.indexOf(p);
    if (i >= 0)
      _locks.splice(i, 1);
  }
  async function waitLocks() {
    await Promise.all(_locks);
  }
  const utils = {
    init,
    ensureInit,
    extractFile,
    applyExtractors: applyExtractors2,
    generateCSS,
    getFiles,
    clearCache,
    transformCSS,
    transformGroups,
    get transformAlias() {
      return _transformAlias;
    },
    buildPendingStyles,
    isDetectTarget,
    isScanTarget,
    isCssTransformTarget,
    isExcluded,
    scan,
    classesGenerated,
    classesPending,
    tagsGenerated,
    tagsPending,
    tagsAvailable,
    layersMeta: layers,
    addClasses,
    addTags,
    getCompletions,
    lock,
    waitLocks,
    get initialized() {
      return !!processor;
    },
    get options() {
      return options;
    },
    get files() {
      return files;
    },
    get globs() {
      return options.scanOptions.include;
    },
    get processor() {
      return processor;
    },
    get scanned() {
      return scanned;
    },
    get configFilePath() {
      return options.configFilePath;
    },
    get hasPending() {
      return Boolean(tagsPending.size || classesPending.size);
    }
  };
  async function _init() {
    var _a;
    options = await resolveOptions(userOptions, utilsOptions, true);
    files = [];
    processor = new Processor(options.config);
    clearCache(false);
    (_a = options.onInitialized) == null ? void 0 : _a.call(options, utils);
    _transformAlias = buildAliasTransformer(options.config.alias);
    return processor;
  }
  let _promise_init;
  async function init() {
    _promise_init = _init();
    return _promise_init;
  }
  async function ensureInit() {
    if (processor)
      return processor;
    if (!_promise_init)
      _promise_init = _init();
    return _promise_init;
  }
  return utils;
}

// src/index.ts
__reExport$1(src_exports, resolveOptions_exports);

// src/merge.ts
var isObject = (val) => toString.call(val) === "[object Object]";
function deepMerge(a, b, rootPath) {
  a = __spreadValues$1({}, a);
  Object.keys(b).forEach((key) => {
    if (isObject(a[key]))
      a[key] = deepMerge(a[key], b[key]);
    else if (Array.isArray(a[key]))
      a[key] = [...a[key], ...b[key]];
    else
      a[key] = b[key];
  });
  return a;
}
function mergeWindicssConfig(a, b) {
  return deepMerge(a, b);
}

var src$1 = {exports: {}};

var browser$1 = {exports: {}};

var debug$2 = {exports: {}};

/**
 * Helpers.
 */

var s$1 = 1000;
var m$1 = s$1 * 60;
var h$1 = m$1 * 60;
var d$1 = h$1 * 24;
var y$1 = d$1 * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms$1 = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse$2(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong$1(val) : fmtShort$1(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse$2(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y$1;
    case 'days':
    case 'day':
    case 'd':
      return n * d$1;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h$1;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m$1;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s$1;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort$1(ms) {
  if (ms >= d$1) {
    return Math.round(ms / d$1) + 'd';
  }
  if (ms >= h$1) {
    return Math.round(ms / h$1) + 'h';
  }
  if (ms >= m$1) {
    return Math.round(ms / m$1) + 'm';
  }
  if (ms >= s$1) {
    return Math.round(ms / s$1) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong$1(ms) {
  return plural$1(ms, d$1, 'day') ||
    plural$1(ms, h$1, 'hour') ||
    plural$1(ms, m$1, 'minute') ||
    plural$1(ms, s$1, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural$1(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

(function (module, exports) {
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = ms$1;

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}
}(debug$2, debug$2.exports));

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

(function (module, exports) {
exports = module.exports = debug$2.exports;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}
}(browser$1, browser$1.exports));

var node$1 = {exports: {}};

/**
 * Module dependencies.
 */

(function (module, exports) {
var tty = require$$0__default$2["default"];
var util = require$$1__default["default"];

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug$2.exports;
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = fs__default["default"];
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = require$$4__default["default"];
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());
}(node$1, node$1.exports));

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  src$1.exports = browser$1.exports;
} else {
  src$1.exports = node$1.exports;
}

var src = {exports: {}};

var browser = {exports: {}};

var debug$1 = {exports: {}};

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse$1(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse$1(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

(function (module, exports) {
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = ms;

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}
}(debug$1, debug$1.exports));

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

(function (module, exports) {
exports = module.exports = debug$1.exports;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}
}(browser, browser.exports));

var node = {exports: {}};

/**
 * Module dependencies.
 */

(function (module, exports) {
var tty = require$$0__default$2["default"];
var util = require$$1__default["default"];

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug$1.exports;
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = fs__default["default"];
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = require$$4__default["default"];
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());
}(node, node.exports));

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  src.exports = browser.exports;
} else {
  src.exports = node.exports;
}

var onFinished$2 = {exports: {}};

/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var eeFirst = first$1;

/**
 * Get the first event in a set of event emitters and event pairs.
 *
 * @param {array} stuff
 * @param {function} done
 * @public
 */

function first$1(stuff, done) {
  if (!Array.isArray(stuff))
    throw new TypeError('arg must be an array of [ee, events...] arrays')

  var cleanups = [];

  for (var i = 0; i < stuff.length; i++) {
    var arr = stuff[i];

    if (!Array.isArray(arr) || arr.length < 2)
      throw new TypeError('each array member must be [ee, events...]')

    var ee = arr[0];

    for (var j = 1; j < arr.length; j++) {
      var event = arr[j];
      var fn = listener(event, callback);

      // listen to the event
      ee.on(event, fn);
      // push this listener to the list of cleanups
      cleanups.push({
        ee: ee,
        event: event,
        fn: fn,
      });
    }
  }

  function callback() {
    cleanup();
    done.apply(null, arguments);
  }

  function cleanup() {
    var x;
    for (var i = 0; i < cleanups.length; i++) {
      x = cleanups[i];
      x.ee.removeListener(x.event, x.fn);
    }
  }

  function thunk(fn) {
    done = fn;
  }

  thunk.cancel = cleanup;

  return thunk
}

/**
 * Create the event listener.
 * @private
 */

function listener(event, done) {
  return function onevent(arg1) {
    var args = new Array(arguments.length);
    var ee = this;
    var err = event === 'error'
      ? arg1
      : null;

    // copy args to prevent arguments escaping scope
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    done(err, ee, event, args);
  }
}

/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

onFinished$2.exports = onFinished$1;
onFinished$2.exports.isFinished = isFinished;

/**
 * Module dependencies.
 * @private
 */

var first = eeFirst;

/**
 * Variables.
 * @private
 */

/* istanbul ignore next */
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)); };

/**
 * Invoke callback when the response has finished, useful for
 * cleaning up resources afterwards.
 *
 * @param {object} msg
 * @param {function} listener
 * @return {object}
 * @public
 */

function onFinished$1(msg, listener) {
  if (isFinished(msg) !== false) {
    defer(listener, null, msg);
    return msg
  }

  // attach the listener to the message
  attachListener(msg, listener);

  return msg
}

/**
 * Determine if message is already finished.
 *
 * @param {object} msg
 * @return {boolean}
 * @public
 */

function isFinished(msg) {
  var socket = msg.socket;

  if (typeof msg.finished === 'boolean') {
    // OutgoingMessage
    return Boolean(msg.finished || (socket && !socket.writable))
  }

  if (typeof msg.complete === 'boolean') {
    // IncomingMessage
    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))
  }

  // don't know
  return undefined
}

/**
 * Attach a finished listener to the message.
 *
 * @param {object} msg
 * @param {function} callback
 * @private
 */

function attachFinishedListener(msg, callback) {
  var eeMsg;
  var eeSocket;
  var finished = false;

  function onFinish(error) {
    eeMsg.cancel();
    eeSocket.cancel();

    finished = true;
    callback(error);
  }

  // finished on first message event
  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish);

  function onSocket(socket) {
    // remove listener
    msg.removeListener('socket', onSocket);

    if (finished) return
    if (eeMsg !== eeSocket) return

    // finished on first socket event
    eeSocket = first([[socket, 'error', 'close']], onFinish);
  }

  if (msg.socket) {
    // socket already assigned
    onSocket(msg.socket);
    return
  }

  // wait for socket to be assigned
  msg.on('socket', onSocket);

  if (msg.socket === undefined) {
    // node.js 0.8 patch
    patchAssignSocket(msg, onSocket);
  }
}

/**
 * Attach the listener to the message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */

function attachListener(msg, listener) {
  var attached = msg.__onFinished;

  // create a private single listener with queue
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg);
    attachFinishedListener(msg, attached);
  }

  attached.queue.push(listener);
}

/**
 * Create listener on message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */

function createListener(msg) {
  function listener(err) {
    if (msg.__onFinished === listener) msg.__onFinished = null;
    if (!listener.queue) return

    var queue = listener.queue;
    listener.queue = null;

    for (var i = 0; i < queue.length; i++) {
      queue[i](err, msg);
    }
  }

  listener.queue = [];

  return listener
}

/**
 * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
 *
 * @param {ServerResponse} res
 * @param {function} callback
 * @private
 */

function patchAssignSocket(res, callback) {
  var assignSocket = res.assignSocket;

  if (typeof assignSocket !== 'function') return

  // res.on('socket', callback) is broken in 0.8
  res.assignSocket = function _assignSocket(socket) {
    assignSocket.call(this, socket);
    callback(socket);
  };
}

var parseurl$1 = {exports: {}};

/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 * @private
 */

var url = require$$7__default["default"];
var parse = url.parse;
var Url = url.Url;

/**
 * Module exports.
 * @public
 */

parseurl$1.exports = parseurl;
parseurl$1.exports.original = originalurl;

/**
 * Parse the `req` url with memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @public
 */

function parseurl (req) {
  var url = req.url;

  if (url === undefined) {
    // URL is undefined
    return undefined
  }

  var parsed = req._parsedUrl;

  if (fresh(url, parsed)) {
    // Return cached URL parse
    return parsed
  }

  // Parse the URL
  parsed = fastparse(url);
  parsed._raw = url;

  return (req._parsedUrl = parsed)
}
/**
 * Parse the `req` original url with fallback and memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @public
 */

function originalurl (req) {
  var url = req.originalUrl;

  if (typeof url !== 'string') {
    // Fallback
    return parseurl(req)
  }

  var parsed = req._parsedOriginalUrl;

  if (fresh(url, parsed)) {
    // Return cached URL parse
    return parsed
  }

  // Parse the URL
  parsed = fastparse(url);
  parsed._raw = url;

  return (req._parsedOriginalUrl = parsed)
}
/**
 * Parse the `str` url with fast-path short-cut.
 *
 * @param {string} str
 * @return {Object}
 * @private
 */

function fastparse (str) {
  if (typeof str !== 'string' || str.charCodeAt(0) !== 0x2f /* / */) {
    return parse(str)
  }

  var pathname = str;
  var query = null;
  var search = null;

  // This takes the regexp from https://github.com/joyent/node/pull/7878
  // Which is /^(\/[^?#\s]*)(\?[^#\s]*)?$/
  // And unrolls it into a for loop
  for (var i = 1; i < str.length; i++) {
    switch (str.charCodeAt(i)) {
      case 0x3f: /* ?  */
        if (search === null) {
          pathname = str.substring(0, i);
          query = str.substring(i + 1);
          search = str.substring(i);
        }
        break
      case 0x09: /* \t */
      case 0x0a: /* \n */
      case 0x0c: /* \f */
      case 0x0d: /* \r */
      case 0x20: /*    */
      case 0x23: /* #  */
      case 0xa0:
      case 0xfeff:
        return parse(str)
    }
  }

  var url = Url !== undefined
    ? new Url()
    : {};

  url.path = str;
  url.href = str;
  url.pathname = pathname;

  if (search !== null) {
    url.query = query;
    url.search = search;
  }

  return url
}

/**
 * Determine if parsed is still fresh for url.
 *
 * @param {string} url
 * @param {object} parsedUrl
 * @return {boolean}
 * @private
 */

function fresh (url, parsedUrl) {
  return typeof parsedUrl === 'object' &&
    parsedUrl !== null &&
    (Url === undefined || parsedUrl instanceof Url) &&
    parsedUrl._raw === url
}

var require$$0 = {
	"100": "Continue",
	"101": "Switching Protocols",
	"102": "Processing",
	"103": "Early Hints",
	"200": "OK",
	"201": "Created",
	"202": "Accepted",
	"203": "Non-Authoritative Information",
	"204": "No Content",
	"205": "Reset Content",
	"206": "Partial Content",
	"207": "Multi-Status",
	"208": "Already Reported",
	"226": "IM Used",
	"300": "Multiple Choices",
	"301": "Moved Permanently",
	"302": "Found",
	"303": "See Other",
	"304": "Not Modified",
	"305": "Use Proxy",
	"306": "(Unused)",
	"307": "Temporary Redirect",
	"308": "Permanent Redirect",
	"400": "Bad Request",
	"401": "Unauthorized",
	"402": "Payment Required",
	"403": "Forbidden",
	"404": "Not Found",
	"405": "Method Not Allowed",
	"406": "Not Acceptable",
	"407": "Proxy Authentication Required",
	"408": "Request Timeout",
	"409": "Conflict",
	"410": "Gone",
	"411": "Length Required",
	"412": "Precondition Failed",
	"413": "Payload Too Large",
	"414": "URI Too Long",
	"415": "Unsupported Media Type",
	"416": "Range Not Satisfiable",
	"417": "Expectation Failed",
	"418": "I'm a teapot",
	"421": "Misdirected Request",
	"422": "Unprocessable Entity",
	"423": "Locked",
	"424": "Failed Dependency",
	"425": "Unordered Collection",
	"426": "Upgrade Required",
	"428": "Precondition Required",
	"429": "Too Many Requests",
	"431": "Request Header Fields Too Large",
	"451": "Unavailable For Legal Reasons",
	"500": "Internal Server Error",
	"501": "Not Implemented",
	"502": "Bad Gateway",
	"503": "Service Unavailable",
	"504": "Gateway Timeout",
	"505": "HTTP Version Not Supported",
	"506": "Variant Also Negotiates",
	"507": "Insufficient Storage",
	"508": "Loop Detected",
	"509": "Bandwidth Limit Exceeded",
	"510": "Not Extended",
	"511": "Network Authentication Required"
};

/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 * @private
 */

var codes = require$$0;

// status code to message map
status.STATUS_CODES = codes;

// array of status codes
status.codes = populateStatusesMap(status, codes);

// status codes for redirects
status.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true
};

// status codes for empty bodies
status.empty = {
  204: true,
  205: true,
  304: true
};

// status codes for when you should retry the request
status.retry = {
  502: true,
  503: true,
  504: true
};

/**
 * Populate the statuses map for given codes.
 * @private
 */

function populateStatusesMap (statuses, codes) {
  var arr = [];

  Object.keys(codes).forEach(function forEachCode (code) {
    var message = codes[code];
    var status = Number(code);

    // Populate properties
    statuses[status] = message;
    statuses[message] = status;
    statuses[message.toLowerCase()] = status;

    // Add to array
    arr.push(status);
  });

  return arr
}

/**
 * Get the status code.
 *
 * Given a number, this will throw if it is not a known status
 * code, otherwise the code will be returned. Given a string,
 * the string will be parsed for a number and return the code
 * if valid, otherwise will lookup the code assuming this is
 * the status message.
 *
 * @param {string|number} code
 * @returns {number}
 * @public
 */

function status (code) {
  if (typeof code === 'number') {
    if (!status[code]) throw new Error('invalid status code: ' + code)
    return code
  }

  if (typeof code !== 'string') {
    throw new TypeError('code must be a number or string')
  }

  // '403'
  var n = parseInt(code, 10);
  if (!isNaN(n)) {
    if (!status[n]) throw new Error('invalid status code: ' + n)
    return n
  }

  n = status[code.toLowerCase()];
  if (!n) throw new Error('invalid status message: "' + code + '"')
  return n
}

/*!
 * finalhandler
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 * @private
 */

src.exports('finalhandler');
var onFinished = onFinished$2.exports;

/* istanbul ignore next */
typeof setImmediate === 'function'
  ? setImmediate
  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)); };
onFinished.isFinished;

var utilsMerge = {exports: {}};

/**
 * Merge object b with object a.
 *
 *     var a = { foo: 'bar' }
 *       , b = { bar: 'baz' };
 *
 *     merge(a, b);
 *     // => { foo: 'bar', bar: 'baz' }
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object}
 * @api public
 */

(function (module, exports) {
module.exports = function(a, b){
  if (a && b) {
    for (var key in b) {
      a[key] = b[key];
    }
  }
  return a;
};
}(utilsMerge));

/*!
 * connect
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 * @private
 */

src$1.exports('connect:dispatcher');
require$$0__default$4["default"].EventEmitter;

/**
 * Module variables.
 * @private
 */

process.env.NODE_ENV || 'development';

/* istanbul ignore next */
typeof setImmediate === 'function'
  ? setImmediate
  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)); };

var fs$i = {};

var universalify$2 = {};

universalify$2.fromCallback = function (fn) {
  return Object.defineProperty(function (...args) {
    if (typeof args[args.length - 1] === 'function') fn.apply(this, args);
    else {
      return new Promise((resolve, reject) => {
        fn.call(
          this,
          ...args,
          (err, res) => (err != null) ? reject(err) : resolve(res)
        );
      })
    }
  }, 'name', { value: fn.name })
};

universalify$2.fromPromise = function (fn) {
  return Object.defineProperty(function (...args) {
    const cb = args[args.length - 1];
    if (typeof cb !== 'function') return fn.apply(this, args)
    else fn.apply(this, args.slice(0, -1)).then(r => cb(null, r), cb);
  }, 'name', { value: fn.name })
};

var constants = require$$0__default$5["default"];

var origCwd = process.cwd;
var cwd = null;

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;

process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process);
  return cwd
};
try {
  process.cwd();
} catch (er) {}

// This check is needed until node.js 12 is required
if (typeof process.chdir === 'function') {
  var chdir = process.chdir;
  process.chdir = function (d) {
    cwd = null;
    chdir.call(process, d);
  };
  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
}

var polyfills$1 = patch$1;

function patch$1 (fs) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants.hasOwnProperty('O_SYMLINK') &&
      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs);
  }

  // lutimes implementation, or no-op
  if (!fs.lutimes) {
    patchLutimes(fs);
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown);
  fs.fchown = chownFix(fs.fchown);
  fs.lchown = chownFix(fs.lchown);

  fs.chmod = chmodFix(fs.chmod);
  fs.fchmod = chmodFix(fs.fchmod);
  fs.lchmod = chmodFix(fs.lchmod);

  fs.chownSync = chownFixSync(fs.chownSync);
  fs.fchownSync = chownFixSync(fs.fchownSync);
  fs.lchownSync = chownFixSync(fs.lchownSync);

  fs.chmodSync = chmodFixSync(fs.chmodSync);
  fs.fchmodSync = chmodFixSync(fs.fchmodSync);
  fs.lchmodSync = chmodFixSync(fs.lchmodSync);

  fs.stat = statFix(fs.stat);
  fs.fstat = statFix(fs.fstat);
  fs.lstat = statFix(fs.lstat);

  fs.statSync = statFixSync(fs.statSync);
  fs.fstatSync = statFixSync(fs.fstatSync);
  fs.lstatSync = statFixSync(fs.lstatSync);

  // if lchmod/lchown do not exist, then make them no-ops
  if (!fs.lchmod) {
    fs.lchmod = function (path, mode, cb) {
      if (cb) process.nextTick(cb);
    };
    fs.lchmodSync = function () {};
  }
  if (!fs.lchown) {
    fs.lchown = function (path, uid, gid, cb) {
      if (cb) process.nextTick(cb);
    };
    fs.lchownSync = function () {};
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs.rename = (function (fs$rename) { return function (from, to, cb) {
      var start = Date.now();
      var backoff = 0;
      fs$rename(from, to, function CB (er) {
        if (er
            && (er.code === "EACCES" || er.code === "EPERM")
            && Date.now() - start < 60000) {
          setTimeout(function() {
            fs.stat(to, function (stater, st) {
              if (stater && stater.code === "ENOENT")
                fs$rename(from, to, CB);
              else
                cb(er);
            });
          }, backoff);
          if (backoff < 100)
            backoff += 10;
          return;
        }
        if (cb) cb(er);
      });
    }})(fs.rename);
  }

  // if read() returns EAGAIN, then just try it again.
  fs.read = (function (fs$read) {
    function read (fd, buffer, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0;
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter ++;
            return fs$read.call(fs, fd, buffer, offset, length, position, callback)
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs, fd, buffer, offset, length, position, callback)
    }

    // This ensures `util.promisify` works as it does for native `fs.read`.
    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
    return read
  })(fs.read);

  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
    var eagCounter = 0;
    while (true) {
      try {
        return fs$readSync.call(fs, fd, buffer, offset, length, position)
      } catch (er) {
        if (er.code === 'EAGAIN' && eagCounter < 10) {
          eagCounter ++;
          continue
        }
        throw er
      }
    }
  }})(fs.readSync);

  function patchLchmod (fs) {
    fs.lchmod = function (path, mode, callback) {
      fs.open( path
             , constants.O_WRONLY | constants.O_SYMLINK
             , mode
             , function (err, fd) {
        if (err) {
          if (callback) callback(err);
          return
        }
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        fs.fchmod(fd, mode, function (err) {
          fs.close(fd, function(err2) {
            if (callback) callback(err || err2);
          });
        });
      });
    };

    fs.lchmodSync = function (path, mode) {
      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);

      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      var threw = true;
      var ret;
      try {
        ret = fs.fchmodSync(fd, mode);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd);
          } catch (er) {}
        } else {
          fs.closeSync(fd);
        }
      }
      return ret
    };
  }

  function patchLutimes (fs) {
    if (constants.hasOwnProperty("O_SYMLINK")) {
      fs.lutimes = function (path, at, mt, cb) {
        fs.open(path, constants.O_SYMLINK, function (er, fd) {
          if (er) {
            if (cb) cb(er);
            return
          }
          fs.futimes(fd, at, mt, function (er) {
            fs.close(fd, function (er2) {
              if (cb) cb(er || er2);
            });
          });
        });
      };

      fs.lutimesSync = function (path, at, mt) {
        var fd = fs.openSync(path, constants.O_SYMLINK);
        var ret;
        var threw = true;
        try {
          ret = fs.futimesSync(fd, at, mt);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs.closeSync(fd);
            } catch (er) {}
          } else {
            fs.closeSync(fd);
          }
        }
        return ret
      };

    } else {
      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb); };
      fs.lutimesSync = function () {};
    }
  }

  function chmodFix (orig) {
    if (!orig) return orig
    return function (target, mode, cb) {
      return orig.call(fs, target, mode, function (er) {
        if (chownErOk(er)) er = null;
        if (cb) cb.apply(this, arguments);
      })
    }
  }

  function chmodFixSync (orig) {
    if (!orig) return orig
    return function (target, mode) {
      try {
        return orig.call(fs, target, mode)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }


  function chownFix (orig) {
    if (!orig) return orig
    return function (target, uid, gid, cb) {
      return orig.call(fs, target, uid, gid, function (er) {
        if (chownErOk(er)) er = null;
        if (cb) cb.apply(this, arguments);
      })
    }
  }

  function chownFixSync (orig) {
    if (!orig) return orig
    return function (target, uid, gid) {
      try {
        return orig.call(fs, target, uid, gid)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }

  function statFix (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options, cb) {
      if (typeof options === 'function') {
        cb = options;
        options = null;
      }
      function callback (er, stats) {
        if (stats) {
          if (stats.uid < 0) stats.uid += 0x100000000;
          if (stats.gid < 0) stats.gid += 0x100000000;
        }
        if (cb) cb.apply(this, arguments);
      }
      return options ? orig.call(fs, target, options, callback)
        : orig.call(fs, target, callback)
    }
  }

  function statFixSync (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options) {
      var stats = options ? orig.call(fs, target, options)
        : orig.call(fs, target);
      if (stats) {
        if (stats.uid < 0) stats.uid += 0x100000000;
        if (stats.gid < 0) stats.gid += 0x100000000;
      }
      return stats;
    }
  }

  // ENOSYS means that the fs doesn't support the op. Just ignore
  // that, because it doesn't matter.
  //
  // if there's no getuid, or if getuid() is something other
  // than 0, and the error is EINVAL or EPERM, then just ignore
  // it.
  //
  // This specific case is a silent failure in cp, install, tar,
  // and most other unix tools that manage permissions.
  //
  // When running as root, or if other types of errors are
  // encountered, then it's strict.
  function chownErOk (er) {
    if (!er)
      return true

    if (er.code === "ENOSYS")
      return true

    var nonroot = !process.getuid || process.getuid() !== 0;
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true
    }

    return false
  }
}

var Stream = require$$0__default$3["default"].Stream;

var legacyStreams = legacy$1;

function legacy$1 (fs) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  }

  function ReadStream (path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function() {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    });
  }

  function WriteStream (path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}

var clone_1 = clone$1;

var getPrototypeOf = Object.getPrototypeOf || function (obj) {
  return obj.__proto__
};

function clone$1 (obj) {
  if (obj === null || typeof obj !== 'object')
    return obj

  if (obj instanceof Object)
    var copy = { __proto__: getPrototypeOf(obj) };
  else
    var copy = Object.create(null);

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
  });

  return copy
}

var fs$h = fs__default["default"];
var polyfills = polyfills$1;
var legacy = legacyStreams;
var clone = clone_1;

var util$1 = require$$1__default["default"];

/* istanbul ignore next - node 0.x polyfill */
var gracefulQueue;
var previousSymbol;

/* istanbul ignore else - node 0.x polyfill */
if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
  gracefulQueue = Symbol.for('graceful-fs.queue');
  // This is used in testing by future versions
  previousSymbol = Symbol.for('graceful-fs.previous');
} else {
  gracefulQueue = '___graceful-fs.queue';
  previousSymbol = '___graceful-fs.previous';
}

function noop () {}

function publishQueue(context, queue) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue
    }
  });
}

var debug = noop;
if (util$1.debuglog)
  debug = util$1.debuglog('gfs4');
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
  debug = function() {
    var m = util$1.format.apply(util$1, arguments);
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
    console.error(m);
  };

// Once time initialization
if (!fs$h[gracefulQueue]) {
  // This queue can be shared by multiple loaded instances
  var queue = commonjsGlobal[gracefulQueue] || [];
  publishQueue(fs$h, queue);

  // Patch fs.close/closeSync to shared queue version, because we need
  // to retry() whenever a close happens *anywhere* in the program.
  // This is essential when multiple graceful-fs instances are
  // in play at the same time.
  fs$h.close = (function (fs$close) {
    function close (fd, cb) {
      return fs$close.call(fs$h, fd, function (err) {
        // This function uses the graceful-fs shared queue
        if (!err) {
          resetQueue();
        }

        if (typeof cb === 'function')
          cb.apply(this, arguments);
      })
    }

    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    });
    return close
  })(fs$h.close);

  fs$h.closeSync = (function (fs$closeSync) {
    function closeSync (fd) {
      // This function uses the graceful-fs shared queue
      fs$closeSync.apply(fs$h, arguments);
      resetQueue();
    }

    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    });
    return closeSync
  })(fs$h.closeSync);

  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
    process.on('exit', function() {
      debug(fs$h[gracefulQueue]);
      require$$8__default["default"].equal(fs$h[gracefulQueue].length, 0);
    });
  }
}

if (!commonjsGlobal[gracefulQueue]) {
  publishQueue(commonjsGlobal, fs$h[gracefulQueue]);
}

var gracefulFs = patch(clone(fs$h));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$h.__patched) {
    gracefulFs = patch(fs$h);
    fs$h.__patched = true;
}

function patch (fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs);
  fs.gracefulify = patch;

  fs.createReadStream = createReadStream;
  fs.createWriteStream = createWriteStream;
  var fs$readFile = fs.readFile;
  fs.readFile = readFile;
  function readFile (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null;

    return go$readFile(path, options, cb)

    function go$readFile (path, options, cb, startTime) {
      return fs$readFile(path, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
        }
      })
    }
  }

  var fs$writeFile = fs.writeFile;
  fs.writeFile = writeFile;
  function writeFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null;

    return go$writeFile(path, data, options, cb)

    function go$writeFile (path, data, options, cb, startTime) {
      return fs$writeFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
        }
      })
    }
  }

  var fs$appendFile = fs.appendFile;
  if (fs$appendFile)
    fs.appendFile = appendFile;
  function appendFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null;

    return go$appendFile(path, data, options, cb)

    function go$appendFile (path, data, options, cb, startTime) {
      return fs$appendFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
        }
      })
    }
  }

  var fs$copyFile = fs.copyFile;
  if (fs$copyFile)
    fs.copyFile = copyFile;
  function copyFile (src, dest, flags, cb) {
    if (typeof flags === 'function') {
      cb = flags;
      flags = 0;
    }
    return go$copyFile(src, dest, flags, cb)

    function go$copyFile (src, dest, flags, cb, startTime) {
      return fs$copyFile(src, dest, flags, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
        }
      })
    }
  }

  var fs$readdir = fs.readdir;
  fs.readdir = readdir;
  function readdir (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null;

    return go$readdir(path, options, cb)

    function go$readdir (path, options, cb, startTime) {
      return fs$readdir(path, options, function (err, files) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readdir, [path, options, cb], err, startTime || Date.now(), Date.now()]);
        else {
          if (files && files.sort)
            files.sort();

          if (typeof cb === 'function')
            cb.call(this, err, files);
        }
      })
    }
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacy(fs);
    ReadStream = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }

  var fs$ReadStream = fs.ReadStream;
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype);
    ReadStream.prototype.open = ReadStream$open;
  }

  var fs$WriteStream = fs.WriteStream;
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype);
    WriteStream.prototype.open = WriteStream$open;
  }

  Object.defineProperty(fs, 'ReadStream', {
    get: function () {
      return ReadStream
    },
    set: function (val) {
      ReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(fs, 'WriteStream', {
    get: function () {
      return WriteStream
    },
    set: function (val) {
      WriteStream = val;
    },
    enumerable: true,
    configurable: true
  });

  // legacy names
  var FileReadStream = ReadStream;
  Object.defineProperty(fs, 'FileReadStream', {
    get: function () {
      return FileReadStream
    },
    set: function (val) {
      FileReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileWriteStream = WriteStream;
  Object.defineProperty(fs, 'FileWriteStream', {
    get: function () {
      return FileWriteStream
    },
    set: function (val) {
      FileWriteStream = val;
    },
    enumerable: true,
    configurable: true
  });

  function ReadStream (path, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
  }

  function ReadStream$open () {
    var that = this;
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy();

        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
        that.read();
      }
    });
  }

  function WriteStream (path, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
  }

  function WriteStream$open () {
    var that = this;
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy();
        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
      }
    });
  }

  function createReadStream (path, options) {
    return new fs.ReadStream(path, options)
  }

  function createWriteStream (path, options) {
    return new fs.WriteStream(path, options)
  }

  var fs$open = fs.open;
  fs.open = open;
  function open (path, flags, mode, cb) {
    if (typeof mode === 'function')
      cb = mode, mode = null;

    return go$open(path, flags, mode, cb)

    function go$open (path, flags, mode, cb, startTime) {
      return fs$open(path, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
        }
      })
    }
  }

  return fs
}

function enqueue (elem) {
  debug('ENQUEUE', elem[0].name, elem[1]);
  fs$h[gracefulQueue].push(elem);
  retry();
}

// keep track of the timeout between retry() calls
var retryTimer;

// reset the startTime and lastTime to now
// this resets the start of the 60 second overall timeout as well as the
// delay between attempts so that we'll retry these jobs sooner
function resetQueue () {
  var now = Date.now();
  for (var i = 0; i < fs$h[gracefulQueue].length; ++i) {
    // entries that are only a length of 2 are from an older version, don't
    // bother modifying those since they'll be retried anyway.
    if (fs$h[gracefulQueue][i].length > 2) {
      fs$h[gracefulQueue][i][3] = now; // startTime
      fs$h[gracefulQueue][i][4] = now; // lastTime
    }
  }
  // call retry to make sure we're actively processing the queue
  retry();
}

function retry () {
  // clear the timer and remove it to help prevent unintended concurrency
  clearTimeout(retryTimer);
  retryTimer = undefined;

  if (fs$h[gracefulQueue].length === 0)
    return

  var elem = fs$h[gracefulQueue].shift();
  var fn = elem[0];
  var args = elem[1];
  // these items may be unset if they were added by an older graceful-fs
  var err = elem[2];
  var startTime = elem[3];
  var lastTime = elem[4];

  // if we don't have a startTime we have no way of knowing if we've waited
  // long enough, so go ahead and retry this item now
  if (startTime === undefined) {
    debug('RETRY', fn.name, args);
    fn.apply(null, args);
  } else if (Date.now() - startTime >= 60000) {
    // it's been more than 60 seconds total, bail now
    debug('TIMEOUT', fn.name, args);
    var cb = args.pop();
    if (typeof cb === 'function')
      cb.call(null, err);
  } else {
    // the amount of time between the last attempt and right now
    var sinceAttempt = Date.now() - lastTime;
    // the amount of time between when we first tried, and when we last tried
    // rounded up to at least 1
    var sinceStart = Math.max(lastTime - startTime, 1);
    // backoff. wait longer than the total time we've been retrying, but only
    // up to a maximum of 100ms
    var desiredDelay = Math.min(sinceStart * 1.2, 100);
    // it's been long enough since the last retry, do it again
    if (sinceAttempt >= desiredDelay) {
      debug('RETRY', fn.name, args);
      fn.apply(null, args.concat([startTime]));
    } else {
      // if we can't do this job yet, push it to the end of the queue
      // and let the next iteration check again
      fs$h[gracefulQueue].push(elem);
    }
  }

  // schedule our next run if one isn't already scheduled
  if (retryTimer === undefined) {
    retryTimer = setTimeout(retry, 0);
  }
}

(function (exports) {
// This is adapted from https://github.com/normalize/mz
// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
const u = universalify$2.fromCallback;
const fs = gracefulFs;

const api = [
  'access',
  'appendFile',
  'chmod',
  'chown',
  'close',
  'copyFile',
  'fchmod',
  'fchown',
  'fdatasync',
  'fstat',
  'fsync',
  'ftruncate',
  'futimes',
  'lchmod',
  'lchown',
  'link',
  'lstat',
  'mkdir',
  'mkdtemp',
  'open',
  'opendir',
  'readdir',
  'readFile',
  'readlink',
  'realpath',
  'rename',
  'rm',
  'rmdir',
  'stat',
  'symlink',
  'truncate',
  'unlink',
  'utimes',
  'writeFile'
].filter(key => {
  // Some commands are not available on some systems. Ex:
  // fs.opendir was added in Node.js v12.12.0
  // fs.rm was added in Node.js v14.14.0
  // fs.lchown is not available on at least some Linux
  return typeof fs[key] === 'function'
});

// Export cloned fs:
Object.assign(exports, fs);

// Universalify async methods:
api.forEach(method => {
  exports[method] = u(fs[method]);
});
exports.realpath.native = u(fs.realpath.native);

// We differ from mz/fs in that we still ship the old, broken, fs.exists()
// since we are a drop-in replacement for the native module
exports.exists = function (filename, callback) {
  if (typeof callback === 'function') {
    return fs.exists(filename, callback)
  }
  return new Promise(resolve => {
    return fs.exists(filename, resolve)
  })
};

// fs.read(), fs.write(), & fs.writev() need special treatment due to multiple callback args

exports.read = function (fd, buffer, offset, length, position, callback) {
  if (typeof callback === 'function') {
    return fs.read(fd, buffer, offset, length, position, callback)
  }
  return new Promise((resolve, reject) => {
    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
      if (err) return reject(err)
      resolve({ bytesRead, buffer });
    });
  })
};

// Function signature can be
// fs.write(fd, buffer[, offset[, length[, position]]], callback)
// OR
// fs.write(fd, string[, position[, encoding]], callback)
// We need to handle both cases, so we use ...args
exports.write = function (fd, buffer, ...args) {
  if (typeof args[args.length - 1] === 'function') {
    return fs.write(fd, buffer, ...args)
  }

  return new Promise((resolve, reject) => {
    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
      if (err) return reject(err)
      resolve({ bytesWritten, buffer });
    });
  })
};

// fs.writev only available in Node v12.9.0+
if (typeof fs.writev === 'function') {
  // Function signature is
  // s.writev(fd, buffers[, position], callback)
  // We need to handle the optional arg, so we use ...args
  exports.writev = function (fd, buffers, ...args) {
    if (typeof args[args.length - 1] === 'function') {
      return fs.writev(fd, buffers, ...args)
    }

    return new Promise((resolve, reject) => {
      fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {
        if (err) return reject(err)
        resolve({ bytesWritten, buffers });
      });
    })
  };
}
}(fs$i));

var makeDir$1 = {};

var utils$1 = {};

const path$c = require$$0__default$1["default"];

// https://github.com/nodejs/node/issues/8987
// https://github.com/libuv/libuv/pull/1088
utils$1.checkPath = function checkPath (pth) {
  if (process.platform === 'win32') {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path$c.parse(pth).root, ''));

    if (pathHasInvalidWinCharacters) {
      const error = new Error(`Path contains invalid characters: ${pth}`);
      error.code = 'EINVAL';
      throw error
    }
  }
};

const fs$g = fs$i;
const { checkPath } = utils$1;

const getMode = options => {
  const defaults = { mode: 0o777 };
  if (typeof options === 'number') return options
  return ({ ...defaults, ...options }).mode
};

makeDir$1.makeDir = async (dir, options) => {
  checkPath(dir);

  return fs$g.mkdir(dir, {
    mode: getMode(options),
    recursive: true
  })
};

makeDir$1.makeDirSync = (dir, options) => {
  checkPath(dir);

  return fs$g.mkdirSync(dir, {
    mode: getMode(options),
    recursive: true
  })
};

const u$a = universalify$2.fromPromise;
const { makeDir: _makeDir, makeDirSync } = makeDir$1;
const makeDir = u$a(_makeDir);

var mkdirs$2 = {
  mkdirs: makeDir,
  mkdirsSync: makeDirSync,
  // alias
  mkdirp: makeDir,
  mkdirpSync: makeDirSync,
  ensureDir: makeDir,
  ensureDirSync: makeDirSync
};

const fs$f = gracefulFs;

function utimesMillis$1 (path, atime, mtime, callback) {
  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
  fs$f.open(path, 'r+', (err, fd) => {
    if (err) return callback(err)
    fs$f.futimes(fd, atime, mtime, futimesErr => {
      fs$f.close(fd, closeErr => {
        if (callback) callback(futimesErr || closeErr);
      });
    });
  });
}

function utimesMillisSync$1 (path, atime, mtime) {
  const fd = fs$f.openSync(path, 'r+');
  fs$f.futimesSync(fd, atime, mtime);
  return fs$f.closeSync(fd)
}

var utimes = {
  utimesMillis: utimesMillis$1,
  utimesMillisSync: utimesMillisSync$1
};

const fs$e = fs$i;
const path$b = require$$0__default$1["default"];
const util = require$$1__default["default"];

function getStats$2 (src, dest, opts) {
  const statFunc = opts.dereference
    ? (file) => fs$e.stat(file, { bigint: true })
    : (file) => fs$e.lstat(file, { bigint: true });
  return Promise.all([
    statFunc(src),
    statFunc(dest).catch(err => {
      if (err.code === 'ENOENT') return null
      throw err
    })
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))
}

function getStatsSync (src, dest, opts) {
  let destStat;
  const statFunc = opts.dereference
    ? (file) => fs$e.statSync(file, { bigint: true })
    : (file) => fs$e.lstatSync(file, { bigint: true });
  const srcStat = statFunc(src);
  try {
    destStat = statFunc(dest);
  } catch (err) {
    if (err.code === 'ENOENT') return { srcStat, destStat: null }
    throw err
  }
  return { srcStat, destStat }
}

function checkPaths (src, dest, funcName, opts, cb) {
  util.callbackify(getStats$2)(src, dest, opts, (err, stats) => {
    if (err) return cb(err)
    const { srcStat, destStat } = stats;

    if (destStat) {
      if (areIdentical$2(srcStat, destStat)) {
        const srcBaseName = path$b.basename(src);
        const destBaseName = path$b.basename(dest);
        if (funcName === 'move' &&
          srcBaseName !== destBaseName &&
          srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return cb(null, { srcStat, destStat, isChangingCase: true })
        }
        return cb(new Error('Source and destination must not be the same.'))
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`))
      }
    }

    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      return cb(new Error(errMsg(src, dest, funcName)))
    }
    return cb(null, { srcStat, destStat })
  });
}

function checkPathsSync (src, dest, funcName, opts) {
  const { srcStat, destStat } = getStatsSync(src, dest, opts);

  if (destStat) {
    if (areIdentical$2(srcStat, destStat)) {
      const srcBaseName = path$b.basename(src);
      const destBaseName = path$b.basename(dest);
      if (funcName === 'move' &&
        srcBaseName !== destBaseName &&
        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true }
      }
      throw new Error('Source and destination must not be the same.')
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)
    }
  }

  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName))
  }
  return { srcStat, destStat }
}

// recursively check if dest parent is a subdirectory of src.
// It works for all file types including symlinks since it
// checks the src and dest inodes. It starts from the deepest
// parent and stops once it reaches the src parent or the root path.
function checkParentPaths (src, srcStat, dest, funcName, cb) {
  const srcParent = path$b.resolve(path$b.dirname(src));
  const destParent = path$b.resolve(path$b.dirname(dest));
  if (destParent === srcParent || destParent === path$b.parse(destParent).root) return cb()
  fs$e.stat(destParent, { bigint: true }, (err, destStat) => {
    if (err) {
      if (err.code === 'ENOENT') return cb()
      return cb(err)
    }
    if (areIdentical$2(srcStat, destStat)) {
      return cb(new Error(errMsg(src, dest, funcName)))
    }
    return checkParentPaths(src, srcStat, destParent, funcName, cb)
  });
}

function checkParentPathsSync (src, srcStat, dest, funcName) {
  const srcParent = path$b.resolve(path$b.dirname(src));
  const destParent = path$b.resolve(path$b.dirname(dest));
  if (destParent === srcParent || destParent === path$b.parse(destParent).root) return
  let destStat;
  try {
    destStat = fs$e.statSync(destParent, { bigint: true });
  } catch (err) {
    if (err.code === 'ENOENT') return
    throw err
  }
  if (areIdentical$2(srcStat, destStat)) {
    throw new Error(errMsg(src, dest, funcName))
  }
  return checkParentPathsSync(src, srcStat, destParent, funcName)
}

function areIdentical$2 (srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev
}

// return true if dest is a subdir of src, otherwise false.
// It only checks the path strings.
function isSrcSubdir (src, dest) {
  const srcArr = path$b.resolve(src).split(path$b.sep).filter(i => i);
  const destArr = path$b.resolve(dest).split(path$b.sep).filter(i => i);
  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)
}

function errMsg (src, dest, funcName) {
  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`
}

var stat$4 = {
  checkPaths,
  checkPathsSync,
  checkParentPaths,
  checkParentPathsSync,
  isSrcSubdir,
  areIdentical: areIdentical$2
};

const fs$d = gracefulFs;
const path$a = require$$0__default$1["default"];
const mkdirsSync$1 = mkdirs$2.mkdirsSync;
const utimesMillisSync = utimes.utimesMillisSync;
const stat$3 = stat$4;

function copySync$2 (src, dest, opts) {
  if (typeof opts === 'function') {
    opts = { filter: opts };
  }

  opts = opts || {};
  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }

  const { srcStat, destStat } = stat$3.checkPathsSync(src, dest, 'copy', opts);
  stat$3.checkParentPathsSync(src, srcStat, dest, 'copy');
  return handleFilterAndCopy(destStat, src, dest, opts)
}

function handleFilterAndCopy (destStat, src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return
  const destParent = path$a.dirname(dest);
  if (!fs$d.existsSync(destParent)) mkdirsSync$1(destParent);
  return getStats$1(destStat, src, dest, opts)
}

function startCopy$1 (destStat, src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return
  return getStats$1(destStat, src, dest, opts)
}

function getStats$1 (destStat, src, dest, opts) {
  const statSync = opts.dereference ? fs$d.statSync : fs$d.lstatSync;
  const srcStat = statSync(src);

  if (srcStat.isDirectory()) return onDir$1(srcStat, destStat, src, dest, opts)
  else if (srcStat.isFile() ||
           srcStat.isCharacterDevice() ||
           srcStat.isBlockDevice()) return onFile$1(srcStat, destStat, src, dest, opts)
  else if (srcStat.isSymbolicLink()) return onLink$1(destStat, src, dest, opts)
  else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)
  else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)
  throw new Error(`Unknown file: ${src}`)
}

function onFile$1 (srcStat, destStat, src, dest, opts) {
  if (!destStat) return copyFile$1(srcStat, src, dest, opts)
  return mayCopyFile$1(srcStat, src, dest, opts)
}

function mayCopyFile$1 (srcStat, src, dest, opts) {
  if (opts.overwrite) {
    fs$d.unlinkSync(dest);
    return copyFile$1(srcStat, src, dest, opts)
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`)
  }
}

function copyFile$1 (srcStat, src, dest, opts) {
  fs$d.copyFileSync(src, dest);
  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
  return setDestMode$1(dest, srcStat.mode)
}

function handleTimestamps (srcMode, src, dest) {
  // Make sure the file is writable before setting the timestamp
  // otherwise open fails with EPERM when invoked with 'r+'
  // (through utimes call)
  if (fileIsNotWritable$1(srcMode)) makeFileWritable$1(dest, srcMode);
  return setDestTimestamps$1(src, dest)
}

function fileIsNotWritable$1 (srcMode) {
  return (srcMode & 0o200) === 0
}

function makeFileWritable$1 (dest, srcMode) {
  return setDestMode$1(dest, srcMode | 0o200)
}

function setDestMode$1 (dest, srcMode) {
  return fs$d.chmodSync(dest, srcMode)
}

function setDestTimestamps$1 (src, dest) {
  // The initial srcStat.atime cannot be trusted
  // because it is modified by the read(2) system call
  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
  const updatedSrcStat = fs$d.statSync(src);
  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime)
}

function onDir$1 (srcStat, destStat, src, dest, opts) {
  if (!destStat) return mkDirAndCopy$1(srcStat.mode, src, dest, opts)
  return copyDir$1(src, dest, opts)
}

function mkDirAndCopy$1 (srcMode, src, dest, opts) {
  fs$d.mkdirSync(dest);
  copyDir$1(src, dest, opts);
  return setDestMode$1(dest, srcMode)
}

function copyDir$1 (src, dest, opts) {
  fs$d.readdirSync(src).forEach(item => copyDirItem$1(item, src, dest, opts));
}

function copyDirItem$1 (item, src, dest, opts) {
  const srcItem = path$a.join(src, item);
  const destItem = path$a.join(dest, item);
  const { destStat } = stat$3.checkPathsSync(srcItem, destItem, 'copy', opts);
  return startCopy$1(destStat, srcItem, destItem, opts)
}

function onLink$1 (destStat, src, dest, opts) {
  let resolvedSrc = fs$d.readlinkSync(src);
  if (opts.dereference) {
    resolvedSrc = path$a.resolve(process.cwd(), resolvedSrc);
  }

  if (!destStat) {
    return fs$d.symlinkSync(resolvedSrc, dest)
  } else {
    let resolvedDest;
    try {
      resolvedDest = fs$d.readlinkSync(dest);
    } catch (err) {
      // dest exists and is a regular file or directory,
      // Windows may throw UNKNOWN error. If dest already exists,
      // fs throws error anyway, so no need to guard against it here.
      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs$d.symlinkSync(resolvedSrc, dest)
      throw err
    }
    if (opts.dereference) {
      resolvedDest = path$a.resolve(process.cwd(), resolvedDest);
    }
    if (stat$3.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)
    }

    // prevent copy if src is a subdir of dest since unlinking
    // dest in this case would result in removing src contents
    // and therefore a broken symlink would be created.
    if (fs$d.statSync(dest).isDirectory() && stat$3.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)
    }
    return copyLink$1(resolvedSrc, dest)
  }
}

function copyLink$1 (resolvedSrc, dest) {
  fs$d.unlinkSync(dest);
  return fs$d.symlinkSync(resolvedSrc, dest)
}

var copySync_1 = copySync$2;

var copySync$1 = {
  copySync: copySync_1
};

const u$9 = universalify$2.fromPromise;
const fs$c = fs$i;

function pathExists$6 (path) {
  return fs$c.access(path).then(() => true).catch(() => false)
}

var pathExists_1 = {
  pathExists: u$9(pathExists$6),
  pathExistsSync: fs$c.existsSync
};

const fs$b = gracefulFs;
const path$9 = require$$0__default$1["default"];
const mkdirs$1 = mkdirs$2.mkdirs;
const pathExists$5 = pathExists_1.pathExists;
const utimesMillis = utimes.utimesMillis;
const stat$2 = stat$4;

function copy$2 (src, dest, opts, cb) {
  if (typeof opts === 'function' && !cb) {
    cb = opts;
    opts = {};
  } else if (typeof opts === 'function') {
    opts = { filter: opts };
  }

  cb = cb || function () {};
  opts = opts || {};

  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }

  stat$2.checkPaths(src, dest, 'copy', opts, (err, stats) => {
    if (err) return cb(err)
    const { srcStat, destStat } = stats;
    stat$2.checkParentPaths(src, srcStat, dest, 'copy', err => {
      if (err) return cb(err)
      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)
      return checkParentDir(destStat, src, dest, opts, cb)
    });
  });
}

function checkParentDir (destStat, src, dest, opts, cb) {
  const destParent = path$9.dirname(dest);
  pathExists$5(destParent, (err, dirExists) => {
    if (err) return cb(err)
    if (dirExists) return getStats(destStat, src, dest, opts, cb)
    mkdirs$1(destParent, err => {
      if (err) return cb(err)
      return getStats(destStat, src, dest, opts, cb)
    });
  });
}

function handleFilter (onInclude, destStat, src, dest, opts, cb) {
  Promise.resolve(opts.filter(src, dest)).then(include => {
    if (include) return onInclude(destStat, src, dest, opts, cb)
    return cb()
  }, error => cb(error));
}

function startCopy (destStat, src, dest, opts, cb) {
  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)
  return getStats(destStat, src, dest, opts, cb)
}

function getStats (destStat, src, dest, opts, cb) {
  const stat = opts.dereference ? fs$b.stat : fs$b.lstat;
  stat(src, (err, srcStat) => {
    if (err) return cb(err)

    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)
    else if (srcStat.isFile() ||
             srcStat.isCharacterDevice() ||
             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)
    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)
    else if (srcStat.isSocket()) return cb(new Error(`Cannot copy a socket file: ${src}`))
    else if (srcStat.isFIFO()) return cb(new Error(`Cannot copy a FIFO pipe: ${src}`))
    return cb(new Error(`Unknown file: ${src}`))
  });
}

function onFile (srcStat, destStat, src, dest, opts, cb) {
  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)
  return mayCopyFile(srcStat, src, dest, opts, cb)
}

function mayCopyFile (srcStat, src, dest, opts, cb) {
  if (opts.overwrite) {
    fs$b.unlink(dest, err => {
      if (err) return cb(err)
      return copyFile(srcStat, src, dest, opts, cb)
    });
  } else if (opts.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`))
  } else return cb()
}

function copyFile (srcStat, src, dest, opts, cb) {
  fs$b.copyFile(src, dest, err => {
    if (err) return cb(err)
    if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src, dest, cb)
    return setDestMode(dest, srcStat.mode, cb)
  });
}

function handleTimestampsAndMode (srcMode, src, dest, cb) {
  // Make sure the file is writable before setting the timestamp
  // otherwise open fails with EPERM when invoked with 'r+'
  // (through utimes call)
  if (fileIsNotWritable(srcMode)) {
    return makeFileWritable(dest, srcMode, err => {
      if (err) return cb(err)
      return setDestTimestampsAndMode(srcMode, src, dest, cb)
    })
  }
  return setDestTimestampsAndMode(srcMode, src, dest, cb)
}

function fileIsNotWritable (srcMode) {
  return (srcMode & 0o200) === 0
}

function makeFileWritable (dest, srcMode, cb) {
  return setDestMode(dest, srcMode | 0o200, cb)
}

function setDestTimestampsAndMode (srcMode, src, dest, cb) {
  setDestTimestamps(src, dest, err => {
    if (err) return cb(err)
    return setDestMode(dest, srcMode, cb)
  });
}

function setDestMode (dest, srcMode, cb) {
  return fs$b.chmod(dest, srcMode, cb)
}

function setDestTimestamps (src, dest, cb) {
  // The initial srcStat.atime cannot be trusted
  // because it is modified by the read(2) system call
  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
  fs$b.stat(src, (err, updatedSrcStat) => {
    if (err) return cb(err)
    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb)
  });
}

function onDir (srcStat, destStat, src, dest, opts, cb) {
  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts, cb)
  return copyDir(src, dest, opts, cb)
}

function mkDirAndCopy (srcMode, src, dest, opts, cb) {
  fs$b.mkdir(dest, err => {
    if (err) return cb(err)
    copyDir(src, dest, opts, err => {
      if (err) return cb(err)
      return setDestMode(dest, srcMode, cb)
    });
  });
}

function copyDir (src, dest, opts, cb) {
  fs$b.readdir(src, (err, items) => {
    if (err) return cb(err)
    return copyDirItems(items, src, dest, opts, cb)
  });
}

function copyDirItems (items, src, dest, opts, cb) {
  const item = items.pop();
  if (!item) return cb()
  return copyDirItem(items, item, src, dest, opts, cb)
}

function copyDirItem (items, item, src, dest, opts, cb) {
  const srcItem = path$9.join(src, item);
  const destItem = path$9.join(dest, item);
  stat$2.checkPaths(srcItem, destItem, 'copy', opts, (err, stats) => {
    if (err) return cb(err)
    const { destStat } = stats;
    startCopy(destStat, srcItem, destItem, opts, err => {
      if (err) return cb(err)
      return copyDirItems(items, src, dest, opts, cb)
    });
  });
}

function onLink (destStat, src, dest, opts, cb) {
  fs$b.readlink(src, (err, resolvedSrc) => {
    if (err) return cb(err)
    if (opts.dereference) {
      resolvedSrc = path$9.resolve(process.cwd(), resolvedSrc);
    }

    if (!destStat) {
      return fs$b.symlink(resolvedSrc, dest, cb)
    } else {
      fs$b.readlink(dest, (err, resolvedDest) => {
        if (err) {
          // dest exists and is a regular file or directory,
          // Windows may throw UNKNOWN error. If dest already exists,
          // fs throws error anyway, so no need to guard against it here.
          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs$b.symlink(resolvedSrc, dest, cb)
          return cb(err)
        }
        if (opts.dereference) {
          resolvedDest = path$9.resolve(process.cwd(), resolvedDest);
        }
        if (stat$2.isSrcSubdir(resolvedSrc, resolvedDest)) {
          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))
        }

        // do not copy if src is a subdir of dest since unlinking
        // dest in this case would result in removing src contents
        // and therefore a broken symlink would be created.
        if (destStat.isDirectory() && stat$2.isSrcSubdir(resolvedDest, resolvedSrc)) {
          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))
        }
        return copyLink(resolvedSrc, dest, cb)
      });
    }
  });
}

function copyLink (resolvedSrc, dest, cb) {
  fs$b.unlink(dest, err => {
    if (err) return cb(err)
    return fs$b.symlink(resolvedSrc, dest, cb)
  });
}

var copy_1 = copy$2;

const u$8 = universalify$2.fromCallback;
var copy$1 = {
  copy: u$8(copy_1)
};

const fs$a = gracefulFs;
const path$8 = require$$0__default$1["default"];
const assert = require$$8__default["default"];

const isWindows = (process.platform === 'win32');

function defaults (options) {
  const methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ];
  methods.forEach(m => {
    options[m] = options[m] || fs$a[m];
    m = m + 'Sync';
    options[m] = options[m] || fs$a[m];
  });

  options.maxBusyTries = options.maxBusyTries || 3;
}

function rimraf$1 (p, options, cb) {
  let busyTries = 0;

  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  assert(p, 'rimraf: missing path');
  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string');
  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required');
  assert(options, 'rimraf: invalid options argument provided');
  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object');

  defaults(options);

  rimraf_(p, options, function CB (er) {
    if (er) {
      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&
          busyTries < options.maxBusyTries) {
        busyTries++;
        const time = busyTries * 100;
        // try again, with the same exact callback as this one.
        return setTimeout(() => rimraf_(p, options, CB), time)
      }

      // already gone
      if (er.code === 'ENOENT') er = null;
    }

    cb(er);
  });
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, (er, st) => {
    if (er && er.code === 'ENOENT') {
      return cb(null)
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === 'EPERM' && isWindows) {
      return fixWinEPERM(p, options, er, cb)
    }

    if (st && st.isDirectory()) {
      return rmdir(p, options, er, cb)
    }

    options.unlink(p, er => {
      if (er) {
        if (er.code === 'ENOENT') {
          return cb(null)
        }
        if (er.code === 'EPERM') {
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        }
        if (er.code === 'EISDIR') {
          return rmdir(p, options, er, cb)
        }
      }
      return cb(er)
    });
  });
}

function fixWinEPERM (p, options, er, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  options.chmod(p, 0o666, er2 => {
    if (er2) {
      cb(er2.code === 'ENOENT' ? null : er);
    } else {
      options.stat(p, (er3, stats) => {
        if (er3) {
          cb(er3.code === 'ENOENT' ? null : er);
        } else if (stats.isDirectory()) {
          rmdir(p, options, er, cb);
        } else {
          options.unlink(p, cb);
        }
      });
    }
  });
}

function fixWinEPERMSync (p, options, er) {
  let stats;

  assert(p);
  assert(options);

  try {
    options.chmodSync(p, 0o666);
  } catch (er2) {
    if (er2.code === 'ENOENT') {
      return
    } else {
      throw er
    }
  }

  try {
    stats = options.statSync(p);
  } catch (er3) {
    if (er3.code === 'ENOENT') {
      return
    } else {
      throw er
    }
  }

  if (stats.isDirectory()) {
    rmdirSync(p, options, er);
  } else {
    options.unlinkSync(p);
  }
}

function rmdir (p, options, originalEr, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, er => {
    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {
      rmkids(p, options, cb);
    } else if (er && er.code === 'ENOTDIR') {
      cb(originalEr);
    } else {
      cb(er);
    }
  });
}

function rmkids (p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  options.readdir(p, (er, files) => {
    if (er) return cb(er)

    let n = files.length;
    let errState;

    if (n === 0) return options.rmdir(p, cb)

    files.forEach(f => {
      rimraf$1(path$8.join(p, f), options, er => {
        if (errState) {
          return
        }
        if (er) return cb(errState = er)
        if (--n === 0) {
          options.rmdir(p, cb);
        }
      });
    });
  });
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) {
  let st;

  options = options || {};
  defaults(options);

  assert(p, 'rimraf: missing path');
  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string');
  assert(options, 'rimraf: missing options');
  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object');

  try {
    st = options.lstatSync(p);
  } catch (er) {
    if (er.code === 'ENOENT') {
      return
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er.code === 'EPERM' && isWindows) {
      fixWinEPERMSync(p, options, er);
    }
  }

  try {
    // sunos lets the root user unlink directories, which is... weird.
    if (st && st.isDirectory()) {
      rmdirSync(p, options, null);
    } else {
      options.unlinkSync(p);
    }
  } catch (er) {
    if (er.code === 'ENOENT') {
      return
    } else if (er.code === 'EPERM') {
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
    } else if (er.code !== 'EISDIR') {
      throw er
    }
    rmdirSync(p, options, er);
  }
}

function rmdirSync (p, options, originalEr) {
  assert(p);
  assert(options);

  try {
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === 'ENOTDIR') {
      throw originalEr
    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {
      rmkidsSync(p, options);
    } else if (er.code !== 'ENOENT') {
      throw er
    }
  }
}

function rmkidsSync (p, options) {
  assert(p);
  assert(options);
  options.readdirSync(p).forEach(f => rimrafSync(path$8.join(p, f), options));

  if (isWindows) {
    // We only end up here once we got ENOTEMPTY at least once, and
    // at this point, we are guaranteed to have removed all the kids.
    // So, we know that it won't be ENOENT or ENOTDIR or anything else.
    // try really hard to delete stuff on windows, because it has a
    // PROFOUNDLY annoying habit of not closing handles promptly when
    // files are deleted, resulting in spurious ENOTEMPTY errors.
    const startTime = Date.now();
    do {
      try {
        const ret = options.rmdirSync(p, options);
        return ret
      } catch {}
    } while (Date.now() - startTime < 500) // give up after 500ms
  } else {
    const ret = options.rmdirSync(p, options);
    return ret
  }
}

var rimraf_1 = rimraf$1;
rimraf$1.sync = rimrafSync;

const fs$9 = gracefulFs;
const u$7 = universalify$2.fromCallback;
const rimraf = rimraf_1;

function remove$2 (path, callback) {
  // Node 14.14.0+
  if (fs$9.rm) return fs$9.rm(path, { recursive: true, force: true }, callback)
  rimraf(path, callback);
}

function removeSync$1 (path) {
  // Node 14.14.0+
  if (fs$9.rmSync) return fs$9.rmSync(path, { recursive: true, force: true })
  rimraf.sync(path);
}

var remove_1 = {
  remove: u$7(remove$2),
  removeSync: removeSync$1
};

const u$6 = universalify$2.fromPromise;
const fs$8 = fs$i;
const path$7 = require$$0__default$1["default"];
const mkdir$3 = mkdirs$2;
const remove$1 = remove_1;

const emptyDir = u$6(async function emptyDir (dir) {
  let items;
  try {
    items = await fs$8.readdir(dir);
  } catch {
    return mkdir$3.mkdirs(dir)
  }

  return Promise.all(items.map(item => remove$1.remove(path$7.join(dir, item))))
});

function emptyDirSync (dir) {
  let items;
  try {
    items = fs$8.readdirSync(dir);
  } catch {
    return mkdir$3.mkdirsSync(dir)
  }

  items.forEach(item => {
    item = path$7.join(dir, item);
    remove$1.removeSync(item);
  });
}

var empty = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
};

const u$5 = universalify$2.fromCallback;
const path$6 = require$$0__default$1["default"];
const fs$7 = gracefulFs;
const mkdir$2 = mkdirs$2;

function createFile (file, callback) {
  function makeFile () {
    fs$7.writeFile(file, '', err => {
      if (err) return callback(err)
      callback();
    });
  }

  fs$7.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err
    if (!err && stats.isFile()) return callback()
    const dir = path$6.dirname(file);
    fs$7.stat(dir, (err, stats) => {
      if (err) {
        // if the directory doesn't exist, make it
        if (err.code === 'ENOENT') {
          return mkdir$2.mkdirs(dir, err => {
            if (err) return callback(err)
            makeFile();
          })
        }
        return callback(err)
      }

      if (stats.isDirectory()) makeFile();
      else {
        // parent is not a directory
        // This is just to cause an internal ENOTDIR error to be thrown
        fs$7.readdir(dir, err => {
          if (err) return callback(err)
        });
      }
    });
  });
}

function createFileSync (file) {
  let stats;
  try {
    stats = fs$7.statSync(file);
  } catch {}
  if (stats && stats.isFile()) return

  const dir = path$6.dirname(file);
  try {
    if (!fs$7.statSync(dir).isDirectory()) {
      // parent is not a directory
      // This is just to cause an internal ENOTDIR error to be thrown
      fs$7.readdirSync(dir);
    }
  } catch (err) {
    // If the stat call above failed because the directory doesn't exist, create it
    if (err && err.code === 'ENOENT') mkdir$2.mkdirsSync(dir);
    else throw err
  }

  fs$7.writeFileSync(file, '');
}

var file$1 = {
  createFile: u$5(createFile),
  createFileSync
};

const u$4 = universalify$2.fromCallback;
const path$5 = require$$0__default$1["default"];
const fs$6 = gracefulFs;
const mkdir$1 = mkdirs$2;
const pathExists$4 = pathExists_1.pathExists;
const { areIdentical: areIdentical$1 } = stat$4;

function createLink (srcpath, dstpath, callback) {
  function makeLink (srcpath, dstpath) {
    fs$6.link(srcpath, dstpath, err => {
      if (err) return callback(err)
      callback(null);
    });
  }

  fs$6.lstat(dstpath, (_, dstStat) => {
    fs$6.lstat(srcpath, (err, srcStat) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureLink');
        return callback(err)
      }
      if (dstStat && areIdentical$1(srcStat, dstStat)) return callback(null)

      const dir = path$5.dirname(dstpath);
      pathExists$4(dir, (err, dirExists) => {
        if (err) return callback(err)
        if (dirExists) return makeLink(srcpath, dstpath)
        mkdir$1.mkdirs(dir, err => {
          if (err) return callback(err)
          makeLink(srcpath, dstpath);
        });
      });
    });
  });
}

function createLinkSync (srcpath, dstpath) {
  let dstStat;
  try {
    dstStat = fs$6.lstatSync(dstpath);
  } catch {}

  try {
    const srcStat = fs$6.lstatSync(srcpath);
    if (dstStat && areIdentical$1(srcStat, dstStat)) return
  } catch (err) {
    err.message = err.message.replace('lstat', 'ensureLink');
    throw err
  }

  const dir = path$5.dirname(dstpath);
  const dirExists = fs$6.existsSync(dir);
  if (dirExists) return fs$6.linkSync(srcpath, dstpath)
  mkdir$1.mkdirsSync(dir);

  return fs$6.linkSync(srcpath, dstpath)
}

var link$1 = {
  createLink: u$4(createLink),
  createLinkSync
};

const path$4 = require$$0__default$1["default"];
const fs$5 = gracefulFs;
const pathExists$3 = pathExists_1.pathExists;

/**
 * Function that returns two types of paths, one relative to symlink, and one
 * relative to the current working directory. Checks if path is absolute or
 * relative. If the path is relative, this function checks if the path is
 * relative to symlink or relative to current working directory. This is an
 * initiative to find a smarter `srcpath` to supply when building symlinks.
 * This allows you to determine which path to use out of one of three possible
 * types of source paths. The first is an absolute path. This is detected by
 * `path.isAbsolute()`. When an absolute path is provided, it is checked to
 * see if it exists. If it does it's used, if not an error is returned
 * (callback)/ thrown (sync). The other two options for `srcpath` are a
 * relative url. By default Node's `fs.symlink` works by creating a symlink
 * using `dstpath` and expects the `srcpath` to be relative to the newly
 * created symlink. If you provide a `srcpath` that does not exist on the file
 * system it results in a broken symlink. To minimize this, the function
 * checks to see if the 'relative to symlink' source file exists, and if it
 * does it will use it. If it does not, it checks if there's a file that
 * exists that is relative to the current working directory, if does its used.
 * This preserves the expectations of the original fs.symlink spec and adds
 * the ability to pass in `relative to current working direcotry` paths.
 */

function symlinkPaths$1 (srcpath, dstpath, callback) {
  if (path$4.isAbsolute(srcpath)) {
    return fs$5.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureSymlink');
        return callback(err)
      }
      return callback(null, {
        toCwd: srcpath,
        toDst: srcpath
      })
    })
  } else {
    const dstdir = path$4.dirname(dstpath);
    const relativeToDst = path$4.join(dstdir, srcpath);
    return pathExists$3(relativeToDst, (err, exists) => {
      if (err) return callback(err)
      if (exists) {
        return callback(null, {
          toCwd: relativeToDst,
          toDst: srcpath
        })
      } else {
        return fs$5.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace('lstat', 'ensureSymlink');
            return callback(err)
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: path$4.relative(dstdir, srcpath)
          })
        })
      }
    })
  }
}

function symlinkPathsSync$1 (srcpath, dstpath) {
  let exists;
  if (path$4.isAbsolute(srcpath)) {
    exists = fs$5.existsSync(srcpath);
    if (!exists) throw new Error('absolute srcpath does not exist')
    return {
      toCwd: srcpath,
      toDst: srcpath
    }
  } else {
    const dstdir = path$4.dirname(dstpath);
    const relativeToDst = path$4.join(dstdir, srcpath);
    exists = fs$5.existsSync(relativeToDst);
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      }
    } else {
      exists = fs$5.existsSync(srcpath);
      if (!exists) throw new Error('relative srcpath does not exist')
      return {
        toCwd: srcpath,
        toDst: path$4.relative(dstdir, srcpath)
      }
    }
  }
}

var symlinkPaths_1 = {
  symlinkPaths: symlinkPaths$1,
  symlinkPathsSync: symlinkPathsSync$1
};

const fs$4 = gracefulFs;

function symlinkType$1 (srcpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback;
  type = (typeof type === 'function') ? false : type;
  if (type) return callback(null, type)
  fs$4.lstat(srcpath, (err, stats) => {
    if (err) return callback(null, 'file')
    type = (stats && stats.isDirectory()) ? 'dir' : 'file';
    callback(null, type);
  });
}

function symlinkTypeSync$1 (srcpath, type) {
  let stats;

  if (type) return type
  try {
    stats = fs$4.lstatSync(srcpath);
  } catch {
    return 'file'
  }
  return (stats && stats.isDirectory()) ? 'dir' : 'file'
}

var symlinkType_1 = {
  symlinkType: symlinkType$1,
  symlinkTypeSync: symlinkTypeSync$1
};

const u$3 = universalify$2.fromCallback;
const path$3 = require$$0__default$1["default"];
const fs$3 = fs$i;
const _mkdirs = mkdirs$2;
const mkdirs = _mkdirs.mkdirs;
const mkdirsSync = _mkdirs.mkdirsSync;

const _symlinkPaths = symlinkPaths_1;
const symlinkPaths = _symlinkPaths.symlinkPaths;
const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;

const _symlinkType = symlinkType_1;
const symlinkType = _symlinkType.symlinkType;
const symlinkTypeSync = _symlinkType.symlinkTypeSync;

const pathExists$2 = pathExists_1.pathExists;

const { areIdentical } = stat$4;

function createSymlink (srcpath, dstpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback;
  type = (typeof type === 'function') ? false : type;

  fs$3.lstat(dstpath, (err, stats) => {
    if (!err && stats.isSymbolicLink()) {
      Promise.all([
        fs$3.stat(srcpath),
        fs$3.stat(dstpath)
      ]).then(([srcStat, dstStat]) => {
        if (areIdentical(srcStat, dstStat)) return callback(null)
        _createSymlink(srcpath, dstpath, type, callback);
      });
    } else _createSymlink(srcpath, dstpath, type, callback);
  });
}

function _createSymlink (srcpath, dstpath, type, callback) {
  symlinkPaths(srcpath, dstpath, (err, relative) => {
    if (err) return callback(err)
    srcpath = relative.toDst;
    symlinkType(relative.toCwd, type, (err, type) => {
      if (err) return callback(err)
      const dir = path$3.dirname(dstpath);
      pathExists$2(dir, (err, dirExists) => {
        if (err) return callback(err)
        if (dirExists) return fs$3.symlink(srcpath, dstpath, type, callback)
        mkdirs(dir, err => {
          if (err) return callback(err)
          fs$3.symlink(srcpath, dstpath, type, callback);
        });
      });
    });
  });
}

function createSymlinkSync (srcpath, dstpath, type) {
  let stats;
  try {
    stats = fs$3.lstatSync(dstpath);
  } catch {}
  if (stats && stats.isSymbolicLink()) {
    const srcStat = fs$3.statSync(srcpath);
    const dstStat = fs$3.statSync(dstpath);
    if (areIdentical(srcStat, dstStat)) return
  }

  const relative = symlinkPathsSync(srcpath, dstpath);
  srcpath = relative.toDst;
  type = symlinkTypeSync(relative.toCwd, type);
  const dir = path$3.dirname(dstpath);
  const exists = fs$3.existsSync(dir);
  if (exists) return fs$3.symlinkSync(srcpath, dstpath, type)
  mkdirsSync(dir);
  return fs$3.symlinkSync(srcpath, dstpath, type)
}

var symlink$1 = {
  createSymlink: u$3(createSymlink),
  createSymlinkSync
};

const file = file$1;
const link = link$1;
const symlink = symlink$1;

var ensure = {
  // file
  createFile: file.createFile,
  createFileSync: file.createFileSync,
  ensureFile: file.createFile,
  ensureFileSync: file.createFileSync,
  // link
  createLink: link.createLink,
  createLinkSync: link.createLinkSync,
  ensureLink: link.createLink,
  ensureLinkSync: link.createLinkSync,
  // symlink
  createSymlink: symlink.createSymlink,
  createSymlinkSync: symlink.createSymlinkSync,
  ensureSymlink: symlink.createSymlink,
  ensureSymlinkSync: symlink.createSymlinkSync
};

var universalify$1 = {};

universalify$1.fromCallback = function (fn) {
  return Object.defineProperty(function (...args) {
    if (typeof args[args.length - 1] === 'function') fn.apply(this, args);
    else {
      return new Promise((resolve, reject) => {
        fn.call(
          this,
          ...args,
          (err, res) => (err != null) ? reject(err) : resolve(res)
        );
      })
    }
  }, 'name', { value: fn.name })
};

universalify$1.fromPromise = function (fn) {
  return Object.defineProperty(function (...args) {
    const cb = args[args.length - 1];
    if (typeof cb !== 'function') return fn.apply(this, args)
    else fn.apply(this, args.slice(0, -1)).then(r => cb(null, r), cb);
  }, 'name', { value: fn.name })
};

function stringify$3 (obj, { EOL = '\n', finalEOL = true, replacer = null, spaces } = {}) {
  const EOF = finalEOL ? EOL : '';
  const str = JSON.stringify(obj, replacer, spaces);

  return str.replace(/\n/g, EOL) + EOF
}

function stripBom$1 (content) {
  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
  if (Buffer.isBuffer(content)) content = content.toString('utf8');
  return content.replace(/^\uFEFF/, '')
}

var utils = { stringify: stringify$3, stripBom: stripBom$1 };

let _fs;
try {
  _fs = require('graceful-fs');
} catch (_) {
  _fs = fs__default["default"];
}
const universalify = universalify$1;
const { stringify: stringify$2, stripBom } = utils;

async function _readFile (file, options = {}) {
  if (typeof options === 'string') {
    options = { encoding: options };
  }

  const fs = options.fs || _fs;

  const shouldThrow = 'throws' in options ? options.throws : true;

  let data = await universalify.fromCallback(fs.readFile)(file, options);

  data = stripBom(data);

  let obj;
  try {
    obj = JSON.parse(data, options ? options.reviver : null);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file}: ${err.message}`;
      throw err
    } else {
      return null
    }
  }

  return obj
}

const readFile = universalify.fromPromise(_readFile);

function readFileSync (file, options = {}) {
  if (typeof options === 'string') {
    options = { encoding: options };
  }

  const fs = options.fs || _fs;

  const shouldThrow = 'throws' in options ? options.throws : true;

  try {
    let content = fs.readFileSync(file, options);
    content = stripBom(content);
    return JSON.parse(content, options.reviver)
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file}: ${err.message}`;
      throw err
    } else {
      return null
    }
  }
}

async function _writeFile (file, obj, options = {}) {
  const fs = options.fs || _fs;

  const str = stringify$2(obj, options);

  await universalify.fromCallback(fs.writeFile)(file, str, options);
}

const writeFile = universalify.fromPromise(_writeFile);

function writeFileSync (file, obj, options = {}) {
  const fs = options.fs || _fs;

  const str = stringify$2(obj, options);
  // not sure if fs.writeFileSync returns anything, but just in case
  return fs.writeFileSync(file, str, options)
}

const jsonfile$1 = {
  readFile,
  readFileSync,
  writeFile,
  writeFileSync
};

var jsonfile_1 = jsonfile$1;

const jsonFile$1 = jsonfile_1;

var jsonfile = {
  // jsonfile exports
  readJson: jsonFile$1.readFile,
  readJsonSync: jsonFile$1.readFileSync,
  writeJson: jsonFile$1.writeFile,
  writeJsonSync: jsonFile$1.writeFileSync
};

const u$2 = universalify$2.fromCallback;
const fs$2 = gracefulFs;
const path$2 = require$$0__default$1["default"];
const mkdir = mkdirs$2;
const pathExists$1 = pathExists_1.pathExists;

function outputFile$1 (file, data, encoding, callback) {
  if (typeof encoding === 'function') {
    callback = encoding;
    encoding = 'utf8';
  }

  const dir = path$2.dirname(file);
  pathExists$1(dir, (err, itDoes) => {
    if (err) return callback(err)
    if (itDoes) return fs$2.writeFile(file, data, encoding, callback)

    mkdir.mkdirs(dir, err => {
      if (err) return callback(err)

      fs$2.writeFile(file, data, encoding, callback);
    });
  });
}

function outputFileSync$1 (file, ...args) {
  const dir = path$2.dirname(file);
  if (fs$2.existsSync(dir)) {
    return fs$2.writeFileSync(file, ...args)
  }
  mkdir.mkdirsSync(dir);
  fs$2.writeFileSync(file, ...args);
}

var output = {
  outputFile: u$2(outputFile$1),
  outputFileSync: outputFileSync$1
};

const { stringify: stringify$1 } = utils;
const { outputFile } = output;

async function outputJson (file, data, options = {}) {
  const str = stringify$1(data, options);

  await outputFile(file, str, options);
}

var outputJson_1 = outputJson;

const { stringify } = utils;
const { outputFileSync } = output;

function outputJsonSync (file, data, options) {
  const str = stringify(data, options);

  outputFileSync(file, str, options);
}

var outputJsonSync_1 = outputJsonSync;

const u$1 = universalify$2.fromPromise;
const jsonFile = jsonfile;

jsonFile.outputJson = u$1(outputJson_1);
jsonFile.outputJsonSync = outputJsonSync_1;
// aliases
jsonFile.outputJSON = jsonFile.outputJson;
jsonFile.outputJSONSync = jsonFile.outputJsonSync;
jsonFile.writeJSON = jsonFile.writeJson;
jsonFile.writeJSONSync = jsonFile.writeJsonSync;
jsonFile.readJSON = jsonFile.readJson;
jsonFile.readJSONSync = jsonFile.readJsonSync;

var json = jsonFile;

const fs$1 = gracefulFs;
const path$1 = require$$0__default$1["default"];
const copySync = copySync$1.copySync;
const removeSync = remove_1.removeSync;
const mkdirpSync = mkdirs$2.mkdirpSync;
const stat$1 = stat$4;

function moveSync$1 (src, dest, opts) {
  opts = opts || {};
  const overwrite = opts.overwrite || opts.clobber || false;

  const { srcStat, isChangingCase = false } = stat$1.checkPathsSync(src, dest, 'move', opts);
  stat$1.checkParentPathsSync(src, srcStat, dest, 'move');
  if (!isParentRoot$1(dest)) mkdirpSync(path$1.dirname(dest));
  return doRename$1(src, dest, overwrite, isChangingCase)
}

function isParentRoot$1 (dest) {
  const parent = path$1.dirname(dest);
  const parsedPath = path$1.parse(parent);
  return parsedPath.root === parent
}

function doRename$1 (src, dest, overwrite, isChangingCase) {
  if (isChangingCase) return rename$1(src, dest, overwrite)
  if (overwrite) {
    removeSync(dest);
    return rename$1(src, dest, overwrite)
  }
  if (fs$1.existsSync(dest)) throw new Error('dest already exists.')
  return rename$1(src, dest, overwrite)
}

function rename$1 (src, dest, overwrite) {
  try {
    fs$1.renameSync(src, dest);
  } catch (err) {
    if (err.code !== 'EXDEV') throw err
    return moveAcrossDevice$1(src, dest, overwrite)
  }
}

function moveAcrossDevice$1 (src, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true
  };
  copySync(src, dest, opts);
  return removeSync(src)
}

var moveSync_1 = moveSync$1;

var moveSync = {
  moveSync: moveSync_1
};

const fs = gracefulFs;
const path = require$$0__default$1["default"];
const copy = copy$1.copy;
const remove = remove_1.remove;
const mkdirp = mkdirs$2.mkdirp;
const pathExists = pathExists_1.pathExists;
const stat = stat$4;

function move$1 (src, dest, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts;
    opts = {};
  }

  const overwrite = opts.overwrite || opts.clobber || false;

  stat.checkPaths(src, dest, 'move', opts, (err, stats) => {
    if (err) return cb(err)
    const { srcStat, isChangingCase = false } = stats;
    stat.checkParentPaths(src, srcStat, dest, 'move', err => {
      if (err) return cb(err)
      if (isParentRoot(dest)) return doRename(src, dest, overwrite, isChangingCase, cb)
      mkdirp(path.dirname(dest), err => {
        if (err) return cb(err)
        return doRename(src, dest, overwrite, isChangingCase, cb)
      });
    });
  });
}

function isParentRoot (dest) {
  const parent = path.dirname(dest);
  const parsedPath = path.parse(parent);
  return parsedPath.root === parent
}

function doRename (src, dest, overwrite, isChangingCase, cb) {
  if (isChangingCase) return rename(src, dest, overwrite, cb)
  if (overwrite) {
    return remove(dest, err => {
      if (err) return cb(err)
      return rename(src, dest, overwrite, cb)
    })
  }
  pathExists(dest, (err, destExists) => {
    if (err) return cb(err)
    if (destExists) return cb(new Error('dest already exists.'))
    return rename(src, dest, overwrite, cb)
  });
}

function rename (src, dest, overwrite, cb) {
  fs.rename(src, dest, err => {
    if (!err) return cb()
    if (err.code !== 'EXDEV') return cb(err)
    return moveAcrossDevice(src, dest, overwrite, cb)
  });
}

function moveAcrossDevice (src, dest, overwrite, cb) {
  const opts = {
    overwrite,
    errorOnExist: true
  };
  copy(src, dest, opts, err => {
    if (err) return cb(err)
    return remove(src, cb)
  });
}

var move_1 = move$1;

const u = universalify$2.fromCallback;
var move = {
  move: u(move_1)
};

({
  // Export promiseified graceful-fs:
  ...fs$i,
  // Export extra methods:
  ...copySync$1,
  ...copy$1,
  ...empty,
  ...ensure,
  ...json,
  ...mkdirs$2,
  ...moveSync,
  ...move,
  ...output,
  ...pathExists_1,
  ...remove_1
});

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __require = (x) => {
  if (typeof require !== "undefined")
    return require(x);
  throw new Error('Dynamic require of "' + x + '" is not supported');
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};

// node_modules/.pnpm/duplexer@0.1.2/node_modules/duplexer/index.js
var require_duplexer = __commonJS({
  "node_modules/.pnpm/duplexer@0.1.2/node_modules/duplexer/index.js"(exports, module) {
    var Stream = __require("stream");
    var writeMethods = ["write", "end", "destroy"];
    var readMethods = ["resume", "pause"];
    var readEvents = ["data", "close"];
    var slice = Array.prototype.slice;
    module.exports = duplex;
    function forEach(arr, fn) {
      if (arr.forEach) {
        return arr.forEach(fn);
      }
      for (var i = 0; i < arr.length; i++) {
        fn(arr[i], i);
      }
    }
    function duplex(writer, reader) {
      var stream = new Stream();
      var ended = false;
      forEach(writeMethods, proxyWriter);
      forEach(readMethods, proxyReader);
      forEach(readEvents, proxyStream);
      reader.on("end", handleEnd);
      writer.on("drain", function() {
        stream.emit("drain");
      });
      writer.on("error", reemit);
      reader.on("error", reemit);
      stream.writable = writer.writable;
      stream.readable = reader.readable;
      return stream;
      function proxyWriter(methodName) {
        stream[methodName] = method;
        function method() {
          return writer[methodName].apply(writer, arguments);
        }
      }
      function proxyReader(methodName) {
        stream[methodName] = method;
        function method() {
          stream.emit(methodName);
          var func = reader[methodName];
          if (func) {
            return func.apply(reader, arguments);
          }
          reader.emit(methodName);
        }
      }
      function proxyStream(methodName) {
        reader.on(methodName, reemit2);
        function reemit2() {
          var args = slice.call(arguments);
          args.unshift(methodName);
          stream.emit.apply(stream, args);
        }
      }
      function handleEnd() {
        if (ended) {
          return;
        }
        ended = true;
        var args = slice.call(arguments);
        args.unshift("end");
        stream.emit.apply(stream, args);
      }
      function reemit(err) {
        stream.emit("error", err);
      }
    }
  }
});

// node_modules/.pnpm/gzip-size@6.0.0/node_modules/gzip-size/index.js
var require_gzip_size = __commonJS({
  "node_modules/.pnpm/gzip-size@6.0.0/node_modules/gzip-size/index.js"(exports, module) {
    var fs4 = __require("fs");
    var stream = __require("stream");
    var zlib = __require("zlib");
    var { promisify } = __require("util");
    var duplexer = require_duplexer();
    var getOptions = (options) => __spreadValues({ level: 9 }, options);
    var gzip = promisify(zlib.gzip);
    module.exports = async (input, options) => {
      if (!input) {
        return 0;
      }
      const data = await gzip(input, getOptions(options));
      return data.length;
    };
    module.exports.sync = (input, options) => zlib.gzipSync(input, getOptions(options)).length;
    module.exports.stream = (options) => {
      const input = new stream.PassThrough();
      const output = new stream.PassThrough();
      const wrapper = duplexer(input, output);
      let gzipSize2 = 0;
      const gzip2 = zlib.createGzip(getOptions(options)).on("data", (buf) => {
        gzipSize2 += buf.length;
      }).on("error", () => {
        wrapper.gzipSize = 0;
      }).on("end", () => {
        wrapper.gzipSize = gzipSize2;
        wrapper.emit("gzip-size", gzipSize2);
        output.end();
      });
      input.pipe(gzip2);
      input.pipe(output, { end: false });
      return wrapper;
    };
    module.exports.file = (path, options) => {
      return new Promise((resolve3, reject) => {
        const stream2 = fs4.createReadStream(path);
        stream2.on("error", reject);
        const gzipStream = stream2.pipe(module.exports.stream(options));
        gzipStream.on("error", reject);
        gzipStream.on("gzip-size", resolve3);
      });
    };
    module.exports.fileSync = (path, options) => module.exports.sync(fs4.readFileSync(path), options);
  }
});

// node_modules/.pnpm/filesize@6.4.0/node_modules/filesize/lib/filesize.js
var require_filesize = __commonJS({
  "node_modules/.pnpm/filesize@6.4.0/node_modules/filesize/lib/filesize.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.filesize = factory());
    })(exports, function() {
      var b = /^(b|B)$/, symbol = {
        iec: {
          bits: ["b", "Kib", "Mib", "Gib", "Tib", "Pib", "Eib", "Zib", "Yib"],
          bytes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
        },
        jedec: {
          bits: ["b", "Kb", "Mb", "Gb", "Tb", "Pb", "Eb", "Zb", "Yb"],
          bytes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
        }
      }, fullform = {
        iec: ["", "kibi", "mebi", "gibi", "tebi", "pebi", "exbi", "zebi", "yobi"],
        jedec: ["", "kilo", "mega", "giga", "tera", "peta", "exa", "zetta", "yotta"]
      }, roundingFuncs = {
        floor: Math.floor,
        ceil: Math.ceil
      };
      function filesize(arg) {
        var descriptor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var result = [], val = 0, e, base, bits, ceil, full, fullforms, locale, localeOptions, neg, num, output, pad, round, u, unix, separator, spacer, standard, symbols, roundingFunc, precision;
        if (isNaN(arg)) {
          throw new TypeError("Invalid number");
        }
        bits = descriptor.bits === true;
        unix = descriptor.unix === true;
        pad = descriptor.pad === true;
        base = descriptor.base || 2;
        round = descriptor.round !== void 0 ? descriptor.round : unix ? 1 : 2;
        locale = descriptor.locale !== void 0 ? descriptor.locale : "";
        localeOptions = descriptor.localeOptions || {};
        separator = descriptor.separator !== void 0 ? descriptor.separator : "";
        spacer = descriptor.spacer !== void 0 ? descriptor.spacer : unix ? "" : " ";
        symbols = descriptor.symbols || {};
        standard = base === 2 ? descriptor.standard || "jedec" : "jedec";
        output = descriptor.output || "string";
        full = descriptor.fullform === true;
        fullforms = descriptor.fullforms instanceof Array ? descriptor.fullforms : [];
        e = descriptor.exponent !== void 0 ? descriptor.exponent : -1;
        roundingFunc = roundingFuncs[descriptor.roundingMethod] || Math.round;
        num = Number(arg);
        neg = num < 0;
        ceil = base > 2 ? 1e3 : 1024;
        precision = isNaN(descriptor.precision) === false ? parseInt(descriptor.precision, 10) : 0;
        if (neg) {
          num = -num;
        }
        if (e === -1 || isNaN(e)) {
          e = Math.floor(Math.log(num) / Math.log(ceil));
          if (e < 0) {
            e = 0;
          }
        }
        if (e > 8) {
          if (precision > 0) {
            precision += 8 - e;
          }
          e = 8;
        }
        if (output === "exponent") {
          return e;
        }
        if (num === 0) {
          result[0] = 0;
          u = result[1] = unix ? "" : symbol[standard][bits ? "bits" : "bytes"][e];
        } else {
          val = num / (base === 2 ? Math.pow(2, e * 10) : Math.pow(1e3, e));
          if (bits) {
            val = val * 8;
            if (val >= ceil && e < 8) {
              val = val / ceil;
              e++;
            }
          }
          var p = Math.pow(10, e > 0 ? round : 0);
          result[0] = roundingFunc(val * p) / p;
          if (result[0] === ceil && e < 8 && descriptor.exponent === void 0) {
            result[0] = 1;
            e++;
          }
          u = result[1] = base === 10 && e === 1 ? bits ? "kb" : "kB" : symbol[standard][bits ? "bits" : "bytes"][e];
          if (unix) {
            result[1] = standard === "jedec" ? result[1].charAt(0) : e > 0 ? result[1].replace(/B$/, "") : result[1];
            if (b.test(result[1])) {
              result[0] = Math.floor(result[0]);
              result[1] = "";
            }
          }
        }
        if (neg) {
          result[0] = -result[0];
        }
        if (precision > 0) {
          result[0] = result[0].toPrecision(precision);
        }
        result[1] = symbols[result[1]] || result[1];
        if (locale === true) {
          result[0] = result[0].toLocaleString();
        } else if (locale.length > 0) {
          result[0] = result[0].toLocaleString(locale, localeOptions);
        } else if (separator.length > 0) {
          result[0] = result[0].toString().replace(".", separator);
        }
        if (pad && Number.isInteger(result[0]) === false && round > 0) {
          var x = separator || ".", tmp = result[0].toString().split(x), s = tmp[1] || "", l = s.length, n = round - l;
          result[0] = "".concat(tmp[0]).concat(x).concat(s.padEnd(l + n, "0"));
        }
        if (full) {
          result[1] = fullforms[e] ? fullforms[e] : fullform[standard][e] + (bits ? "bit" : "byte") + (result[0] === 1 ? "" : "s");
        }
        return output === "array" ? result : output === "object" ? {
          value: result[0],
          symbol: result[1],
          exponent: e,
          unit: u
        } : result.join(spacer);
      }
      filesize.partial = function(opt) {
        return function(arg) {
          return filesize(arg, opt);
        };
      };
      return filesize;
    });
  }
});

// node_modules/.pnpm/is-docker@2.1.1/node_modules/is-docker/index.js
var require_is_docker = __commonJS({
  "node_modules/.pnpm/is-docker@2.1.1/node_modules/is-docker/index.js"(exports, module) {
    var fs4 = __require("fs");
    var isDocker;
    function hasDockerEnv() {
      try {
        fs4.statSync("/.dockerenv");
        return true;
      } catch (_) {
        return false;
      }
    }
    function hasDockerCGroup() {
      try {
        return fs4.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
      } catch (_) {
        return false;
      }
    }
    module.exports = () => {
      if (isDocker === void 0) {
        isDocker = hasDockerEnv() || hasDockerCGroup();
      }
      return isDocker;
    };
  }
});

// node_modules/.pnpm/is-wsl@2.2.0/node_modules/is-wsl/index.js
var require_is_wsl = __commonJS({
  "node_modules/.pnpm/is-wsl@2.2.0/node_modules/is-wsl/index.js"(exports, module) {
    var os = __require("os");
    var fs4 = __require("fs");
    var isDocker = require_is_docker();
    var isWsl = () => {
      if (process.platform !== "linux") {
        return false;
      }
      if (os.release().toLowerCase().includes("microsoft")) {
        if (isDocker()) {
          return false;
        }
        return true;
      }
      try {
        return fs4.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker() : false;
      } catch (_) {
        return false;
      }
    };
    if (process.env.__IS_WSL_TEST__) {
      module.exports = isWsl;
    } else {
      module.exports = isWsl();
    }
  }
});

// node_modules/.pnpm/define-lazy-prop@2.0.0/node_modules/define-lazy-prop/index.js
var require_define_lazy_prop = __commonJS({
  "node_modules/.pnpm/define-lazy-prop@2.0.0/node_modules/define-lazy-prop/index.js"(exports, module) {
    module.exports = (object, propertyName, fn) => {
      const define2 = (value) => Object.defineProperty(object, propertyName, { value, enumerable: true, writable: true });
      Object.defineProperty(object, propertyName, {
        configurable: true,
        enumerable: true,
        get() {
          const result = fn();
          define2(result);
          return result;
        },
        set(value) {
          define2(value);
        }
      });
      return object;
    };
  }
});

// node_modules/.pnpm/open@8.2.1/node_modules/open/index.js
var require_open = __commonJS({
  "node_modules/.pnpm/open@8.2.1/node_modules/open/index.js"(exports, module) {
    var path = __require("path");
    var childProcess = __require("child_process");
    var { promises: fs4, constants: fsConstants } = __require("fs");
    var isWsl = require_is_wsl();
    var isDocker = require_is_docker();
    var defineLazyProperty = require_define_lazy_prop();
    var localXdgOpenPath = path.join(__dirname, "xdg-open");
    var { platform, arch } = process;
    var getWslDrivesMountPoint = (() => {
      const defaultMountPoint = "/mnt/";
      let mountPoint;
      return async function() {
        if (mountPoint) {
          return mountPoint;
        }
        const configFilePath = "/etc/wsl.conf";
        let isConfigFileExists = false;
        try {
          await fs4.access(configFilePath, fsConstants.F_OK);
          isConfigFileExists = true;
        } catch {
        }
        if (!isConfigFileExists) {
          return defaultMountPoint;
        }
        const configContent = await fs4.readFile(configFilePath, { encoding: "utf8" });
        const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
        if (!configMountPoint) {
          return defaultMountPoint;
        }
        mountPoint = configMountPoint.groups.mountPoint.trim();
        mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
        return mountPoint;
      };
    })();
    var pTryEach = async (array, mapper) => {
      let latestError;
      for (const item of array) {
        try {
          return await mapper(item);
        } catch (error) {
          latestError = error;
        }
      }
      throw latestError;
    };
    var open = async (target, options) => {
      if (typeof target !== "string") {
        throw new TypeError("Expected a `target`");
      }
      options = __spreadValues({
        wait: false,
        background: false,
        newInstance: false,
        allowNonzeroExitCode: false
      }, options);
      if (Array.isArray(options.app)) {
        return pTryEach(options.app, (singleApp) => open(target, __spreadProps(__spreadValues({}, options), {
          app: singleApp
        })));
      }
      let { name: app, arguments: appArguments = [] } = options.app || {};
      appArguments = [...appArguments];
      if (Array.isArray(app)) {
        return pTryEach(app, (appName) => open(target, __spreadProps(__spreadValues({}, options), {
          app: {
            name: appName,
            arguments: appArguments
          }
        })));
      }
      let command;
      const cliArguments = [];
      const childProcessOptions = {};
      if (platform === "darwin") {
        command = "open";
        if (options.wait) {
          cliArguments.push("--wait-apps");
        }
        if (options.background) {
          cliArguments.push("--background");
        }
        if (options.newInstance) {
          cliArguments.push("--new");
        }
        if (app) {
          cliArguments.push("-a", app);
        }
      } else if (platform === "win32" || isWsl && !isDocker()) {
        const mountPoint = await getWslDrivesMountPoint();
        command = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
        cliArguments.push("-NoProfile", "-NonInteractive", "\u2013ExecutionPolicy", "Bypass", "-EncodedCommand");
        if (!isWsl) {
          childProcessOptions.windowsVerbatimArguments = true;
        }
        const encodedArguments = ["Start"];
        if (options.wait) {
          encodedArguments.push("-Wait");
        }
        if (app) {
          encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList");
          appArguments.unshift(target);
        } else {
          encodedArguments.push(`"${target}"`);
        }
        if (appArguments.length > 0) {
          appArguments = appArguments.map((arg) => `"\`"${arg}\`""`);
          encodedArguments.push(appArguments.join(","));
        }
        target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
      } else {
        if (app) {
          command = app;
        } else {
          const isBundled = !__dirname || __dirname === "/";
          let exeLocalXdgOpen = false;
          try {
            await fs4.access(localXdgOpenPath, fsConstants.X_OK);
            exeLocalXdgOpen = true;
          } catch {
          }
          const useSystemXdgOpen = process.versions.electron || platform === "android" || isBundled || !exeLocalXdgOpen;
          command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
        }
        if (appArguments.length > 0) {
          cliArguments.push(...appArguments);
        }
        if (!options.wait) {
          childProcessOptions.stdio = "ignore";
          childProcessOptions.detached = true;
        }
      }
      cliArguments.push(target);
      if (platform === "darwin" && appArguments.length > 0) {
        cliArguments.push("--args", ...appArguments);
      }
      const subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);
      if (options.wait) {
        return new Promise((resolve3, reject) => {
          subprocess.once("error", reject);
          subprocess.once("close", (exitCode) => {
            if (options.allowNonzeroExitCode && exitCode > 0) {
              reject(new Error(`Exited with code ${exitCode}`));
              return;
            }
            resolve3(subprocess);
          });
        });
      }
      subprocess.unref();
      return subprocess;
    };
    function detectArchBinary(binary) {
      if (typeof binary === "string" || Array.isArray(binary)) {
        return binary;
      }
      const { [arch]: archBinary } = binary;
      if (!archBinary) {
        throw new Error(`${arch} is not supported`);
      }
      return archBinary;
    }
    function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
      if (wsl && isWsl) {
        return detectArchBinary(wsl);
      }
      if (!platformBinary) {
        throw new Error(`${platform} is not supported`);
      }
      return detectArchBinary(platformBinary);
    }
    var apps = {};
    defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
      darwin: "google chrome",
      win32: "chrome",
      linux: ["google-chrome", "google-chrome-stable"]
    }, {
      wsl: {
        ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
        x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
      }
    }));
    defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
      darwin: "firefox",
      win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
      linux: "firefox"
    }, {
      wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
    }));
    defineLazyProperty(apps, "edge", () => detectPlatformBinary({
      darwin: "microsoft edge",
      win32: "msedge",
      linux: "microsoft-edge"
    }, {
      wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
    }));
    open.apps = apps;
    module.exports = open;
  }
});

// node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js"(exports, module) {
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js"(exports, module) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js"(exports, module) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js"(exports, module) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module.exports = convert;
  }
});

// node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js"(exports, module) {
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `[${style[0]}m`,
            close: `[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "[39m";
      styles.bgColor.close = "[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports, module) {
    module.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports, module) {
    var os = __require("os");
    var tty = __require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/.pnpm/chalk@4.1.1/node_modules/chalk/source/util.js
var require_util = __commonJS({
  "node_modules/.pnpm/chalk@4.1.1/node_modules/chalk/source/util.js"(exports, module) {
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/.pnpm/chalk@4.1.1/node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "node_modules/.pnpm/chalk@4.1.1/node_modules/chalk/source/templates.js"(exports, module) {
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", ""],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module.exports = (chalk, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/.pnpm/chalk@4.1.1/node_modules/chalk/source/index.js
var require_source = __commonJS({
  "node_modules/.pnpm/chalk@4.1.1/node_modules/chalk/source/index.js"(exports, module) {
    var ansiStyles = require_ansi_styles();
    var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk2 = {};
      applyOptions(chalk2, options);
      chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk2.template.Instance = ChalkClass;
      return chalk2.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, __spreadProps(__spreadValues({}, styles), {
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    }));
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self2, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self2;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self2, string) => {
      if (self2.level <= 0 || !string) {
        return self2._isEmpty ? "" : string;
      }
      let styler = self2._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk2, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk2, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk.stderr.supportsColor = stderrColor;
    module.exports = chalk;
  }
});
function uniq(data) {
  return Array.from(new Set(data));
}
function countElement(arr, element) {
  let num = 0;
  arr.forEach((i) => {
    if (i === element)
      num += 1;
  });
  return num;
}

// node/analysis/index.ts
var import_gzip_size = __toModule(require_gzip_size());
var import_filesize = __toModule(require_filesize());

// node/analysis/tools.ts
function hex2RGB(hex) {
  const RGB_HEX = /^#?(?:([\da-f]{3})[\da-f]?|([\da-f]{6})(?:[\da-f]{2})?)$/i;
  const [, short, long] = String(hex).match(RGB_HEX) || [];
  if (long) {
    const value = Number.parseInt(long, 16);
    return [value >> 16, value >> 8 & 255, value & 255];
  } else if (short) {
    return Array.from(short, (s) => Number.parseInt(s, 16)).map((n) => n << 4 | n);
  }
}
function flatColors(colors, head) {
  let flatten = {};
  for (const [key, value] of Object.entries(colors)) {
    if (typeof value === "string" || Array.isArray(value))
      flatten[head && key === "DEFAULT" ? head : head ? `${head}-${key}` : key] = value;
    else
      flatten = __spreadValues(__spreadValues({}, flatten), flatColors(value, head ? `${head}-${key}` : key));
  }
  return flatten;
}

// node/analysis/colors.ts
function parseColor(value, map) {
  let color;
  let name;
  if (map && typeof map === "object") {
    const colors = flatColors(map);
    const body = value.replace(/^ring-offset|outline-solid|outline-dotted/, "head").replace(/^\w+-/, "");
    if (body in colors) {
      color = colors[body];
      if (Array.isArray(color))
        color = color[0];
      name = body;
    } else if (body.startsWith("hex-")) {
      const hex = body.slice(4);
      if (hex2RGB(hex)) {
        color = `#${hex}`;
        name = body;
      }
    } else if (body.startsWith("[#") && body.endsWith("]")) {
      const hex = body.slice(2, -1);
      if (hex2RGB(hex)) {
        color = `#${hex}`;
        name = body;
      }
    }
  }
  return { color, name };
}

// node/analysis/categories.ts
var staticUtilities = {
  "box-border": "boxSizing",
  "box-content": "boxSizing",
  "block": "display",
  "inline-block": "display",
  "inline": "display",
  "flex": "display",
  "inline-flex": "display",
  "table": "display",
  "table-caption": "display",
  "table-cell": "display",
  "table-column": "display",
  "table-column-group": "display",
  "table-footer-group": "display",
  "table-header-group": "display",
  "table-row-group": "display",
  "table-row": "display",
  "flow-root": "display",
  "grid": "display",
  "inline-grid": "display",
  "contents": "display",
  "hidden": "display",
  "float-right": "float",
  "float-left": "float",
  "float-none": "float",
  "clear-left": "clear",
  "clear-right": "clear",
  "clear-both": "clear",
  "clear-none": "clear",
  "object-contain": "objectFit",
  "object-cover": "objectFit",
  "object-fill": "objectFit",
  "object-none": "objectFit",
  "object-scale-down": "objectFit",
  "overflow-auto": "overflow",
  "overflow-hidden": "overflow",
  "overflow-visible": "overflow",
  "overflow-scroll": "overflow",
  "overflow-x-auto": "overflow",
  "overflow-y-auto": "overflow",
  "overflow-x-hidden": "overflow",
  "overflow-y-hidden": "overflow",
  "overflow-x-visible": "overflow",
  "overflow-y-visible": "overflow",
  "overflow-x-scroll": "overflow",
  "overflow-y-scroll": "overflow",
  "overscroll-auto": "overscrollBehavior",
  "overscroll-contain": "overscrollBehavior",
  "overscroll-none": "overscrollBehavior",
  "overscroll-y-auto": "overscrollBehavior",
  "overscroll-y-contain": "overscrollBehavior",
  "overscroll-y-none": "overscrollBehavior",
  "overscroll-x-auto": "overscrollBehavior",
  "overscroll-x-contain": "overscrollBehavior",
  "overscroll-x-none": "overscrollBehavior",
  "static": "position",
  "fixed": "position",
  "absolute": "position",
  "relative": "position",
  "sticky": "position",
  "visible": "visibility",
  "invisible": "visibility",
  "flex-row": "flex",
  "flex-row-reverse": "flex",
  "flex-col": "flex",
  "flex-col-reverse": "flex",
  "flex-wrap": "flex",
  "flex-wrap-reverse": "flex",
  "flex-nowrap": "flex",
  "col-auto": "grid",
  "row-auto": "grid",
  "grid-flow-row": "grid",
  "grid-flow-col": "grid",
  "grid-flow-row-dense": "grid",
  "grid-flow-col-dense": "grid",
  "justify-start": "justifyContent",
  "justify-end": "justifyContent",
  "justify-center": "justifyContent",
  "justify-between": "justifyContent",
  "justify-around": "justifyContent",
  "justify-evenly": "justifyContent",
  "justify-items-auto": "justifyItems",
  "justify-items-start": "justifyItems",
  "justify-items-end": "justifyItems",
  "justify-items-center": "justifyItems",
  "justify-items-stretch": "justifyItems",
  "justify-self-auto": "justifySelf",
  "justify-self-start": "justifySelf",
  "justify-self-end": "justifySelf",
  "justify-self-center": "justifySelf",
  "justify-self-stretch": "justifySelf",
  "content-center": "alignContent",
  "content-start": "alignContent",
  "content-end": "alignContent",
  "content-between": "alignContent",
  "content-around": "alignContent",
  "content-evenly": "alignContent",
  "items-start": "alignItems",
  "items-end": "alignItems",
  "items-center": "alignItems",
  "items-baseline": "alignItems",
  "items-stretch": "alignItems",
  "self-auto": "alignSelf",
  "self-start": "alignSelf",
  "self-end": "alignSelf",
  "self-center": "alignSelf",
  "self-stretch": "alignSelf",
  "place-content-center": "placeContent",
  "place-content-start": "placeContent",
  "place-content-end": "placeContent",
  "place-content-between": "placeContent",
  "place-content-around": "placeContent",
  "place-content-evenly": "placeContent",
  "place-content-stretch": "placeContent",
  "place-items-auto": "placeItems",
  "place-items-start": "placeItems",
  "place-items-end": "placeItems",
  "place-items-center": "placeItems",
  "place-items-stretch": "placeItems",
  "place-self-auto": "placeSelf",
  "place-self-start": "placeSelf",
  "place-self-end": "placeSelf",
  "place-self-center": "placeSelf",
  "place-self-stretch": "placeSelf",
  "antialiased": "fontSmoothing",
  "subpixel-antialiased": "font",
  "italic": "font",
  "not-italic": "font",
  "normal-nums": "font",
  "ordinal": "font",
  "slashed-zero": "font",
  "lining-nums": "font",
  "oldstyle-nums": "font",
  "proportional-nums": "font",
  "tabular-nums": "font",
  "diagonal-fractions": "font",
  "stacked-fractions": "font",
  "list-inside": "listStylePosition",
  "list-outside": "listStylePosition",
  "text-left": "textAlign",
  "text-center": "textAlign",
  "text-right": "textAlign",
  "text-justify": "textAlign",
  "underline": "textDecoration",
  "line-through": "textDecoration",
  "no-underline": "textDecoration",
  "uppercase": "textTransform",
  "lowercase": "textTransform",
  "capitalize": "textTransform",
  "normal-case": "textTransform",
  "truncate": "textOverflow",
  "overflow-ellipsis": "textOverflow",
  "overflow-clip": "textOverflow",
  "align-baseline": "verticalAlign",
  "align-top": "verticalAlign",
  "align-middle": "verticalAlign",
  "align-bottom": "verticalAlign",
  "align-text-top": "verticalAlign",
  "align-text-bottom": "verticalAlign",
  "whitespace-normal": "whitespace",
  "whitespace-nowrap": "whitespace",
  "whitespace-pre": "whitespace",
  "whitespace-pre-line": "whitespace",
  "whitespace-pre-wrap": "whitespace",
  "break-normal": "wordBreak",
  "break-words": "wordBreak",
  "break-all": "wordBreak",
  "bg-fixed": "background",
  "bg-local": "background",
  "bg-scroll": "background",
  "bg-clip-border": "background",
  "bg-clip-padding": "background",
  "bg-clip-content": "background",
  "bg-clip-text": "background",
  "bg-repeat": "background",
  "bg-no-repeat": "background",
  "bg-repeat-x": "background",
  "bg-repeat-y": "background",
  "bg-repeat-round": "background",
  "bg-repeat-space": "background",
  "border-solid": "border",
  "border-dashed": "border",
  "border-dotted": "border",
  "border-double": "border",
  "border-none": "border",
  "border-collapse": "border",
  "border-separate": "border",
  "table-auto": "table",
  "table-fixed": "table",
  "transform": "transform",
  "transform-gpu": "transform",
  "transform-none": "transform",
  "appearance-none": "appearance",
  "pointer-events-none": "pointerEvents",
  "pointer-events-auto": "pointerEvents",
  "resize-none": "resize",
  "resize-y": "resize",
  "resize-x": "resize",
  "resize": "resize",
  "select-none": "userSelect",
  "select-text": "userSelect",
  "select-all": "userSelect",
  "select-auto": "userSelect",
  "fill-current": "fill",
  "stroke-current": "stroke",
  "sr-only": "accessibility",
  "not-sr-only": "accessibility"
};
var dynamicUtilities = {
  container: "container",
  space: "space",
  divide: "divide",
  bg: "background",
  from: "gradientColor",
  via: "gradientColor",
  to: "gradientColor",
  border: "border",
  rounded: "borderRadius",
  cursor: "cursor",
  flex: "flex",
  order: "order",
  font: "font",
  h: "size",
  leading: "lineHeight",
  list: "listStyleType",
  m: "margin",
  my: "margin",
  mx: "margin",
  mt: "margin",
  mr: "margin",
  mb: "margin",
  ml: "margin",
  min: "size",
  max: "size",
  object: "objectPosition",
  opacity: "opacity",
  outline: "outline",
  p: "padding",
  py: "padding",
  px: "padding",
  pt: "padding",
  pr: "padding",
  pb: "padding",
  pl: "padding",
  placeholder: "placeholder",
  inset: "inset",
  top: "position",
  right: "position",
  bottom: "position",
  left: "position",
  shadow: "boxShadow",
  ring: "ring",
  fill: "fill",
  stroke: "stroke",
  text: "text",
  tracking: "letterSpacing",
  w: "size",
  z: "zIndex",
  gap: "gap",
  auto: "grid",
  grid: "grid",
  col: "grid",
  row: "grid",
  origin: "transform",
  scale: "transform",
  rotate: "transform",
  translate: "transform",
  skew: "transform",
  transition: "animation",
  ease: "animation",
  duration: "animation",
  delay: "animation",
  animate: "animation"
};

// node/analysis/parse.ts
function parseUtility(name, processor) {
  const info = {};
  const shortcuts = processor.config("shortcuts") || {};
  if (shortcuts[name]) {
    info.shortcut = shortcuts[name];
    info.category = "shortcut";
  }
  if (name[0] === "!") {
    info.important = true;
    name = name.slice(1);
  }
  if (name.includes(":")) {
    const variants = name.split(/:/g);
    info.prefixes = variants.slice(0, -1);
    name = variants.slice(-1)[0];
  }
  info.base = name;
  const prefix = processor.config("prefix");
  const utilityName = prefix ? name.replace(prefix, "") : name;
  const [type] = (utilityName.startsWith("-") ? utilityName.slice(1) : utilityName).split("-");
  if (!info.category) {
    if (utilityName.includes("$")) {
      info.category = "variable";
    } else if (utilityName in staticUtilities) {
      info.category = staticUtilities[utilityName];
      info.type = type;
    } else if (type in dynamicUtilities) {
      info.category = dynamicUtilities[type];
    }
  }
  info.category = info.category || "unknown";
  info.type = info.type || type;
  const color = parseColor(utilityName, processor.theme("colors"));
  if (color.name) {
    info.colorHex = color.color;
    info.colorName = color.name;
  }
  return info;
}

// node/analysis/index.ts
var NAME = "windicss-analysis";
async function runAnalysis(userOptions = {}, options = {}) {
  var _a, _b;
  const {
    interpretUtilities = false
  } = options;
  const utils = (_a = options.utils) != null ? _a : createUtils(userOptions, { name: NAME });
  await utils.init();
  const root = utils.options.root;
  const files = [];
  const allcodes = [];
  for (const filepath of await utils.getFiles()) {
    let code = await fs$r.promises.readFile(filepath, "utf-8");
    code = ((_b = utils.transformGroups(code)) == null ? void 0 : _b.code) || code;
    const { classes } = await utils.applyExtractors(code, filepath);
    files.push({
      utilities: classes || [],
      filepath
    });
    allcodes.push({ filepath, code });
  }
  const shortcuts = utils.processor.config("shortcuts") || {};
  const { success: utilityNames, styleSheet } = utils.processor.interpret(files.flatMap((i) => i.utilities).join(" "));
  files.forEach((i) => i.utilities = i.utilities.filter((c) => utilityNames.includes(c)));
  const allUsages = files.flatMap((i) => i.utilities);
  const utilitiesList = utilityNames.map((i) => __spreadValues({
    count: countElement(allUsages, i),
    base: i,
    full: i
  }, parseUtility(i, utils.processor)));
  if (interpretUtilities) {
    utilitiesList.forEach((i) => {
      i.css = utils.processor.interpret(i.full).styleSheet.build();
    });
  }
  const utilities = Object.fromEntries(utilitiesList.map((i) => [i.full, i]));
  const baseNames = uniq(utilitiesList.map((u) => u.base));
  const bases = Object.fromEntries(baseNames.map((i) => [i, {
    count: utilitiesList.filter((u) => u.base === i).reduce((a, b) => a.count + b.count, { count: 0 }),
    base: i,
    variants: utilitiesList.filter((u) => u.base === i).map((i2) => i2.full)
  }]));
  const css = styleSheet.build().replace(/[\s\n]+/gm, "");
  const size = await (0, import_gzip_size.default)(css);
  const colors = Object.fromEntries(uniq(utilitiesList.map((u) => u.colorName).filter((i) => i)).map((i) => [i, {
    name: i,
    hex: utilitiesList.find((u) => u.colorName === i).colorHex || "",
    utilities: utilitiesList.filter((u) => u.colorName === i).map((i2) => i2.full),
    prefixes: uniq(utilitiesList.filter((u) => u.colorName === i).flatMap((i2) => i2.prefixes || []))
  }]));
  const _files = {};
  const _groups = declass_1(allcodes.map(({ code }) => code).join("\n"));
  allcodes.forEach(({ code, filepath }) => {
    const g = [];
    _groups.forEach((group) => {
      for (const e of group.uses) {
        if (code.includes(e))
          g.push(group.class);
      }
    });
    if (Object.keys(g).length > 0)
      _files[filepath] = g;
  });
  const result = {
    root,
    include: utils.options.scanOptions.include,
    exclude: utils.options.scanOptions.exclude,
    colors,
    files,
    groups: {
      files: _files,
      groups: _groups
    },
    utilities,
    shortcuts,
    bases,
    dist: {
      gzip: (0, import_filesize.default)(size)
    }
  };
  const packageJsonPath = require$$0$4.join(root, "package.json");
  if (fs$r.existsSync(packageJsonPath)) {
    const { name, version: version2 } = JSON.parse(await fs$r.promises.readFile(packageJsonPath, "utf-8"));
    result.name = name;
    result.version = version2;
  }
  return {
    result,
    utils
  };
}

// node/server.ts
__toModule(require_open());
__toModule(require_source());
/**
 * filesize
 *
 * @copyright 2021 Jason Mulligan <jason.mulligan@avoidwork.com>
 * @license BSD-3-Clause
 * @version 6.4.0
 */

exports.Processor = Processor;
exports.jiti = lib$d;
exports.runAnalysis = runAnalysis;
