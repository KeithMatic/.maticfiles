"use strict";
var refactorName = "Convert JSX className string literal to expression";
var refactorDescription = "Convert JSX className string literal to expression";
var convertJsxStringLiteralAction = {
    name: refactorName,
    description: refactorDescription,
    kind: "refactor.typescript-react.jsx-classname-string-literal",
};
function init(modules) {
    var ts = modules.typescript;
    function create(info) {
        var proxy = Object.create(null);
        var _loop_1 = function (k) {
            var x = info.languageService[k];
            // @ts-ignore
            proxy[k] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return x.apply(info.languageService, args);
            };
        };
        for (var _i = 0, _a = Object.keys(info.languageService); _i < _a.length; _i++) {
            var k = _a[_i];
            _loop_1(k);
        }
        function getJsxAttributeClassnameStringLiteral(sourceFile, positionOrRange) {
            if (sourceFile === undefined || sourceFile.isDeclarationFile) {
                return;
            }
            var position = typeof positionOrRange === "number"
                ? positionOrRange
                : positionOrRange.pos;
            var node = getNodeAtPosition(sourceFile, position);
            while (node !== undefined) {
                if (ts.isJsxAttribute(node) &&
                    node.name.text === "className" &&
                    node.initializer !== undefined &&
                    ts.isStringLiteral(node.initializer)) {
                    return node.initializer;
                }
                node = node.parent;
            }
            return undefined;
        }
        proxy.getApplicableRefactors = function (fileName, positionOrRange, preferences, triggerReason, kind) {
            var _a;
            var refactors = info.languageService.getApplicableRefactors(fileName, positionOrRange, preferences, triggerReason, kind);
            var sourceFile = (_a = info.languageService
                .getProgram()) === null || _a === void 0 ? void 0 : _a.getSourceFile(fileName);
            if (getJsxAttributeClassnameStringLiteral(sourceFile, positionOrRange) !==
                undefined) {
                refactors.push({
                    name: refactorName,
                    description: refactorDescription,
                    actions: [convertJsxStringLiteralAction],
                });
            }
            return refactors;
        };
        function getEdits(fileName, positionOrRange, formatOptions, preferences) {
            var _a;
            var sourceFile = (_a = info.languageService
                .getProgram()) === null || _a === void 0 ? void 0 : _a.getSourceFile(fileName);
            var jsxAttributeClassnameStringLiteralNode = getJsxAttributeClassnameStringLiteral(sourceFile, positionOrRange);
            if (jsxAttributeClassnameStringLiteralNode === undefined) {
                return;
            }
            var nodeFactory = ts.factory;
            // @ts-ignore
            var edits = ts["textChanges"].ChangeTracker.with({
                host: info.languageServiceHost,
                // @ts-ignore
                formatContext: ts["formatting"].getFormatContext(formatOptions),
                preferences: preferences,
            }, 
            // @ts-ignore
            function (tracker) {
                tracker.replaceNode(sourceFile, jsxAttributeClassnameStringLiteralNode, nodeFactory.createJsxExpression(undefined, nodeFactory.createCallExpression(nodeFactory.createIdentifier("classNames"), undefined, [jsxAttributeClassnameStringLiteralNode])), undefined);
            });
            return edits;
        }
        proxy.getEditsForRefactor = function (fileName, formatOptions, positionOrRange, refactorNameArgument, actionName, preferences) {
            if (actionName === refactorName) {
                var edits = getEdits(fileName, positionOrRange, formatOptions, preferences);
                if (edits !== undefined) {
                    return { edits: edits };
                }
            }
            return info.languageService.getEditsForRefactor(fileName, formatOptions, positionOrRange, refactorNameArgument, actionName, preferences);
        };
        return proxy;
    }
    function getNodeAtPosition(sourceFile, position) {
        function find(node) {
            var _a;
            if (position >= node.getStart() && position < node.getEnd()) {
                return (_a = node.forEachChild(find)) !== null && _a !== void 0 ? _a : node;
            }
        }
        return find(sourceFile);
    }
    return { create: create };
}
module.exports = init;
