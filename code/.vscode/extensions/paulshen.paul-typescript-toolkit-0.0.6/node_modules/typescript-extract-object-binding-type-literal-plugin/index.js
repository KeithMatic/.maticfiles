"use strict";
var refactorName = "Extract object binding type literal properties";
var refactorDescription = "Extract object binding type literal properties";
var extractFunctionTypeLiteralAction = {
    name: refactorName,
    description: refactorDescription,
    kind: "refactor.extract.object-type-literal",
};
function init(modules) {
    var ts = modules.typescript;
    function create(info) {
        var proxy = Object.create(null);
        var _loop_1 = function (k) {
            var x = info.languageService[k];
            // @ts-ignore
            proxy[k] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return x.apply(info.languageService, args);
            };
        };
        for (var _i = 0, _a = Object.keys(info.languageService); _i < _a.length; _i++) {
            var k = _a[_i];
            _loop_1(k);
        }
        function f(_a) { }
        function getTypeLiteralNodeAndObjectBindingPattern(sourceFile, positionOrRange) {
            if (sourceFile === undefined || sourceFile.isDeclarationFile) {
                return;
            }
            var position = typeof positionOrRange === "number"
                ? positionOrRange
                : positionOrRange.pos;
            var node = getNodeAtPosition(sourceFile, position);
            while (node !== undefined) {
                if (
                // @ts-ignore
                node.name !== undefined &&
                    // @ts-ignore
                    node.type !== undefined &&
                    // @ts-ignore
                    ts.isObjectBindingPattern(node.name) &&
                    // @ts-ignore
                    ts.isTypeLiteralNode(node.type)) {
                    // @ts-ignore
                    return [node.name, node.type];
                }
                node = node.parent;
            }
            return undefined;
        }
        proxy.getApplicableRefactors = function (fileName, positionOrRange, preferences, triggerReason, kind) {
            var _a;
            var refactors = info.languageService.getApplicableRefactors(fileName, positionOrRange, preferences, triggerReason, kind);
            var sourceFile = (_a = info.languageService
                .getProgram()) === null || _a === void 0 ? void 0 : _a.getSourceFile(fileName);
            var nodes = getTypeLiteralNodeAndObjectBindingPattern(sourceFile, positionOrRange);
            if (nodes !== undefined) {
                refactors.push({
                    name: refactorName,
                    description: refactorDescription,
                    actions: [extractFunctionTypeLiteralAction],
                });
            }
            return refactors;
        };
        function getEdits(fileName, positionOrRange, formatOptions, preferences) {
            var _a;
            var sourceFile = (_a = info.languageService
                .getProgram()) === null || _a === void 0 ? void 0 : _a.getSourceFile(fileName);
            var nodes = getTypeLiteralNodeAndObjectBindingPattern(sourceFile, positionOrRange);
            if (nodes === undefined) {
                return;
            }
            var objectBindingNode = nodes[0], typeLiteralNode = nodes[1];
            var nodeFactory = ts.factory;
            var bindingElements = [];
            for (var i = 0; i < typeLiteralNode.members.length; i++) {
                var member = typeLiteralNode.members[i];
                if (member.name === undefined || !ts.isIdentifier(member.name)) {
                    return;
                }
                bindingElements.push(nodeFactory.createBindingElement(undefined, undefined, member.name.getText()));
            }
            var newObjectBindingPattern = nodeFactory.createObjectBindingPattern(bindingElements);
            // @ts-ignore
            var edits = ts["textChanges"].ChangeTracker.with({
                host: info.languageServiceHost,
                // @ts-ignore
                formatContext: ts["formatting"].getFormatContext(formatOptions),
                preferences: preferences,
            }, 
            // @ts-ignore
            function (tracker) {
                tracker.replaceNode(sourceFile, objectBindingNode, newObjectBindingPattern, undefined);
            });
            return edits;
        }
        proxy.getEditsForRefactor = function (fileName, formatOptions, positionOrRange, refactorNameArgument, actionName, preferences) {
            if (actionName === refactorName) {
                var edits = getEdits(fileName, positionOrRange, formatOptions, preferences);
                if (edits !== undefined) {
                    return { edits: edits };
                }
            }
            return info.languageService.getEditsForRefactor(fileName, formatOptions, positionOrRange, refactorNameArgument, actionName, preferences);
        };
        return proxy;
    }
    function getNodeAtPosition(sourceFile, position) {
        function find(node) {
            var _a;
            if (position >= node.getStart() && position < node.getEnd()) {
                return (_a = node.forEachChild(find)) !== null && _a !== void 0 ? _a : node;
            }
        }
        return find(sourceFile);
    }
    return { create: create };
}
module.exports = init;
